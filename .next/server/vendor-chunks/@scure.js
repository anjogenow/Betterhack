"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@scure";
exports.ids = ["vendor-chunks/@scure"];
exports.modules = {

/***/ "(ssr)/./node_modules/@scure/base/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@scure/base/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.createBase58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64nopad = exports.base64 = exports.base32crockford = exports.base32hexnopad = exports.base32hex = exports.base32nopad = exports.base32 = exports.base16 = exports.utils = void 0;\nexports.assertNumber = assertNumber;\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */ function assertNumber(n) {\n    if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);\n}\nfunction isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function chain(...args) {\n    const id = (a)=>a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b)=>(c)=>a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x)=>x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x)=>x.decode).reduce(wrap, id);\n    return {\n        encode,\n        decode\n    };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */ function alphabet(alphabet) {\n    return {\n        encode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"alphabet.encode input should be an array of numbers\");\n            return digits.map((i)=>{\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input)=>{\n            if (!Array.isArray(input) || input.length && typeof input[0] !== \"string\") throw new Error(\"alphabet.decode input should be array of strings\");\n            return input.map((letter)=>{\n                if (typeof letter !== \"string\") throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function join(separator = \"\") {\n    if (typeof separator !== \"string\") throw new Error(\"join separator should be string\");\n    return {\n        encode: (from)=>{\n            if (!Array.isArray(from) || from.length && typeof from[0] !== \"string\") throw new Error(\"join.encode input should be array of strings\");\n            for (let i of from)if (typeof i !== \"string\") throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to)=>{\n            if (typeof to !== \"string\") throw new Error(\"join.decode input should be string\");\n            return to.split(separator);\n        }\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */ function padding(bits, chr = \"=\") {\n    assertNumber(bits);\n    if (typeof chr !== \"string\") throw new Error(\"padding chr should be string\");\n    return {\n        encode (data) {\n            if (!Array.isArray(data) || data.length && typeof data[0] !== \"string\") throw new Error(\"padding.encode input should be array of strings\");\n            for (let i of data)if (typeof i !== \"string\") throw new Error(`padding.encode: non-string input=${i}`);\n            while(data.length * bits % 8)data.push(chr);\n            return data;\n        },\n        decode (input) {\n            if (!Array.isArray(input) || input.length && typeof input[0] !== \"string\") throw new Error(\"padding.encode input should be array of strings\");\n            for (let i of input)if (typeof i !== \"string\") throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if (end * bits % 8) throw new Error(\"Invalid padding: string should have whole number of bytes\");\n            for(; end > 0 && input[end - 1] === chr; end--){\n                if (!((end - 1) * bits % 8)) throw new Error(\"Invalid padding: string has too much padding\");\n            }\n            return input.slice(0, end);\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function normalize(fn) {\n    if (typeof fn !== \"function\") throw new Error(\"normalize fn should be function\");\n    return {\n        encode: (from)=>from,\n        decode: (to)=>fn(to)\n    };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */ function convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data)) throw new Error(\"convertRadix: data should be array\");\n    if (!data.length) return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d)=>{\n        assertNumber(d);\n        if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);\n    });\n    while(true){\n        let carry = 0;\n        let done = true;\n        for(let i = pos; i < digits.length; i++){\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {\n                throw new Error(\"convertRadix: carry overflow\");\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error(\"convertRadix: carry overflow\");\n            if (!done) continue;\n            else if (!rounded) pos = i;\n            else done = false;\n        }\n        res.push(carry);\n        if (done) break;\n    }\n    for(let i = 0; i < data.length - 1 && data[i] === 0; i++)res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b)=>!b ? a : gcd(b, a % b);\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to)=>from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */ function convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data)) throw new Error(\"convertRadix2: data should be array\");\n    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data){\n        assertNumber(n);\n        if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = carry << from | n;\n        if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for(; pos >= to; pos -= to)res.push((carry >> pos - to & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = carry << to - pos & mask;\n    if (!padding && pos >= from) throw new Error(\"Excess padding\");\n    if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0) res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes)=>{\n            if (!isBytes(bytes)) throw new Error(\"radix.encode input should be Uint8Array\");\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"radix.decode input should be array of numbers\");\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        }\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */ function radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32) throw new Error(\"radix2: bits should be in (0..32]\");\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error(\"radix2: carry overflow\");\n    return {\n        encode: (bytes)=>{\n            if (!isBytes(bytes)) throw new Error(\"radix2.encode input should be Uint8Array\");\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"radix2.decode input should be array of numbers\");\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function unsafeWrapper(fn) {\n    if (typeof fn !== \"function\") throw new Error(\"unsafeWrapper fn should be function\");\n    return function(...args) {\n        try {\n            return fn.apply(null, args);\n        } catch (e) {}\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== \"function\") throw new Error(\"checksum fn should be function\");\n    return {\n        encode (data) {\n            if (!isBytes(data)) throw new Error(\"checksum.encode: input should be Uint8Array\");\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode (data) {\n            if (!isBytes(data)) throw new Error(\"checksum.decode: input should be Uint8Array\");\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for(let i = 0; i < len; i++)if (newChecksum[i] !== oldChecksum[i]) throw new Error(\"Invalid checksum\");\n            return payload;\n        }\n    };\n}\n// prettier-ignore\nexports.utils = {\n    alphabet,\n    chain,\n    checksum,\n    convertRadix,\n    convertRadix2,\n    radix,\n    radix2,\n    join,\n    padding\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nexports.base16 = chain(radix2(4), alphabet(\"0123456789ABCDEF\"), join(\"\"));\nexports.base32 = chain(radix2(5), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), padding(5), join(\"\"));\nexports.base32nopad = chain(radix2(5), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), join(\"\"));\nexports.base32hex = chain(radix2(5), alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), padding(5), join(\"\"));\nexports.base32hexnopad = chain(radix2(5), alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), join(\"\"));\nexports.base32crockford = chain(radix2(5), alphabet(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"), join(\"\"), normalize((s)=>s.toUpperCase().replace(/O/g, \"0\").replace(/[IL]/g, \"1\")));\nexports.base64 = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), padding(6), join(\"\"));\nexports.base64nopad = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), join(\"\"));\nexports.base64url = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), padding(6), join(\"\"));\nexports.base64urlnopad = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), join(\"\"));\n// base58 code\n// -----------\nconst genBase58 = (abc)=>chain(radix(58), alphabet(abc), join(\"\"));\nexports.base58 = genBase58(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\nexports.base58flickr = genBase58(\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\");\nexports.base58xrp = genBase58(\"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\");\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [\n    0,\n    2,\n    3,\n    5,\n    6,\n    7,\n    9,\n    10,\n    11\n];\nexports.base58xmr = {\n    encode (data) {\n        let res = \"\";\n        for(let i = 0; i < data.length; i += 8){\n            const block = data.subarray(i, i + 8);\n            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], \"1\");\n        }\n        return res;\n    },\n    decode (str) {\n        let res = [];\n        for(let i = 0; i < str.length; i += 11){\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = exports.base58.decode(slice);\n            for(let j = 0; j < block.length - blockLen; j++){\n                if (block[j] !== 0) throw new Error(\"base58xmr: wrong padding\");\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    }\n};\nconst createBase58check = (sha256)=>chain(checksum(4, (data)=>sha256(sha256(data))), exports.base58);\nexports.createBase58check = createBase58check;\n// legacy export, bad name\nexports.base58check = exports.createBase58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet(\"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"), join(\"\"));\nconst POLYMOD_GENERATORS = [\n    0x3b6a57b2,\n    0x26508e6d,\n    0x1ea119fa,\n    0x3d4233dd,\n    0x2a1462b3\n];\n/**\n * @__NO_SIDE_EFFECTS__\n */ function bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for(let i = 0; i < POLYMOD_GENERATORS.length; i++){\n        if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for(let i = 0; i < len; i++){\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ c >> 5;\n    }\n    chk = bech32Polymod(chk);\n    for(let i = 0; i < len; i++)chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;\n    for (let v of words)chk = bech32Polymod(chk) ^ v;\n    for(let i = 0; i < 6; i++)chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([\n        chk % 2 ** 30\n    ], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function genBech32(encoding) {\n    const ENCODING_CONST = encoding === \"bech32\" ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== \"string\") throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (words instanceof Uint8Array) words = Array.from(words);\n        if (!Array.isArray(words) || words.length && typeof words[0] !== \"number\") throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        if (prefix.length === 0) throw new TypeError(`Invalid prefix length ${prefix.length}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== \"string\") throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf(\"1\");\n        if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6) throw new Error(\"Data must be at least 6 characters long\");\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return {\n            prefix,\n            words\n        };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return {\n            prefix,\n            words,\n            bytes: fromWords(words)\n        };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords\n    };\n}\nexports.bech32 = genBech32(\"bech32\");\nexports.bech32m = genBech32(\"bech32m\");\nexports.utf8 = {\n    encode: (data)=>new TextDecoder().decode(data),\n    decode: (str)=>new TextEncoder().encode(str)\n};\nexports.hex = chain(radix2(4), alphabet(\"0123456789abcdef\"), join(\"\"), normalize((s)=>{\n    if (typeof s !== \"string\" || s.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8: exports.utf8,\n    hex: exports.hex,\n    base16: exports.base16,\n    base32: exports.base32,\n    base64: exports.base64,\n    base64url: exports.base64url,\n    base58: exports.base58,\n    base58xmr: exports.base58xmr\n};\nconst coderTypeError = \"Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr\";\nconst bytesToString = (type, bytes)=>{\n    if (typeof type !== \"string\" || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (!isBytes(bytes)) throw new TypeError(\"bytesToString() expects Uint8Array\");\n    return CODERS[type].encode(bytes);\n};\nexports.bytesToString = bytesToString;\nexports.str = exports.bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str)=>{\n    if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (typeof str !== \"string\") throw new TypeError(\"stringToBytes() expects string\");\n    return CODERS[type].decode(str);\n};\nexports.stringToBytes = stringToBytes;\nexports.bytes = exports.stringToBytes; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2Isa0VBQWtFLEdBQ2xFQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHQSxxQkFBcUIsR0FBR0EsV0FBVyxHQUFHQSxxQkFBcUIsR0FBR0EsV0FBVyxHQUFHQSxZQUFZLEdBQUdBLGVBQWUsR0FBR0EsY0FBYyxHQUFHQSxtQkFBbUIsR0FBR0EseUJBQXlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0Esb0JBQW9CLEdBQUdBLGNBQWMsR0FBR0Esc0JBQXNCLEdBQUdBLGlCQUFpQixHQUFHQSxtQkFBbUIsR0FBR0EsY0FBYyxHQUFHQSx1QkFBdUIsR0FBR0Esc0JBQXNCLEdBQUdBLGlCQUFpQixHQUFHQSxtQkFBbUIsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUdBLGFBQWEsR0FBRyxLQUFLO0FBQ3hmQSxvQkFBb0IsR0FBRzJCO0FBQ3ZCLFlBQVk7QUFDWjs7Q0FFQyxHQUNELFNBQVNBLGFBQWFDLENBQUM7SUFDbkIsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNGLElBQ3RCLE1BQU0sSUFBSUcsTUFBTSxDQUFDLGVBQWUsRUFBRUgsRUFBRSxDQUFDO0FBQzdDO0FBQ0EsU0FBU0ksUUFBUUMsQ0FBQztJQUNkLE9BQVFBLGFBQWFDLGNBQ2hCRCxLQUFLLFFBQVEsT0FBT0EsTUFBTSxZQUFZQSxFQUFFRSxXQUFXLENBQUNDLElBQUksS0FBSztBQUN0RTtBQUNBOztDQUVDLEdBQ0QsU0FBU0MsTUFBTSxHQUFHQyxJQUFJO0lBQ2xCLE1BQU1DLEtBQUssQ0FBQ04sSUFBTUE7SUFDbEIsK0NBQStDO0lBQy9DLE1BQU1PLE9BQU8sQ0FBQ1AsR0FBR1EsSUFBTSxDQUFDQyxJQUFNVCxFQUFFUSxFQUFFQztJQUNsQyw2REFBNkQ7SUFDN0QsTUFBTUMsU0FBU0wsS0FBS00sR0FBRyxDQUFDLENBQUND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cE07QUFDQSxNQUFNeUksaUJBQWlCO0FBQ3ZCLE1BQU1oSixnQkFBZ0IsQ0FBQ2lKLE1BQU1wSjtJQUN6QixJQUFJLE9BQU9vSixTQUFTLFlBQVksQ0FBQ0YsT0FBT0csY0FBYyxDQUFDRCxPQUNuRCxNQUFNLElBQUlmLFVBQVVjO0lBQ3hCLElBQUksQ0FBQ3JILFFBQVE5QixRQUNULE1BQU0sSUFBSXFJLFVBQVU7SUFDeEIsT0FBT2EsTUFBTSxDQUFDRSxLQUFLLENBQUMzRyxNQUFNLENBQUN6QztBQUMvQjtBQUNBRixxQkFBcUIsR0FBR0s7QUFDeEJMLFdBQVcsR0FBR0EsUUFBUUssYUFBYSxFQUFFLG1DQUFtQztBQUN4RSxNQUFNRixnQkFBZ0IsQ0FBQ21KLE1BQU1sSjtJQUN6QixJQUFJLENBQUNnSixPQUFPRyxjQUFjLENBQUNELE9BQ3ZCLE1BQU0sSUFBSWYsVUFBVWM7SUFDeEIsSUFBSSxPQUFPakosUUFBUSxVQUNmLE1BQU0sSUFBSW1JLFVBQVU7SUFDeEIsT0FBT2EsTUFBTSxDQUFDRSxLQUFLLENBQUN2RyxNQUFNLENBQUMzQztBQUMvQjtBQUNBSixxQkFBcUIsR0FBR0c7QUFDeEJILGFBQWEsR0FBR0EsUUFBUUcsYUFBYSxFQUNyQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iZXR0ZXJoYWNrLy4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9pbmRleC5qcz8xODI0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyohIHNjdXJlLWJhc2UgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnl0ZXMgPSBleHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGV4cG9ydHMuaGV4ID0gZXhwb3J0cy51dGY4ID0gZXhwb3J0cy5iZWNoMzJtID0gZXhwb3J0cy5iZWNoMzIgPSBleHBvcnRzLmJhc2U1OGNoZWNrID0gZXhwb3J0cy5jcmVhdGVCYXNlNThjaGVjayA9IGV4cG9ydHMuYmFzZTU4eG1yID0gZXhwb3J0cy5iYXNlNTh4cnAgPSBleHBvcnRzLmJhc2U1OGZsaWNrciA9IGV4cG9ydHMuYmFzZTU4ID0gZXhwb3J0cy5iYXNlNjR1cmxub3BhZCA9IGV4cG9ydHMuYmFzZTY0dXJsID0gZXhwb3J0cy5iYXNlNjRub3BhZCA9IGV4cG9ydHMuYmFzZTY0ID0gZXhwb3J0cy5iYXNlMzJjcm9ja2ZvcmQgPSBleHBvcnRzLmJhc2UzMmhleG5vcGFkID0gZXhwb3J0cy5iYXNlMzJoZXggPSBleHBvcnRzLmJhc2UzMm5vcGFkID0gZXhwb3J0cy5iYXNlMzIgPSBleHBvcnRzLmJhc2UxNiA9IGV4cG9ydHMudXRpbHMgPSB2b2lkIDA7XG5leHBvcnRzLmFzc2VydE51bWJlciA9IGFzc2VydE51bWJlcjtcbi8vIFV0aWxpdGllc1xuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBhc3NlcnROdW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtufWApO1xufVxuZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAoYSAhPSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5JykpO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjaGFpbiguLi5hcmdzKSB7XG4gICAgY29uc3QgaWQgPSAoYSkgPT4gYTtcbiAgICAvLyBXcmFwIGNhbGwgaW4gY2xvc3VyZSBzbyBKSVQgY2FuIGlubGluZSBjYWxsc1xuICAgIGNvbnN0IHdyYXAgPSAoYSwgYikgPT4gKGMpID0+IGEoYihjKSk7XG4gICAgLy8gQ29uc3RydWN0IGNoYWluIG9mIGFyZ3NbLTFdLmVuY29kZShhcmdzWy0yXS5lbmNvZGUoWy4uLl0pKVxuICAgIGNvbnN0IGVuY29kZSA9IGFyZ3MubWFwKCh4KSA9PiB4LmVuY29kZSkucmVkdWNlUmlnaHQod3JhcCwgaWQpO1xuICAgIC8vIENvbnN0cnVjdCBjaGFpbiBvZiBhcmdzWzBdLmRlY29kZShhcmdzWzFdLmRlY29kZSguLi4pKVxuICAgIGNvbnN0IGRlY29kZSA9IGFyZ3MubWFwKCh4KSA9PiB4LmRlY29kZSkucmVkdWNlKHdyYXAsIGlkKTtcbiAgICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSB9O1xufVxuLyoqXG4gKiBFbmNvZGVzIGludGVnZXIgcmFkaXggcmVwcmVzZW50YXRpb24gdG8gYXJyYXkgb2Ygc3RyaW5ncyB1c2luZyBhbHBoYWJldCBhbmQgYmFja1xuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYWxwaGFiZXQoYWxwaGFiZXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgbnVtYmVycycpO1xuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnROdW1iZXIoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0gYWxwaGFiZXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpZ2l0IGluZGV4IG91dHNpZGUgYWxwaGFiZXQ6ICR7aX0gKGFscGhhYmV0OiAke2FscGhhYmV0Lmxlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFscGhhYmV0W2ldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5tYXAoKGxldHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGV0dGVyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhbHBoYWJldC5kZWNvZGU6IG5vdCBzdHJpbmcgZWxlbWVudD0ke2xldHRlcn1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGFscGhhYmV0LmluZGV4T2YobGV0dGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbGV0dGVyOiBcIiR7bGV0dGVyfVwiLiBBbGxvd2VkOiAke2FscGhhYmV0fWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yID0gJycpIHtcbiAgICBpZiAodHlwZW9mIHNlcGFyYXRvciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbiBzZXBhcmF0b3Igc2hvdWxkIGJlIHN0cmluZycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGZyb20pID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShmcm9tKSB8fCAoZnJvbS5sZW5ndGggJiYgdHlwZW9mIGZyb21bMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4uZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGZyb20pXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBqb2luLmVuY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICByZXR1cm4gZnJvbS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKHRvKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRvICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4uZGVjb2RlIGlucHV0IHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiB0by5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIFBhZCBzdHJpbmdzIGFycmF5IHNvIGl0IGhhcyBpbnRlZ2VyIG51bWJlciBvZiBiaXRzXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBwYWRkaW5nKGJpdHMsIGNociA9ICc9Jykge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAodHlwZW9mIGNociAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZyBjaHIgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkgfHwgKGRhdGEubGVuZ3RoICYmIHR5cGVvZiBkYXRhWzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBkYXRhKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgd2hpbGUgKChkYXRhLmxlbmd0aCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goY2hyKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGlucHV0KVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5kZWNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgbGV0IGVuZCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmICgoZW5kICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgc2hvdWxkIGhhdmUgd2hvbGUgbnVtYmVyIG9mIGJ5dGVzJyk7XG4gICAgICAgICAgICBmb3IgKDsgZW5kID4gMCAmJiBpbnB1dFtlbmQgLSAxXSA9PT0gY2hyOyBlbmQtLSkge1xuICAgICAgICAgICAgICAgIGlmICghKCgoZW5kIC0gMSkgKiBiaXRzKSAlIDgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIGhhcyB0b28gbXVjaCBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuc2xpY2UoMCwgZW5kKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBub3JtYWxpemUoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vcm1hbGl6ZSBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4geyBlbmNvZGU6IChmcm9tKSA9PiBmcm9tLCBkZWNvZGU6ICh0bykgPT4gZm4odG8pIH07XG59XG4vKipcbiAqIFNsb3c6IE8obl4yKSB0aW1lIGNvbXBsZXhpdHlcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeChkYXRhLCBmcm9tLCB0bykge1xuICAgIC8vIGJhc2UgMSBpcyBpbXBvc3NpYmxlXG4gICAgaWYgKGZyb20gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgZnJvbT0ke2Zyb219LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICh0byA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyB0bz0ke3RvfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmICghZGF0YS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBjb25zdCBkaWdpdHMgPSBBcnJheS5mcm9tKGRhdGEpO1xuICAgIGRpZ2l0cy5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgIGFzc2VydE51bWJlcihkKTtcbiAgICAgICAgaWYgKGQgPCAwIHx8IGQgPj0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtkfWApO1xuICAgIH0pO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBjYXJyeSA9IDA7XG4gICAgICAgIGxldCBkb25lID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGRpZ2l0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGlnaXQgPSBkaWdpdHNbaV07XG4gICAgICAgICAgICBjb25zdCBkaWdpdEJhc2UgPSBmcm9tICogY2FycnkgKyBkaWdpdDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZGlnaXRCYXNlKSB8fFxuICAgICAgICAgICAgICAgIChmcm9tICogY2FycnkpIC8gZnJvbSAhPT0gY2FycnkgfHxcbiAgICAgICAgICAgICAgICBkaWdpdEJhc2UgLSBkaWdpdCAhPT0gZnJvbSAqIGNhcnJ5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXJyeSA9IGRpZ2l0QmFzZSAlIHRvO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IE1hdGguZmxvb3IoZGlnaXRCYXNlIC8gdG8pO1xuICAgICAgICAgICAgZGlnaXRzW2ldID0gcm91bmRlZDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIocm91bmRlZCkgfHwgcm91bmRlZCAqIHRvICsgY2FycnkgIT09IGRpZ2l0QmFzZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFyb3VuZGVkKVxuICAgICAgICAgICAgICAgIHBvcyA9IGk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5KTtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDEgJiYgZGF0YVtpXSA9PT0gMDsgaSsrKVxuICAgICAgICByZXMucHVzaCgwKTtcbiAgICByZXR1cm4gcmVzLnJldmVyc2UoKTtcbn1cbmNvbnN0IGdjZCA9IC8qIEBfX05PX1NJREVfRUZGRUNUU19fICovIChhLCBiKSA9PiAoIWIgPyBhIDogZ2NkKGIsIGEgJSBiKSk7XG5jb25zdCByYWRpeDJjYXJyeSA9IC8qQF9fTk9fU0lERV9FRkZFQ1RTX18gKi8gKGZyb20sIHRvKSA9PiBmcm9tICsgKHRvIC0gZ2NkKGZyb20sIHRvKSk7XG4vKipcbiAqIEltcGxlbWVudGVkIHdpdGggbnVtYmVycywgYmVjYXVzZSBCaWdJbnQgaXMgNXggc2xvd2VyXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgyKGRhdGEsIGZyb20sIHRvLCBwYWRkaW5nKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDI6IGRhdGEgc2hvdWxkIGJlIGFycmF5Jyk7XG4gICAgaWYgKGZyb20gPD0gMCB8fCBmcm9tID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgZnJvbT0ke2Zyb219YCk7XG4gICAgaWYgKHRvIDw9IDAgfHwgdG8gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyB0bz0ke3RvfWApO1xuICAgIGlmIChyYWRpeDJjYXJyeShmcm9tLCB0bykgPiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IGZyb209JHtmcm9tfSB0bz0ke3RvfSBjYXJyeUJpdHM9JHtyYWRpeDJjYXJyeShmcm9tLCB0byl9YCk7XG4gICAgfVxuICAgIGxldCBjYXJyeSA9IDA7XG4gICAgbGV0IHBvcyA9IDA7IC8vIGJpdHdpc2UgcG9zaXRpb24gaW4gY3VycmVudCBlbGVtZW50XG4gICAgY29uc3QgbWFzayA9IDIgKiogdG8gLSAxO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbiBvZiBkYXRhKSB7XG4gICAgICAgIGFzc2VydE51bWJlcihuKTtcbiAgICAgICAgaWYgKG4gPj0gMiAqKiBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBpbnZhbGlkIGRhdGEgd29yZD0ke259IGZyb209JHtmcm9tfWApO1xuICAgICAgICBjYXJyeSA9IChjYXJyeSA8PCBmcm9tKSB8IG47XG4gICAgICAgIGlmIChwb3MgKyBmcm9tID4gMzIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IHBvcz0ke3Bvc30gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIHBvcyArPSBmcm9tO1xuICAgICAgICBmb3IgKDsgcG9zID49IHRvOyBwb3MgLT0gdG8pXG4gICAgICAgICAgICByZXMucHVzaCgoKGNhcnJ5ID4+IChwb3MgLSB0bykpICYgbWFzaykgPj4+IDApO1xuICAgICAgICBjYXJyeSAmPSAyICoqIHBvcyAtIDE7IC8vIGNsZWFuIGNhcnJ5LCBvdGhlcndpc2UgaXQgd2lsbCBjYXVzZSBvdmVyZmxvd1xuICAgIH1cbiAgICBjYXJyeSA9IChjYXJyeSA8PCAodG8gLSBwb3MpKSAmIG1hc2s7XG4gICAgaWYgKCFwYWRkaW5nICYmIHBvcyA+PSBmcm9tKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4Y2VzcyBwYWRkaW5nJyk7XG4gICAgaWYgKCFwYWRkaW5nICYmIGNhcnJ5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi16ZXJvIHBhZGRpbmc6ICR7Y2Fycnl9YCk7XG4gICAgaWYgKHBhZGRpbmcgJiYgcG9zID4gMClcbiAgICAgICAgcmVzLnB1c2goY2FycnkgPj4+IDApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHJhZGl4KG51bSkge1xuICAgIGFzc2VydE51bWJlcihudW0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXguZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFJhZGl4KEFycmF5LmZyb20oYnl0ZXMpLCAyICoqIDgsIG51bSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXguZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeChkaWdpdHMsIG51bSwgMiAqKiA4KSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogSWYgYm90aCBiYXNlcyBhcmUgcG93ZXIgb2Ygc2FtZSBudW1iZXIgKGxpa2UgYDIqKjggPC0+IDIqKjY0YCksXG4gKiB0aGVyZSBpcyBhIGxpbmVhciBhbGdvcml0aG0uIEZvciBub3cgd2UgaGF2ZSBpbXBsZW1lbnRhdGlvbiBmb3IgcG93ZXItb2YtdHdvIGJhc2VzIG9ubHkuXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiByYWRpeDIoYml0cywgcmV2UGFkZGluZyA9IGZhbHNlKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGJpdHMpO1xuICAgIGlmIChiaXRzIDw9IDAgfHwgYml0cyA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogYml0cyBzaG91bGQgYmUgaW4gKDAuLjMyXScpO1xuICAgIGlmIChyYWRpeDJjYXJyeSg4LCBiaXRzKSA+IDMyIHx8IHJhZGl4MmNhcnJ5KGJpdHMsIDgpID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBjYXJyeSBvdmVyZmxvdycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeDIoQXJyYXkuZnJvbShieXRlcyksIDgsIGJpdHMsICFyZXZQYWRkaW5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeDIoZGlnaXRzLCBiaXRzLCA4LCByZXZQYWRkaW5nKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gdW5zYWZlV3JhcHBlcihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zYWZlV3JhcHBlciBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY2hlY2tzdW0obGVuLCBmbikge1xuICAgIGFzc2VydE51bWJlcihsZW4pO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0gZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhkYXRhKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmVuY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gZm4oZGF0YSkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgbGVuKTtcbiAgICAgICAgICAgIHJlcy5zZXQoZGF0YSk7XG4gICAgICAgICAgICByZXMuc2V0KGNoZWNrc3VtLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGRhdGEpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZGVjb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGEuc2xpY2UoMCwgLWxlbik7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGVja3N1bSA9IGZuKHBheWxvYWQpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCBvbGRDaGVja3N1bSA9IGRhdGEuc2xpY2UoLWxlbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChuZXdDaGVja3N1bVtpXSAhPT0gb2xkQ2hlY2tzdW1baV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGVja3N1bScpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0cy51dGlscyA9IHtcbiAgICBhbHBoYWJldCwgY2hhaW4sIGNoZWNrc3VtLCBjb252ZXJ0UmFkaXgsIGNvbnZlcnRSYWRpeDIsIHJhZGl4LCByYWRpeDIsIGpvaW4sIHBhZGRpbmcsXG59O1xuLy8gUkZDIDQ2NDggYWthIFJGQyAzNTQ4XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydHMuYmFzZTE2ID0gY2hhaW4ocmFkaXgyKDQpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRicpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2UzMiA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3JyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydHMuYmFzZTMybm9wYWQgPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2UzMmhleCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydHMuYmFzZTMyaGV4bm9wYWQgPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2UzMmNyb2NrZm9yZCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSEpLTU5QUVJTVFZXWFlaJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9PL2csICcwJykucmVwbGFjZSgvW0lMXS9nLCAnMScpKSk7XG5leHBvcnRzLmJhc2U2NCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlNjRub3BhZCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlNjR1cmwgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmV4cG9ydHMuYmFzZTY0dXJsbm9wYWQgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIGpvaW4oJycpKTtcbi8vIGJhc2U1OCBjb2RlXG4vLyAtLS0tLS0tLS0tLVxuY29uc3QgZ2VuQmFzZTU4ID0gKGFiYykgPT4gY2hhaW4ocmFkaXgoNTgpLCBhbHBoYWJldChhYmMpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2U1OCA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eicpO1xuZXhwb3J0cy5iYXNlNThmbGlja3IgPSBnZW5CYXNlNTgoJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonKTtcbmV4cG9ydHMuYmFzZTU4eHJwID0gZ2VuQmFzZTU4KCdycHNobmFmMzl3QlVETkVHSEpLTE00UFFSU1Q3VldYWVoyYmNkZUNnNjVqa204b0ZxaTF0dXZBeHl6Jyk7XG4vLyB4bXIgdmVyIGlzIGRvbmUgaW4gOC1ieXRlIGJsb2NrcyAod2hpY2ggZXF1YWxzIDExIGNoYXJzIGluIGRlY29kaW5nKS4gTGFzdCAobm9uLWZ1bGwpIGJsb2NrIHBhZGRlZCB3aXRoICcxJyB0byBzaXplIGluIFhNUl9CTE9DS19MRU4uXG4vLyBCbG9jayBlbmNvZGluZyBzaWduaWZpY2FudGx5IHJlZHVjZXMgcXVhZHJhdGljIGNvbXBsZXhpdHkgb2YgYmFzZTU4LlxuLy8gRGF0YSBsZW4gKGluZGV4KSAtPiBlbmNvZGVkIGJsb2NrIGxlblxuY29uc3QgWE1SX0JMT0NLX0xFTiA9IFswLCAyLCAzLCA1LCA2LCA3LCA5LCAxMCwgMTFdO1xuZXhwb3J0cy5iYXNlNTh4bXIgPSB7XG4gICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gZGF0YS5zdWJhcnJheShpLCBpICsgOCk7XG4gICAgICAgICAgICByZXMgKz0gZXhwb3J0cy5iYXNlNTguZW5jb2RlKGJsb2NrKS5wYWRTdGFydChYTVJfQkxPQ0tfTEVOW2Jsb2NrLmxlbmd0aF0sICcxJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGRlY29kZShzdHIpIHtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gc3RyLnNsaWNlKGksIGkgKyAxMSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja0xlbiA9IFhNUl9CTE9DS19MRU4uaW5kZXhPZihzbGljZS5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBleHBvcnRzLmJhc2U1OC5kZWNvZGUoc2xpY2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBibG9jay5sZW5ndGggLSBibG9ja0xlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrW2pdICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jhc2U1OHhtcjogd3JvbmcgcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChBcnJheS5mcm9tKGJsb2NrLnNsaWNlKGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20ocmVzKTtcbiAgICB9LFxufTtcbmNvbnN0IGNyZWF0ZUJhc2U1OGNoZWNrID0gKHNoYTI1NikgPT4gY2hhaW4oY2hlY2tzdW0oNCwgKGRhdGEpID0+IHNoYTI1NihzaGEyNTYoZGF0YSkpKSwgZXhwb3J0cy5iYXNlNTgpO1xuZXhwb3J0cy5jcmVhdGVCYXNlNThjaGVjayA9IGNyZWF0ZUJhc2U1OGNoZWNrO1xuLy8gbGVnYWN5IGV4cG9ydCwgYmFkIG5hbWVcbmV4cG9ydHMuYmFzZTU4Y2hlY2sgPSBleHBvcnRzLmNyZWF0ZUJhc2U1OGNoZWNrO1xuY29uc3QgQkVDSF9BTFBIQUJFVCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihhbHBoYWJldCgncXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2wnKSwgam9pbignJykpO1xuY29uc3QgUE9MWU1PRF9HRU5FUkFUT1JTID0gWzB4M2I2YTU3YjIsIDB4MjY1MDhlNmQsIDB4MWVhMTE5ZmEsIDB4M2Q0MjMzZGQsIDB4MmExNDYyYjNdO1xuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBiZWNoMzJQb2x5bW9kKHByZSkge1xuICAgIGNvbnN0IGIgPSBwcmUgPj4gMjU7XG4gICAgbGV0IGNoayA9IChwcmUgJiAweDFmZmZmZmYpIDw8IDU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQT0xZTU9EX0dFTkVSQVRPUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCgoYiA+PiBpKSAmIDEpID09PSAxKVxuICAgICAgICAgICAgY2hrIF49IFBPTFlNT0RfR0VORVJBVE9SU1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaztcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIGVuY29kaW5nQ29uc3QgPSAxKSB7XG4gICAgY29uc3QgbGVuID0gcHJlZml4Lmxlbmd0aDtcbiAgICBsZXQgY2hrID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByZWZpeCAoJHtwcmVmaXh9KWApO1xuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAoYyA+PiA1KTtcbiAgICB9XG4gICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChwcmVmaXguY2hhckNvZGVBdChpKSAmIDB4MWYpO1xuICAgIGZvciAobGV0IHYgb2Ygd29yZHMpXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIHY7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBjaGsgXj0gZW5jb2RpbmdDb25zdDtcbiAgICByZXR1cm4gQkVDSF9BTFBIQUJFVC5lbmNvZGUoY29udmVydFJhZGl4MihbY2hrICUgMiAqKiAzMF0sIDMwLCA1LCBmYWxzZSkpO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBnZW5CZWNoMzIoZW5jb2RpbmcpIHtcbiAgICBjb25zdCBFTkNPRElOR19DT05TVCA9IGVuY29kaW5nID09PSAnYmVjaDMyJyA/IDEgOiAweDJiYzgzMGEzO1xuICAgIGNvbnN0IF93b3JkcyA9IHJhZGl4Mig1KTtcbiAgICBjb25zdCBmcm9tV29yZHMgPSBfd29yZHMuZGVjb2RlO1xuICAgIGNvbnN0IHRvV29yZHMgPSBfd29yZHMuZW5jb2RlO1xuICAgIGNvbnN0IGZyb21Xb3Jkc1Vuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZnJvbVdvcmRzKTtcbiAgICBmdW5jdGlvbiBlbmNvZGUocHJlZml4LCB3b3JkcywgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHByZWZpeCAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgcHJlZml4IHNob3VsZCBiZSBzdHJpbmcsIG5vdCAke3R5cGVvZiBwcmVmaXh9YCk7XG4gICAgICAgIGlmICh3b3JkcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgICAgICB3b3JkcyA9IEFycmF5LmZyb20od29yZHMpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZHMpIHx8ICh3b3Jkcy5sZW5ndGggJiYgdHlwZW9mIHdvcmRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgd29yZHMgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMsIG5vdCAke3R5cGVvZiB3b3Jkc31gKTtcbiAgICAgICAgaWYgKHByZWZpeC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHByZWZpeCBsZW5ndGggJHtwcmVmaXgubGVuZ3RofWApO1xuICAgICAgICBjb25zdCBhY3R1YWxMZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgNyArIHdvcmRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxpbWl0ICE9PSBmYWxzZSAmJiBhY3R1YWxMZW5ndGggPiBsaW1pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYExlbmd0aCAke2FjdHVhbExlbmd0aH0gZXhjZWVkcyBsaW1pdCAke2xpbWl0fWApO1xuICAgICAgICBjb25zdCBsb3dlcmVkID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShsb3dlcmVkLCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICByZXR1cm4gYCR7bG93ZXJlZH0xJHtCRUNIX0FMUEhBQkVULmVuY29kZSh3b3Jkcyl9JHtzdW19YDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHN0cn1gKTtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc3RyLmxlbmd0aCA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFdyb25nIHN0cmluZyBsZW5ndGg6ICR7c3RyLmxlbmd0aH0gKCR7c3RyfSkuIEV4cGVjdGVkICg4Li4ke2xpbWl0fSlgKTtcbiAgICAgICAgLy8gZG9uJ3QgYWxsb3cgbWl4ZWQgY2FzZVxuICAgICAgICBjb25zdCBsb3dlcmVkID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSBzdHIudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaW5nIG11c3QgYmUgbG93ZXJjYXNlIG9yIHVwcGVyY2FzZWApO1xuICAgICAgICBjb25zdCBzZXBJbmRleCA9IGxvd2VyZWQubGFzdEluZGV4T2YoJzEnKTtcbiAgICAgICAgaWYgKHNlcEluZGV4ID09PSAwIHx8IHNlcEluZGV4ID09PSAtMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGV0dGVyIFwiMVwiIG11c3QgYmUgcHJlc2VudCBiZXR3ZWVuIHByZWZpeCBhbmQgZGF0YSBvbmx5YCk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGxvd2VyZWQuc2xpY2UoMCwgc2VwSW5kZXgpO1xuICAgICAgICBjb25zdCBkYXRhID0gbG93ZXJlZC5zbGljZShzZXBJbmRleCArIDEpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCA2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgYmUgYXQgbGVhc3QgNiBjaGFyYWN0ZXJzIGxvbmcnKTtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBCRUNIX0FMUEhBQkVULmRlY29kZShkYXRhKS5zbGljZSgwLCAtNik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIGlmICghZGF0YS5lbmRzV2l0aChzdW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoZWNrc3VtIGluICR7c3RyfTogZXhwZWN0ZWQgXCIke3N1bX1cImApO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzIH07XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZVVuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZGVjb2RlKTtcbiAgICBmdW5jdGlvbiBkZWNvZGVUb0J5dGVzKHN0cikge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgd29yZHMgfSA9IGRlY29kZShzdHIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcywgYnl0ZXM6IGZyb21Xb3Jkcyh3b3JkcykgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlRnJvbUJ5dGVzKHByZWZpeCwgYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZShwcmVmaXgsIHRvV29yZHMoYnl0ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlLFxuICAgICAgICBkZWNvZGUsXG4gICAgICAgIGVuY29kZUZyb21CeXRlcyxcbiAgICAgICAgZGVjb2RlVG9CeXRlcyxcbiAgICAgICAgZGVjb2RlVW5zYWZlLFxuICAgICAgICBmcm9tV29yZHMsXG4gICAgICAgIGZyb21Xb3Jkc1Vuc2FmZSxcbiAgICAgICAgdG9Xb3JkcyxcbiAgICB9O1xufVxuZXhwb3J0cy5iZWNoMzIgPSBnZW5CZWNoMzIoJ2JlY2gzMicpO1xuZXhwb3J0cy5iZWNoMzJtID0gZ2VuQmVjaDMyKCdiZWNoMzJtJyk7XG5leHBvcnRzLnV0ZjggPSB7XG4gICAgZW5jb2RlOiAoZGF0YSkgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpLFxuICAgIGRlY29kZTogKHN0cikgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0ciksXG59O1xuZXhwb3J0cy5oZXggPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5YWJjZGVmJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnIHx8IHMubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaGV4LmRlY29kZTogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc30gd2l0aCBsZW5ndGggJHtzLmxlbmd0aH1gKTtcbiAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpO1xufSkpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBDT0RFUlMgPSB7XG4gICAgdXRmODogZXhwb3J0cy51dGY4LCBoZXg6IGV4cG9ydHMuaGV4LCBiYXNlMTY6IGV4cG9ydHMuYmFzZTE2LCBiYXNlMzI6IGV4cG9ydHMuYmFzZTMyLCBiYXNlNjQ6IGV4cG9ydHMuYmFzZTY0LCBiYXNlNjR1cmw6IGV4cG9ydHMuYmFzZTY0dXJsLCBiYXNlNTg6IGV4cG9ydHMuYmFzZTU4LCBiYXNlNTh4bXI6IGV4cG9ydHMuYmFzZTU4eG1yXG59O1xuY29uc3QgY29kZXJUeXBlRXJyb3IgPSAnSW52YWxpZCBlbmNvZGluZyB0eXBlLiBBdmFpbGFibGUgdHlwZXM6IHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtcic7XG5jb25zdCBieXRlc1RvU3RyaW5nID0gKHR5cGUsIGJ5dGVzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyB8fCAhQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1RvU3RyaW5nKCkgZXhwZWN0cyBVaW50OEFycmF5Jyk7XG4gICAgcmV0dXJuIENPREVSU1t0eXBlXS5lbmNvZGUoYnl0ZXMpO1xufTtcbmV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGJ5dGVzVG9TdHJpbmc7XG5leHBvcnRzLnN0ciA9IGV4cG9ydHMuYnl0ZXNUb1N0cmluZzsgLy8gYXMgaW4gcHl0aG9uLCBidXQgZm9yIGJ5dGVzIG9ubHlcbmNvbnN0IHN0cmluZ1RvQnl0ZXMgPSAodHlwZSwgc3RyKSA9PiB7XG4gICAgaWYgKCFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5nVG9CeXRlcygpIGV4cGVjdHMgc3RyaW5nJyk7XG4gICAgcmV0dXJuIENPREVSU1t0eXBlXS5kZWNvZGUoc3RyKTtcbn07XG5leHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuZXhwb3J0cy5ieXRlcyA9IGV4cG9ydHMuc3RyaW5nVG9CeXRlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImJ5dGVzIiwic3RyaW5nVG9CeXRlcyIsInN0ciIsImJ5dGVzVG9TdHJpbmciLCJoZXgiLCJ1dGY4IiwiYmVjaDMybSIsImJlY2gzMiIsImJhc2U1OGNoZWNrIiwiY3JlYXRlQmFzZTU4Y2hlY2siLCJiYXNlNTh4bXIiLCJiYXNlNTh4cnAiLCJiYXNlNThmbGlja3IiLCJiYXNlNTgiLCJiYXNlNjR1cmxub3BhZCIsImJhc2U2NHVybCIsImJhc2U2NG5vcGFkIiwiYmFzZTY0IiwiYmFzZTMyY3JvY2tmb3JkIiwiYmFzZTMyaGV4bm9wYWQiLCJiYXNlMzJoZXgiLCJiYXNlMzJub3BhZCIsImJhc2UzMiIsImJhc2UxNiIsInV0aWxzIiwiYXNzZXJ0TnVtYmVyIiwibiIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsImlzQnl0ZXMiLCJhIiwiVWludDhBcnJheSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImNoYWluIiwiYXJncyIsImlkIiwid3JhcCIsImIiLCJjIiwiZW5jb2RlIiwibWFwIiwieCIsInJlZHVjZVJpZ2h0IiwiZGVjb2RlIiwicmVkdWNlIiwiYWxwaGFiZXQiLCJkaWdpdHMiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJpIiwiaW5wdXQiLCJsZXR0ZXIiLCJpbmRleCIsImluZGV4T2YiLCJqb2luIiwic2VwYXJhdG9yIiwiZnJvbSIsInRvIiwic3BsaXQiLCJwYWRkaW5nIiwiYml0cyIsImNociIsImRhdGEiLCJwdXNoIiwiZW5kIiwic2xpY2UiLCJub3JtYWxpemUiLCJmbiIsImNvbnZlcnRSYWRpeCIsInBvcyIsInJlcyIsImZvckVhY2giLCJkIiwiY2FycnkiLCJkb25lIiwiZGlnaXQiLCJkaWdpdEJhc2UiLCJyb3VuZGVkIiwiTWF0aCIsImZsb29yIiwicmV2ZXJzZSIsImdjZCIsInJhZGl4MmNhcnJ5IiwiY29udmVydFJhZGl4MiIsIm1hc2siLCJyYWRpeCIsIm51bSIsInJhZGl4MiIsInJldlBhZGRpbmciLCJ1bnNhZmVXcmFwcGVyIiwiYXBwbHkiLCJlIiwiY2hlY2tzdW0iLCJsZW4iLCJzZXQiLCJwYXlsb2FkIiwibmV3Q2hlY2tzdW0iLCJvbGRDaGVja3N1bSIsInMiLCJ0b1VwcGVyQ2FzZSIsInJlcGxhY2UiLCJnZW5CYXNlNTgiLCJhYmMiLCJYTVJfQkxPQ0tfTEVOIiwiYmxvY2siLCJzdWJhcnJheSIsInBhZFN0YXJ0IiwiYmxvY2tMZW4iLCJqIiwiY29uY2F0Iiwic2hhMjU2IiwiQkVDSF9BTFBIQUJFVCIsIlBPTFlNT0RfR0VORVJBVE9SUyIsImJlY2gzMlBvbHltb2QiLCJwcmUiLCJjaGsiLCJiZWNoQ2hlY2tzdW0iLCJwcmVmaXgiLCJ3b3JkcyIsImVuY29kaW5nQ29uc3QiLCJjaGFyQ29kZUF0IiwidiIsImdlbkJlY2gzMiIsImVuY29kaW5nIiwiRU5DT0RJTkdfQ09OU1QiLCJfd29yZHMiLCJmcm9tV29yZHMiLCJ0b1dvcmRzIiwiZnJvbVdvcmRzVW5zYWZlIiwibGltaXQiLCJUeXBlRXJyb3IiLCJhY3R1YWxMZW5ndGgiLCJsb3dlcmVkIiwidG9Mb3dlckNhc2UiLCJzdW0iLCJzZXBJbmRleCIsImxhc3RJbmRleE9mIiwiZW5kc1dpdGgiLCJkZWNvZGVVbnNhZmUiLCJkZWNvZGVUb0J5dGVzIiwiZW5jb2RlRnJvbUJ5dGVzIiwiVGV4dERlY29kZXIiLCJUZXh0RW5jb2RlciIsIkNPREVSUyIsImNvZGVyVHlwZUVycm9yIiwidHlwZSIsImhhc093blByb3BlcnR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/base/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/starknet/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@scure/starknet/lib/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.poseidonHashMany = exports.poseidonHashSingle = exports.poseidonHashFunc = exports.poseidonHash = exports.poseidonSmall = exports.poseidonCreate = exports.poseidonBasic = exports._poseidonMDS = exports.Fp251 = exports.keccak = exports.computeHashOnElements = exports.pedersen = exports.getAccountPath = exports.ethSigToPrivate = exports.getStarkKey = exports.grindKey = exports.utils = exports.Signature = exports.ProjectivePoint = exports.CURVE = exports.verify = exports.sign = exports.getSharedSecret = exports.getPublicKey = exports._starkCurve = exports.MAX_VALUE = void 0;\nconst sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@noble/hashes/sha3.js\");\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/sha256.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nconst modular_1 = __webpack_require__(/*! @noble/curves/abstract/modular */ \"(ssr)/./node_modules/@noble/curves/abstract/modular.js\");\nconst poseidon_1 = __webpack_require__(/*! @noble/curves/abstract/poseidon */ \"(ssr)/./node_modules/@noble/curves/abstract/poseidon.js\");\nconst weierstrass_1 = __webpack_require__(/*! @noble/curves/abstract/weierstrass */ \"(ssr)/./node_modules/@noble/curves/abstract/weierstrass.js\");\nconst u = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/abstract/utils.js\");\nconst _shortw_utils_1 = __webpack_require__(/*! @noble/curves/_shortw_utils */ \"(ssr)/./node_modules/@noble/curves/_shortw_utils.js\");\nconst CURVE_ORDER = BigInt(\"3618502788666131213697322783095070105526743751716087489154079457884512865583\");\nexports.MAX_VALUE = BigInt(\"0x800000000000000000000000000000000000000000000000000000000000000\");\nconst nBitLength = 252;\nfunction bits2int(bytes) {\n    while(bytes[0] === 0)bytes = bytes.subarray(1);\n    const delta = bytes.length * 8 - nBitLength;\n    const num = u.bytesToNumberBE(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction hex0xToBytes(hex) {\n    if (typeof hex === \"string\") {\n        hex = strip0x(hex);\n        if (hex.length & 1) hex = \"0\" + hex;\n    }\n    return u.hexToBytes(hex);\n}\nconst curve = (0, weierstrass_1.weierstrass)({\n    a: BigInt(1),\n    b: BigInt(\"3141592653589793238462643383279502884197169399375105820974944592307816406665\"),\n    Fp: (0, modular_1.Field)(BigInt(\"0x800000000000011000000000000000000000000000000000000000000000001\")),\n    n: CURVE_ORDER,\n    nBitLength,\n    Gx: BigInt(\"874739451078007766457464989774322083649278607533249481151382481072868806602\"),\n    Gy: BigInt(\"152666792071518830868575557812948353041420400780739481342941381225525861407\"),\n    h: BigInt(1),\n    lowS: false,\n    ...(0, _shortw_utils_1.getHash)(sha256_1.sha256),\n    bits2int,\n    bits2int_modN: (bytes)=>{\n        const hex = u.bytesToNumberBE(bytes).toString(16);\n        if (hex.length === 63) bytes = hex0xToBytes(hex + \"0\");\n        return (0, modular_1.mod)(bits2int(bytes), CURVE_ORDER);\n    }\n});\nexports._starkCurve = curve;\nfunction ensureBytes(hex) {\n    return u.ensureBytes(\"\", typeof hex === \"string\" ? hex0xToBytes(hex) : hex);\n}\nfunction normPrivKey(privKey) {\n    return u.bytesToHex(ensureBytes(privKey)).padStart(64, \"0\");\n}\nfunction getPublicKey(privKey, isCompressed = false) {\n    return curve.getPublicKey(normPrivKey(privKey), isCompressed);\n}\nexports.getPublicKey = getPublicKey;\nfunction getSharedSecret(privKeyA, pubKeyB) {\n    return curve.getSharedSecret(normPrivKey(privKeyA), pubKeyB);\n}\nexports.getSharedSecret = getSharedSecret;\nfunction checkSignature(signature) {\n    const { r, s } = signature;\n    if (r < 0n || r >= exports.MAX_VALUE) throw new Error(`Signature.r should be [1, ${exports.MAX_VALUE})`);\n    const w = (0, modular_1.invert)(s, CURVE_ORDER);\n    if (w < 0n || w >= exports.MAX_VALUE) throw new Error(`inv(Signature.s) should be [1, ${exports.MAX_VALUE})`);\n}\nfunction checkMessage(msgHash) {\n    const bytes = ensureBytes(msgHash);\n    const num = u.bytesToNumberBE(bytes);\n    if (num >= exports.MAX_VALUE) throw new Error(`msgHash should be [0, ${exports.MAX_VALUE})`);\n    return bytes;\n}\nfunction sign(msgHash, privKey, opts) {\n    const sig = curve.sign(checkMessage(msgHash), normPrivKey(privKey), opts);\n    checkSignature(sig);\n    return sig;\n}\nexports.sign = sign;\nfunction verify(signature, msgHash, pubKey) {\n    if (!(signature instanceof Signature)) {\n        const bytes = ensureBytes(signature);\n        try {\n            signature = Signature.fromDER(bytes);\n        } catch (derError) {\n            if (!(derError instanceof weierstrass_1.DER.Err)) throw derError;\n            signature = Signature.fromCompact(bytes);\n        }\n    }\n    checkSignature(signature);\n    return curve.verify(signature, checkMessage(msgHash), ensureBytes(pubKey));\n}\nexports.verify = verify;\nconst { CURVE, ProjectivePoint, Signature, utils } = curve;\nexports.CURVE = CURVE;\nexports.ProjectivePoint = ProjectivePoint;\nexports.Signature = Signature;\nexports.utils = utils;\nfunction extractX(bytes) {\n    const hex = u.bytesToHex(bytes.subarray(1));\n    const stripped = hex.replace(/^0+/gm, \"\");\n    return `0x${stripped}`;\n}\nfunction strip0x(hex) {\n    return hex.replace(/^0x/i, \"\");\n}\nfunction grindKey(seed) {\n    const _seed = ensureBytes(seed);\n    const sha256mask = 2n ** 256n;\n    const limit = sha256mask - (0, modular_1.mod)(sha256mask, CURVE_ORDER);\n    for(let i = 0;; i++){\n        const key = sha256Num(u.concatBytes(_seed, u.numberToVarBytesBE(BigInt(i))));\n        if (key < limit) return (0, modular_1.mod)(key, CURVE_ORDER).toString(16);\n        if (i === 100000) throw new Error(\"grindKey is broken: tried 100k vals\");\n    }\n}\nexports.grindKey = grindKey;\nfunction getStarkKey(privateKey) {\n    return extractX(getPublicKey(privateKey, true));\n}\nexports.getStarkKey = getStarkKey;\nfunction ethSigToPrivate(signature) {\n    signature = strip0x(signature);\n    if (signature.length !== 130) throw new Error(\"Wrong ethereum signature\");\n    return grindKey(signature.substring(0, 64));\n}\nexports.ethSigToPrivate = ethSigToPrivate;\nconst MASK_31 = 2n ** 31n - 1n;\nconst int31 = (n)=>Number(n & MASK_31);\nfunction getAccountPath(layer, application, ethereumAddress, index) {\n    const layerNum = int31(sha256Num(layer));\n    const applicationNum = int31(sha256Num(application));\n    const eth = u.hexToNumber(strip0x(ethereumAddress));\n    return `m/2645'/${layerNum}'/${applicationNum}'/${int31(eth)}'/${int31(eth >> 31n)}'/${index}`;\n}\nexports.getAccountPath = getAccountPath;\nconst PEDERSEN_POINTS = [\n    new ProjectivePoint(2089986280348253421170679821480865132823066470938446095505822317253594081284n, 1713931329540660377023406109199410414810705867260802078187082345529207694986n, 1n),\n    new ProjectivePoint(996781205833008774514500082376783249102396023663454813447423147977397232763n, 1668503676786377725805489344771023921079126552019160156920634619255970485781n, 1n),\n    new ProjectivePoint(2251563274489750535117886426533222435294046428347329203627021249169616184184n, 1798716007562728905295480679789526322175868328062420237419143593021674992973n, 1n),\n    new ProjectivePoint(2138414695194151160943305727036575959195309218611738193261179310511854807447n, 113410276730064486255102093846540133784865286929052426931474106396135072156n, 1n),\n    new ProjectivePoint(2379962749567351885752724891227938183011949129833673362440656643086021394946n, 776496453633298175483985398648758586525933812536653089401905292063708816422n, 1n)\n];\nfunction pedersenPrecompute(p1, p2) {\n    const out = [];\n    let p = p1;\n    for(let i = 0; i < 248; i++){\n        out.push(p);\n        p = p.double();\n    }\n    p = p2;\n    for(let i = 0; i < 4; i++){\n        out.push(p);\n        p = p.double();\n    }\n    return out;\n}\nconst PEDERSEN_POINTS1 = pedersenPrecompute(PEDERSEN_POINTS[1], PEDERSEN_POINTS[2]);\nconst PEDERSEN_POINTS2 = pedersenPrecompute(PEDERSEN_POINTS[3], PEDERSEN_POINTS[4]);\nfunction pedersenArg(arg) {\n    let value;\n    if (typeof arg === \"bigint\") {\n        value = arg;\n    } else if (typeof arg === \"number\") {\n        if (!Number.isSafeInteger(arg)) throw new Error(`Invalid pedersenArg: ${arg}`);\n        value = BigInt(arg);\n    } else {\n        value = u.bytesToNumberBE(ensureBytes(arg));\n    }\n    if (!(0n <= value && value < curve.CURVE.Fp.ORDER)) throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${value}`);\n    return value;\n}\nfunction pedersenSingle(point, value, constants) {\n    let x = pedersenArg(value);\n    for(let j = 0; j < 252; j++){\n        const pt = constants[j];\n        if (pt.equals(point)) throw new Error(\"Same point\");\n        if ((x & 1n) !== 0n) point = point.add(pt);\n        x >>= 1n;\n    }\n    return point;\n}\nfunction pedersen(x, y) {\n    let point = PEDERSEN_POINTS[0];\n    point = pedersenSingle(point, x, PEDERSEN_POINTS1);\n    point = pedersenSingle(point, y, PEDERSEN_POINTS2);\n    return extractX(point.toRawBytes(true));\n}\nexports.pedersen = pedersen;\nconst computeHashOnElements = (data, fn = pedersen)=>[\n        0,\n        ...data,\n        data.length\n    ].reduce((x, y)=>fn(x, y));\nexports.computeHashOnElements = computeHashOnElements;\nconst MASK_250 = u.bitMask(250);\nconst keccak = (data)=>u.bytesToNumberBE((0, sha3_1.keccak_256)(data)) & MASK_250;\nexports.keccak = keccak;\nconst sha256Num = (data)=>u.bytesToNumberBE((0, sha256_1.sha256)(data));\nexports.Fp251 = (0, modular_1.Field)(BigInt(\"3618502788666131213697322783095070105623107215331596699973092056135872020481\"));\nfunction poseidonRoundConstant(Fp, name, idx) {\n    const val = Fp.fromBytes((0, sha256_1.sha256)((0, utils_1.utf8ToBytes)(`${name}${idx}`)));\n    return Fp.create(val);\n}\nfunction _poseidonMDS(Fp, name, m, attempt = 0) {\n    const x_values = [];\n    const y_values = [];\n    for(let i = 0; i < m; i++){\n        x_values.push(poseidonRoundConstant(Fp, `${name}x`, attempt * m + i));\n        y_values.push(poseidonRoundConstant(Fp, `${name}y`, attempt * m + i));\n    }\n    if (new Set([\n        ...x_values,\n        ...y_values\n    ]).size !== 2 * m) throw new Error(\"X and Y values are not distinct\");\n    return x_values.map((x)=>y_values.map((y)=>Fp.inv(Fp.sub(x, y))));\n}\nexports._poseidonMDS = _poseidonMDS;\nconst MDS_SMALL = [\n    [\n        3,\n        1,\n        1\n    ],\n    [\n        1,\n        -1,\n        1\n    ],\n    [\n        1,\n        1,\n        -2\n    ]\n].map((i)=>i.map(BigInt));\nfunction poseidonBasic(opts, mds) {\n    (0, modular_1.validateField)(opts.Fp);\n    if (!Number.isSafeInteger(opts.rate) || !Number.isSafeInteger(opts.capacity)) throw new Error(`Wrong poseidon opts: ${opts}`);\n    const m = opts.rate + opts.capacity;\n    const rounds = opts.roundsFull + opts.roundsPartial;\n    const roundConstants = [];\n    for(let i = 0; i < rounds; i++){\n        const row = [];\n        for(let j = 0; j < m; j++)row.push(poseidonRoundConstant(opts.Fp, \"Hades\", m * i + j));\n        roundConstants.push(row);\n    }\n    const res = (0, poseidon_1.poseidon)({\n        ...opts,\n        t: m,\n        sboxPower: 3,\n        reversePartialPowIdx: true,\n        mds,\n        roundConstants\n    });\n    res.m = m;\n    res.rate = opts.rate;\n    res.capacity = opts.capacity;\n    return res;\n}\nexports.poseidonBasic = poseidonBasic;\nfunction poseidonCreate(opts, mdsAttempt = 0) {\n    const m = opts.rate + opts.capacity;\n    if (!Number.isSafeInteger(mdsAttempt)) throw new Error(`Wrong mdsAttempt=${mdsAttempt}`);\n    return poseidonBasic(opts, _poseidonMDS(opts.Fp, \"HadesMDS\", m, mdsAttempt));\n}\nexports.poseidonCreate = poseidonCreate;\nexports.poseidonSmall = poseidonBasic({\n    Fp: exports.Fp251,\n    rate: 2,\n    capacity: 1,\n    roundsFull: 8,\n    roundsPartial: 83\n}, MDS_SMALL);\nfunction poseidonHash(x, y, fn = exports.poseidonSmall) {\n    return fn([\n        x,\n        y,\n        2n\n    ])[0];\n}\nexports.poseidonHash = poseidonHash;\nfunction poseidonHashFunc(x, y, fn = exports.poseidonSmall) {\n    return u.numberToVarBytesBE(poseidonHash(u.bytesToNumberBE(x), u.bytesToNumberBE(y), fn));\n}\nexports.poseidonHashFunc = poseidonHashFunc;\nfunction poseidonHashSingle(x, fn = exports.poseidonSmall) {\n    return fn([\n        x,\n        0n,\n        1n\n    ])[0];\n}\nexports.poseidonHashSingle = poseidonHashSingle;\nfunction poseidonHashMany(values, fn = exports.poseidonSmall) {\n    const { m, rate } = fn;\n    if (!Array.isArray(values)) throw new Error(\"bigint array expected in values\");\n    const padded = Array.from(values);\n    padded.push(1n);\n    while(padded.length % rate !== 0)padded.push(0n);\n    let state = new Array(m).fill(0n);\n    for(let i = 0; i < padded.length; i += rate){\n        for(let j = 0; j < rate; j++)state[j] += padded[i + j];\n        state = fn(state);\n    }\n    return state[0];\n}\nexports.poseidonHashMany = poseidonHashMany;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsd0JBQXdCLEdBQUdBLDBCQUEwQixHQUFHQSx3QkFBd0IsR0FBR0Esb0JBQW9CLEdBQUdBLHFCQUFxQixHQUFHQSxzQkFBc0IsR0FBR0EscUJBQXFCLEdBQUdBLG9CQUFvQixHQUFHQSxhQUFhLEdBQUdBLGNBQWMsR0FBR0EsNkJBQTZCLEdBQUdBLGdCQUFnQixHQUFHQSxzQkFBc0IsR0FBR0EsdUJBQXVCLEdBQUdBLG1CQUFtQixHQUFHQSxnQkFBZ0IsR0FBR0EsYUFBYSxHQUFHQSxpQkFBaUIsR0FBR0EsdUJBQXVCLEdBQUdBLGFBQWEsR0FBR0EsY0FBYyxHQUFHQSxZQUFZLEdBQUdBLHVCQUF1QixHQUFHQSxvQkFBb0IsR0FBR0EsbUJBQW1CLEdBQUdBLGlCQUFpQixHQUFHLEtBQUs7QUFDeGtCLE1BQU00QixTQUFTQyxtQkFBT0EsQ0FBQyxzRUFBb0I7QUFDM0MsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsMEVBQXNCO0FBQy9DLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLHdFQUFxQjtBQUM3QyxNQUFNRyxZQUFZSCxtQkFBT0EsQ0FBQyw4RkFBZ0M7QUFDMUQsTUFBTUksYUFBYUosbUJBQU9BLENBQUMsZ0dBQWlDO0FBQzVELE1BQU1LLGdCQUFnQkwsbUJBQU9BLENBQUMsc0dBQW9DO0FBQ2xFLE1BQU1NLElBQUlOLG1CQUFPQSxDQUFDLDBGQUE4QjtBQUNoRCxNQUFNTyxrQkFBa0JQLG1CQUFPQSxDQUFDLHdGQUE2QjtBQUM3RCxNQUFNUSxjQUFjQyxPQUFPO0FBQzNCdEMsaUJBQWlCLEdBQUdzQyxPQUFPO0FBQzNCLE1BQU1DLGFBQWE7QUFDbkIsU0FBU0MsU0FBU0MsS0FBSztJQUNuQixNQUFPQSxLQUFLLENBQUMsRUFBRSxLQUFLLEVBQ2hCQSxRQUFR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cmUvc3RhcmtuZXQvbGliL2luZGV4LmpzPzQ0OWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBvc2VpZG9uSGFzaE1hbnkgPSBleHBvcnRzLnBvc2VpZG9uSGFzaFNpbmdsZSA9IGV4cG9ydHMucG9zZWlkb25IYXNoRnVuYyA9IGV4cG9ydHMucG9zZWlkb25IYXNoID0gZXhwb3J0cy5wb3NlaWRvblNtYWxsID0gZXhwb3J0cy5wb3NlaWRvbkNyZWF0ZSA9IGV4cG9ydHMucG9zZWlkb25CYXNpYyA9IGV4cG9ydHMuX3Bvc2VpZG9uTURTID0gZXhwb3J0cy5GcDI1MSA9IGV4cG9ydHMua2VjY2FrID0gZXhwb3J0cy5jb21wdXRlSGFzaE9uRWxlbWVudHMgPSBleHBvcnRzLnBlZGVyc2VuID0gZXhwb3J0cy5nZXRBY2NvdW50UGF0aCA9IGV4cG9ydHMuZXRoU2lnVG9Qcml2YXRlID0gZXhwb3J0cy5nZXRTdGFya0tleSA9IGV4cG9ydHMuZ3JpbmRLZXkgPSBleHBvcnRzLnV0aWxzID0gZXhwb3J0cy5TaWduYXR1cmUgPSBleHBvcnRzLlByb2plY3RpdmVQb2ludCA9IGV4cG9ydHMuQ1VSVkUgPSBleHBvcnRzLnZlcmlmeSA9IGV4cG9ydHMuc2lnbiA9IGV4cG9ydHMuZ2V0U2hhcmVkU2VjcmV0ID0gZXhwb3J0cy5nZXRQdWJsaWNLZXkgPSBleHBvcnRzLl9zdGFya0N1cnZlID0gZXhwb3J0cy5NQVhfVkFMVUUgPSB2b2lkIDA7XG5jb25zdCBzaGEzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEzXCIpO1xuY29uc3Qgc2hhMjU2XzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5jb25zdCBtb2R1bGFyXzEgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9tb2R1bGFyXCIpO1xuY29uc3QgcG9zZWlkb25fMSA9IHJlcXVpcmUoXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3Bvc2VpZG9uXCIpO1xuY29uc3Qgd2VpZXJzdHJhc3NfMSA9IHJlcXVpcmUoXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3dlaWVyc3RyYXNzXCIpO1xuY29uc3QgdSA9IHJlcXVpcmUoXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzXCIpO1xuY29uc3QgX3Nob3J0d191dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9jdXJ2ZXMvX3Nob3J0d191dGlsc1wiKTtcbmNvbnN0IENVUlZFX09SREVSID0gQmlnSW50KCczNjE4NTAyNzg4NjY2MTMxMjEzNjk3MzIyNzgzMDk1MDcwMTA1NTI2NzQzNzUxNzE2MDg3NDg5MTU0MDc5NDU3ODg0NTEyODY1NTgzJyk7XG5leHBvcnRzLk1BWF9WQUxVRSA9IEJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTtcbmNvbnN0IG5CaXRMZW5ndGggPSAyNTI7XG5mdW5jdGlvbiBiaXRzMmludChieXRlcykge1xuICAgIHdoaWxlIChieXRlc1swXSA9PT0gMClcbiAgICAgICAgYnl0ZXMgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICBjb25zdCBkZWx0YSA9IGJ5dGVzLmxlbmd0aCAqIDggLSBuQml0TGVuZ3RoO1xuICAgIGNvbnN0IG51bSA9IHUuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG59XG5mdW5jdGlvbiBoZXgweFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhleCA9IHN0cmlwMHgoaGV4KTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggJiAxKVxuICAgICAgICAgICAgaGV4ID0gJzAnICsgaGV4O1xuICAgIH1cbiAgICByZXR1cm4gdS5oZXhUb0J5dGVzKGhleCk7XG59XG5jb25zdCBjdXJ2ZSA9ICgwLCB3ZWllcnN0cmFzc18xLndlaWVyc3RyYXNzKSh7XG4gICAgYTogQmlnSW50KDEpLFxuICAgIGI6IEJpZ0ludCgnMzE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTUwMjg4NDE5NzE2OTM5OTM3NTEwNTgyMDk3NDk0NDU5MjMwNzgxNjQwNjY2NScpLFxuICAgIEZwOiAoMCwgbW9kdWxhcl8xLkZpZWxkKShCaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDExMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJykpLFxuICAgIG46IENVUlZFX09SREVSLFxuICAgIG5CaXRMZW5ndGgsXG4gICAgR3g6IEJpZ0ludCgnODc0NzM5NDUxMDc4MDA3NzY2NDU3NDY0OTg5Nzc0MzIyMDgzNjQ5Mjc4NjA3NTMzMjQ5NDgxMTUxMzgyNDgxMDcyODY4ODA2NjAyJyksXG4gICAgR3k6IEJpZ0ludCgnMTUyNjY2NzkyMDcxNTE4ODMwODY4NTc1NTU3ODEyOTQ4MzUzMDQxNDIwNDAwNzgwNzM5NDgxMzQyOTQxMzgxMjI1NTI1ODYxNDA3JyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IGZhbHNlLFxuICAgIC4uLigwLCBfc2hvcnR3X3V0aWxzXzEuZ2V0SGFzaCkoc2hhMjU2XzEuc2hhMjU2KSxcbiAgICBiaXRzMmludCxcbiAgICBiaXRzMmludF9tb2ROOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgY29uc3QgaGV4ID0gdS5ieXRlc1RvTnVtYmVyQkUoYnl0ZXMpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDYzKVxuICAgICAgICAgICAgYnl0ZXMgPSBoZXgweFRvQnl0ZXMoaGV4ICsgJzAnKTtcbiAgICAgICAgcmV0dXJuICgwLCBtb2R1bGFyXzEubW9kKShiaXRzMmludChieXRlcyksIENVUlZFX09SREVSKTtcbiAgICB9LFxufSk7XG5leHBvcnRzLl9zdGFya0N1cnZlID0gY3VydmU7XG5mdW5jdGlvbiBlbnN1cmVCeXRlcyhoZXgpIHtcbiAgICByZXR1cm4gdS5lbnN1cmVCeXRlcygnJywgdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoZXgweFRvQnl0ZXMoaGV4KSA6IGhleCk7XG59XG5mdW5jdGlvbiBub3JtUHJpdktleShwcml2S2V5KSB7XG4gICAgcmV0dXJuIHUuYnl0ZXNUb0hleChlbnN1cmVCeXRlcyhwcml2S2V5KSkucGFkU3RhcnQoNjQsICcwJyk7XG59XG5mdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdktleSwgaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICByZXR1cm4gY3VydmUuZ2V0UHVibGljS2V5KG5vcm1Qcml2S2V5KHByaXZLZXkpLCBpc0NvbXByZXNzZWQpO1xufVxuZXhwb3J0cy5nZXRQdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXk7XG5mdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdktleUEsIHB1YktleUIpIHtcbiAgICByZXR1cm4gY3VydmUuZ2V0U2hhcmVkU2VjcmV0KG5vcm1Qcml2S2V5KHByaXZLZXlBKSwgcHViS2V5Qik7XG59XG5leHBvcnRzLmdldFNoYXJlZFNlY3JldCA9IGdldFNoYXJlZFNlY3JldDtcbmZ1bmN0aW9uIGNoZWNrU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHsgciwgcyB9ID0gc2lnbmF0dXJlO1xuICAgIGlmIChyIDwgMG4gfHwgciA+PSBleHBvcnRzLk1BWF9WQUxVRSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaWduYXR1cmUuciBzaG91bGQgYmUgWzEsICR7ZXhwb3J0cy5NQVhfVkFMVUV9KWApO1xuICAgIGNvbnN0IHcgPSAoMCwgbW9kdWxhcl8xLmludmVydCkocywgQ1VSVkVfT1JERVIpO1xuICAgIGlmICh3IDwgMG4gfHwgdyA+PSBleHBvcnRzLk1BWF9WQUxVRSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnYoU2lnbmF0dXJlLnMpIHNob3VsZCBiZSBbMSwgJHtleHBvcnRzLk1BWF9WQUxVRX0pYCk7XG59XG5mdW5jdGlvbiBjaGVja01lc3NhZ2UobXNnSGFzaCkge1xuICAgIGNvbnN0IGJ5dGVzID0gZW5zdXJlQnl0ZXMobXNnSGFzaCk7XG4gICAgY29uc3QgbnVtID0gdS5ieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgIGlmIChudW0gPj0gZXhwb3J0cy5NQVhfVkFMVUUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbXNnSGFzaCBzaG91bGQgYmUgWzAsICR7ZXhwb3J0cy5NQVhfVkFMVUV9KWApO1xuICAgIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cykge1xuICAgIGNvbnN0IHNpZyA9IGN1cnZlLnNpZ24oY2hlY2tNZXNzYWdlKG1zZ0hhc2gpLCBub3JtUHJpdktleShwcml2S2V5KSwgb3B0cyk7XG4gICAgY2hlY2tTaWduYXR1cmUoc2lnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuZXhwb3J0cy5zaWduID0gc2lnbjtcbmZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YktleSkge1xuICAgIGlmICghKHNpZ25hdHVyZSBpbnN0YW5jZW9mIFNpZ25hdHVyZSkpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVCeXRlcyhzaWduYXR1cmUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21ERVIoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiB3ZWllcnN0cmFzc18xLkRFUi5FcnIpKVxuICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja1NpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIHJldHVybiBjdXJ2ZS52ZXJpZnkoc2lnbmF0dXJlLCBjaGVja01lc3NhZ2UobXNnSGFzaCksIGVuc3VyZUJ5dGVzKHB1YktleSkpO1xufVxuZXhwb3J0cy52ZXJpZnkgPSB2ZXJpZnk7XG5jb25zdCB7IENVUlZFLCBQcm9qZWN0aXZlUG9pbnQsIFNpZ25hdHVyZSwgdXRpbHMgfSA9IGN1cnZlO1xuZXhwb3J0cy5DVVJWRSA9IENVUlZFO1xuZXhwb3J0cy5Qcm9qZWN0aXZlUG9pbnQgPSBQcm9qZWN0aXZlUG9pbnQ7XG5leHBvcnRzLlNpZ25hdHVyZSA9IFNpZ25hdHVyZTtcbmV4cG9ydHMudXRpbHMgPSB1dGlscztcbmZ1bmN0aW9uIGV4dHJhY3RYKGJ5dGVzKSB7XG4gICAgY29uc3QgaGV4ID0gdS5ieXRlc1RvSGV4KGJ5dGVzLnN1YmFycmF5KDEpKTtcbiAgICBjb25zdCBzdHJpcHBlZCA9IGhleC5yZXBsYWNlKC9eMCsvZ20sICcnKTtcbiAgICByZXR1cm4gYDB4JHtzdHJpcHBlZH1gO1xufVxuZnVuY3Rpb24gc3RyaXAweChoZXgpIHtcbiAgICByZXR1cm4gaGV4LnJlcGxhY2UoL14weC9pLCAnJyk7XG59XG5mdW5jdGlvbiBncmluZEtleShzZWVkKSB7XG4gICAgY29uc3QgX3NlZWQgPSBlbnN1cmVCeXRlcyhzZWVkKTtcbiAgICBjb25zdCBzaGEyNTZtYXNrID0gMm4gKiogMjU2bjtcbiAgICBjb25zdCBsaW1pdCA9IHNoYTI1Nm1hc2sgLSAoMCwgbW9kdWxhcl8xLm1vZCkoc2hhMjU2bWFzaywgQ1VSVkVfT1JERVIpO1xuICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHNoYTI1Nk51bSh1LmNvbmNhdEJ5dGVzKF9zZWVkLCB1Lm51bWJlclRvVmFyQnl0ZXNCRShCaWdJbnQoaSkpKSk7XG4gICAgICAgIGlmIChrZXkgPCBsaW1pdClcbiAgICAgICAgICAgIHJldHVybiAoMCwgbW9kdWxhcl8xLm1vZCkoa2V5LCBDVVJWRV9PUkRFUikudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoaSA9PT0gMTAwMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdncmluZEtleSBpcyBicm9rZW46IHRyaWVkIDEwMGsgdmFscycpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ3JpbmRLZXkgPSBncmluZEtleTtcbmZ1bmN0aW9uIGdldFN0YXJrS2V5KHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gZXh0cmFjdFgoZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIHRydWUpKTtcbn1cbmV4cG9ydHMuZ2V0U3RhcmtLZXkgPSBnZXRTdGFya0tleTtcbmZ1bmN0aW9uIGV0aFNpZ1RvUHJpdmF0ZShzaWduYXR1cmUpIHtcbiAgICBzaWduYXR1cmUgPSBzdHJpcDB4KHNpZ25hdHVyZSk7XG4gICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggIT09IDEzMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBldGhlcmV1bSBzaWduYXR1cmUnKTtcbiAgICByZXR1cm4gZ3JpbmRLZXkoc2lnbmF0dXJlLnN1YnN0cmluZygwLCA2NCkpO1xufVxuZXhwb3J0cy5ldGhTaWdUb1ByaXZhdGUgPSBldGhTaWdUb1ByaXZhdGU7XG5jb25zdCBNQVNLXzMxID0gMm4gKiogMzFuIC0gMW47XG5jb25zdCBpbnQzMSA9IChuKSA9PiBOdW1iZXIobiAmIE1BU0tfMzEpO1xuZnVuY3Rpb24gZ2V0QWNjb3VudFBhdGgobGF5ZXIsIGFwcGxpY2F0aW9uLCBldGhlcmV1bUFkZHJlc3MsIGluZGV4KSB7XG4gICAgY29uc3QgbGF5ZXJOdW0gPSBpbnQzMShzaGEyNTZOdW0obGF5ZXIpKTtcbiAgICBjb25zdCBhcHBsaWNhdGlvbk51bSA9IGludDMxKHNoYTI1Nk51bShhcHBsaWNhdGlvbikpO1xuICAgIGNvbnN0IGV0aCA9IHUuaGV4VG9OdW1iZXIoc3RyaXAweChldGhlcmV1bUFkZHJlc3MpKTtcbiAgICByZXR1cm4gYG0vMjY0NScvJHtsYXllck51bX0nLyR7YXBwbGljYXRpb25OdW19Jy8ke2ludDMxKGV0aCl9Jy8ke2ludDMxKGV0aCA+PiAzMW4pfScvJHtpbmRleH1gO1xufVxuZXhwb3J0cy5nZXRBY2NvdW50UGF0aCA9IGdldEFjY291bnRQYXRoO1xuY29uc3QgUEVERVJTRU5fUE9JTlRTID0gW1xuICAgIG5ldyBQcm9qZWN0aXZlUG9pbnQoMjA4OTk4NjI4MDM0ODI1MzQyMTE3MDY3OTgyMTQ4MDg2NTEzMjgyMzA2NjQ3MDkzODQ0NjA5NTUwNTgyMjMxNzI1MzU5NDA4MTI4NG4sIDE3MTM5MzEzMjk1NDA2NjAzNzcwMjM0MDYxMDkxOTk0MTA0MTQ4MTA3MDU4NjcyNjA4MDIwNzgxODcwODIzNDU1MjkyMDc2OTQ5ODZuLCAxbiksXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCg5OTY3ODEyMDU4MzMwMDg3NzQ1MTQ1MDAwODIzNzY3ODMyNDkxMDIzOTYwMjM2NjM0NTQ4MTM0NDc0MjMxNDc5NzczOTcyMzI3NjNuLCAxNjY4NTAzNjc2Nzg2Mzc3NzI1ODA1NDg5MzQ0NzcxMDIzOTIxMDc5MTI2NTUyMDE5MTYwMTU2OTIwNjM0NjE5MjU1OTcwNDg1NzgxbiwgMW4pLFxuICAgIG5ldyBQcm9qZWN0aXZlUG9pbnQoMjI1MTU2MzI3NDQ4OTc1MDUzNTExNzg4NjQyNjUzMzIyMjQzNTI5NDA0NjQyODM0NzMyOTIwMzYyNzAyMTI0OTE2OTYxNjE4NDE4NG4sIDE3OTg3MTYwMDc1NjI3Mjg5MDUyOTU0ODA2Nzk3ODk1MjYzMjIxNzU4NjgzMjgwNjI0MjAyMzc0MTkxNDM1OTMwMjE2NzQ5OTI5NzNuLCAxbiksXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCgyMTM4NDE0Njk1MTk0MTUxMTYwOTQzMzA1NzI3MDM2NTc1OTU5MTk1MzA5MjE4NjExNzM4MTkzMjYxMTc5MzEwNTExODU0ODA3NDQ3biwgMTEzNDEwMjc2NzMwMDY0NDg2MjU1MTAyMDkzODQ2NTQwMTMzNzg0ODY1Mjg2OTI5MDUyNDI2OTMxNDc0MTA2Mzk2MTM1MDcyMTU2biwgMW4pLFxuICAgIG5ldyBQcm9qZWN0aXZlUG9pbnQoMjM3OTk2Mjc0OTU2NzM1MTg4NTc1MjcyNDg5MTIyNzkzODE4MzAxMTk0OTEyOTgzMzY3MzM2MjQ0MDY1NjY0MzA4NjAyMTM5NDk0Nm4sIDc3NjQ5NjQ1MzYzMzI5ODE3NTQ4Mzk4NTM5ODY0ODc1ODU4NjUyNTkzMzgxMjUzNjY1MzA4OTQwMTkwNTI5MjA2MzcwODgxNjQyMm4sIDFuKSxcbl07XG5mdW5jdGlvbiBwZWRlcnNlblByZWNvbXB1dGUocDEsIHAyKSB7XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgbGV0IHAgPSBwMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI0ODsgaSsrKSB7XG4gICAgICAgIG91dC5wdXNoKHApO1xuICAgICAgICBwID0gcC5kb3VibGUoKTtcbiAgICB9XG4gICAgcCA9IHAyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIG91dC5wdXNoKHApO1xuICAgICAgICBwID0gcC5kb3VibGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmNvbnN0IFBFREVSU0VOX1BPSU5UUzEgPSBwZWRlcnNlblByZWNvbXB1dGUoUEVERVJTRU5fUE9JTlRTWzFdLCBQRURFUlNFTl9QT0lOVFNbMl0pO1xuY29uc3QgUEVERVJTRU5fUE9JTlRTMiA9IHBlZGVyc2VuUHJlY29tcHV0ZShQRURFUlNFTl9QT0lOVFNbM10sIFBFREVSU0VOX1BPSU5UU1s0XSk7XG5mdW5jdGlvbiBwZWRlcnNlbkFyZyhhcmcpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHZhbHVlID0gYXJnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGFyZykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGVkZXJzZW5Bcmc6ICR7YXJnfWApO1xuICAgICAgICB2YWx1ZSA9IEJpZ0ludChhcmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB1LmJ5dGVzVG9OdW1iZXJCRShlbnN1cmVCeXRlcyhhcmcpKTtcbiAgICB9XG4gICAgaWYgKCEoMG4gPD0gdmFsdWUgJiYgdmFsdWUgPCBjdXJ2ZS5DVVJWRS5GcC5PUkRFUikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUGVkZXJzZW5Bcmcgc2hvdWxkIGJlIDAgPD0gdmFsdWUgPCBDVVJWRS5QOiAke3ZhbHVlfWApO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHBlZGVyc2VuU2luZ2xlKHBvaW50LCB2YWx1ZSwgY29uc3RhbnRzKSB7XG4gICAgbGV0IHggPSBwZWRlcnNlbkFyZyh2YWx1ZSk7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAyNTI7IGorKykge1xuICAgICAgICBjb25zdCBwdCA9IGNvbnN0YW50c1tqXTtcbiAgICAgICAgaWYgKHB0LmVxdWFscyhwb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NhbWUgcG9pbnQnKTtcbiAgICAgICAgaWYgKCh4ICYgMW4pICE9PSAwbilcbiAgICAgICAgICAgIHBvaW50ID0gcG9pbnQuYWRkKHB0KTtcbiAgICAgICAgeCA+Pj0gMW47XG4gICAgfVxuICAgIHJldHVybiBwb2ludDtcbn1cbmZ1bmN0aW9uIHBlZGVyc2VuKHgsIHkpIHtcbiAgICBsZXQgcG9pbnQgPSBQRURFUlNFTl9QT0lOVFNbMF07XG4gICAgcG9pbnQgPSBwZWRlcnNlblNpbmdsZShwb2ludCwgeCwgUEVERVJTRU5fUE9JTlRTMSk7XG4gICAgcG9pbnQgPSBwZWRlcnNlblNpbmdsZShwb2ludCwgeSwgUEVERVJTRU5fUE9JTlRTMik7XG4gICAgcmV0dXJuIGV4dHJhY3RYKHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkpO1xufVxuZXhwb3J0cy5wZWRlcnNlbiA9IHBlZGVyc2VuO1xuY29uc3QgY29tcHV0ZUhhc2hPbkVsZW1lbnRzID0gKGRhdGEsIGZuID0gcGVkZXJzZW4pID0+IFswLCAuLi5kYXRhLCBkYXRhLmxlbmd0aF0ucmVkdWNlKCh4LCB5KSA9PiBmbih4LCB5KSk7XG5leHBvcnRzLmNvbXB1dGVIYXNoT25FbGVtZW50cyA9IGNvbXB1dGVIYXNoT25FbGVtZW50cztcbmNvbnN0IE1BU0tfMjUwID0gdS5iaXRNYXNrKDI1MCk7XG5jb25zdCBrZWNjYWsgPSAoZGF0YSkgPT4gdS5ieXRlc1RvTnVtYmVyQkUoKDAsIHNoYTNfMS5rZWNjYWtfMjU2KShkYXRhKSkgJiBNQVNLXzI1MDtcbmV4cG9ydHMua2VjY2FrID0ga2VjY2FrO1xuY29uc3Qgc2hhMjU2TnVtID0gKGRhdGEpID0+IHUuYnl0ZXNUb051bWJlckJFKCgwLCBzaGEyNTZfMS5zaGEyNTYpKGRhdGEpKTtcbmV4cG9ydHMuRnAyNTEgPSAoMCwgbW9kdWxhcl8xLkZpZWxkKShCaWdJbnQoJzM2MTg1MDI3ODg2NjYxMzEyMTM2OTczMjI3ODMwOTUwNzAxMDU2MjMxMDcyMTUzMzE1OTY2OTk5NzMwOTIwNTYxMzU4NzIwMjA0ODEnKSk7XG5mdW5jdGlvbiBwb3NlaWRvblJvdW5kQ29uc3RhbnQoRnAsIG5hbWUsIGlkeCkge1xuICAgIGNvbnN0IHZhbCA9IEZwLmZyb21CeXRlcygoMCwgc2hhMjU2XzEuc2hhMjU2KSgoMCwgdXRpbHNfMS51dGY4VG9CeXRlcykoYCR7bmFtZX0ke2lkeH1gKSkpO1xuICAgIHJldHVybiBGcC5jcmVhdGUodmFsKTtcbn1cbmZ1bmN0aW9uIF9wb3NlaWRvbk1EUyhGcCwgbmFtZSwgbSwgYXR0ZW1wdCA9IDApIHtcbiAgICBjb25zdCB4X3ZhbHVlcyA9IFtdO1xuICAgIGNvbnN0IHlfdmFsdWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgeF92YWx1ZXMucHVzaChwb3NlaWRvblJvdW5kQ29uc3RhbnQoRnAsIGAke25hbWV9eGAsIGF0dGVtcHQgKiBtICsgaSkpO1xuICAgICAgICB5X3ZhbHVlcy5wdXNoKHBvc2VpZG9uUm91bmRDb25zdGFudChGcCwgYCR7bmFtZX15YCwgYXR0ZW1wdCAqIG0gKyBpKSk7XG4gICAgfVxuICAgIGlmIChuZXcgU2V0KFsuLi54X3ZhbHVlcywgLi4ueV92YWx1ZXNdKS5zaXplICE9PSAyICogbSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYIGFuZCBZIHZhbHVlcyBhcmUgbm90IGRpc3RpbmN0Jyk7XG4gICAgcmV0dXJuIHhfdmFsdWVzLm1hcCgoeCkgPT4geV92YWx1ZXMubWFwKCh5KSA9PiBGcC5pbnYoRnAuc3ViKHgsIHkpKSkpO1xufVxuZXhwb3J0cy5fcG9zZWlkb25NRFMgPSBfcG9zZWlkb25NRFM7XG5jb25zdCBNRFNfU01BTEwgPSBbXG4gICAgWzMsIDEsIDFdLFxuICAgIFsxLCAtMSwgMV0sXG4gICAgWzEsIDEsIC0yXSxcbl0ubWFwKChpKSA9PiBpLm1hcChCaWdJbnQpKTtcbmZ1bmN0aW9uIHBvc2VpZG9uQmFzaWMob3B0cywgbWRzKSB7XG4gICAgKDAsIG1vZHVsYXJfMS52YWxpZGF0ZUZpZWxkKShvcHRzLkZwKTtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG9wdHMucmF0ZSkgfHwgIU51bWJlci5pc1NhZmVJbnRlZ2VyKG9wdHMuY2FwYWNpdHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2VpZG9uIG9wdHM6ICR7b3B0c31gKTtcbiAgICBjb25zdCBtID0gb3B0cy5yYXRlICsgb3B0cy5jYXBhY2l0eTtcbiAgICBjb25zdCByb3VuZHMgPSBvcHRzLnJvdW5kc0Z1bGwgKyBvcHRzLnJvdW5kc1BhcnRpYWw7XG4gICAgY29uc3Qgcm91bmRDb25zdGFudHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdW5kczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKylcbiAgICAgICAgICAgIHJvdy5wdXNoKHBvc2VpZG9uUm91bmRDb25zdGFudChvcHRzLkZwLCAnSGFkZXMnLCBtICogaSArIGopKTtcbiAgICAgICAgcm91bmRDb25zdGFudHMucHVzaChyb3cpO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSAoMCwgcG9zZWlkb25fMS5wb3NlaWRvbikoe1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICB0OiBtLFxuICAgICAgICBzYm94UG93ZXI6IDMsXG4gICAgICAgIHJldmVyc2VQYXJ0aWFsUG93SWR4OiB0cnVlLFxuICAgICAgICBtZHMsXG4gICAgICAgIHJvdW5kQ29uc3RhbnRzLFxuICAgIH0pO1xuICAgIHJlcy5tID0gbTtcbiAgICByZXMucmF0ZSA9IG9wdHMucmF0ZTtcbiAgICByZXMuY2FwYWNpdHkgPSBvcHRzLmNhcGFjaXR5O1xuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLnBvc2VpZG9uQmFzaWMgPSBwb3NlaWRvbkJhc2ljO1xuZnVuY3Rpb24gcG9zZWlkb25DcmVhdGUob3B0cywgbWRzQXR0ZW1wdCA9IDApIHtcbiAgICBjb25zdCBtID0gb3B0cy5yYXRlICsgb3B0cy5jYXBhY2l0eTtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG1kc0F0dGVtcHQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIG1kc0F0dGVtcHQ9JHttZHNBdHRlbXB0fWApO1xuICAgIHJldHVybiBwb3NlaWRvbkJhc2ljKG9wdHMsIF9wb3NlaWRvbk1EUyhvcHRzLkZwLCAnSGFkZXNNRFMnLCBtLCBtZHNBdHRlbXB0KSk7XG59XG5leHBvcnRzLnBvc2VpZG9uQ3JlYXRlID0gcG9zZWlkb25DcmVhdGU7XG5leHBvcnRzLnBvc2VpZG9uU21hbGwgPSBwb3NlaWRvbkJhc2ljKHsgRnA6IGV4cG9ydHMuRnAyNTEsIHJhdGU6IDIsIGNhcGFjaXR5OiAxLCByb3VuZHNGdWxsOiA4LCByb3VuZHNQYXJ0aWFsOiA4MyB9LCBNRFNfU01BTEwpO1xuZnVuY3Rpb24gcG9zZWlkb25IYXNoKHgsIHksIGZuID0gZXhwb3J0cy5wb3NlaWRvblNtYWxsKSB7XG4gICAgcmV0dXJuIGZuKFt4LCB5LCAybl0pWzBdO1xufVxuZXhwb3J0cy5wb3NlaWRvbkhhc2ggPSBwb3NlaWRvbkhhc2g7XG5mdW5jdGlvbiBwb3NlaWRvbkhhc2hGdW5jKHgsIHksIGZuID0gZXhwb3J0cy5wb3NlaWRvblNtYWxsKSB7XG4gICAgcmV0dXJuIHUubnVtYmVyVG9WYXJCeXRlc0JFKHBvc2VpZG9uSGFzaCh1LmJ5dGVzVG9OdW1iZXJCRSh4KSwgdS5ieXRlc1RvTnVtYmVyQkUoeSksIGZuKSk7XG59XG5leHBvcnRzLnBvc2VpZG9uSGFzaEZ1bmMgPSBwb3NlaWRvbkhhc2hGdW5jO1xuZnVuY3Rpb24gcG9zZWlkb25IYXNoU2luZ2xlKHgsIGZuID0gZXhwb3J0cy5wb3NlaWRvblNtYWxsKSB7XG4gICAgcmV0dXJuIGZuKFt4LCAwbiwgMW5dKVswXTtcbn1cbmV4cG9ydHMucG9zZWlkb25IYXNoU2luZ2xlID0gcG9zZWlkb25IYXNoU2luZ2xlO1xuZnVuY3Rpb24gcG9zZWlkb25IYXNoTWFueSh2YWx1ZXMsIGZuID0gZXhwb3J0cy5wb3NlaWRvblNtYWxsKSB7XG4gICAgY29uc3QgeyBtLCByYXRlIH0gPSBmbjtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaWdpbnQgYXJyYXkgZXhwZWN0ZWQgaW4gdmFsdWVzJyk7XG4gICAgY29uc3QgcGFkZGVkID0gQXJyYXkuZnJvbSh2YWx1ZXMpO1xuICAgIHBhZGRlZC5wdXNoKDFuKTtcbiAgICB3aGlsZSAocGFkZGVkLmxlbmd0aCAlIHJhdGUgIT09IDApXG4gICAgICAgIHBhZGRlZC5wdXNoKDBuKTtcbiAgICBsZXQgc3RhdGUgPSBuZXcgQXJyYXkobSkuZmlsbCgwbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkZWQubGVuZ3RoOyBpICs9IHJhdGUpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByYXRlOyBqKyspXG4gICAgICAgICAgICBzdGF0ZVtqXSArPSBwYWRkZWRbaSArIGpdO1xuICAgICAgICBzdGF0ZSA9IGZuKHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlWzBdO1xufVxuZXhwb3J0cy5wb3NlaWRvbkhhc2hNYW55ID0gcG9zZWlkb25IYXNoTWFueTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBvc2VpZG9uSGFzaE1hbnkiLCJwb3NlaWRvbkhhc2hTaW5nbGUiLCJwb3NlaWRvbkhhc2hGdW5jIiwicG9zZWlkb25IYXNoIiwicG9zZWlkb25TbWFsbCIsInBvc2VpZG9uQ3JlYXRlIiwicG9zZWlkb25CYXNpYyIsIl9wb3NlaWRvbk1EUyIsIkZwMjUxIiwia2VjY2FrIiwiY29tcHV0ZUhhc2hPbkVsZW1lbnRzIiwicGVkZXJzZW4iLCJnZXRBY2NvdW50UGF0aCIsImV0aFNpZ1RvUHJpdmF0ZSIsImdldFN0YXJrS2V5IiwiZ3JpbmRLZXkiLCJ1dGlscyIsIlNpZ25hdHVyZSIsIlByb2plY3RpdmVQb2ludCIsIkNVUlZFIiwidmVyaWZ5Iiwic2lnbiIsImdldFNoYXJlZFNlY3JldCIsImdldFB1YmxpY0tleSIsIl9zdGFya0N1cnZlIiwiTUFYX1ZBTFVFIiwic2hhM18xIiwicmVxdWlyZSIsInNoYTI1Nl8xIiwidXRpbHNfMSIsIm1vZHVsYXJfMSIsInBvc2VpZG9uXzEiLCJ3ZWllcnN0cmFzc18xIiwidSIsIl9zaG9ydHdfdXRpbHNfMSIsIkNVUlZFX09SREVSIiwiQmlnSW50IiwibkJpdExlbmd0aCIsImJpdHMyaW50IiwiYnl0ZXMiLCJzdWJhcnJheSIsImRlbHRhIiwibGVuZ3RoIiwibnVtIiwiYnl0ZXNUb051bWJlckJFIiwiaGV4MHhUb0J5dGVzIiwiaGV4Iiwic3RyaXAweCIsImhleFRvQnl0ZXMiLCJjdXJ2ZSIsIndlaWVyc3RyYXNzIiwiYSIsImIiLCJGcCIsIkZpZWxkIiwibiIsIkd4IiwiR3kiLCJoIiwibG93UyIsImdldEhhc2giLCJzaGEyNTYiLCJiaXRzMmludF9tb2ROIiwidG9TdHJpbmciLCJtb2QiLCJlbnN1cmVCeXRlcyIsIm5vcm1Qcml2S2V5IiwicHJpdktleSIsImJ5dGVzVG9IZXgiLCJwYWRTdGFydCIsImlzQ29tcHJlc3NlZCIsInByaXZLZXlBIiwicHViS2V5QiIsImNoZWNrU2lnbmF0dXJlIiwic2lnbmF0dXJlIiwiciIsInMiLCJFcnJvciIsInciLCJpbnZlcnQiLCJjaGVja01lc3NhZ2UiLCJtc2dIYXNoIiwib3B0cyIsInNpZyIsInB1YktleSIsImZyb21ERVIiLCJkZXJFcnJvciIsIkRFUiIsIkVyciIsImZyb21Db21wYWN0IiwiZXh0cmFjdFgiLCJzdHJpcHBlZCIsInJlcGxhY2UiLCJzZWVkIiwiX3NlZWQiLCJzaGEyNTZtYXNrIiwibGltaXQiLCJpIiwia2V5Iiwic2hhMjU2TnVtIiwiY29uY2F0Qnl0ZXMiLCJudW1iZXJUb1ZhckJ5dGVzQkUiLCJwcml2YXRlS2V5Iiwic3Vic3RyaW5nIiwiTUFTS18zMSIsImludDMxIiwiTnVtYmVyIiwibGF5ZXIiLCJhcHBsaWNhdGlvbiIsImV0aGVyZXVtQWRkcmVzcyIsImluZGV4IiwibGF5ZXJOdW0iLCJhcHBsaWNhdGlvbk51bSIsImV0aCIsImhleFRvTnVtYmVyIiwiUEVERVJTRU5fUE9JTlRTIiwicGVkZXJzZW5QcmVjb21wdXRlIiwicDEiLCJwMiIsIm91dCIsInAiLCJwdXNoIiwiZG91YmxlIiwiUEVERVJTRU5fUE9JTlRTMSIsIlBFREVSU0VOX1BPSU5UUzIiLCJwZWRlcnNlbkFyZyIsImFyZyIsImlzU2FmZUludGVnZXIiLCJPUkRFUiIsInBlZGVyc2VuU2luZ2xlIiwicG9pbnQiLCJjb25zdGFudHMiLCJ4IiwiaiIsInB0IiwiZXF1YWxzIiwiYWRkIiwieSIsInRvUmF3Qnl0ZXMiLCJkYXRhIiwiZm4iLCJyZWR1Y2UiLCJNQVNLXzI1MCIsImJpdE1hc2siLCJrZWNjYWtfMjU2IiwicG9zZWlkb25Sb3VuZENvbnN0YW50IiwibmFtZSIsImlkeCIsInZhbCIsImZyb21CeXRlcyIsInV0ZjhUb0J5dGVzIiwiY3JlYXRlIiwibSIsImF0dGVtcHQiLCJ4X3ZhbHVlcyIsInlfdmFsdWVzIiwiU2V0Iiwic2l6ZSIsIm1hcCIsImludiIsInN1YiIsIk1EU19TTUFMTCIsIm1kcyIsInZhbGlkYXRlRmllbGQiLCJyYXRlIiwiY2FwYWNpdHkiLCJyb3VuZHMiLCJyb3VuZHNGdWxsIiwicm91bmRzUGFydGlhbCIsInJvdW5kQ29uc3RhbnRzIiwicm93IiwicmVzIiwicG9zZWlkb24iLCJ0Iiwic2JveFBvd2VyIiwicmV2ZXJzZVBhcnRpYWxQb3dJZHgiLCJtZHNBdHRlbXB0IiwidmFsdWVzIiwiQXJyYXkiLCJpc0FycmF5IiwicGFkZGVkIiwiZnJvbSIsInN0YXRlIiwiZmlsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/starknet/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/base/lib/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@scure/base/lib/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base32hexnopad: () => (/* binding */ base32hexnopad),\n/* harmony export */   base32nopad: () => (/* binding */ base32nopad),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64nopad: () => (/* binding */ base64nopad),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   base64urlnopad: () => (/* binding */ base64urlnopad),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   createBase58check: () => (/* binding */ createBase58check),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */ function assertNumber(n) {\n    if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);\n}\nfunction isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function chain(...args) {\n    const id = (a)=>a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b)=>(c)=>a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x)=>x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x)=>x.decode).reduce(wrap, id);\n    return {\n        encode,\n        decode\n    };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */ function alphabet(alphabet) {\n    return {\n        encode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"alphabet.encode input should be an array of numbers\");\n            return digits.map((i)=>{\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input)=>{\n            if (!Array.isArray(input) || input.length && typeof input[0] !== \"string\") throw new Error(\"alphabet.decode input should be array of strings\");\n            return input.map((letter)=>{\n                if (typeof letter !== \"string\") throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function join(separator = \"\") {\n    if (typeof separator !== \"string\") throw new Error(\"join separator should be string\");\n    return {\n        encode: (from)=>{\n            if (!Array.isArray(from) || from.length && typeof from[0] !== \"string\") throw new Error(\"join.encode input should be array of strings\");\n            for (let i of from)if (typeof i !== \"string\") throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to)=>{\n            if (typeof to !== \"string\") throw new Error(\"join.decode input should be string\");\n            return to.split(separator);\n        }\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */ function padding(bits, chr = \"=\") {\n    assertNumber(bits);\n    if (typeof chr !== \"string\") throw new Error(\"padding chr should be string\");\n    return {\n        encode (data) {\n            if (!Array.isArray(data) || data.length && typeof data[0] !== \"string\") throw new Error(\"padding.encode input should be array of strings\");\n            for (let i of data)if (typeof i !== \"string\") throw new Error(`padding.encode: non-string input=${i}`);\n            while(data.length * bits % 8)data.push(chr);\n            return data;\n        },\n        decode (input) {\n            if (!Array.isArray(input) || input.length && typeof input[0] !== \"string\") throw new Error(\"padding.encode input should be array of strings\");\n            for (let i of input)if (typeof i !== \"string\") throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if (end * bits % 8) throw new Error(\"Invalid padding: string should have whole number of bytes\");\n            for(; end > 0 && input[end - 1] === chr; end--){\n                if (!((end - 1) * bits % 8)) throw new Error(\"Invalid padding: string has too much padding\");\n            }\n            return input.slice(0, end);\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function normalize(fn) {\n    if (typeof fn !== \"function\") throw new Error(\"normalize fn should be function\");\n    return {\n        encode: (from)=>from,\n        decode: (to)=>fn(to)\n    };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */ function convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data)) throw new Error(\"convertRadix: data should be array\");\n    if (!data.length) return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d)=>{\n        assertNumber(d);\n        if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);\n    });\n    while(true){\n        let carry = 0;\n        let done = true;\n        for(let i = pos; i < digits.length; i++){\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {\n                throw new Error(\"convertRadix: carry overflow\");\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error(\"convertRadix: carry overflow\");\n            if (!done) continue;\n            else if (!rounded) pos = i;\n            else done = false;\n        }\n        res.push(carry);\n        if (done) break;\n    }\n    for(let i = 0; i < data.length - 1 && data[i] === 0; i++)res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b)=>!b ? a : gcd(b, a % b);\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to)=>from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */ function convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data)) throw new Error(\"convertRadix2: data should be array\");\n    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data){\n        assertNumber(n);\n        if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = carry << from | n;\n        if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for(; pos >= to; pos -= to)res.push((carry >> pos - to & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = carry << to - pos & mask;\n    if (!padding && pos >= from) throw new Error(\"Excess padding\");\n    if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0) res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes)=>{\n            if (!isBytes(bytes)) throw new Error(\"radix.encode input should be Uint8Array\");\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"radix.decode input should be array of numbers\");\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        }\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */ function radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32) throw new Error(\"radix2: bits should be in (0..32]\");\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error(\"radix2: carry overflow\");\n    return {\n        encode: (bytes)=>{\n            if (!isBytes(bytes)) throw new Error(\"radix2.encode input should be Uint8Array\");\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"radix2.decode input should be array of numbers\");\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function unsafeWrapper(fn) {\n    if (typeof fn !== \"function\") throw new Error(\"unsafeWrapper fn should be function\");\n    return function(...args) {\n        try {\n            return fn.apply(null, args);\n        } catch (e) {}\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== \"function\") throw new Error(\"checksum fn should be function\");\n    return {\n        encode (data) {\n            if (!isBytes(data)) throw new Error(\"checksum.encode: input should be Uint8Array\");\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode (data) {\n            if (!isBytes(data)) throw new Error(\"checksum.decode: input should be Uint8Array\");\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for(let i = 0; i < len; i++)if (newChecksum[i] !== oldChecksum[i]) throw new Error(\"Invalid checksum\");\n            return payload;\n        }\n    };\n}\n// prettier-ignore\nconst utils = {\n    alphabet,\n    chain,\n    checksum,\n    convertRadix,\n    convertRadix2,\n    radix,\n    radix2,\n    join,\n    padding\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nconst base16 = /* @__PURE__ */ chain(radix2(4), alphabet(\"0123456789ABCDEF\"), join(\"\"));\nconst base32 = /* @__PURE__ */ chain(radix2(5), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), padding(5), join(\"\"));\nconst base32nopad = /* @__PURE__ */ chain(radix2(5), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), join(\"\"));\nconst base32hex = /* @__PURE__ */ chain(radix2(5), alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), padding(5), join(\"\"));\nconst base32hexnopad = /* @__PURE__ */ chain(radix2(5), alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), join(\"\"));\nconst base32crockford = /* @__PURE__ */ chain(radix2(5), alphabet(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"), join(\"\"), normalize((s)=>s.toUpperCase().replace(/O/g, \"0\").replace(/[IL]/g, \"1\")));\nconst base64 = /* @__PURE__ */ chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), padding(6), join(\"\"));\nconst base64nopad = /* @__PURE__ */ chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), join(\"\"));\nconst base64url = /* @__PURE__ */ chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), padding(6), join(\"\"));\nconst base64urlnopad = /* @__PURE__ */ chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), join(\"\"));\n// base58 code\n// -----------\nconst genBase58 = (abc)=>chain(radix(58), alphabet(abc), join(\"\"));\nconst base58 = /* @__PURE__ */ genBase58(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\nconst base58flickr = /* @__PURE__ */ genBase58(\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\");\nconst base58xrp = /* @__PURE__ */ genBase58(\"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\");\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [\n    0,\n    2,\n    3,\n    5,\n    6,\n    7,\n    9,\n    10,\n    11\n];\nconst base58xmr = {\n    encode (data) {\n        let res = \"\";\n        for(let i = 0; i < data.length; i += 8){\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], \"1\");\n        }\n        return res;\n    },\n    decode (str) {\n        let res = [];\n        for(let i = 0; i < str.length; i += 11){\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for(let j = 0; j < block.length - blockLen; j++){\n                if (block[j] !== 0) throw new Error(\"base58xmr: wrong padding\");\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    }\n};\nconst createBase58check = (sha256)=>chain(checksum(4, (data)=>sha256(sha256(data))), base58);\n// legacy export, bad name\nconst base58check = createBase58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet(\"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"), join(\"\"));\nconst POLYMOD_GENERATORS = [\n    0x3b6a57b2,\n    0x26508e6d,\n    0x1ea119fa,\n    0x3d4233dd,\n    0x2a1462b3\n];\n/**\n * @__NO_SIDE_EFFECTS__\n */ function bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for(let i = 0; i < POLYMOD_GENERATORS.length; i++){\n        if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for(let i = 0; i < len; i++){\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ c >> 5;\n    }\n    chk = bech32Polymod(chk);\n    for(let i = 0; i < len; i++)chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;\n    for (let v of words)chk = bech32Polymod(chk) ^ v;\n    for(let i = 0; i < 6; i++)chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([\n        chk % 2 ** 30\n    ], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function genBech32(encoding) {\n    const ENCODING_CONST = encoding === \"bech32\" ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== \"string\") throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (words instanceof Uint8Array) words = Array.from(words);\n        if (!Array.isArray(words) || words.length && typeof words[0] !== \"number\") throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        if (prefix.length === 0) throw new TypeError(`Invalid prefix length ${prefix.length}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== \"string\") throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf(\"1\");\n        if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6) throw new Error(\"Data must be at least 6 characters long\");\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return {\n            prefix,\n            words\n        };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return {\n            prefix,\n            words,\n            bytes: fromWords(words)\n        };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords\n    };\n}\nconst bech32 = /* @__PURE__ */ genBech32(\"bech32\");\nconst bech32m = /* @__PURE__ */ genBech32(\"bech32m\");\nconst utf8 = {\n    encode: (data)=>new TextDecoder().decode(data),\n    decode: (str)=>new TextEncoder().encode(str)\n};\nconst hex = /* @__PURE__ */ chain(radix2(4), alphabet(\"0123456789abcdef\"), join(\"\"), normalize((s)=>{\n    if (typeof s !== \"string\" || s.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8,\n    hex,\n    base16,\n    base32,\n    base64,\n    base64url,\n    base58,\n    base58xmr\n};\nconst coderTypeError = \"Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr\";\nconst bytesToString = (type, bytes)=>{\n    if (typeof type !== \"string\" || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (!isBytes(bytes)) throw new TypeError(\"bytesToString() expects Uint8Array\");\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str)=>{\n    if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (typeof str !== \"string\") throw new TypeError(\"stringToBytes() expects string\");\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGtFQUFrRSxHQUNsRSxZQUFZO0FBQ1o7O0NBRUMsR0FDTSxTQUFTQSxhQUFhQyxDQUFDO0lBQzFCLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDRixJQUN0QixNQUFNLElBQUlHLE1BQU0sQ0FBQyxlQUFlLEVBQUVILEVBQUUsQ0FBQztBQUM3QztBQUNBLFNBQVNJLFFBQVFDLENBQUM7SUFDZCxPQUFRQSxhQUFhQyxjQUNoQkQsS0FBSyxRQUFRLE9BQU9BLE1BQU0sWUFBWUEsRUFBRUUsV0FBVyxDQUFDQyxJQUFJLEtBQUs7QUFDdEU7QUFDQTs7Q0FFQyxHQUNELFNBQVNDLE1BQU0sR0FBR0MsSUFBSTtJQUNsQixNQUFNQyxLQUFLLENBQUNOLElBQU1BO0lBQ2xCLCtDQUErQztJQUMvQyxNQUFNTyxPQUFPLENBQUNQLEdBQUdRLElBQU0sQ0FBQ0MsSUFBTVQsRUFBRVEsRUFBRUM7SUFDbEMsNkRBQTZEO0lBQzdELE1BQU1DLFNBQVNMLEtBQUtNLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxFQUFFRixNQUFNLEVBQUVHLFdBQVcsQ0FBQ04sTUFBTUQ7SUFDM0QseURBQXlEO0lBQ3pELE1BQU1RLFNBQVNULEtBQUtNLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxFQUFFRSxNQUFNLEVBQUVDLE1BQU0sQ0FBQ1IsTUFBTUQ7SUFDdEQsT0FBTztRQUFFSTtRQUFRSTtJQUFPO0FBQzVCO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU0UsU0FBU0EsUUFBUTtJQUN0QixPQUFPO1FBQ0hOLFFBQVEsQ0FBQ087WUFDTCxJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0YsV0FBWUEsT0FBT0csTUFBTSxJQUFJLE9BQU9ILE1BQU0sQ0FBQyxFQUFFLEtBQUssVUFDakUsTUFBTSxJQUFJbkIsTUFBTTtZQUNwQixPQUFPbUIs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LENBQUMyQyxPQUFPSSxjQUFjLENBQUNELE9BQ3ZCLE1BQU0sSUFBSXBCLFVBQVVrQjtJQUN4QixJQUFJLE9BQU81QyxRQUFRLFVBQ2YsTUFBTSxJQUFJMEIsVUFBVTtJQUN4QixPQUFPaUIsTUFBTSxDQUFDRyxLQUFLLENBQUMvSCxNQUFNLENBQUNpRjtBQUMvQixFQUFFO0FBQ0ssTUFBTXBDLFFBQVFvRixjQUFjLENBQ25DLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2JldHRlcmhhY2svLi9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcz9lNzkxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBzY3VyZS1iYXNlIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBVdGlsaXRpZXNcbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke259YCk7XG59XG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNoYWluKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBpZCA9IChhKSA9PiBhO1xuICAgIC8vIFdyYXAgY2FsbCBpbiBjbG9zdXJlIHNvIEpJVCBjYW4gaW5saW5lIGNhbGxzXG4gICAgY29uc3Qgd3JhcCA9IChhLCBiKSA9PiAoYykgPT4gYShiKGMpKTtcbiAgICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1stMV0uZW5jb2RlKGFyZ3NbLTJdLmVuY29kZShbLi4uXSkpXG4gICAgY29uc3QgZW5jb2RlID0gYXJncy5tYXAoKHgpID0+IHguZW5jb2RlKS5yZWR1Y2VSaWdodCh3cmFwLCBpZCk7XG4gICAgLy8gQ29uc3RydWN0IGNoYWluIG9mIGFyZ3NbMF0uZGVjb2RlKGFyZ3NbMV0uZGVjb2RlKC4uLikpXG4gICAgY29uc3QgZGVjb2RlID0gYXJncy5tYXAoKHgpID0+IHguZGVjb2RlKS5yZWR1Y2Uod3JhcCwgaWQpO1xuICAgIHJldHVybiB7IGVuY29kZSwgZGVjb2RlIH07XG59XG4vKipcbiAqIEVuY29kZXMgaW50ZWdlciByYWRpeCByZXByZXNlbnRhdGlvbiB0byBhcnJheSBvZiBzdHJpbmdzIHVzaW5nIGFscGhhYmV0IGFuZCBiYWNrXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBhbHBoYWJldChhbHBoYWJldCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhbiBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgICAgICAgICByZXR1cm4gZGlnaXRzLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydE51bWJlcihpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSBhbHBoYWJldC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlnaXQgaW5kZXggb3V0c2lkZSBhbHBoYWJldDogJHtpfSAoYWxwaGFiZXQ6ICR7YWxwaGFiZXQubGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxwaGFiZXRbaV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm1hcCgobGV0dGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXR0ZXIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFscGhhYmV0LmRlY29kZTogbm90IHN0cmluZyBlbGVtZW50PSR7bGV0dGVyfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYWxwaGFiZXQuaW5kZXhPZihsZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsZXR0ZXI6IFwiJHtsZXR0ZXJ9XCIuIEFsbG93ZWQ6ICR7YWxwaGFiZXR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gam9pbihzZXBhcmF0b3IgPSAnJykge1xuICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luIHNlcGFyYXRvciBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZnJvbSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZyb20pIHx8IChmcm9tLmxlbmd0aCAmJiB0eXBlb2YgZnJvbVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZnJvbSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGpvaW4uZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHJldHVybiBmcm9tLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAodG8pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG8gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogUGFkIHN0cmluZ3MgYXJyYXkgc28gaXQgaGFzIGludGVnZXIgbnVtYmVyIG9mIGJpdHNcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHBhZGRpbmcoYml0cywgY2hyID0gJz0nKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGJpdHMpO1xuICAgIGlmICh0eXBlb2YgY2hyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nIGNociBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSB8fCAoZGF0YS5sZW5ndGggJiYgdHlwZW9mIGRhdGFbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGRhdGEpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmVuY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICB3aGlsZSAoKGRhdGEubGVuZ3RoICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIGRhdGEucHVzaChjaHIpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgaW5wdXQpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmRlY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICBsZXQgZW5kID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChlbmQgKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBzaG91bGQgaGF2ZSB3aG9sZSBudW1iZXIgb2YgYnl0ZXMnKTtcbiAgICAgICAgICAgIGZvciAoOyBlbmQgPiAwICYmIGlucHV0W2VuZCAtIDFdID09PSBjaHI7IGVuZC0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoKChlbmQgLSAxKSAqIGJpdHMpICUgOCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgaGFzIHRvbyBtdWNoIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5zbGljZSgwLCBlbmQpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9ybWFsaXplIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiB7IGVuY29kZTogKGZyb20pID0+IGZyb20sIGRlY29kZTogKHRvKSA9PiBmbih0bykgfTtcbn1cbi8qKlxuICogU2xvdzogTyhuXjIpIHRpbWUgY29tcGxleGl0eVxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhZGl4KGRhdGEsIGZyb20sIHRvKSB7XG4gICAgLy8gYmFzZSAxIGlzIGltcG9zc2libGVcbiAgICBpZiAoZnJvbSA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyBmcm9tPSR7ZnJvbX0sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKHRvIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIHRvPSR7dG99LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGRhdGEgc2hvdWxkIGJlIGFycmF5Jyk7XG4gICAgaWYgKCFkYXRhLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGNvbnN0IGRpZ2l0cyA9IEFycmF5LmZyb20oZGF0YSk7XG4gICAgZGlnaXRzLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKGQpO1xuICAgICAgICBpZiAoZCA8IDAgfHwgZCA+PSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke2R9YCk7XG4gICAgfSk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGNhcnJ5ID0gMDtcbiAgICAgICAgbGV0IGRvbmUgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgZGlnaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkaWdpdCA9IGRpZ2l0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0QmFzZSA9IGZyb20gKiBjYXJyeSArIGRpZ2l0O1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaWdpdEJhc2UpIHx8XG4gICAgICAgICAgICAgICAgKGZyb20gKiBjYXJyeSkgLyBmcm9tICE9PSBjYXJyeSB8fFxuICAgICAgICAgICAgICAgIGRpZ2l0QmFzZSAtIGRpZ2l0ICE9PSBmcm9tICogY2FycnkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhcnJ5ID0gZGlnaXRCYXNlICUgdG87XG4gICAgICAgICAgICBjb25zdCByb3VuZGVkID0gTWF0aC5mbG9vcihkaWdpdEJhc2UgLyB0byk7XG4gICAgICAgICAgICBkaWdpdHNbaV0gPSByb3VuZGVkO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihyb3VuZGVkKSB8fCByb3VuZGVkICogdG8gKyBjYXJyeSAhPT0gZGlnaXRCYXNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoIXJvdW5kZWQpXG4gICAgICAgICAgICAgICAgcG9zID0gaTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goY2FycnkpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMSAmJiBkYXRhW2ldID09PSAwOyBpKyspXG4gICAgICAgIHJlcy5wdXNoKDApO1xuICAgIHJldHVybiByZXMucmV2ZXJzZSgpO1xufVxuY29uc3QgZ2NkID0gLyogQF9fTk9fU0lERV9FRkZFQ1RTX18gKi8gKGEsIGIpID0+ICghYiA/IGEgOiBnY2QoYiwgYSAlIGIpKTtcbmNvbnN0IHJhZGl4MmNhcnJ5ID0gLypAX19OT19TSURFX0VGRkVDVFNfXyAqLyAoZnJvbSwgdG8pID0+IGZyb20gKyAodG8gLSBnY2QoZnJvbSwgdG8pKTtcbi8qKlxuICogSW1wbGVtZW50ZWQgd2l0aCBudW1iZXJzLCBiZWNhdXNlIEJpZ0ludCBpcyA1eCBzbG93ZXJcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeDIoZGF0YSwgZnJvbSwgdG8sIHBhZGRpbmcpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4MjogZGF0YSBzaG91bGQgYmUgYXJyYXknKTtcbiAgICBpZiAoZnJvbSA8PSAwIHx8IGZyb20gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyBmcm9tPSR7ZnJvbX1gKTtcbiAgICBpZiAodG8gPD0gMCB8fCB0byA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIHRvPSR7dG99YCk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KGZyb20sIHRvKSA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgZnJvbT0ke2Zyb219IHRvPSR7dG99IGNhcnJ5Qml0cz0ke3JhZGl4MmNhcnJ5KGZyb20sIHRvKX1gKTtcbiAgICB9XG4gICAgbGV0IGNhcnJ5ID0gMDtcbiAgICBsZXQgcG9zID0gMDsgLy8gYml0d2lzZSBwb3NpdGlvbiBpbiBjdXJyZW50IGVsZW1lbnRcbiAgICBjb25zdCBtYXNrID0gMiAqKiB0byAtIDE7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChjb25zdCBuIG9mIGRhdGEpIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKG4pO1xuICAgICAgICBpZiAobiA+PSAyICoqIGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGludmFsaWQgZGF0YSB3b3JkPSR7bn0gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IDw8IGZyb20pIHwgbjtcbiAgICAgICAgaWYgKHBvcyArIGZyb20gPiAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgcG9zPSR7cG9zfSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgcG9zICs9IGZyb207XG4gICAgICAgIGZvciAoOyBwb3MgPj0gdG87IHBvcyAtPSB0bylcbiAgICAgICAgICAgIHJlcy5wdXNoKCgoY2FycnkgPj4gKHBvcyAtIHRvKSkgJiBtYXNrKSA+Pj4gMCk7XG4gICAgICAgIGNhcnJ5ICY9IDIgKiogcG9zIC0gMTsgLy8gY2xlYW4gY2FycnksIG90aGVyd2lzZSBpdCB3aWxsIGNhdXNlIG92ZXJmbG93XG4gICAgfVxuICAgIGNhcnJ5ID0gKGNhcnJ5IDw8ICh0byAtIHBvcykpICYgbWFzaztcbiAgICBpZiAoIXBhZGRpbmcgJiYgcG9zID49IGZyb20pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhjZXNzIHBhZGRpbmcnKTtcbiAgICBpZiAoIXBhZGRpbmcgJiYgY2FycnkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9uLXplcm8gcGFkZGluZzogJHtjYXJyeX1gKTtcbiAgICBpZiAocGFkZGluZyAmJiBwb3MgPiAwKVxuICAgICAgICByZXMucHVzaChjYXJyeSA+Pj4gMCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcmFkaXgobnVtKSB7XG4gICAgYXNzZXJ0TnVtYmVyKG51bSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgoQXJyYXkuZnJvbShieXRlcyksIDIgKiogOCwgbnVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4KGRpZ2l0cywgbnVtLCAyICoqIDgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBJZiBib3RoIGJhc2VzIGFyZSBwb3dlciBvZiBzYW1lIG51bWJlciAobGlrZSBgMioqOCA8LT4gMioqNjRgKSxcbiAqIHRoZXJlIGlzIGEgbGluZWFyIGFsZ29yaXRobS4gRm9yIG5vdyB3ZSBoYXZlIGltcGxlbWVudGF0aW9uIGZvciBwb3dlci1vZi10d28gYmFzZXMgb25seS5cbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHJhZGl4MihiaXRzLCByZXZQYWRkaW5nID0gZmFsc2UpIHtcbiAgICBhc3NlcnROdW1iZXIoYml0cyk7XG4gICAgaWYgKGJpdHMgPD0gMCB8fCBiaXRzID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBiaXRzIHNob3VsZCBiZSBpbiAoMC4uMzJdJyk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KDgsIGJpdHMpID4gMzIgfHwgcmFkaXgyY2FycnkoYml0cywgOCkgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFJhZGl4MihBcnJheS5mcm9tKGJ5dGVzKSwgOCwgYml0cywgIXJldlBhZGRpbmcpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4MihkaWdpdHMsIGJpdHMsIDgsIHJldlBhZGRpbmcpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiB1bnNhZmVXcmFwcGVyKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNhZmVXcmFwcGVyIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjaGVja3N1bShsZW4sIGZuKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGxlbik7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bSBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGRhdGEpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZW5jb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBmbihkYXRhKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyBsZW4pO1xuICAgICAgICAgICAgcmVzLnNldChkYXRhKTtcbiAgICAgICAgICAgIHJlcy5zZXQoY2hlY2tzdW0sIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoZGF0YSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5kZWNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YS5zbGljZSgwLCAtbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoZWNrc3VtID0gZm4ocGF5bG9hZCkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZENoZWNrc3VtID0gZGF0YS5zbGljZSgtbGVuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoZWNrc3VtW2ldICE9PSBvbGRDaGVja3N1bVtpXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtJyk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgdXRpbHMgPSB7XG4gICAgYWxwaGFiZXQsIGNoYWluLCBjaGVja3N1bSwgY29udmVydFJhZGl4LCBjb252ZXJ0UmFkaXgyLCByYWRpeCwgcmFkaXgyLCBqb2luLCBwYWRkaW5nLFxufTtcbi8vIFJGQyA0NjQ4IGFrYSBSRkMgMzU0OFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5leHBvcnQgY29uc3QgYmFzZTE2ID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUYnKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMiA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMybm9wYWQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4bm9wYWQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmNyb2NrZm9yZCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiBzLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvTy9nLCAnMCcpLnJlcGxhY2UoL1tJTF0vZywgJzEnKSkpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjRub3BhZCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjR1cmwgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLCBwYWRkaW5nKDYpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTY0dXJsbm9wYWQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLCBqb2luKCcnKSk7XG4vLyBiYXNlNTggY29kZVxuLy8gLS0tLS0tLS0tLS1cbmNvbnN0IGdlbkJhc2U1OCA9IChhYmMpID0+IGNoYWluKHJhZGl4KDU4KSwgYWxwaGFiZXQoYWJjKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OCA9IC8qIEBfX1BVUkVfXyAqLyBnZW5CYXNlNTgoJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonKTtcbmV4cG9ydCBjb25zdCBiYXNlNThmbGlja3IgPSAvKiBAX19QVVJFX18gKi8gZ2VuQmFzZTU4KCcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJyk7XG5leHBvcnQgY29uc3QgYmFzZTU4eHJwID0gLyogQF9fUFVSRV9fICovIGdlbkJhc2U1OCgncnBzaG5hZjM5d0JVRE5FR0hKS0xNNFBRUlNUN1ZXWFlaMmJjZGVDZzY1amttOG9GcWkxdHV2QXh5eicpO1xuLy8geG1yIHZlciBpcyBkb25lIGluIDgtYnl0ZSBibG9ja3MgKHdoaWNoIGVxdWFscyAxMSBjaGFycyBpbiBkZWNvZGluZykuIExhc3QgKG5vbi1mdWxsKSBibG9jayBwYWRkZWQgd2l0aCAnMScgdG8gc2l6ZSBpbiBYTVJfQkxPQ0tfTEVOLlxuLy8gQmxvY2sgZW5jb2Rpbmcgc2lnbmlmaWNhbnRseSByZWR1Y2VzIHF1YWRyYXRpYyBjb21wbGV4aXR5IG9mIGJhc2U1OC5cbi8vIERhdGEgbGVuIChpbmRleCkgLT4gZW5jb2RlZCBibG9jayBsZW5cbmNvbnN0IFhNUl9CTE9DS19MRU4gPSBbMCwgMiwgMywgNSwgNiwgNywgOSwgMTAsIDExXTtcbmV4cG9ydCBjb25zdCBiYXNlNTh4bXIgPSB7XG4gICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gZGF0YS5zdWJhcnJheShpLCBpICsgOCk7XG4gICAgICAgICAgICByZXMgKz0gYmFzZTU4LmVuY29kZShibG9jaykucGFkU3RhcnQoWE1SX0JMT0NLX0xFTltibG9jay5sZW5ndGhdLCAnMScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBkZWNvZGUoc3RyKSB7XG4gICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDExKSB7XG4gICAgICAgICAgICBjb25zdCBzbGljZSA9IHN0ci5zbGljZShpLCBpICsgMTEpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tMZW4gPSBYTVJfQkxPQ0tfTEVOLmluZGV4T2Yoc2xpY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYmFzZTU4LmRlY29kZShzbGljZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tbal0gIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFzZTU4eG1yOiB3cm9uZyBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KEFycmF5LmZyb20oYmxvY2suc2xpY2UoYmxvY2subGVuZ3RoIC0gYmxvY2tMZW4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShyZXMpO1xuICAgIH0sXG59O1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUJhc2U1OGNoZWNrID0gKHNoYTI1NikgPT4gY2hhaW4oY2hlY2tzdW0oNCwgKGRhdGEpID0+IHNoYTI1NihzaGEyNTYoZGF0YSkpKSwgYmFzZTU4KTtcbi8vIGxlZ2FjeSBleHBvcnQsIGJhZCBuYW1lXG5leHBvcnQgY29uc3QgYmFzZTU4Y2hlY2sgPSBjcmVhdGVCYXNlNThjaGVjaztcbmNvbnN0IEJFQ0hfQUxQSEFCRVQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4oYWxwaGFiZXQoJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJyksIGpvaW4oJycpKTtcbmNvbnN0IFBPTFlNT0RfR0VORVJBVE9SUyA9IFsweDNiNmE1N2IyLCAweDI2NTA4ZTZkLCAweDFlYTExOWZhLCAweDNkNDIzM2RkLCAweDJhMTQ2MmIzXTtcbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYmVjaDMyUG9seW1vZChwcmUpIHtcbiAgICBjb25zdCBiID0gcHJlID4+IDI1O1xuICAgIGxldCBjaGsgPSAocHJlICYgMHgxZmZmZmZmKSA8PCA1O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUE9MWU1PRF9HRU5FUkFUT1JTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgoKGIgPj4gaSkgJiAxKSA9PT0gMSlcbiAgICAgICAgICAgIGNoayBePSBQT0xZTU9EX0dFTkVSQVRPUlNbaV07XG4gICAgfVxuICAgIHJldHVybiBjaGs7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBlbmNvZGluZ0NvbnN0ID0gMSkge1xuICAgIGNvbnN0IGxlbiA9IHByZWZpeC5sZW5ndGg7XG4gICAgbGV0IGNoayA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjID0gcHJlZml4LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMzMgfHwgYyA+IDEyNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcmVmaXggKCR7cHJlZml4fSlgKTtcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKGMgPj4gNSk7XG4gICAgfVxuICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAocHJlZml4LmNoYXJDb2RlQXQoaSkgJiAweDFmKTtcbiAgICBmb3IgKGxldCB2IG9mIHdvcmRzKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiB2O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgY2hrIF49IGVuY29kaW5nQ29uc3Q7XG4gICAgcmV0dXJuIEJFQ0hfQUxQSEFCRVQuZW5jb2RlKGNvbnZlcnRSYWRpeDIoW2NoayAlIDIgKiogMzBdLCAzMCwgNSwgZmFsc2UpKTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gZ2VuQmVjaDMyKGVuY29kaW5nKSB7XG4gICAgY29uc3QgRU5DT0RJTkdfQ09OU1QgPSBlbmNvZGluZyA9PT0gJ2JlY2gzMicgPyAxIDogMHgyYmM4MzBhMztcbiAgICBjb25zdCBfd29yZHMgPSByYWRpeDIoNSk7XG4gICAgY29uc3QgZnJvbVdvcmRzID0gX3dvcmRzLmRlY29kZTtcbiAgICBjb25zdCB0b1dvcmRzID0gX3dvcmRzLmVuY29kZTtcbiAgICBjb25zdCBmcm9tV29yZHNVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGZyb21Xb3Jkcyk7XG4gICAgZnVuY3Rpb24gZW5jb2RlKHByZWZpeCwgd29yZHMsIGxpbWl0ID0gOTApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmaXggIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHByZWZpeCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2YgcHJlZml4fWApO1xuICAgICAgICBpZiAod29yZHMgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgd29yZHMgPSBBcnJheS5mcm9tKHdvcmRzKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdvcmRzKSB8fCAod29yZHMubGVuZ3RoICYmIHR5cGVvZiB3b3Jkc1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHdvcmRzIHNob3VsZCBiZSBhcnJheSBvZiBudW1iZXJzLCBub3QgJHt0eXBlb2Ygd29yZHN9YCk7XG4gICAgICAgIGlmIChwcmVmaXgubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBwcmVmaXggbGVuZ3RoICR7cHJlZml4Lmxlbmd0aH1gKTtcbiAgICAgICAgY29uc3QgYWN0dWFsTGVuZ3RoID0gcHJlZml4Lmxlbmd0aCArIDcgKyB3b3Jkcy5sZW5ndGg7XG4gICAgICAgIGlmIChsaW1pdCAhPT0gZmFsc2UgJiYgYWN0dWFsTGVuZ3RoID4gbGltaXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBMZW5ndGggJHthY3R1YWxMZW5ndGh9IGV4Y2VlZHMgbGltaXQgJHtsaW1pdH1gKTtcbiAgICAgICAgY29uc3QgbG93ZXJlZCA9IHByZWZpeC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBzdW0gPSBiZWNoQ2hlY2tzdW0obG93ZXJlZCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKTtcbiAgICAgICAgcmV0dXJuIGAke2xvd2VyZWR9MSR7QkVDSF9BTFBIQUJFVC5lbmNvZGUod29yZHMpfSR7c3VtfWA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZShzdHIsIGxpbWl0ID0gOTApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBzdHJpbmcsIG5vdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoIDwgOCB8fCAobGltaXQgIT09IGZhbHNlICYmIHN0ci5sZW5ndGggPiBsaW1pdCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBXcm9uZyBzdHJpbmcgbGVuZ3RoOiAke3N0ci5sZW5ndGh9ICgke3N0cn0pLiBFeHBlY3RlZCAoOC4uJHtsaW1pdH0pYCk7XG4gICAgICAgIC8vIGRvbid0IGFsbG93IG1peGVkIGNhc2VcbiAgICAgICAgY29uc3QgbG93ZXJlZCA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc3RyICE9PSBsb3dlcmVkICYmIHN0ciAhPT0gc3RyLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cmluZyBtdXN0IGJlIGxvd2VyY2FzZSBvciB1cHBlcmNhc2VgKTtcbiAgICAgICAgY29uc3Qgc2VwSW5kZXggPSBsb3dlcmVkLmxhc3RJbmRleE9mKCcxJyk7XG4gICAgICAgIGlmIChzZXBJbmRleCA9PT0gMCB8fCBzZXBJbmRleCA9PT0gLTEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExldHRlciBcIjFcIiBtdXN0IGJlIHByZXNlbnQgYmV0d2VlbiBwcmVmaXggYW5kIGRhdGEgb25seWApO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBsb3dlcmVkLnNsaWNlKDAsIHNlcEluZGV4KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGxvd2VyZWQuc2xpY2Uoc2VwSW5kZXggKyAxKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGJlIGF0IGxlYXN0IDYgY2hhcmFjdGVycyBsb25nJyk7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gQkVDSF9BTFBIQUJFVC5kZWNvZGUoZGF0YSkuc2xpY2UoMCwgLTYpO1xuICAgICAgICBjb25zdCBzdW0gPSBiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICBpZiAoIWRhdGEuZW5kc1dpdGgoc3VtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGVja3N1bSBpbiAke3N0cn06IGV4cGVjdGVkIFwiJHtzdW19XCJgKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWNvZGVVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGRlY29kZSk7XG4gICAgZnVuY3Rpb24gZGVjb2RlVG9CeXRlcyhzdHIpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHdvcmRzIH0gPSBkZWNvZGUoc3RyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMsIGJ5dGVzOiBmcm9tV29yZHMod29yZHMpIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZUZyb21CeXRlcyhwcmVmaXgsIGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGUocHJlZml4LCB0b1dvcmRzKGJ5dGVzKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZSxcbiAgICAgICAgZGVjb2RlLFxuICAgICAgICBlbmNvZGVGcm9tQnl0ZXMsXG4gICAgICAgIGRlY29kZVRvQnl0ZXMsXG4gICAgICAgIGRlY29kZVVuc2FmZSxcbiAgICAgICAgZnJvbVdvcmRzLFxuICAgICAgICBmcm9tV29yZHNVbnNhZmUsXG4gICAgICAgIHRvV29yZHMsXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBiZWNoMzIgPSAvKiBAX19QVVJFX18gKi8gZ2VuQmVjaDMyKCdiZWNoMzInKTtcbmV4cG9ydCBjb25zdCBiZWNoMzJtID0gLyogQF9fUFVSRV9fICovIGdlbkJlY2gzMignYmVjaDMybScpO1xuZXhwb3J0IGNvbnN0IHV0ZjggPSB7XG4gICAgZW5jb2RlOiAoZGF0YSkgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpLFxuICAgIGRlY29kZTogKHN0cikgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0ciksXG59O1xuZXhwb3J0IGNvbnN0IGhleCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5YWJjZGVmJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnIHx8IHMubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaGV4LmRlY29kZTogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc30gd2l0aCBsZW5ndGggJHtzLmxlbmd0aH1gKTtcbiAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpO1xufSkpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBDT0RFUlMgPSB7XG4gICAgdXRmOCwgaGV4LCBiYXNlMTYsIGJhc2UzMiwgYmFzZTY0LCBiYXNlNjR1cmwsIGJhc2U1OCwgYmFzZTU4eG1yXG59O1xuY29uc3QgY29kZXJUeXBlRXJyb3IgPSAnSW52YWxpZCBlbmNvZGluZyB0eXBlLiBBdmFpbGFibGUgdHlwZXM6IHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtcic7XG5leHBvcnQgY29uc3QgYnl0ZXNUb1N0cmluZyA9ICh0eXBlLCBieXRlcykgPT4ge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycgfHwgIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNUb1N0cmluZygpIGV4cGVjdHMgVWludDhBcnJheScpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZW5jb2RlKGJ5dGVzKTtcbn07XG5leHBvcnQgY29uc3Qgc3RyID0gYnl0ZXNUb1N0cmluZzsgLy8gYXMgaW4gcHl0aG9uLCBidXQgZm9yIGJ5dGVzIG9ubHlcbmV4cG9ydCBjb25zdCBzdHJpbmdUb0J5dGVzID0gKHR5cGUsIHN0cikgPT4ge1xuICAgIGlmICghQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ1RvQnl0ZXMoKSBleHBlY3RzIHN0cmluZycpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZGVjb2RlKHN0cik7XG59O1xuZXhwb3J0IGNvbnN0IGJ5dGVzID0gc3RyaW5nVG9CeXRlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJhc3NlcnROdW1iZXIiLCJuIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwiaXNCeXRlcyIsImEiLCJVaW50OEFycmF5IiwiY29uc3RydWN0b3IiLCJuYW1lIiwiY2hhaW4iLCJhcmdzIiwiaWQiLCJ3cmFwIiwiYiIsImMiLCJlbmNvZGUiLCJtYXAiLCJ4IiwicmVkdWNlUmlnaHQiLCJkZWNvZGUiLCJyZWR1Y2UiLCJhbHBoYWJldCIsImRpZ2l0cyIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImkiLCJpbnB1dCIsImxldHRlciIsImluZGV4IiwiaW5kZXhPZiIsImpvaW4iLCJzZXBhcmF0b3IiLCJmcm9tIiwidG8iLCJzcGxpdCIsInBhZGRpbmciLCJiaXRzIiwiY2hyIiwiZGF0YSIsInB1c2giLCJlbmQiLCJzbGljZSIsIm5vcm1hbGl6ZSIsImZuIiwiY29udmVydFJhZGl4IiwicG9zIiwicmVzIiwiZm9yRWFjaCIsImQiLCJjYXJyeSIsImRvbmUiLCJkaWdpdCIsImRpZ2l0QmFzZSIsInJvdW5kZWQiLCJNYXRoIiwiZmxvb3IiLCJyZXZlcnNlIiwiZ2NkIiwicmFkaXgyY2FycnkiLCJjb252ZXJ0UmFkaXgyIiwibWFzayIsInJhZGl4IiwibnVtIiwiYnl0ZXMiLCJyYWRpeDIiLCJyZXZQYWRkaW5nIiwidW5zYWZlV3JhcHBlciIsImFwcGx5IiwiZSIsImNoZWNrc3VtIiwibGVuIiwic2V0IiwicGF5bG9hZCIsIm5ld0NoZWNrc3VtIiwib2xkQ2hlY2tzdW0iLCJ1dGlscyIsImJhc2UxNiIsImJhc2UzMiIsImJhc2UzMm5vcGFkIiwiYmFzZTMyaGV4IiwiYmFzZTMyaGV4bm9wYWQiLCJiYXNlMzJjcm9ja2ZvcmQiLCJzIiwidG9VcHBlckNhc2UiLCJyZXBsYWNlIiwiYmFzZTY0IiwiYmFzZTY0bm9wYWQiLCJiYXNlNjR1cmwiLCJiYXNlNjR1cmxub3BhZCIsImdlbkJhc2U1OCIsImFiYyIsImJhc2U1OCIsImJhc2U1OGZsaWNrciIsImJhc2U1OHhycCIsIlhNUl9CTE9DS19MRU4iLCJiYXNlNTh4bXIiLCJibG9jayIsInN1YmFycmF5IiwicGFkU3RhcnQiLCJzdHIiLCJibG9ja0xlbiIsImoiLCJjb25jYXQiLCJjcmVhdGVCYXNlNThjaGVjayIsInNoYTI1NiIsImJhc2U1OGNoZWNrIiwiQkVDSF9BTFBIQUJFVCIsIlBPTFlNT0RfR0VORVJBVE9SUyIsImJlY2gzMlBvbHltb2QiLCJwcmUiLCJjaGsiLCJiZWNoQ2hlY2tzdW0iLCJwcmVmaXgiLCJ3b3JkcyIsImVuY29kaW5nQ29uc3QiLCJjaGFyQ29kZUF0IiwidiIsImdlbkJlY2gzMiIsImVuY29kaW5nIiwiRU5DT0RJTkdfQ09OU1QiLCJfd29yZHMiLCJmcm9tV29yZHMiLCJ0b1dvcmRzIiwiZnJvbVdvcmRzVW5zYWZlIiwibGltaXQiLCJUeXBlRXJyb3IiLCJhY3R1YWxMZW5ndGgiLCJsb3dlcmVkIiwidG9Mb3dlckNhc2UiLCJzdW0iLCJzZXBJbmRleCIsImxhc3RJbmRleE9mIiwiZW5kc1dpdGgiLCJkZWNvZGVVbnNhZmUiLCJkZWNvZGVUb0J5dGVzIiwiZW5jb2RlRnJvbUJ5dGVzIiwiYmVjaDMyIiwiYmVjaDMybSIsInV0ZjgiLCJUZXh0RGVjb2RlciIsIlRleHRFbmNvZGVyIiwiaGV4IiwiQ09ERVJTIiwiY29kZXJUeXBlRXJyb3IiLCJieXRlc1RvU3RyaW5nIiwidHlwZSIsImhhc093blByb3BlcnR5Iiwic3RyaW5nVG9CeXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/base/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/starknet/lib/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@scure/starknet/lib/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURVE: () => (/* binding */ CURVE),\n/* harmony export */   Fp251: () => (/* binding */ Fp251),\n/* harmony export */   MAX_VALUE: () => (/* binding */ MAX_VALUE),\n/* harmony export */   ProjectivePoint: () => (/* binding */ ProjectivePoint),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   _poseidonMDS: () => (/* binding */ _poseidonMDS),\n/* harmony export */   _starkCurve: () => (/* binding */ _starkCurve),\n/* harmony export */   computeHashOnElements: () => (/* binding */ computeHashOnElements),\n/* harmony export */   ethSigToPrivate: () => (/* binding */ ethSigToPrivate),\n/* harmony export */   getAccountPath: () => (/* binding */ getAccountPath),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   getStarkKey: () => (/* binding */ getStarkKey),\n/* harmony export */   grindKey: () => (/* binding */ grindKey),\n/* harmony export */   keccak: () => (/* binding */ keccak),\n/* harmony export */   pedersen: () => (/* binding */ pedersen),\n/* harmony export */   poseidonBasic: () => (/* binding */ poseidonBasic),\n/* harmony export */   poseidonCreate: () => (/* binding */ poseidonCreate),\n/* harmony export */   poseidonHash: () => (/* binding */ poseidonHash),\n/* harmony export */   poseidonHashFunc: () => (/* binding */ poseidonHashFunc),\n/* harmony export */   poseidonHashMany: () => (/* binding */ poseidonHashMany),\n/* harmony export */   poseidonHashSingle: () => (/* binding */ poseidonHashSingle),\n/* harmony export */   poseidonSmall: () => (/* binding */ poseidonSmall),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/abstract/modular */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/curves/abstract/poseidon */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/poseidon.js\");\n/* harmony import */ var _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/weierstrass */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _noble_curves_shortw_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/_shortw_utils */ \"(ssr)/./node_modules/@noble/curves/esm/_shortw_utils.js\");\n\n\n\n\n\n\n\n\nconst CURVE_ORDER = BigInt(\"3618502788666131213697322783095070105526743751716087489154079457884512865583\");\nconst MAX_VALUE = BigInt(\"0x800000000000000000000000000000000000000000000000000000000000000\");\nconst nBitLength = 252;\nfunction bits2int(bytes) {\n    while(bytes[0] === 0)bytes = bytes.subarray(1);\n    const delta = bytes.length * 8 - nBitLength;\n    const num = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction hex0xToBytes(hex) {\n    if (typeof hex === \"string\") {\n        hex = strip0x(hex);\n        if (hex.length & 1) hex = \"0\" + hex;\n    }\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes(hex);\n}\nconst curve = (0,_noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_1__.weierstrass)({\n    a: BigInt(1),\n    b: BigInt(\"3141592653589793238462643383279502884197169399375105820974944592307816406665\"),\n    Fp: (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.Field)(BigInt(\"0x800000000000011000000000000000000000000000000000000000000000001\")),\n    n: CURVE_ORDER,\n    nBitLength,\n    Gx: BigInt(\"874739451078007766457464989774322083649278607533249481151382481072868806602\"),\n    Gy: BigInt(\"152666792071518830868575557812948353041420400780739481342941381225525861407\"),\n    h: BigInt(1),\n    lowS: false,\n    ...(0,_noble_curves_shortw_utils__WEBPACK_IMPORTED_MODULE_3__.getHash)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256),\n    bits2int,\n    bits2int_modN: (bytes)=>{\n        const hex = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes).toString(16);\n        if (hex.length === 63) bytes = hex0xToBytes(hex + \"0\");\n        return (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(bits2int(bytes), CURVE_ORDER);\n    }\n});\nconst _starkCurve = curve;\nfunction ensureBytes(hex) {\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.ensureBytes(\"\", typeof hex === \"string\" ? hex0xToBytes(hex) : hex);\n}\nfunction normPrivKey(privKey) {\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(ensureBytes(privKey)).padStart(64, \"0\");\n}\nfunction getPublicKey(privKey, isCompressed = false) {\n    return curve.getPublicKey(normPrivKey(privKey), isCompressed);\n}\nfunction getSharedSecret(privKeyA, pubKeyB) {\n    return curve.getSharedSecret(normPrivKey(privKeyA), pubKeyB);\n}\nfunction checkSignature(signature) {\n    const { r, s } = signature;\n    if (r < 0n || r >= MAX_VALUE) throw new Error(`Signature.r should be [1, ${MAX_VALUE})`);\n    const w = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.invert)(s, CURVE_ORDER);\n    if (w < 0n || w >= MAX_VALUE) throw new Error(`inv(Signature.s) should be [1, ${MAX_VALUE})`);\n}\nfunction checkMessage(msgHash) {\n    const bytes = ensureBytes(msgHash);\n    const num = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes);\n    if (num >= MAX_VALUE) throw new Error(`msgHash should be [0, ${MAX_VALUE})`);\n    return bytes;\n}\nfunction sign(msgHash, privKey, opts) {\n    const sig = curve.sign(checkMessage(msgHash), normPrivKey(privKey), opts);\n    checkSignature(sig);\n    return sig;\n}\nfunction verify(signature, msgHash, pubKey) {\n    if (!(signature instanceof Signature)) {\n        const bytes = ensureBytes(signature);\n        try {\n            signature = Signature.fromDER(bytes);\n        } catch (derError) {\n            if (!(derError instanceof _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_1__.DER.Err)) throw derError;\n            signature = Signature.fromCompact(bytes);\n        }\n    }\n    checkSignature(signature);\n    return curve.verify(signature, checkMessage(msgHash), ensureBytes(pubKey));\n}\nconst { CURVE, ProjectivePoint, Signature, utils } = curve;\n\nfunction extractX(bytes) {\n    const hex = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(bytes.subarray(1));\n    const stripped = hex.replace(/^0+/gm, \"\");\n    return `0x${stripped}`;\n}\nfunction strip0x(hex) {\n    return hex.replace(/^0x/i, \"\");\n}\nfunction grindKey(seed) {\n    const _seed = ensureBytes(seed);\n    const sha256mask = 2n ** 256n;\n    const limit = sha256mask - (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(sha256mask, CURVE_ORDER);\n    for(let i = 0;; i++){\n        const key = sha256Num(_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes(_seed, _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.numberToVarBytesBE(BigInt(i))));\n        if (key < limit) return (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(key, CURVE_ORDER).toString(16);\n        if (i === 100000) throw new Error(\"grindKey is broken: tried 100k vals\");\n    }\n}\nfunction getStarkKey(privateKey) {\n    return extractX(getPublicKey(privateKey, true));\n}\nfunction ethSigToPrivate(signature) {\n    signature = strip0x(signature);\n    if (signature.length !== 130) throw new Error(\"Wrong ethereum signature\");\n    return grindKey(signature.substring(0, 64));\n}\nconst MASK_31 = 2n ** 31n - 1n;\nconst int31 = (n)=>Number(n & MASK_31);\nfunction getAccountPath(layer, application, ethereumAddress, index) {\n    const layerNum = int31(sha256Num(layer));\n    const applicationNum = int31(sha256Num(application));\n    const eth = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.hexToNumber(strip0x(ethereumAddress));\n    return `m/2645'/${layerNum}'/${applicationNum}'/${int31(eth)}'/${int31(eth >> 31n)}'/${index}`;\n}\nconst PEDERSEN_POINTS = [\n    new ProjectivePoint(2089986280348253421170679821480865132823066470938446095505822317253594081284n, 1713931329540660377023406109199410414810705867260802078187082345529207694986n, 1n),\n    new ProjectivePoint(996781205833008774514500082376783249102396023663454813447423147977397232763n, 1668503676786377725805489344771023921079126552019160156920634619255970485781n, 1n),\n    new ProjectivePoint(2251563274489750535117886426533222435294046428347329203627021249169616184184n, 1798716007562728905295480679789526322175868328062420237419143593021674992973n, 1n),\n    new ProjectivePoint(2138414695194151160943305727036575959195309218611738193261179310511854807447n, 113410276730064486255102093846540133784865286929052426931474106396135072156n, 1n),\n    new ProjectivePoint(2379962749567351885752724891227938183011949129833673362440656643086021394946n, 776496453633298175483985398648758586525933812536653089401905292063708816422n, 1n)\n];\nfunction pedersenPrecompute(p1, p2) {\n    const out = [];\n    let p = p1;\n    for(let i = 0; i < 248; i++){\n        out.push(p);\n        p = p.double();\n    }\n    p = p2;\n    for(let i = 0; i < 4; i++){\n        out.push(p);\n        p = p.double();\n    }\n    return out;\n}\nconst PEDERSEN_POINTS1 = pedersenPrecompute(PEDERSEN_POINTS[1], PEDERSEN_POINTS[2]);\nconst PEDERSEN_POINTS2 = pedersenPrecompute(PEDERSEN_POINTS[3], PEDERSEN_POINTS[4]);\nfunction pedersenArg(arg) {\n    let value;\n    if (typeof arg === \"bigint\") {\n        value = arg;\n    } else if (typeof arg === \"number\") {\n        if (!Number.isSafeInteger(arg)) throw new Error(`Invalid pedersenArg: ${arg}`);\n        value = BigInt(arg);\n    } else {\n        value = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(ensureBytes(arg));\n    }\n    if (!(0n <= value && value < curve.CURVE.Fp.ORDER)) throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${value}`);\n    return value;\n}\nfunction pedersenSingle(point, value, constants) {\n    let x = pedersenArg(value);\n    for(let j = 0; j < 252; j++){\n        const pt = constants[j];\n        if (pt.equals(point)) throw new Error(\"Same point\");\n        if ((x & 1n) !== 0n) point = point.add(pt);\n        x >>= 1n;\n    }\n    return point;\n}\nfunction pedersen(x, y) {\n    let point = PEDERSEN_POINTS[0];\n    point = pedersenSingle(point, x, PEDERSEN_POINTS1);\n    point = pedersenSingle(point, y, PEDERSEN_POINTS2);\n    return extractX(point.toRawBytes(true));\n}\nconst computeHashOnElements = (data, fn = pedersen)=>[\n        0,\n        ...data,\n        data.length\n    ].reduce((x, y)=>fn(x, y));\nconst MASK_250 = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bitMask(250);\nconst keccak = (data)=>_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_5__.keccak_256)(data)) & MASK_250;\nconst sha256Num = (data)=>_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(data));\nconst Fp251 = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.Field)(BigInt(\"3618502788666131213697322783095070105623107215331596699973092056135872020481\"));\nfunction poseidonRoundConstant(Fp, name, idx) {\n    const val = Fp.fromBytes((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.utf8ToBytes)(`${name}${idx}`)));\n    return Fp.create(val);\n}\nfunction _poseidonMDS(Fp, name, m, attempt = 0) {\n    const x_values = [];\n    const y_values = [];\n    for(let i = 0; i < m; i++){\n        x_values.push(poseidonRoundConstant(Fp, `${name}x`, attempt * m + i));\n        y_values.push(poseidonRoundConstant(Fp, `${name}y`, attempt * m + i));\n    }\n    if (new Set([\n        ...x_values,\n        ...y_values\n    ]).size !== 2 * m) throw new Error(\"X and Y values are not distinct\");\n    return x_values.map((x)=>y_values.map((y)=>Fp.inv(Fp.sub(x, y))));\n}\nconst MDS_SMALL = [\n    [\n        3,\n        1,\n        1\n    ],\n    [\n        1,\n        -1,\n        1\n    ],\n    [\n        1,\n        1,\n        -2\n    ]\n].map((i)=>i.map(BigInt));\nfunction poseidonBasic(opts, mds) {\n    (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.validateField)(opts.Fp);\n    if (!Number.isSafeInteger(opts.rate) || !Number.isSafeInteger(opts.capacity)) throw new Error(`Wrong poseidon opts: ${opts}`);\n    const m = opts.rate + opts.capacity;\n    const rounds = opts.roundsFull + opts.roundsPartial;\n    const roundConstants = [];\n    for(let i = 0; i < rounds; i++){\n        const row = [];\n        for(let j = 0; j < m; j++)row.push(poseidonRoundConstant(opts.Fp, \"Hades\", m * i + j));\n        roundConstants.push(row);\n    }\n    const res = (0,_noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_7__.poseidon)({\n        ...opts,\n        t: m,\n        sboxPower: 3,\n        reversePartialPowIdx: true,\n        mds,\n        roundConstants\n    });\n    res.m = m;\n    res.rate = opts.rate;\n    res.capacity = opts.capacity;\n    return res;\n}\nfunction poseidonCreate(opts, mdsAttempt = 0) {\n    const m = opts.rate + opts.capacity;\n    if (!Number.isSafeInteger(mdsAttempt)) throw new Error(`Wrong mdsAttempt=${mdsAttempt}`);\n    return poseidonBasic(opts, _poseidonMDS(opts.Fp, \"HadesMDS\", m, mdsAttempt));\n}\nconst poseidonSmall = poseidonBasic({\n    Fp: Fp251,\n    rate: 2,\n    capacity: 1,\n    roundsFull: 8,\n    roundsPartial: 83\n}, MDS_SMALL);\nfunction poseidonHash(x, y, fn = poseidonSmall) {\n    return fn([\n        x,\n        y,\n        2n\n    ])[0];\n}\nfunction poseidonHashFunc(x, y, fn = poseidonSmall) {\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.numberToVarBytesBE(poseidonHash(_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(x), _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(y), fn));\n}\nfunction poseidonHashSingle(x, fn = poseidonSmall) {\n    return fn([\n        x,\n        0n,\n        1n\n    ])[0];\n}\nfunction poseidonHashMany(values, fn = poseidonSmall) {\n    const { m, rate } = fn;\n    if (!Array.isArray(values)) throw new Error(\"bigint array expected in values\");\n    const padded = Array.from(values);\n    padded.push(1n);\n    while(padded.length % rate !== 0)padded.push(0n);\n    let state = new Array(m).fill(0n);\n    for(let i = 0; i < padded.length; i += rate){\n        for(let j = 0; j < rate; j++)state[j] += padded[i + j];\n        state = fn(state);\n    }\n    return state[0];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnRDtBQUNGO0FBQ0k7QUFDaUM7QUFDeEI7QUFDVztBQUNwQjtBQUNJO0FBQ3RELE1BQU1ZLGNBQWNDLE9BQU87QUFDcEIsTUFBTUMsWUFBWUQsT0FBTyxxRUFBcUU7QUFDckcsTUFBTUUsYUFBYTtBQUNuQixTQUFTQyxTQUFTQyxLQUFLO0lBQ25CLE1BQU9BLEtBQUssQ0FBQyxFQUFFLEtBQUssRUFDaEJBLFFBQVFBLE1BQU1DLFFBQVEsQ0FBQztJQUMzQixNQUFNQyxRQUFRRixNQUFNRyxNQUFNLEdBQUcsSUFBSUw7SUFDakMsTUFBTU0sTUFBTVgseUVBQWlCLENBQUNPO0lBQzlCLE9BQU9FLFFBQVEsSUFBSUUsT0FBT1IsT0FBT00sU0FBU0U7QUFDOUM7QUFDQSxTQUFTRSxhQUFhQyxHQUFHO0lBQ3JCLElBQUksT0FBT0EsUUFBUSxVQUFVO1FBQ3pCQSxNQUFNQyxRQUFRRDtRQUNkLElBQUlBLElBQUlKLE1BQU0sR0FBRyxHQUNiSSxNQUFNLE1BQU1BO0lBQ3BCO0lBQ0EsT0FBT2Qsb0VBQVksQ0FBQ2M7QUFDeEI7QUFDQSxNQUFNRyxRQUFRbkIsK0VBQVdBLENBQUM7SUFDdEJvQixHQUFHZixPQUFPO0lBQ1ZnQixHQUFHaEIsT0FBTztJQUNWaUIsSUFBSTNCLHFFQUFLQSxDQUFDVSxPQUFPO0lBQ2pCa0IsR0FBR25CO0lBQ0hHO0lBQ0FpQixJQUFJbkIsT0FBTztJQUNYb0IsSUFBSXBCLE9BQU87SUFDWHFCLEdBQUdyQixPQUFPO0lBQ1ZzQixNQUFNO0lBQ04sR0FBR3hCLG1FQUFPQSxDQUFDVix3REFBTUEsQ0FBQztJQUNsQmU7SUFDQW9CLGVBQWUsQ0FBQ25CO1FBQ1osTUFBTU8sTUFBTWQseUVBQWlCLENBQUNPLE9BQU9vQixRQUFRLENBQUM7UUFDOUMsSUFBSWIs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LElBQUlKLE1BQU0vQixHQUFHb0MsSUFBSSxDQUFDLEVBQUU7SUFDaEMsSUFBSyxJQUFJbEcsSUFBSSxHQUFHQSxJQUFJK0YsT0FBT3pKLE1BQU0sRUFBRTBELEtBQUswRSxLQUFNO1FBQzFDLElBQUssSUFBSWxDLElBQUksR0FBR0EsSUFBSWtDLE1BQU1sQyxJQUN0QnlELEtBQUssQ0FBQ3pELEVBQUUsSUFBSXVELE1BQU0sQ0FBQy9GLElBQUl3QyxFQUFFO1FBQzdCeUQsUUFBUWhELEdBQUdnRDtJQUNmO0lBQ0EsT0FBT0EsS0FBSyxDQUFDLEVBQUU7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iZXR0ZXJoYWNrLy4vbm9kZV9tb2R1bGVzL0BzY3VyZS9zdGFya25ldC9saWIvZXNtL2luZGV4LmpzPzVkOTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrXzI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMyc7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgeyB1dGY4VG9CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgRmllbGQsIG1vZCwgdmFsaWRhdGVGaWVsZCwgaW52ZXJ0IH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9tb2R1bGFyJztcbmltcG9ydCB7IHBvc2VpZG9uIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9wb3NlaWRvbic7XG5pbXBvcnQgeyB3ZWllcnN0cmFzcywgREVSIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC93ZWllcnN0cmFzcyc7XG5pbXBvcnQgKiBhcyB1IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0SGFzaCB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvX3Nob3J0d191dGlscyc7XG5jb25zdCBDVVJWRV9PUkRFUiA9IEJpZ0ludCgnMzYxODUwMjc4ODY2NjEzMTIxMzY5NzMyMjc4MzA5NTA3MDEwNTUyNjc0Mzc1MTcxNjA4NzQ4OTE1NDA3OTQ1Nzg4NDUxMjg2NTU4MycpO1xuZXhwb3J0IGNvbnN0IE1BWF9WQUxVRSA9IEJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTtcbmNvbnN0IG5CaXRMZW5ndGggPSAyNTI7XG5mdW5jdGlvbiBiaXRzMmludChieXRlcykge1xuICAgIHdoaWxlIChieXRlc1swXSA9PT0gMClcbiAgICAgICAgYnl0ZXMgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICBjb25zdCBkZWx0YSA9IGJ5dGVzLmxlbmd0aCAqIDggLSBuQml0TGVuZ3RoO1xuICAgIGNvbnN0IG51bSA9IHUuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG59XG5mdW5jdGlvbiBoZXgweFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhleCA9IHN0cmlwMHgoaGV4KTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggJiAxKVxuICAgICAgICAgICAgaGV4ID0gJzAnICsgaGV4O1xuICAgIH1cbiAgICByZXR1cm4gdS5oZXhUb0J5dGVzKGhleCk7XG59XG5jb25zdCBjdXJ2ZSA9IHdlaWVyc3RyYXNzKHtcbiAgICBhOiBCaWdJbnQoMSksXG4gICAgYjogQmlnSW50KCczMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NTAyODg0MTk3MTY5Mzk5Mzc1MTA1ODIwOTc0OTQ0NTkyMzA3ODE2NDA2NjY1JyksXG4gICAgRnA6IEZpZWxkKEJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMTEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnKSksXG4gICAgbjogQ1VSVkVfT1JERVIsXG4gICAgbkJpdExlbmd0aCxcbiAgICBHeDogQmlnSW50KCc4NzQ3Mzk0NTEwNzgwMDc3NjY0NTc0NjQ5ODk3NzQzMjIwODM2NDkyNzg2MDc1MzMyNDk0ODExNTEzODI0ODEwNzI4Njg4MDY2MDInKSxcbiAgICBHeTogQmlnSW50KCcxNTI2NjY3OTIwNzE1MTg4MzA4Njg1NzU1NTc4MTI5NDgzNTMwNDE0MjA0MDA3ODA3Mzk0ODEzNDI5NDEzODEyMjU1MjU4NjE0MDcnKSxcbiAgICBoOiBCaWdJbnQoMSksXG4gICAgbG93UzogZmFsc2UsXG4gICAgLi4uZ2V0SGFzaChzaGEyNTYpLFxuICAgIGJpdHMyaW50LFxuICAgIGJpdHMyaW50X21vZE46IChieXRlcykgPT4ge1xuICAgICAgICBjb25zdCBoZXggPSB1LmJ5dGVzVG9OdW1iZXJCRShieXRlcykudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gNjMpXG4gICAgICAgICAgICBieXRlcyA9IGhleDB4VG9CeXRlcyhoZXggKyAnMCcpO1xuICAgICAgICByZXR1cm4gbW9kKGJpdHMyaW50KGJ5dGVzKSwgQ1VSVkVfT1JERVIpO1xuICAgIH0sXG59KTtcbmV4cG9ydCBjb25zdCBfc3RhcmtDdXJ2ZSA9IGN1cnZlO1xuZnVuY3Rpb24gZW5zdXJlQnl0ZXMoaGV4KSB7XG4gICAgcmV0dXJuIHUuZW5zdXJlQnl0ZXMoJycsIHR5cGVvZiBoZXggPT09ICdzdHJpbmcnID8gaGV4MHhUb0J5dGVzKGhleCkgOiBoZXgpO1xufVxuZnVuY3Rpb24gbm9ybVByaXZLZXkocHJpdktleSkge1xuICAgIHJldHVybiB1LmJ5dGVzVG9IZXgoZW5zdXJlQnl0ZXMocHJpdktleSkpLnBhZFN0YXJ0KDY0LCAnMCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2S2V5LCBpc0NvbXByZXNzZWQgPSBmYWxzZSkge1xuICAgIHJldHVybiBjdXJ2ZS5nZXRQdWJsaWNLZXkobm9ybVByaXZLZXkocHJpdktleSksIGlzQ29tcHJlc3NlZCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZLZXlBLCBwdWJLZXlCKSB7XG4gICAgcmV0dXJuIGN1cnZlLmdldFNoYXJlZFNlY3JldChub3JtUHJpdktleShwcml2S2V5QSksIHB1YktleUIpO1xufVxuZnVuY3Rpb24gY2hlY2tTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgeyByLCBzIH0gPSBzaWduYXR1cmU7XG4gICAgaWYgKHIgPCAwbiB8fCByID49IE1BWF9WQUxVRSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaWduYXR1cmUuciBzaG91bGQgYmUgWzEsICR7TUFYX1ZBTFVFfSlgKTtcbiAgICBjb25zdCB3ID0gaW52ZXJ0KHMsIENVUlZFX09SREVSKTtcbiAgICBpZiAodyA8IDBuIHx8IHcgPj0gTUFYX1ZBTFVFKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludihTaWduYXR1cmUucykgc2hvdWxkIGJlIFsxLCAke01BWF9WQUxVRX0pYCk7XG59XG5mdW5jdGlvbiBjaGVja01lc3NhZ2UobXNnSGFzaCkge1xuICAgIGNvbnN0IGJ5dGVzID0gZW5zdXJlQnl0ZXMobXNnSGFzaCk7XG4gICAgY29uc3QgbnVtID0gdS5ieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgIGlmIChudW0gPj0gTUFYX1ZBTFVFKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1zZ0hhc2ggc2hvdWxkIGJlIFswLCAke01BWF9WQUxVRX0pYCk7XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cykge1xuICAgIGNvbnN0IHNpZyA9IGN1cnZlLnNpZ24oY2hlY2tNZXNzYWdlKG1zZ0hhc2gpLCBub3JtUHJpdktleShwcml2S2V5KSwgb3B0cyk7XG4gICAgY2hlY2tTaWduYXR1cmUoc2lnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YktleSkge1xuICAgIGlmICghKHNpZ25hdHVyZSBpbnN0YW5jZW9mIFNpZ25hdHVyZSkpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVCeXRlcyhzaWduYXR1cmUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21ERVIoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBkZXJFcnJvcjtcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tQ29tcGFjdChieXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gY3VydmUudmVyaWZ5KHNpZ25hdHVyZSwgY2hlY2tNZXNzYWdlKG1zZ0hhc2gpLCBlbnN1cmVCeXRlcyhwdWJLZXkpKTtcbn1cbmNvbnN0IHsgQ1VSVkUsIFByb2plY3RpdmVQb2ludCwgU2lnbmF0dXJlLCB1dGlscyB9ID0gY3VydmU7XG5leHBvcnQgeyBDVVJWRSwgUHJvamVjdGl2ZVBvaW50LCBTaWduYXR1cmUsIHV0aWxzIH07XG5mdW5jdGlvbiBleHRyYWN0WChieXRlcykge1xuICAgIGNvbnN0IGhleCA9IHUuYnl0ZXNUb0hleChieXRlcy5zdWJhcnJheSgxKSk7XG4gICAgY29uc3Qgc3RyaXBwZWQgPSBoZXgucmVwbGFjZSgvXjArL2dtLCAnJyk7XG4gICAgcmV0dXJuIGAweCR7c3RyaXBwZWR9YDtcbn1cbmZ1bmN0aW9uIHN0cmlwMHgoaGV4KSB7XG4gICAgcmV0dXJuIGhleC5yZXBsYWNlKC9eMHgvaSwgJycpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdyaW5kS2V5KHNlZWQpIHtcbiAgICBjb25zdCBfc2VlZCA9IGVuc3VyZUJ5dGVzKHNlZWQpO1xuICAgIGNvbnN0IHNoYTI1Nm1hc2sgPSAybiAqKiAyNTZuO1xuICAgIGNvbnN0IGxpbWl0ID0gc2hhMjU2bWFzayAtIG1vZChzaGEyNTZtYXNrLCBDVVJWRV9PUkRFUik7XG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gc2hhMjU2TnVtKHUuY29uY2F0Qnl0ZXMoX3NlZWQsIHUubnVtYmVyVG9WYXJCeXRlc0JFKEJpZ0ludChpKSkpKTtcbiAgICAgICAgaWYgKGtleSA8IGxpbWl0KVxuICAgICAgICAgICAgcmV0dXJuIG1vZChrZXksIENVUlZFX09SREVSKS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChpID09PSAxMDAwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dyaW5kS2V5IGlzIGJyb2tlbjogdHJpZWQgMTAwayB2YWxzJyk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXJrS2V5KHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gZXh0cmFjdFgoZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIHRydWUpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBldGhTaWdUb1ByaXZhdGUoc2lnbmF0dXJlKSB7XG4gICAgc2lnbmF0dXJlID0gc3RyaXAweChzaWduYXR1cmUpO1xuICAgIGlmIChzaWduYXR1cmUubGVuZ3RoICE9PSAxMzApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgZXRoZXJldW0gc2lnbmF0dXJlJyk7XG4gICAgcmV0dXJuIGdyaW5kS2V5KHNpZ25hdHVyZS5zdWJzdHJpbmcoMCwgNjQpKTtcbn1cbmNvbnN0IE1BU0tfMzEgPSAybiAqKiAzMW4gLSAxbjtcbmNvbnN0IGludDMxID0gKG4pID0+IE51bWJlcihuICYgTUFTS18zMSk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0QWNjb3VudFBhdGgobGF5ZXIsIGFwcGxpY2F0aW9uLCBldGhlcmV1bUFkZHJlc3MsIGluZGV4KSB7XG4gICAgY29uc3QgbGF5ZXJOdW0gPSBpbnQzMShzaGEyNTZOdW0obGF5ZXIpKTtcbiAgICBjb25zdCBhcHBsaWNhdGlvbk51bSA9IGludDMxKHNoYTI1Nk51bShhcHBsaWNhdGlvbikpO1xuICAgIGNvbnN0IGV0aCA9IHUuaGV4VG9OdW1iZXIoc3RyaXAweChldGhlcmV1bUFkZHJlc3MpKTtcbiAgICByZXR1cm4gYG0vMjY0NScvJHtsYXllck51bX0nLyR7YXBwbGljYXRpb25OdW19Jy8ke2ludDMxKGV0aCl9Jy8ke2ludDMxKGV0aCA+PiAzMW4pfScvJHtpbmRleH1gO1xufVxuY29uc3QgUEVERVJTRU5fUE9JTlRTID0gW1xuICAgIG5ldyBQcm9qZWN0aXZlUG9pbnQoMjA4OTk4NjI4MDM0ODI1MzQyMTE3MDY3OTgyMTQ4MDg2NTEzMjgyMzA2NjQ3MDkzODQ0NjA5NTUwNTgyMjMxNzI1MzU5NDA4MTI4NG4sIDE3MTM5MzEzMjk1NDA2NjAzNzcwMjM0MDYxMDkxOTk0MTA0MTQ4MTA3MDU4NjcyNjA4MDIwNzgxODcwODIzNDU1MjkyMDc2OTQ5ODZuLCAxbiksXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCg5OTY3ODEyMDU4MzMwMDg3NzQ1MTQ1MDAwODIzNzY3ODMyNDkxMDIzOTYwMjM2NjM0NTQ4MTM0NDc0MjMxNDc5NzczOTcyMzI3NjNuLCAxNjY4NTAzNjc2Nzg2Mzc3NzI1ODA1NDg5MzQ0NzcxMDIzOTIxMDc5MTI2NTUyMDE5MTYwMTU2OTIwNjM0NjE5MjU1OTcwNDg1NzgxbiwgMW4pLFxuICAgIG5ldyBQcm9qZWN0aXZlUG9pbnQoMjI1MTU2MzI3NDQ4OTc1MDUzNTExNzg4NjQyNjUzMzIyMjQzNTI5NDA0NjQyODM0NzMyOTIwMzYyNzAyMTI0OTE2OTYxNjE4NDE4NG4sIDE3OTg3MTYwMDc1NjI3Mjg5MDUyOTU0ODA2Nzk3ODk1MjYzMjIxNzU4NjgzMjgwNjI0MjAyMzc0MTkxNDM1OTMwMjE2NzQ5OTI5NzNuLCAxbiksXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCgyMTM4NDE0Njk1MTk0MTUxMTYwOTQzMzA1NzI3MDM2NTc1OTU5MTk1MzA5MjE4NjExNzM4MTkzMjYxMTc5MzEwNTExODU0ODA3NDQ3biwgMTEzNDEwMjc2NzMwMDY0NDg2MjU1MTAyMDkzODQ2NTQwMTMzNzg0ODY1Mjg2OTI5MDUyNDI2OTMxNDc0MTA2Mzk2MTM1MDcyMTU2biwgMW4pLFxuICAgIG5ldyBQcm9qZWN0aXZlUG9pbnQoMjM3OTk2Mjc0OTU2NzM1MTg4NTc1MjcyNDg5MTIyNzkzODE4MzAxMTk0OTEyOTgzMzY3MzM2MjQ0MDY1NjY0MzA4NjAyMTM5NDk0Nm4sIDc3NjQ5NjQ1MzYzMzI5ODE3NTQ4Mzk4NTM5ODY0ODc1ODU4NjUyNTkzMzgxMjUzNjY1MzA4OTQwMTkwNTI5MjA2MzcwODgxNjQyMm4sIDFuKSxcbl07XG5mdW5jdGlvbiBwZWRlcnNlblByZWNvbXB1dGUocDEsIHAyKSB7XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgbGV0IHAgPSBwMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI0ODsgaSsrKSB7XG4gICAgICAgIG91dC5wdXNoKHApO1xuICAgICAgICBwID0gcC5kb3VibGUoKTtcbiAgICB9XG4gICAgcCA9IHAyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIG91dC5wdXNoKHApO1xuICAgICAgICBwID0gcC5kb3VibGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmNvbnN0IFBFREVSU0VOX1BPSU5UUzEgPSBwZWRlcnNlblByZWNvbXB1dGUoUEVERVJTRU5fUE9JTlRTWzFdLCBQRURFUlNFTl9QT0lOVFNbMl0pO1xuY29uc3QgUEVERVJTRU5fUE9JTlRTMiA9IHBlZGVyc2VuUHJlY29tcHV0ZShQRURFUlNFTl9QT0lOVFNbM10sIFBFREVSU0VOX1BPSU5UU1s0XSk7XG5mdW5jdGlvbiBwZWRlcnNlbkFyZyhhcmcpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHZhbHVlID0gYXJnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGFyZykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGVkZXJzZW5Bcmc6ICR7YXJnfWApO1xuICAgICAgICB2YWx1ZSA9IEJpZ0ludChhcmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB1LmJ5dGVzVG9OdW1iZXJCRShlbnN1cmVCeXRlcyhhcmcpKTtcbiAgICB9XG4gICAgaWYgKCEoMG4gPD0gdmFsdWUgJiYgdmFsdWUgPCBjdXJ2ZS5DVVJWRS5GcC5PUkRFUikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUGVkZXJzZW5Bcmcgc2hvdWxkIGJlIDAgPD0gdmFsdWUgPCBDVVJWRS5QOiAke3ZhbHVlfWApO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHBlZGVyc2VuU2luZ2xlKHBvaW50LCB2YWx1ZSwgY29uc3RhbnRzKSB7XG4gICAgbGV0IHggPSBwZWRlcnNlbkFyZyh2YWx1ZSk7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAyNTI7IGorKykge1xuICAgICAgICBjb25zdCBwdCA9IGNvbnN0YW50c1tqXTtcbiAgICAgICAgaWYgKHB0LmVxdWFscyhwb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NhbWUgcG9pbnQnKTtcbiAgICAgICAgaWYgKCh4ICYgMW4pICE9PSAwbilcbiAgICAgICAgICAgIHBvaW50ID0gcG9pbnQuYWRkKHB0KTtcbiAgICAgICAgeCA+Pj0gMW47XG4gICAgfVxuICAgIHJldHVybiBwb2ludDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwZWRlcnNlbih4LCB5KSB7XG4gICAgbGV0IHBvaW50ID0gUEVERVJTRU5fUE9JTlRTWzBdO1xuICAgIHBvaW50ID0gcGVkZXJzZW5TaW5nbGUocG9pbnQsIHgsIFBFREVSU0VOX1BPSU5UUzEpO1xuICAgIHBvaW50ID0gcGVkZXJzZW5TaW5nbGUocG9pbnQsIHksIFBFREVSU0VOX1BPSU5UUzIpO1xuICAgIHJldHVybiBleHRyYWN0WChwb2ludC50b1Jhd0J5dGVzKHRydWUpKTtcbn1cbmV4cG9ydCBjb25zdCBjb21wdXRlSGFzaE9uRWxlbWVudHMgPSAoZGF0YSwgZm4gPSBwZWRlcnNlbikgPT4gWzAsIC4uLmRhdGEsIGRhdGEubGVuZ3RoXS5yZWR1Y2UoKHgsIHkpID0+IGZuKHgsIHkpKTtcbmNvbnN0IE1BU0tfMjUwID0gdS5iaXRNYXNrKDI1MCk7XG5leHBvcnQgY29uc3Qga2VjY2FrID0gKGRhdGEpID0+IHUuYnl0ZXNUb051bWJlckJFKGtlY2Nha18yNTYoZGF0YSkpICYgTUFTS18yNTA7XG5jb25zdCBzaGEyNTZOdW0gPSAoZGF0YSkgPT4gdS5ieXRlc1RvTnVtYmVyQkUoc2hhMjU2KGRhdGEpKTtcbmV4cG9ydCBjb25zdCBGcDI1MSA9IEZpZWxkKEJpZ0ludCgnMzYxODUwMjc4ODY2NjEzMTIxMzY5NzMyMjc4MzA5NTA3MDEwNTYyMzEwNzIxNTMzMTU5NjY5OTk3MzA5MjA1NjEzNTg3MjAyMDQ4MScpKTtcbmZ1bmN0aW9uIHBvc2VpZG9uUm91bmRDb25zdGFudChGcCwgbmFtZSwgaWR4KSB7XG4gICAgY29uc3QgdmFsID0gRnAuZnJvbUJ5dGVzKHNoYTI1Nih1dGY4VG9CeXRlcyhgJHtuYW1lfSR7aWR4fWApKSk7XG4gICAgcmV0dXJuIEZwLmNyZWF0ZSh2YWwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9wb3NlaWRvbk1EUyhGcCwgbmFtZSwgbSwgYXR0ZW1wdCA9IDApIHtcbiAgICBjb25zdCB4X3ZhbHVlcyA9IFtdO1xuICAgIGNvbnN0IHlfdmFsdWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgeF92YWx1ZXMucHVzaChwb3NlaWRvblJvdW5kQ29uc3RhbnQoRnAsIGAke25hbWV9eGAsIGF0dGVtcHQgKiBtICsgaSkpO1xuICAgICAgICB5X3ZhbHVlcy5wdXNoKHBvc2VpZG9uUm91bmRDb25zdGFudChGcCwgYCR7bmFtZX15YCwgYXR0ZW1wdCAqIG0gKyBpKSk7XG4gICAgfVxuICAgIGlmIChuZXcgU2V0KFsuLi54X3ZhbHVlcywgLi4ueV92YWx1ZXNdKS5zaXplICE9PSAyICogbSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYIGFuZCBZIHZhbHVlcyBhcmUgbm90IGRpc3RpbmN0Jyk7XG4gICAgcmV0dXJuIHhfdmFsdWVzLm1hcCgoeCkgPT4geV92YWx1ZXMubWFwKCh5KSA9PiBGcC5pbnYoRnAuc3ViKHgsIHkpKSkpO1xufVxuY29uc3QgTURTX1NNQUxMID0gW1xuICAgIFszLCAxLCAxXSxcbiAgICBbMSwgLTEsIDFdLFxuICAgIFsxLCAxLCAtMl0sXG5dLm1hcCgoaSkgPT4gaS5tYXAoQmlnSW50KSk7XG5leHBvcnQgZnVuY3Rpb24gcG9zZWlkb25CYXNpYyhvcHRzLCBtZHMpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKG9wdHMuRnApO1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIob3B0cy5yYXRlKSB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIob3B0cy5jYXBhY2l0eSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zZWlkb24gb3B0czogJHtvcHRzfWApO1xuICAgIGNvbnN0IG0gPSBvcHRzLnJhdGUgKyBvcHRzLmNhcGFjaXR5O1xuICAgIGNvbnN0IHJvdW5kcyA9IG9wdHMucm91bmRzRnVsbCArIG9wdHMucm91bmRzUGFydGlhbDtcbiAgICBjb25zdCByb3VuZENvbnN0YW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91bmRzOyBpKyspIHtcbiAgICAgICAgY29uc3Qgcm93ID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKVxuICAgICAgICAgICAgcm93LnB1c2gocG9zZWlkb25Sb3VuZENvbnN0YW50KG9wdHMuRnAsICdIYWRlcycsIG0gKiBpICsgaikpO1xuICAgICAgICByb3VuZENvbnN0YW50cy5wdXNoKHJvdyk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IHBvc2VpZG9uKHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgdDogbSxcbiAgICAgICAgc2JveFBvd2VyOiAzLFxuICAgICAgICByZXZlcnNlUGFydGlhbFBvd0lkeDogdHJ1ZSxcbiAgICAgICAgbWRzLFxuICAgICAgICByb3VuZENvbnN0YW50cyxcbiAgICB9KTtcbiAgICByZXMubSA9IG07XG4gICAgcmVzLnJhdGUgPSBvcHRzLnJhdGU7XG4gICAgcmVzLmNhcGFjaXR5ID0gb3B0cy5jYXBhY2l0eTtcbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvc2VpZG9uQ3JlYXRlKG9wdHMsIG1kc0F0dGVtcHQgPSAwKSB7XG4gICAgY29uc3QgbSA9IG9wdHMucmF0ZSArIG9wdHMuY2FwYWNpdHk7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihtZHNBdHRlbXB0KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBtZHNBdHRlbXB0PSR7bWRzQXR0ZW1wdH1gKTtcbiAgICByZXR1cm4gcG9zZWlkb25CYXNpYyhvcHRzLCBfcG9zZWlkb25NRFMob3B0cy5GcCwgJ0hhZGVzTURTJywgbSwgbWRzQXR0ZW1wdCkpO1xufVxuZXhwb3J0IGNvbnN0IHBvc2VpZG9uU21hbGwgPSBwb3NlaWRvbkJhc2ljKHsgRnA6IEZwMjUxLCByYXRlOiAyLCBjYXBhY2l0eTogMSwgcm91bmRzRnVsbDogOCwgcm91bmRzUGFydGlhbDogODMgfSwgTURTX1NNQUxMKTtcbmV4cG9ydCBmdW5jdGlvbiBwb3NlaWRvbkhhc2goeCwgeSwgZm4gPSBwb3NlaWRvblNtYWxsKSB7XG4gICAgcmV0dXJuIGZuKFt4LCB5LCAybl0pWzBdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvc2VpZG9uSGFzaEZ1bmMoeCwgeSwgZm4gPSBwb3NlaWRvblNtYWxsKSB7XG4gICAgcmV0dXJuIHUubnVtYmVyVG9WYXJCeXRlc0JFKHBvc2VpZG9uSGFzaCh1LmJ5dGVzVG9OdW1iZXJCRSh4KSwgdS5ieXRlc1RvTnVtYmVyQkUoeSksIGZuKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcG9zZWlkb25IYXNoU2luZ2xlKHgsIGZuID0gcG9zZWlkb25TbWFsbCkge1xuICAgIHJldHVybiBmbihbeCwgMG4sIDFuXSlbMF07XG59XG5leHBvcnQgZnVuY3Rpb24gcG9zZWlkb25IYXNoTWFueSh2YWx1ZXMsIGZuID0gcG9zZWlkb25TbWFsbCkge1xuICAgIGNvbnN0IHsgbSwgcmF0ZSB9ID0gZm47XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmlnaW50IGFycmF5IGV4cGVjdGVkIGluIHZhbHVlcycpO1xuICAgIGNvbnN0IHBhZGRlZCA9IEFycmF5LmZyb20odmFsdWVzKTtcbiAgICBwYWRkZWQucHVzaCgxbik7XG4gICAgd2hpbGUgKHBhZGRlZC5sZW5ndGggJSByYXRlICE9PSAwKVxuICAgICAgICBwYWRkZWQucHVzaCgwbik7XG4gICAgbGV0IHN0YXRlID0gbmV3IEFycmF5KG0pLmZpbGwoMG4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkZGVkLmxlbmd0aDsgaSArPSByYXRlKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmF0ZTsgaisrKVxuICAgICAgICAgICAgc3RhdGVbal0gKz0gcGFkZGVkW2kgKyBqXTtcbiAgICAgICAgc3RhdGUgPSBmbihzdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZVswXTtcbn1cbiJdLCJuYW1lcyI6WyJrZWNjYWtfMjU2Iiwic2hhMjU2IiwidXRmOFRvQnl0ZXMiLCJGaWVsZCIsIm1vZCIsInZhbGlkYXRlRmllbGQiLCJpbnZlcnQiLCJwb3NlaWRvbiIsIndlaWVyc3RyYXNzIiwiREVSIiwidSIsImdldEhhc2giLCJDVVJWRV9PUkRFUiIsIkJpZ0ludCIsIk1BWF9WQUxVRSIsIm5CaXRMZW5ndGgiLCJiaXRzMmludCIsImJ5dGVzIiwic3ViYXJyYXkiLCJkZWx0YSIsImxlbmd0aCIsIm51bSIsImJ5dGVzVG9OdW1iZXJCRSIsImhleDB4VG9CeXRlcyIsImhleCIsInN0cmlwMHgiLCJoZXhUb0J5dGVzIiwiY3VydmUiLCJhIiwiYiIsIkZwIiwibiIsIkd4IiwiR3kiLCJoIiwibG93UyIsImJpdHMyaW50X21vZE4iLCJ0b1N0cmluZyIsIl9zdGFya0N1cnZlIiwiZW5zdXJlQnl0ZXMiLCJub3JtUHJpdktleSIsInByaXZLZXkiLCJieXRlc1RvSGV4IiwicGFkU3RhcnQiLCJnZXRQdWJsaWNLZXkiLCJpc0NvbXByZXNzZWQiLCJnZXRTaGFyZWRTZWNyZXQiLCJwcml2S2V5QSIsInB1YktleUIiLCJjaGVja1NpZ25hdHVyZSIsInNpZ25hdHVyZSIsInIiLCJzIiwiRXJyb3IiLCJ3IiwiY2hlY2tNZXNzYWdlIiwibXNnSGFzaCIsInNpZ24iLCJvcHRzIiwic2lnIiwidmVyaWZ5IiwicHViS2V5IiwiU2lnbmF0dXJlIiwiZnJvbURFUiIsImRlckVycm9yIiwiRXJyIiwiZnJvbUNvbXBhY3QiLCJDVVJWRSIsIlByb2plY3RpdmVQb2ludCIsInV0aWxzIiwiZXh0cmFjdFgiLCJzdHJpcHBlZCIsInJlcGxhY2UiLCJncmluZEtleSIsInNlZWQiLCJfc2VlZCIsInNoYTI1Nm1hc2siLCJsaW1pdCIsImkiLCJrZXkiLCJzaGEyNTZOdW0iLCJjb25jYXRCeXRlcyIsIm51bWJlclRvVmFyQnl0ZXNCRSIsImdldFN0YXJrS2V5IiwicHJpdmF0ZUtleSIsImV0aFNpZ1RvUHJpdmF0ZSIsInN1YnN0cmluZyIsIk1BU0tfMzEiLCJpbnQzMSIsIk51bWJlciIsImdldEFjY291bnRQYXRoIiwibGF5ZXIiLCJhcHBsaWNhdGlvbiIsImV0aGVyZXVtQWRkcmVzcyIsImluZGV4IiwibGF5ZXJOdW0iLCJhcHBsaWNhdGlvbk51bSIsImV0aCIsImhleFRvTnVtYmVyIiwiUEVERVJTRU5fUE9JTlRTIiwicGVkZXJzZW5QcmVjb21wdXRlIiwicDEiLCJwMiIsIm91dCIsInAiLCJwdXNoIiwiZG91YmxlIiwiUEVERVJTRU5fUE9JTlRTMSIsIlBFREVSU0VOX1BPSU5UUzIiLCJwZWRlcnNlbkFyZyIsImFyZyIsInZhbHVlIiwiaXNTYWZlSW50ZWdlciIsIk9SREVSIiwicGVkZXJzZW5TaW5nbGUiLCJwb2ludCIsImNvbnN0YW50cyIsIngiLCJqIiwicHQiLCJlcXVhbHMiLCJhZGQiLCJwZWRlcnNlbiIsInkiLCJ0b1Jhd0J5dGVzIiwiY29tcHV0ZUhhc2hPbkVsZW1lbnRzIiwiZGF0YSIsImZuIiwicmVkdWNlIiwiTUFTS18yNTAiLCJiaXRNYXNrIiwia2VjY2FrIiwiRnAyNTEiLCJwb3NlaWRvblJvdW5kQ29uc3RhbnQiLCJuYW1lIiwiaWR4IiwidmFsIiwiZnJvbUJ5dGVzIiwiY3JlYXRlIiwiX3Bvc2VpZG9uTURTIiwibSIsImF0dGVtcHQiLCJ4X3ZhbHVlcyIsInlfdmFsdWVzIiwiU2V0Iiwic2l6ZSIsIm1hcCIsImludiIsInN1YiIsIk1EU19TTUFMTCIsInBvc2VpZG9uQmFzaWMiLCJtZHMiLCJyYXRlIiwiY2FwYWNpdHkiLCJyb3VuZHMiLCJyb3VuZHNGdWxsIiwicm91bmRzUGFydGlhbCIsInJvdW5kQ29uc3RhbnRzIiwicm93IiwicmVzIiwidCIsInNib3hQb3dlciIsInJldmVyc2VQYXJ0aWFsUG93SWR4IiwicG9zZWlkb25DcmVhdGUiLCJtZHNBdHRlbXB0IiwicG9zZWlkb25TbWFsbCIsInBvc2VpZG9uSGFzaCIsInBvc2VpZG9uSGFzaEZ1bmMiLCJwb3NlaWRvbkhhc2hTaW5nbGUiLCJwb3NlaWRvbkhhc2hNYW55IiwidmFsdWVzIiwiQXJyYXkiLCJpc0FycmF5IiwicGFkZGVkIiwiZnJvbSIsInN0YXRlIiwiZmlsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/starknet/lib/esm/index.js\n");

/***/ })

};
;