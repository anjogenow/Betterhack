"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/starknet";
exports.ids = ["vendor-chunks/starknet"];
exports.modules = {

/***/ "(ssr)/./node_modules/starknet/dist/index.js":
/*!*********************************************!*\
  !*** ./node_modules/starknet/dist/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\nvar __toCommonJS = (mod)=>__copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n    Account: ()=>Account,\n    AccountInterface: ()=>AccountInterface,\n    BlockStatus: ()=>BlockStatus,\n    BlockTag: ()=>BlockTag,\n    CairoCustomEnum: ()=>CairoCustomEnum,\n    CairoOption: ()=>CairoOption,\n    CairoOptionVariant: ()=>CairoOptionVariant,\n    CairoResult: ()=>CairoResult,\n    CairoResultVariant: ()=>CairoResultVariant,\n    CallData: ()=>CallData,\n    Contract: ()=>Contract,\n    ContractFactory: ()=>ContractFactory,\n    ContractInterface: ()=>ContractInterface,\n    CustomError: ()=>CustomError,\n    EntryPointType: ()=>EntryPointType,\n    GatewayError: ()=>GatewayError,\n    HttpError: ()=>HttpError,\n    LibraryError: ()=>LibraryError,\n    Litteral: ()=>Litteral,\n    Provider: ()=>Provider,\n    ProviderInterface: ()=>ProviderInterface,\n    RPC: ()=>rpc_exports,\n    RpcProvider: ()=>RpcProvider,\n    SIMULATION_FLAG: ()=>SIMULATION_FLAG,\n    Sequencer: ()=>sequencer_exports,\n    SequencerProvider: ()=>SequencerProvider,\n    Signer: ()=>Signer,\n    SignerInterface: ()=>SignerInterface,\n    TransactionExecutionStatus: ()=>TransactionExecutionStatus,\n    TransactionFinalityStatus: ()=>TransactionFinalityStatus,\n    TransactionStatus: ()=>TransactionStatus,\n    TransactionType: ()=>TransactionType,\n    Uint: ()=>Uint,\n    ValidateType: ()=>ValidateType,\n    addAddressPadding: ()=>addAddressPadding,\n    buildUrl: ()=>buildUrl,\n    cairo: ()=>cairo_exports,\n    constants: ()=>constants_exports,\n    contractClassResponseToLegacyCompiledContract: ()=>contractClassResponseToLegacyCompiledContract,\n    defaultProvider: ()=>defaultProvider,\n    ec: ()=>ec_exports,\n    encode: ()=>encode_exports,\n    events: ()=>events_exports,\n    extractContractHashes: ()=>extractContractHashes,\n    fixProto: ()=>fixProto,\n    fixStack: ()=>fixStack,\n    getCalldata: ()=>getCalldata,\n    getChecksumAddress: ()=>getChecksumAddress,\n    getDefaultNodeUrl: ()=>getDefaultNodeUrl,\n    hash: ()=>hash_exports,\n    isSierra: ()=>isSierra,\n    isUrl: ()=>isUrl,\n    json: ()=>json_exports,\n    merkle: ()=>merkle_exports,\n    num: ()=>num_exports,\n    number: ()=>number,\n    parseUDCEvent: ()=>parseUDCEvent,\n    provider: ()=>provider_exports,\n    selector: ()=>selector_exports,\n    shortString: ()=>shortString_exports,\n    splitArgsAndOptions: ()=>splitArgsAndOptions,\n    stark: ()=>stark_exports,\n    starknetId: ()=>starknetId_exports,\n    transaction: ()=>transaction_exports,\n    typedData: ()=>typedData_exports,\n    types: ()=>types_exports,\n    uint256: ()=>uint256_exports,\n    validateAndParseAddress: ()=>validateAndParseAddress,\n    validateChecksumAddress: ()=>validateChecksumAddress\n});\nmodule.exports = __toCommonJS(src_exports);\n// src/constants.ts\nvar constants_exports = {};\n__export(constants_exports, {\n    API_VERSION: ()=>API_VERSION,\n    BN_FEE_TRANSACTION_VERSION_1: ()=>BN_FEE_TRANSACTION_VERSION_1,\n    BN_FEE_TRANSACTION_VERSION_2: ()=>BN_FEE_TRANSACTION_VERSION_2,\n    BN_TRANSACTION_VERSION_1: ()=>BN_TRANSACTION_VERSION_1,\n    BN_TRANSACTION_VERSION_2: ()=>BN_TRANSACTION_VERSION_2,\n    BaseUrl: ()=>BaseUrl,\n    HEX_STR_TRANSACTION_VERSION_1: ()=>HEX_STR_TRANSACTION_VERSION_1,\n    HEX_STR_TRANSACTION_VERSION_2: ()=>HEX_STR_TRANSACTION_VERSION_2,\n    IS_BROWSER: ()=>IS_BROWSER,\n    MASK_250: ()=>MASK_250,\n    MASK_251: ()=>MASK_251,\n    NetworkName: ()=>NetworkName,\n    RPC_GOERLI_NODES: ()=>RPC_GOERLI_NODES,\n    RPC_MAINNET_NODES: ()=>RPC_MAINNET_NODES,\n    StarknetChainId: ()=>StarknetChainId,\n    TEXT_TO_FELT_MAX_LEN: ()=>TEXT_TO_FELT_MAX_LEN,\n    TransactionHashPrefix: ()=>TransactionHashPrefix,\n    UDC: ()=>UDC,\n    ZERO: ()=>ZERO\n});\n// src/utils/encode.ts\nvar encode_exports = {};\n__export(encode_exports, {\n    IS_BROWSER: ()=>IS_BROWSER,\n    addHexPrefix: ()=>addHexPrefix,\n    arrayBufferToString: ()=>arrayBufferToString,\n    atobUniversal: ()=>atobUniversal,\n    btoaUniversal: ()=>btoaUniversal,\n    buf2hex: ()=>buf2hex,\n    calcByteLength: ()=>calcByteLength,\n    padLeft: ()=>padLeft,\n    pascalToSnake: ()=>pascalToSnake,\n    removeHexPrefix: ()=>removeHexPrefix,\n    sanitizeBytes: ()=>sanitizeBytes,\n    sanitizeHex: ()=>sanitizeHex,\n    stringToArrayBuffer: ()=>stringToArrayBuffer,\n    utf8ToArray: ()=>utf8ToArray\n});\nvar import_base = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/index.js\");\nvar IS_BROWSER = \"undefined\" !== \"undefined\";\nvar STRING_ZERO = \"0\";\nfunction arrayBufferToString(array) {\n    return new Uint8Array(array).reduce((data, byte)=>data + String.fromCharCode(byte), \"\");\n}\nfunction utf8ToArray(str) {\n    return new TextEncoder().encode(str);\n}\nfunction stringToArrayBuffer(str) {\n    return utf8ToArray(str);\n}\nfunction atobUniversal(a) {\n    return import_base.base64.decode(a);\n}\nfunction btoaUniversal(b) {\n    return import_base.base64.encode(new Uint8Array(b));\n}\nfunction buf2hex(buffer) {\n    return buffer.reduce((r, x)=>r + x.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction removeHexPrefix(hex) {\n    return hex.replace(/^0x/i, \"\");\n}\nfunction addHexPrefix(hex) {\n    return `0x${removeHexPrefix(hex)}`;\n}\nfunction padString(str, length, left, padding = STRING_ZERO) {\n    const diff = length - str.length;\n    let result = str;\n    if (diff > 0) {\n        const pad = padding.repeat(diff);\n        result = left ? pad + str : str + pad;\n    }\n    return result;\n}\nfunction padLeft(str, length, padding = STRING_ZERO) {\n    return padString(str, length, true, padding);\n}\nfunction calcByteLength(str, byteSize = 8) {\n    const { length } = str;\n    const remainder = length % byteSize;\n    return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;\n}\nfunction sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {\n    return padLeft(str, calcByteLength(str, byteSize), padding);\n}\nfunction sanitizeHex(hex) {\n    hex = removeHexPrefix(hex);\n    hex = sanitizeBytes(hex, 2);\n    if (hex) {\n        hex = addHexPrefix(hex);\n    }\n    return hex;\n}\nvar pascalToSnake = (text)=>/[a-z]/.test(text) ? text.split(/(?=[A-Z])/).join(\"_\").toUpperCase() : text;\n// src/constants.ts\nvar TEXT_TO_FELT_MAX_LEN = 31;\nvar HEX_STR_TRANSACTION_VERSION_1 = \"0x1\";\nvar HEX_STR_TRANSACTION_VERSION_2 = \"0x2\";\nvar BN_TRANSACTION_VERSION_1 = 1n;\nvar BN_TRANSACTION_VERSION_2 = 2n;\nvar BN_FEE_TRANSACTION_VERSION_1 = 2n ** 128n + BN_TRANSACTION_VERSION_1;\nvar BN_FEE_TRANSACTION_VERSION_2 = 2n ** 128n + BN_TRANSACTION_VERSION_2;\nvar ZERO = 0n;\nvar MASK_250 = 2n ** 250n - 1n;\nvar MASK_251 = 2n ** 251n;\nvar API_VERSION = ZERO;\nvar BaseUrl = /* @__PURE__ */ ((BaseUrl2)=>{\n    BaseUrl2[\"SN_MAIN\"] = \"https://alpha-mainnet.starknet.io\";\n    BaseUrl2[\"SN_GOERLI\"] = \"https://alpha4.starknet.io\";\n    return BaseUrl2;\n})(BaseUrl || {});\nvar NetworkName = /* @__PURE__ */ ((NetworkName2)=>{\n    NetworkName2[\"SN_MAIN\"] = \"SN_MAIN\";\n    NetworkName2[\"SN_GOERLI\"] = \"SN_GOERLI\";\n    return NetworkName2;\n})(NetworkName || {});\nvar StarknetChainId = /* @__PURE__ */ ((StarknetChainId4)=>{\n    StarknetChainId4[\"SN_MAIN\"] = \"0x534e5f4d41494e\";\n    StarknetChainId4[\"SN_GOERLI\"] = \"0x534e5f474f45524c49\";\n    return StarknetChainId4;\n})(StarknetChainId || {});\nvar TransactionHashPrefix = /* @__PURE__ */ ((TransactionHashPrefix2)=>{\n    TransactionHashPrefix2[\"DECLARE\"] = \"0x6465636c617265\";\n    TransactionHashPrefix2[\"DEPLOY\"] = \"0x6465706c6f79\";\n    TransactionHashPrefix2[\"DEPLOY_ACCOUNT\"] = \"0x6465706c6f795f6163636f756e74\";\n    TransactionHashPrefix2[\"INVOKE\"] = \"0x696e766f6b65\";\n    TransactionHashPrefix2[\"L1_HANDLER\"] = \"0x6c315f68616e646c6572\";\n    return TransactionHashPrefix2;\n})(TransactionHashPrefix || {});\nvar UDC = {\n    ADDRESS: \"0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf\",\n    ENTRYPOINT: \"deployContract\"\n};\nvar RPC_GOERLI_NODES = [\n    \"https://starknet-testnet.public.blastapi.io/rpc/v0.5\",\n    \"https://limited-rpc.nethermind.io/goerli-juno/v0_5\"\n];\nvar RPC_MAINNET_NODES = [\n    \"https://starknet-mainnet.public.blastapi.io/rpc/v0.5\",\n    \"https://limited-rpc.nethermind.io/mainnet-juno/v0_5\"\n];\n// src/types/index.ts\nvar types_exports = {};\n__export(types_exports, {\n    BlockStatus: ()=>BlockStatus,\n    BlockTag: ()=>BlockTag,\n    EntryPointType: ()=>EntryPointType,\n    Litteral: ()=>Litteral,\n    RPC: ()=>rpc_exports,\n    SIMULATION_FLAG: ()=>SIMULATION_FLAG,\n    Sequencer: ()=>sequencer_exports,\n    TransactionExecutionStatus: ()=>TransactionExecutionStatus,\n    TransactionFinalityStatus: ()=>TransactionFinalityStatus,\n    TransactionStatus: ()=>TransactionStatus,\n    TransactionType: ()=>TransactionType,\n    Uint: ()=>Uint,\n    ValidateType: ()=>ValidateType\n});\n// src/types/account.ts\nvar SIMULATION_FLAG = /* @__PURE__ */ ((SIMULATION_FLAG2)=>{\n    SIMULATION_FLAG2[\"SKIP_VALIDATE\"] = \"SKIP_VALIDATE\";\n    SIMULATION_FLAG2[\"SKIP_EXECUTE\"] = \"SKIP_EXECUTE\";\n    return SIMULATION_FLAG2;\n})(SIMULATION_FLAG || {});\n// src/types/calldata.ts\nvar ValidateType = /* @__PURE__ */ ((ValidateType2)=>{\n    ValidateType2[\"DEPLOY\"] = \"DEPLOY\";\n    ValidateType2[\"CALL\"] = \"CALL\";\n    ValidateType2[\"INVOKE\"] = \"INVOKE\";\n    return ValidateType2;\n})(ValidateType || {});\nvar Uint = /* @__PURE__ */ ((Uint2)=>{\n    Uint2[\"u8\"] = \"core::integer::u8\";\n    Uint2[\"u16\"] = \"core::integer::u16\";\n    Uint2[\"u32\"] = \"core::integer::u32\";\n    Uint2[\"u64\"] = \"core::integer::u64\";\n    Uint2[\"u128\"] = \"core::integer::u128\";\n    Uint2[\"u256\"] = \"core::integer::u256\";\n    return Uint2;\n})(Uint || {});\nvar Litteral = /* @__PURE__ */ ((Litteral2)=>{\n    Litteral2[\"ClassHash\"] = \"core::starknet::class_hash::ClassHash\";\n    Litteral2[\"ContractAddress\"] = \"core::starknet::contract_address::ContractAddress\";\n    return Litteral2;\n})(Litteral || {});\n// src/types/lib/contract/index.ts\nvar EntryPointType = /* @__PURE__ */ ((EntryPointType2)=>{\n    EntryPointType2[\"EXTERNAL\"] = \"EXTERNAL\";\n    EntryPointType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n    EntryPointType2[\"CONSTRUCTOR\"] = \"CONSTRUCTOR\";\n    return EntryPointType2;\n})(EntryPointType || {});\n// src/types/lib/index.ts\nvar TransactionType = /* @__PURE__ */ ((TransactionType2)=>{\n    TransactionType2[\"DECLARE\"] = \"DECLARE\";\n    TransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n    TransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n    TransactionType2[\"INVOKE\"] = \"INVOKE_FUNCTION\";\n    return TransactionType2;\n})(TransactionType || {});\nvar TransactionStatus = /* @__PURE__ */ ((TransactionStatus2)=>{\n    TransactionStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n    TransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n    TransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    TransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    TransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n    TransactionStatus2[\"REVERTED\"] = \"REVERTED\";\n    return TransactionStatus2;\n})(TransactionStatus || {});\nvar TransactionFinalityStatus = /* @__PURE__ */ ((TransactionFinalityStatus2)=>{\n    TransactionFinalityStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n    TransactionFinalityStatus2[\"RECEIVED\"] = \"RECEIVED\";\n    TransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    TransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    return TransactionFinalityStatus2;\n})(TransactionFinalityStatus || {});\nvar TransactionExecutionStatus = /* @__PURE__ */ ((TransactionExecutionStatus2)=>{\n    TransactionExecutionStatus2[\"REJECTED\"] = \"REJECTED\";\n    TransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n    TransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n    return TransactionExecutionStatus2;\n})(TransactionExecutionStatus || {});\nvar BlockStatus = /* @__PURE__ */ ((BlockStatus2)=>{\n    BlockStatus2[\"PENDING\"] = \"PENDING\";\n    BlockStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    BlockStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    BlockStatus2[\"REJECTED\"] = \"REJECTED\";\n    return BlockStatus2;\n})(BlockStatus || {});\nvar BlockTag = /* @__PURE__ */ ((BlockTag2)=>{\n    BlockTag2[\"pending\"] = \"pending\";\n    BlockTag2[\"latest\"] = \"latest\";\n    return BlockTag2;\n})(BlockTag || {});\n// src/types/api/rpc.ts\nvar rpc_exports = {};\n__export(rpc_exports, {\n    EBlockTag: ()=>EBlockTag,\n    EDataAvailabilityMode: ()=>EDataAvailabilityMode,\n    ESimulationFlag: ()=>ESimulationFlag,\n    ETransactionExecutionStatus: ()=>ETransactionExecutionStatus,\n    ETransactionFinalityStatus: ()=>ETransactionFinalityStatus,\n    ETransactionStatus: ()=>ETransactionStatus,\n    ETransactionType: ()=>ETransactionType,\n    Errors: ()=>errors_exports,\n    JRPC: ()=>jsonrpc_exports,\n    SPEC: ()=>components_exports\n});\n// src/types/api/jsonrpc/index.ts\nvar jsonrpc_exports = {};\n// src/types/api/rpcspec/errors.ts\nvar errors_exports = {};\n// src/types/api/rpcspec/components.ts\nvar components_exports = {};\n// src/types/api/rpcspec/nonspec.ts\nvar ETransactionType = /* @__PURE__ */ ((ETransactionType2)=>{\n    ETransactionType2[\"DECLARE\"] = \"DECLARE\";\n    ETransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n    ETransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n    ETransactionType2[\"INVOKE\"] = \"INVOKE\";\n    ETransactionType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n    return ETransactionType2;\n})(ETransactionType || {});\nvar ESimulationFlag = /* @__PURE__ */ ((ESimulationFlag2)=>{\n    ESimulationFlag2[\"SKIP_VALIDATE\"] = \"SKIP_VALIDATE\";\n    ESimulationFlag2[\"SKIP_FEE_CHARGE\"] = \"SKIP_FEE_CHARGE\";\n    return ESimulationFlag2;\n})(ESimulationFlag || {});\nvar ETransactionStatus = /* @__PURE__ */ ((ETransactionStatus2)=>{\n    ETransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n    ETransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n    ETransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    ETransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    return ETransactionStatus2;\n})(ETransactionStatus || {});\nvar ETransactionFinalityStatus = /* @__PURE__ */ ((ETransactionFinalityStatus2)=>{\n    ETransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    ETransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    return ETransactionFinalityStatus2;\n})(ETransactionFinalityStatus || {});\nvar ETransactionExecutionStatus = /* @__PURE__ */ ((ETransactionExecutionStatus2)=>{\n    ETransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n    ETransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n    return ETransactionExecutionStatus2;\n})(ETransactionExecutionStatus || {});\nvar EBlockTag = /* @__PURE__ */ ((EBlockTag2)=>{\n    EBlockTag2[\"LATEST\"] = \"latest\";\n    EBlockTag2[\"PENDING\"] = \"pending\";\n    return EBlockTag2;\n})(EBlockTag || {});\nvar EDataAvailabilityMode = /* @__PURE__ */ ((EDataAvailabilityMode2)=>{\n    EDataAvailabilityMode2[\"L1\"] = \"L1\";\n    EDataAvailabilityMode2[\"L2\"] = \"L2\";\n    return EDataAvailabilityMode2;\n})(EDataAvailabilityMode || {});\n// src/types/api/sequencer.ts\nvar sequencer_exports = {};\n// src/utils/assert.ts\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failure\");\n    }\n}\n// src/utils/num.ts\nvar num_exports = {};\n__export(num_exports, {\n    assertInRange: ()=>assertInRange,\n    bigNumberishArrayToDecimalStringArray: ()=>bigNumberishArrayToDecimalStringArray,\n    bigNumberishArrayToHexadecimalStringArray: ()=>bigNumberishArrayToHexadecimalStringArray,\n    cleanHex: ()=>cleanHex,\n    getDecimalString: ()=>getDecimalString,\n    getHexString: ()=>getHexString,\n    getHexStringArray: ()=>getHexStringArray,\n    hexToBytes: ()=>hexToBytes,\n    hexToDecimalString: ()=>hexToDecimalString,\n    isBigInt: ()=>isBigInt,\n    isHex: ()=>isHex,\n    isStringWholeNumber: ()=>isStringWholeNumber,\n    toBigInt: ()=>toBigInt,\n    toCairoBool: ()=>toCairoBool,\n    toHex: ()=>toHex,\n    toHexString: ()=>toHexString,\n    toStorageKey: ()=>toStorageKey\n});\nvar import_utils = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/abstract/utils.js\");\nfunction isHex(hex) {\n    return /^0x[0-9a-f]*$/i.test(hex);\n}\nfunction toBigInt(value) {\n    return BigInt(value);\n}\nfunction isBigInt(value) {\n    return typeof value === \"bigint\";\n}\nfunction toHex(number2) {\n    return addHexPrefix(toBigInt(number2).toString(16));\n}\nvar toHexString = toHex;\nfunction toStorageKey(number2) {\n    const res = addHexPrefix(toBigInt(number2).toString(16).padStart(64, \"0\"));\n    return res;\n}\nfunction hexToDecimalString(hex) {\n    return BigInt(addHexPrefix(hex)).toString(10);\n}\nvar cleanHex = (hex)=>hex.toLowerCase().replace(/^(0x)0+/, \"$1\");\nfunction assertInRange(input, lowerBound, upperBound, inputName = \"\") {\n    const messageSuffix = inputName === \"\" ? \"invalid length\" : `invalid ${inputName} length`;\n    const inputBigInt = BigInt(input);\n    const lowerBoundBigInt = BigInt(lowerBound);\n    const upperBoundBigInt = BigInt(upperBound);\n    assert(inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt, `Message not signable, ${messageSuffix}.`);\n}\nfunction bigNumberishArrayToDecimalStringArray(rawCalldata) {\n    return rawCalldata.map((x)=>toBigInt(x).toString(10));\n}\nfunction bigNumberishArrayToHexadecimalStringArray(rawCalldata) {\n    return rawCalldata.map((x)=>toHex(x));\n}\nvar isStringWholeNumber = (value)=>/^\\d+$/.test(value);\nfunction getDecimalString(value) {\n    if (isHex(value)) {\n        return hexToDecimalString(value);\n    }\n    if (isStringWholeNumber(value)) {\n        return value;\n    }\n    throw new Error(`${value} need to be hex-string or whole-number-string`);\n}\nfunction getHexString(value) {\n    if (isHex(value)) {\n        return value;\n    }\n    if (isStringWholeNumber(value)) {\n        return toHexString(value);\n    }\n    throw new Error(`${value} need to be hex-string or whole-number-string`);\n}\nfunction getHexStringArray(value) {\n    return value.map((el)=>getHexString(el));\n}\nvar toCairoBool = (value)=>(+value).toString();\nfunction hexToBytes(value) {\n    if (!isHex(value)) throw new Error(`${value} need to be a hex-string`);\n    let adaptedValue = removeHexPrefix(value);\n    if (adaptedValue.length % 2 !== 0) {\n        adaptedValue = `0${adaptedValue}`;\n    }\n    return (0, import_utils.hexToBytes)(adaptedValue);\n}\n// src/utils/selector.ts\nvar selector_exports = {};\n__export(selector_exports, {\n    getSelector: ()=>getSelector,\n    getSelectorFromName: ()=>getSelectorFromName,\n    keccakBn: ()=>keccakBn,\n    starknetKeccak: ()=>starknetKeccak\n});\nvar import_starknet = __webpack_require__(/*! @scure/starknet */ \"(ssr)/./node_modules/@scure/starknet/lib/index.js\");\nfunction keccakBn(value) {\n    const hexWithoutPrefix = removeHexPrefix(toHex(BigInt(value)));\n    const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;\n    return addHexPrefix((0, import_starknet.keccak)(hexToBytes(addHexPrefix(evenHex))).toString(16));\n}\nfunction keccakHex(str) {\n    return addHexPrefix((0, import_starknet.keccak)(utf8ToArray(str)).toString(16));\n}\nfunction starknetKeccak(str) {\n    const hash1 = BigInt(keccakHex(str));\n    return hash1 & MASK_250;\n}\nfunction getSelectorFromName(funcName) {\n    return toHex(starknetKeccak(funcName));\n}\nfunction getSelector(value) {\n    if (isHex(value)) {\n        return value;\n    }\n    if (isStringWholeNumber(value)) {\n        return toHexString(value);\n    }\n    return getSelectorFromName(value);\n}\n// src/utils/shortString.ts\nvar shortString_exports = {};\n__export(shortString_exports, {\n    decodeShortString: ()=>decodeShortString,\n    encodeShortString: ()=>encodeShortString,\n    isASCII: ()=>isASCII,\n    isDecimalString: ()=>isDecimalString,\n    isLongText: ()=>isLongText,\n    isShortString: ()=>isShortString,\n    isShortText: ()=>isShortText,\n    isText: ()=>isText,\n    splitLongString: ()=>splitLongString\n});\nfunction isASCII(str) {\n    return /^[\\x00-\\x7F]*$/.test(str);\n}\nfunction isShortString(str) {\n    return str.length <= TEXT_TO_FELT_MAX_LEN;\n}\nfunction isDecimalString(str) {\n    return /^[0-9]*$/i.test(str);\n}\nfunction isText(val) {\n    return typeof val === \"string\" && !isHex(val) && !isStringWholeNumber(val);\n}\nvar isShortText = (val)=>isText(val) && isShortString(val);\nvar isLongText = (val)=>isText(val) && !isShortString(val);\nfunction splitLongString(longStr) {\n    const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, \"g\");\n    return longStr.match(regex) || [];\n}\nfunction encodeShortString(str) {\n    if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n    if (!isShortString(str)) throw new Error(`${str} is too long`);\n    return addHexPrefix(str.replace(/./g, (char)=>char.charCodeAt(0).toString(16)));\n}\nfunction decodeShortString(str) {\n    if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n    if (isHex(str)) {\n        return removeHexPrefix(str).replace(/.{2}/g, (hex)=>String.fromCharCode(parseInt(hex, 16)));\n    }\n    if (isDecimalString(str)) {\n        return decodeShortString(\"0X\".concat(BigInt(str).toString(16)));\n    }\n    throw new Error(`${str} is not Hex or decimal`);\n}\n// src/utils/calldata/cairo.ts\nvar cairo_exports = {};\n__export(cairo_exports, {\n    felt: ()=>felt,\n    getAbiContractVersion: ()=>getAbiContractVersion,\n    getArrayType: ()=>getArrayType,\n    isCairo1Abi: ()=>isCairo1Abi,\n    isCairo1Type: ()=>isCairo1Type,\n    isLen: ()=>isLen,\n    isTypeArray: ()=>isTypeArray,\n    isTypeBool: ()=>isTypeBool,\n    isTypeContractAddress: ()=>isTypeContractAddress,\n    isTypeEnum: ()=>isTypeEnum,\n    isTypeEthAddress: ()=>isTypeEthAddress,\n    isTypeFelt: ()=>isTypeFelt,\n    isTypeLitteral: ()=>isTypeLitteral,\n    isTypeNamedTuple: ()=>isTypeNamedTuple,\n    isTypeOption: ()=>isTypeOption,\n    isTypeResult: ()=>isTypeResult,\n    isTypeStruct: ()=>isTypeStruct,\n    isTypeTuple: ()=>isTypeTuple,\n    isTypeUint: ()=>isTypeUint,\n    isTypeUint256: ()=>isTypeUint256,\n    tuple: ()=>tuple,\n    uint256: ()=>uint256\n});\n// src/utils/uint256.ts\nvar uint256_exports = {};\n__export(uint256_exports, {\n    UINT_128_MAX: ()=>UINT_128_MAX,\n    UINT_256_MAX: ()=>UINT_256_MAX,\n    bnToUint256: ()=>bnToUint256,\n    isUint256: ()=>isUint256,\n    uint256ToBN: ()=>uint256ToBN\n});\nvar UINT_128_MAX = (1n << 128n) - 1n;\nvar UINT_256_MAX = (1n << 256n) - 1n;\nfunction uint256ToBN(uint2562) {\n    return (toBigInt(uint2562.high) << 128n) + toBigInt(uint2562.low);\n}\nfunction isUint256(bn) {\n    return toBigInt(bn) <= UINT_256_MAX;\n}\nfunction bnToUint256(bn) {\n    const bi = toBigInt(bn);\n    if (!isUint256(bi)) throw new Error(\"Number is too large\");\n    return {\n        low: addHexPrefix((bi & UINT_128_MAX).toString(16)),\n        high: addHexPrefix((bi >> 128n).toString(16))\n    };\n}\n// src/utils/calldata/cairo.ts\nvar isLen = (name)=>/_len$/.test(name);\nvar isTypeFelt = (type)=>type === \"felt\" || type === \"core::felt252\";\nvar isTypeArray = (type)=>/\\*/.test(type) || type.startsWith(\"core::array::Array::\") || type.startsWith(\"core::array::Span::\");\nvar isTypeTuple = (type)=>/^\\(.*\\)$/i.test(type);\nvar isTypeNamedTuple = (type)=>/\\(.*\\)/i.test(type) && type.includes(\":\");\nvar isTypeStruct = (type, structs)=>type in structs;\nvar isTypeEnum = (type, enums)=>type in enums;\nvar isTypeOption = (type)=>type.startsWith(\"core::option::Option::\");\nvar isTypeResult = (type)=>type.startsWith(\"core::result::Result::\");\nvar isTypeUint = (type)=>Object.values(Uint).includes(type);\nvar isTypeLitteral = (type)=>Object.values(Litteral).includes(type);\nvar isTypeUint256 = (type)=>type === \"core::integer::u256\";\nvar isTypeBool = (type)=>type === \"core::bool\";\nvar isTypeContractAddress = (type)=>type === \"core::starknet::contract_address::ContractAddress\";\nvar isTypeEthAddress = (type)=>type === \"core::starknet::eth_address::EthAddress\";\nvar isCairo1Type = (type)=>type.includes(\"::\");\nvar getArrayType = (type)=>{\n    if (isCairo1Type(type)) {\n        return type.substring(type.indexOf(\"<\") + 1, type.lastIndexOf(\">\"));\n    }\n    return type.replace(\"*\", \"\");\n};\nfunction isCairo1Abi(abi) {\n    const { cairo: cairo1 } = getAbiContractVersion(abi);\n    if (cairo1 === void 0) {\n        throw Error(\"Unable to determine Cairo version\");\n    }\n    return cairo1 === \"1\";\n}\nfunction getAbiContractVersion(abi) {\n    if (abi.find((it)=>it.type === \"interface\")) {\n        return {\n            cairo: \"1\",\n            compiler: \"2\"\n        };\n    }\n    const testFunction = abi.find((it)=>it.type === \"function\" && (it.inputs.length || it.outputs.length));\n    if (!testFunction) {\n        return {\n            cairo: void 0,\n            compiler: void 0\n        };\n    }\n    const io = testFunction.inputs.length ? testFunction.inputs : testFunction.outputs;\n    if (isCairo1Type(io[0].type)) {\n        return {\n            cairo: \"1\",\n            compiler: \"1\"\n        };\n    }\n    return {\n        cairo: \"0\",\n        compiler: \"0\"\n    };\n}\nvar uint256 = (it)=>{\n    const bn = BigInt(it);\n    if (!isUint256(bn)) throw new Error(\"Number is too large\");\n    return {\n        // eslint-disable-next-line no-bitwise\n        low: (bn & UINT_128_MAX).toString(10),\n        // eslint-disable-next-line no-bitwise\n        high: (bn >> 128n).toString(10)\n    };\n};\nvar tuple = (...args)=>({\n        ...args\n    });\nfunction felt(it) {\n    if (isBigInt(it) || typeof it === \"number\" && Number.isInteger(it)) {\n        return it.toString();\n    }\n    if (isText(it)) {\n        if (!isShortString(it)) throw new Error(`${it} is a long string > 31 chars, felt can store short strings, split it to array of short strings`);\n        const encoded = encodeShortString(it);\n        return BigInt(encoded).toString();\n    }\n    if (typeof it === \"string\" && isHex(it)) {\n        return BigInt(it).toString();\n    }\n    if (typeof it === \"string\" && isStringWholeNumber(it)) {\n        return it;\n    }\n    if (typeof it === \"boolean\") {\n        return `${+it}`;\n    }\n    throw new Error(`${it} can't be computed by felt()`);\n}\n// src/utils/calldata/enum/CairoCustomEnum.ts\nvar CairoCustomEnum = class {\n    /**\n   * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.\n   */ constructor(enumContent){\n        const variantsList = Object.values(enumContent);\n        if (variantsList.length === 0) {\n            throw new Error(\"This Enum must have a least 1 variant\");\n        }\n        const nbActiveVariants = variantsList.filter((content)=>typeof content !== \"undefined\").length;\n        if (nbActiveVariants !== 1) {\n            throw new Error(\"This Enum must have exactly one active variant\");\n        }\n        this.variant = enumContent;\n    }\n    /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   */ unwrap() {\n        const variants = Object.entries(this.variant);\n        const activeVariant = variants.find((item)=>typeof item[1] !== \"undefined\");\n        if (typeof activeVariant === \"undefined\") {\n            return void 0;\n        }\n        return activeVariant[1];\n    }\n    /**\n   *\n   * @returns the name of the valid variant of a Cairo custom Enum.\n   */ activeVariant() {\n        const variants = Object.entries(this.variant);\n        const activeVariant = variants.find((item)=>typeof item[1] !== \"undefined\");\n        if (typeof activeVariant === \"undefined\") {\n            return \"\";\n        }\n        return activeVariant[0];\n    }\n};\n// src/utils/calldata/enum/CairoOption.ts\nvar CairoOptionVariant = /* @__PURE__ */ ((CairoOptionVariant2)=>{\n    CairoOptionVariant2[CairoOptionVariant2[\"Some\"] = 0] = \"Some\";\n    CairoOptionVariant2[CairoOptionVariant2[\"None\"] = 1] = \"None\";\n    return CairoOptionVariant2;\n})(CairoOptionVariant || {});\nvar CairoOption = class {\n    constructor(variant, someContent){\n        if (!(variant in CairoOptionVariant)) {\n            throw new Error(\"Wrong variant : should be CairoOptionVariant.Some or .None.\");\n        }\n        if (variant === 0 /* Some */ ) {\n            if (typeof someContent === \"undefined\") {\n                throw new Error('The creation of a Cairo Option with \"Some\" variant needs a content as input.');\n            }\n            this.Some = someContent;\n            this.None = void 0;\n        } else {\n            this.Some = void 0;\n            this.None = true;\n        }\n    }\n    /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   *  If None, returns 'undefined'.\n   */ unwrap() {\n        if (this.None) {\n            return void 0;\n        }\n        return this.Some;\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'isSome'.\n   */ isSome() {\n        return !(typeof this.Some === \"undefined\");\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'isNone'.\n   */ isNone() {\n        return this.None === true;\n    }\n};\n// src/utils/calldata/enum/CairoResult.ts\nvar CairoResultVariant = /* @__PURE__ */ ((CairoResultVariant2)=>{\n    CairoResultVariant2[CairoResultVariant2[\"Ok\"] = 0] = \"Ok\";\n    CairoResultVariant2[CairoResultVariant2[\"Err\"] = 1] = \"Err\";\n    return CairoResultVariant2;\n})(CairoResultVariant || {});\nvar CairoResult = class {\n    constructor(variant, resultContent){\n        if (!(variant in CairoResultVariant)) {\n            throw new Error(\"Wrong variant : should be CairoResultVariant.Ok or .Err.\");\n        }\n        if (variant === 0 /* Ok */ ) {\n            this.Ok = resultContent;\n            this.Err = void 0;\n        } else {\n            this.Ok = void 0;\n            this.Err = resultContent;\n        }\n    }\n    /**\n   *\n   * @returns the content of the valid variant of a Cairo Result.\n   */ unwrap() {\n        if (typeof this.Ok !== \"undefined\") {\n            return this.Ok;\n        }\n        if (typeof this.Err !== \"undefined\") {\n            return this.Err;\n        }\n        throw new Error(\"Both Result.Ok and .Err are undefined. Not authorized.\");\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'Ok'.\n   */ isOk() {\n        return !(typeof this.Ok === \"undefined\");\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'isErr'.\n   */ isErr() {\n        return !(typeof this.Err === \"undefined\");\n    }\n};\n// src/utils/calldata/formatter.ts\nvar guard = {\n    isBN: (data, type, key)=>{\n        if (!isBigInt(data[key])) throw new Error(`Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${data[key]} to be BN instead it is ${typeof data[key]}`);\n    },\n    unknown: (data, type, key)=>{\n        throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);\n    }\n};\nfunction formatter(data, type, sameType) {\n    return Object.entries(data).reduce((acc, [key, value])=>{\n        const elType = sameType ?? type[key];\n        if (!(key in type) && !sameType) {\n            acc[key] = value;\n            return acc;\n        }\n        if (elType === \"string\") {\n            if (Array.isArray(data[key])) {\n                const arrayStr = formatter(data[key], data[key].map((_)=>elType));\n                acc[key] = Object.values(arrayStr).join(\"\");\n                return acc;\n            }\n            guard.isBN(data, type, key);\n            acc[key] = decodeShortString(value);\n            return acc;\n        }\n        if (elType === \"number\") {\n            guard.isBN(data, type, key);\n            acc[key] = Number(value);\n            return acc;\n        }\n        if (typeof elType === \"function\") {\n            acc[key] = elType(value);\n            return acc;\n        }\n        if (Array.isArray(elType)) {\n            const arrayObj = formatter(data[key], elType, elType[0]);\n            acc[key] = Object.values(arrayObj);\n            return acc;\n        }\n        if (typeof elType === \"object\") {\n            acc[key] = formatter(data[key], elType);\n            return acc;\n        }\n        guard.unknown(data, type, key);\n        return acc;\n    }, {});\n}\n// src/utils/calldata/parser/parser-0-1.1.0.ts\nvar AbiParser1 = class {\n    constructor(abi){\n        this.abi = abi;\n    }\n    /**\n   * abi method inputs length without '_len' inputs\n   * cairo 0 reducer\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */ methodInputsLength(abiMethod) {\n        return abiMethod.inputs.reduce((acc, input)=>!isLen(input.name) ? acc + 1 : acc, 0);\n    }\n    /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */ getMethod(name) {\n        return this.abi.find((it)=>it.name === name);\n    }\n    /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */ getLegacyFormat() {\n        return this.abi;\n    }\n};\n// src/utils/calldata/parser/parser-2.0.0.ts\nvar AbiParser2 = class {\n    constructor(abi){\n        this.abi = abi;\n    }\n    /**\n   * abi method inputs length\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */ methodInputsLength(abiMethod) {\n        return abiMethod.inputs.length;\n    }\n    /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */ getMethod(name) {\n        const intf = this.abi.find((it)=>it.type === \"interface\");\n        return intf.items.find((it)=>it.name === name);\n    }\n    /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */ getLegacyFormat() {\n        return this.abi.flatMap((e)=>{\n            if (e.type === \"interface\") {\n                return e.items;\n            }\n            return e;\n        });\n    }\n};\n// src/utils/calldata/parser/index.ts\nfunction createAbiParser(abi) {\n    const version = getAbiVersion(abi);\n    if (version === 0 || version === 1) {\n        return new AbiParser1(abi);\n    }\n    if (version === 2) {\n        return new AbiParser2(abi);\n    }\n    throw Error(`Unsupported ABI version ${version}`);\n}\nfunction getAbiVersion(abi) {\n    if (abi.find((it)=>it.type === \"interface\")) return 2;\n    if (isCairo1Abi(abi)) return 1;\n    return 0;\n}\nfunction isNoConstructorValid(method, argsCalldata, abiMethod) {\n    return method === \"constructor\" && !abiMethod && !argsCalldata.length;\n}\n// src/utils/calldata/tuple.ts\nfunction parseNamedTuple(namedTuple) {\n    const name = namedTuple.substring(0, namedTuple.indexOf(\":\"));\n    const type = namedTuple.substring(name.length + \":\".length);\n    return {\n        name,\n        type\n    };\n}\nfunction parseSubTuple(s) {\n    if (!s.includes(\"(\")) return {\n        subTuple: [],\n        result: s\n    };\n    const subTuple = [];\n    let result = \"\";\n    let i = 0;\n    while(i < s.length){\n        if (s[i] === \"(\") {\n            let counter = 1;\n            const lBracket = i;\n            i++;\n            while(counter){\n                if (s[i] === \")\") counter--;\n                if (s[i] === \"(\") counter++;\n                i++;\n            }\n            subTuple.push(s.substring(lBracket, i));\n            result += \" \";\n            i--;\n        } else {\n            result += s[i];\n        }\n        i++;\n    }\n    return {\n        subTuple,\n        result\n    };\n}\nfunction extractCairo0Tuple(type) {\n    const cleanType = type.replace(/\\s/g, \"\").slice(1, -1);\n    const { subTuple, result } = parseSubTuple(cleanType);\n    let recomposed = result.split(\",\").map((it)=>{\n        return subTuple.length ? it.replace(\" \", subTuple.shift()) : it;\n    });\n    if (isTypeNamedTuple(type)) {\n        recomposed = recomposed.reduce((acc, it)=>{\n            return acc.concat(parseNamedTuple(it));\n        }, []);\n    }\n    return recomposed;\n}\nfunction extractCairo1Tuple(type) {\n    const cleanType = type.replace(/\\s/g, \"\").slice(1, -1);\n    const { subTuple, result } = parseSubTuple(cleanType);\n    const recomposed = result.split(\",\").map((it)=>{\n        return subTuple.length ? it.replace(\" \", subTuple.shift()) : it;\n    });\n    return recomposed;\n}\nfunction extractTupleMemberTypes(type) {\n    if (isCairo1Type(type)) {\n        return extractCairo1Tuple(type);\n    }\n    return extractCairo0Tuple(type);\n}\n// src/utils/calldata/propertyOrder.ts\nfunction errorU256(key) {\n    return Error(`Your object includes the property : ${key}, containing an Uint256 object without the 'low' and 'high' keys.`);\n}\nfunction orderPropsByAbi(unorderedObject, abiOfObject, structs, enums) {\n    const orderInput = (unorderedItem, abiType)=>{\n        if (isTypeArray(abiType)) {\n            return orderArray(unorderedItem, abiType);\n        }\n        if (isTypeEnum(abiType, enums)) {\n            const abiObj = enums[abiType];\n            return orderEnum(unorderedItem, abiObj);\n        }\n        if (isTypeTuple(abiType)) {\n            return orderTuple(unorderedItem, abiType);\n        }\n        if (isTypeEthAddress(abiType)) {\n            return unorderedItem;\n        }\n        if (isTypeUint256(abiType)) {\n            const u256 = unorderedItem;\n            if (typeof u256 !== \"object\") {\n                return u256;\n            }\n            if (!(\"low\" in u256 && \"high\" in u256)) {\n                throw errorU256(abiType);\n            }\n            return {\n                low: u256.low,\n                high: u256.high\n            };\n        }\n        if (isTypeStruct(abiType, structs)) {\n            const abiOfStruct = structs[abiType].members;\n            return orderStruct(unorderedItem, abiOfStruct);\n        }\n        return unorderedItem;\n    };\n    const orderStruct = (unorderedObject2, abiObject)=>{\n        const orderedObject2 = abiObject.reduce((orderedObject, abiParam)=>{\n            const setProperty = (value)=>Object.defineProperty(orderedObject, abiParam.name, {\n                    enumerable: true,\n                    value: value ?? unorderedObject2[abiParam.name]\n                });\n            if (unorderedObject2[abiParam.name] === \"undefined\") {\n                if (isCairo1Type(abiParam.type) || !isLen(abiParam.name)) {\n                    throw Error(`Your object needs a property with key : ${abiParam.name} .`);\n                }\n            }\n            setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));\n            return orderedObject;\n        }, {});\n        return orderedObject2;\n    };\n    function orderArray(myArray, abiParam) {\n        const typeInArray = getArrayType(abiParam);\n        if (typeof myArray === \"string\") {\n            return myArray;\n        }\n        return myArray.map((myElem)=>orderInput(myElem, typeInArray));\n    }\n    function orderTuple(unorderedObject2, abiParam) {\n        const typeList = extractTupleMemberTypes(abiParam);\n        const orderedObject2 = typeList.reduce((orderedObject, abiTypeCairoX, index)=>{\n            const myObjKeys = Object.keys(unorderedObject2);\n            const setProperty = (value)=>Object.defineProperty(orderedObject, index.toString(), {\n                    enumerable: true,\n                    value: value ?? unorderedObject2[myObjKeys[index]]\n                });\n            const abiType = abiTypeCairoX?.type ? abiTypeCairoX.type : abiTypeCairoX;\n            setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType));\n            return orderedObject;\n        }, {});\n        return orderedObject2;\n    }\n    const orderEnum = (unorderedObject2, abiObject)=>{\n        if (isTypeResult(abiObject.name)) {\n            const unorderedResult = unorderedObject2;\n            const resultOkType = abiObject.name.substring(abiObject.name.indexOf(\"<\") + 1, abiObject.name.lastIndexOf(\",\"));\n            const resultErrType = abiObject.name.substring(abiObject.name.indexOf(\",\") + 1, abiObject.name.lastIndexOf(\">\"));\n            if (unorderedResult.isOk()) {\n                return new CairoResult(0 /* Ok */ , orderInput(unorderedObject2.unwrap(), resultOkType));\n            }\n            return new CairoResult(1 /* Err */ , orderInput(unorderedObject2.unwrap(), resultErrType));\n        }\n        if (isTypeOption(abiObject.name)) {\n            const unorderedOption = unorderedObject2;\n            const resultSomeType = abiObject.name.substring(abiObject.name.indexOf(\"<\") + 1, abiObject.name.lastIndexOf(\">\"));\n            if (unorderedOption.isSome()) {\n                return new CairoOption(0 /* Some */ , orderInput(unorderedOption.unwrap(), resultSomeType));\n            }\n            return new CairoOption(1 /* None */ , {});\n        }\n        const unorderedCustomEnum = unorderedObject2;\n        const variants = Object.entries(unorderedCustomEnum.variant);\n        const newEntries = variants.map((variant)=>{\n            if (typeof variant[1] === \"undefined\") {\n                return variant;\n            }\n            const variantType = abiObject.type.substring(abiObject.type.lastIndexOf(\"<\") + 1, abiObject.type.lastIndexOf(\">\"));\n            if (variantType === \"()\") {\n                return variant;\n            }\n            return [\n                variant[0],\n                orderInput(unorderedCustomEnum.unwrap(), variantType)\n            ];\n        });\n        return new CairoCustomEnum(Object.fromEntries(newEntries));\n    };\n    const finalOrderedObject = abiOfObject.reduce((orderedObject, abiParam)=>{\n        const setProperty = (value)=>Object.defineProperty(orderedObject, abiParam.name, {\n                enumerable: true,\n                value\n            });\n        if (isLen(abiParam.name) && !isCairo1Type(abiParam.type)) {\n            return orderedObject;\n        }\n        setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));\n        return orderedObject;\n    }, {});\n    return finalOrderedObject;\n}\n// src/utils/calldata/requestParser.ts\nfunction parseBaseTypes(type, val) {\n    switch(true){\n        case isTypeUint256(type):\n            const el_uint256 = uint256(val);\n            return [\n                felt(el_uint256.low),\n                felt(el_uint256.high)\n            ];\n        default:\n            return felt(val);\n    }\n}\nfunction parseTuple(element, typeStr) {\n    const memberTypes = extractTupleMemberTypes(typeStr);\n    const elements = Object.values(element);\n    if (elements.length !== memberTypes.length) {\n        throw Error(`ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${elements} \n      expected: ${memberTypes}`);\n    }\n    return memberTypes.map((it, dx)=>{\n        return {\n            element: elements[dx],\n            type: it.type ?? it\n        };\n    });\n}\nfunction parseUint256(element) {\n    if (typeof element === \"object\") {\n        const { low, high } = element;\n        return [\n            felt(low),\n            felt(high)\n        ];\n    }\n    const el_uint256 = uint256(element);\n    return [\n        felt(el_uint256.low),\n        felt(el_uint256.high)\n    ];\n}\nfunction parseCalldataValue(element, type, structs, enums) {\n    if (element === void 0) {\n        throw Error(`Missing parameter for type ${type}`);\n    }\n    if (Array.isArray(element)) {\n        const result = [];\n        result.push(felt(element.length));\n        const arrayType = getArrayType(type);\n        return element.reduce((acc, it)=>{\n            return acc.concat(parseCalldataValue(it, arrayType, structs, enums));\n        }, result);\n    }\n    if (structs[type] && structs[type].members.length) {\n        if (isTypeUint256(type)) {\n            return parseUint256(element);\n        }\n        if (type === \"core::starknet::eth_address::EthAddress\") return parseBaseTypes(type, element);\n        const { members } = structs[type];\n        const subElement = element;\n        return members.reduce((acc, it)=>{\n            return acc.concat(parseCalldataValue(subElement[it.name], it.type, structs, enums));\n        }, []);\n    }\n    if (isTypeTuple(type)) {\n        const tupled = parseTuple(element, type);\n        return tupled.reduce((acc, it)=>{\n            const parsedData = parseCalldataValue(it.element, it.type, structs, enums);\n            return acc.concat(parsedData);\n        }, []);\n    }\n    if (isTypeUint256(type)) {\n        return parseUint256(element);\n    }\n    if (isTypeEnum(type, enums)) {\n        const { variants } = enums[type];\n        if (isTypeOption(type)) {\n            const myOption = element;\n            if (myOption.isSome()) {\n                const listTypeVariant2 = variants.find((variant)=>variant.name === \"Some\");\n                if (typeof listTypeVariant2 === \"undefined\") {\n                    throw Error(`Error in abi : Option has no 'Some' variant.`);\n                }\n                const typeVariantSome = listTypeVariant2.type;\n                if (typeVariantSome === \"()\") {\n                    return 0..toString();\n                }\n                const parsedParameter2 = parseCalldataValue(myOption.unwrap(), typeVariantSome, structs, enums);\n                if (Array.isArray(parsedParameter2)) {\n                    return [\n                        0..toString(),\n                        ...parsedParameter2\n                    ];\n                }\n                return [\n                    0..toString(),\n                    parsedParameter2\n                ];\n            }\n            return 1..toString();\n        }\n        if (isTypeResult(type)) {\n            const myResult = element;\n            if (myResult.isOk()) {\n                const listTypeVariant3 = variants.find((variant)=>variant.name === \"Ok\");\n                if (typeof listTypeVariant3 === \"undefined\") {\n                    throw Error(`Error in abi : Result has no 'Ok' variant.`);\n                }\n                const typeVariantOk = listTypeVariant3.type;\n                if (typeVariantOk === \"()\") {\n                    return 0..toString();\n                }\n                const parsedParameter3 = parseCalldataValue(myResult.unwrap(), typeVariantOk, structs, enums);\n                if (Array.isArray(parsedParameter3)) {\n                    return [\n                        0..toString(),\n                        ...parsedParameter3\n                    ];\n                }\n                return [\n                    0..toString(),\n                    parsedParameter3\n                ];\n            }\n            const listTypeVariant2 = variants.find((variant)=>variant.name === \"Err\");\n            if (typeof listTypeVariant2 === \"undefined\") {\n                throw Error(`Error in abi : Result has no 'Err' variant.`);\n            }\n            const typeVariantErr = listTypeVariant2.type;\n            if (typeVariantErr === \"()\") {\n                return 1..toString();\n            }\n            const parsedParameter2 = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);\n            if (Array.isArray(parsedParameter2)) {\n                return [\n                    1..toString(),\n                    ...parsedParameter2\n                ];\n            }\n            return [\n                1..toString(),\n                parsedParameter2\n            ];\n        }\n        const myEnum = element;\n        const activeVariant = myEnum.activeVariant();\n        const listTypeVariant = variants.find((variant)=>variant.name === activeVariant);\n        if (typeof listTypeVariant === \"undefined\") {\n            throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);\n        }\n        const typeActiveVariant = listTypeVariant.type;\n        const numActiveVariant = variants.findIndex((variant)=>variant.name === activeVariant);\n        if (typeActiveVariant === \"()\") {\n            return numActiveVariant.toString();\n        }\n        const parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);\n        if (Array.isArray(parsedParameter)) {\n            return [\n                numActiveVariant.toString(),\n                ...parsedParameter\n            ];\n        }\n        return [\n            numActiveVariant.toString(),\n            parsedParameter\n        ];\n    }\n    if (typeof element === \"object\") {\n        throw Error(`Parameter ${element} do not align with abi parameter ${type}`);\n    }\n    return parseBaseTypes(type, element);\n}\nfunction parseCalldataField(argsIterator, input, structs, enums) {\n    const { name, type } = input;\n    let { value } = argsIterator.next();\n    switch(true){\n        case isTypeArray(type):\n            if (!Array.isArray(value) && !isText(value)) {\n                throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);\n            }\n            if (typeof value === \"string\") {\n                value = splitLongString(value);\n            }\n            return parseCalldataValue(value, input.type, structs, enums);\n        case type === \"core::starknet::eth_address::EthAddress\":\n            return parseBaseTypes(type, value);\n        case isTypeStruct(type, structs) || isTypeTuple(type) || isTypeUint256(type):\n            return parseCalldataValue(value, type, structs, enums);\n        case isTypeEnum(type, enums):\n            return parseCalldataValue(value, type, structs, enums);\n        default:\n            return parseBaseTypes(type, value);\n    }\n}\n// src/utils/calldata/responseParser.ts\nfunction parseBaseTypes2(type, it) {\n    let temp;\n    switch(true){\n        case isTypeBool(type):\n            temp = it.next().value;\n            return Boolean(BigInt(temp));\n        case isTypeUint256(type):\n            const low = it.next().value;\n            const high = it.next().value;\n            return uint256ToBN({\n                low,\n                high\n            });\n        case type === \"core::starknet::eth_address::EthAddress\":\n            temp = it.next().value;\n            return BigInt(temp);\n        default:\n            temp = it.next().value;\n            return BigInt(temp);\n    }\n}\nfunction parseResponseValue(responseIterator, element, structs, enums) {\n    if (element.type === \"()\") {\n        return {};\n    }\n    if (isTypeUint256(element.type)) {\n        const low = responseIterator.next().value;\n        const high = responseIterator.next().value;\n        return uint256ToBN({\n            low,\n            high\n        });\n    }\n    if (isTypeArray(element.type)) {\n        const parsedDataArr = [];\n        const el = {\n            name: \"\",\n            type: getArrayType(element.type)\n        };\n        const len = BigInt(responseIterator.next().value);\n        while(parsedDataArr.length < len){\n            parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n        }\n        return parsedDataArr;\n    }\n    if (structs && element.type in structs && structs[element.type]) {\n        if (element.type === \"core::starknet::eth_address::EthAddress\") {\n            return parseBaseTypes2(element.type, responseIterator);\n        }\n        return structs[element.type].members.reduce((acc, el)=>{\n            acc[el.name] = parseResponseValue(responseIterator, el, structs, enums);\n            return acc;\n        }, {});\n    }\n    if (enums && element.type in enums && enums[element.type]) {\n        const variantNum = Number(responseIterator.next().value);\n        const rawEnum = enums[element.type].variants.reduce((acc, variant, num1)=>{\n            if (num1 === variantNum) {\n                acc[variant.name] = parseResponseValue(responseIterator, {\n                    name: \"\",\n                    type: variant.type\n                }, structs, enums);\n                return acc;\n            }\n            acc[variant.name] = void 0;\n            return acc;\n        }, {});\n        if (element.type.startsWith(\"core::option::Option\")) {\n            const content = variantNum === 0 /* Some */  ? rawEnum.Some : void 0;\n            return new CairoOption(variantNum, content);\n        }\n        if (element.type.startsWith(\"core::result::Result\")) {\n            let content;\n            if (variantNum === 0 /* Ok */ ) {\n                content = rawEnum.Ok;\n            } else {\n                content = rawEnum.Err;\n            }\n            return new CairoResult(variantNum, content);\n        }\n        const customEnum = new CairoCustomEnum(rawEnum);\n        return customEnum;\n    }\n    if (isTypeTuple(element.type)) {\n        const memberTypes = extractTupleMemberTypes(element.type);\n        return memberTypes.reduce((acc, it, idx)=>{\n            const name = it?.name ? it.name : idx;\n            const type = it?.type ? it.type : it;\n            const el = {\n                name,\n                type\n            };\n            acc[name] = parseResponseValue(responseIterator, el, structs, enums);\n            return acc;\n        }, {});\n    }\n    if (isTypeArray(element.type)) {\n        const parsedDataArr = [];\n        const el = {\n            name: \"\",\n            type: getArrayType(element.type)\n        };\n        const len = BigInt(responseIterator.next().value);\n        while(parsedDataArr.length < len){\n            parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n        }\n        return parsedDataArr;\n    }\n    return parseBaseTypes2(element.type, responseIterator);\n}\nfunction responseParser(responseIterator, output, structs, enums, parsedResult) {\n    const { name, type } = output;\n    let temp;\n    switch(true){\n        case isLen(name):\n            temp = responseIterator.next().value;\n            return BigInt(temp);\n        case structs && type in structs || isTypeTuple(type):\n            return parseResponseValue(responseIterator, output, structs, enums);\n        case enums && isTypeEnum(type, enums):\n            return parseResponseValue(responseIterator, output, structs, enums);\n        case isTypeArray(type):\n            if (isCairo1Type(type)) {\n                return parseResponseValue(responseIterator, output, structs, enums);\n            }\n            const parsedDataArr = [];\n            if (parsedResult && parsedResult[`${name}_len`]) {\n                const arrLen = parsedResult[`${name}_len`];\n                while(parsedDataArr.length < arrLen){\n                    parsedDataArr.push(parseResponseValue(responseIterator, {\n                        name,\n                        type: output.type.replace(\"*\", \"\")\n                    }, structs, enums));\n                }\n            }\n            return parsedDataArr;\n        default:\n            return parseBaseTypes2(type, responseIterator);\n    }\n}\n// src/utils/calldata/validate.ts\nvar validateFelt = (parameter, input)=>{\n    assert(typeof parameter === \"string\" || typeof parameter === \"number\" || typeof parameter === \"bigint\", `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`);\n    if (typeof parameter === \"string\" && !isHex(parameter)) return;\n    const param = BigInt(parameter.toString(10));\n    assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1266\n    param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);\n};\nvar validateUint = (parameter, input)=>{\n    if (typeof parameter === \"number\") {\n        assert(parameter <= Number.MAX_SAFE_INTEGER, `Validation: Parameter is to large to be typed as Number use (BigInt or String)`);\n    }\n    assert(typeof parameter === \"string\" || typeof parameter === \"number\" || typeof parameter === \"bigint\" || typeof parameter === \"object\" && \"low\" in parameter && \"high\" in parameter, `Validate: arg ${input.name} of cairo type ${input.type} should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`);\n    const param = typeof parameter === \"object\" ? uint256ToBN(parameter) : toBigInt(parameter);\n    switch(input.type){\n        case \"core::integer::u8\" /* u8 */ :\n            assert(param >= 0n && param <= 255n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`);\n            break;\n        case \"core::integer::u16\" /* u16 */ :\n            assert(param >= 0n && param <= 65535n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`);\n            break;\n        case \"core::integer::u32\" /* u32 */ :\n            assert(param >= 0n && param <= 4294967295n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`);\n            break;\n        case \"core::integer::u64\" /* u64 */ :\n            assert(param >= 0n && param <= 2n ** 64n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`);\n            break;\n        case \"core::integer::u128\" /* u128 */ :\n            assert(param >= 0n && param <= 2n ** 128n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`);\n            break;\n        case \"core::integer::u256\" /* u256 */ :\n            assert(param >= 0n && param <= 2n ** 256n - 1n, `Validate: arg ${input.name} is ${input.type} 0 - 2^256-1`);\n            break;\n        case \"core::starknet::class_hash::ClassHash\" /* ClassHash */ :\n            assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1670\n            param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);\n            break;\n        case \"core::starknet::contract_address::ContractAddress\" /* ContractAddress */ :\n            assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1245\n            param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);\n            break;\n        default:\n            break;\n    }\n};\nvar validateBool = (parameter, input)=>{\n    assert(typeof parameter === \"boolean\", `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`);\n};\nvar validateStruct = (parameter, input, structs)=>{\n    if (input.type === \"core::integer::u256\" /* u256 */ ) {\n        validateUint(parameter, input);\n        return;\n    }\n    if (input.type === \"core::starknet::eth_address::EthAddress\") {\n        assert(typeof parameter !== \"object\", `EthAdress type is waiting a BigNumberish. Got ${parameter}`);\n        const param = BigInt(parameter.toString(10));\n        assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1259\n        param >= 0n && param <= 2n ** 160n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`);\n        return;\n    }\n    assert(typeof parameter === \"object\" && !Array.isArray(parameter), `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as js object (not array)`);\n    structs[input.type].members.forEach(({ name })=>{\n        assert(Object.keys(parameter).includes(name), `Validate: arg ${input.name} should have a property ${name}`);\n    });\n};\nvar validateEnum = (parameter, input)=>{\n    assert(typeof parameter === \"object\" && !Array.isArray(parameter), `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as js object (not array)`);\n    const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));\n    const keys = [\n        ...Object.getOwnPropertyNames(parameter),\n        ...methodsKeys\n    ];\n    if (isTypeOption(input.type) && keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n        return;\n    }\n    if (isTypeResult(input.type) && keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n        return;\n    }\n    if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n        return;\n    }\n    throw new Error(`Validate Enum: argument ${input.name}, type ${input.type}, value received ${parameter}, is not an Enum.`);\n};\nvar validateTuple = (parameter, input)=>{\n    assert(typeof parameter === \"object\" && !Array.isArray(parameter), `Validate: arg ${input.name} should be a tuple (defined as object)`);\n};\nvar validateArray = (parameter, input, structs, enums)=>{\n    const baseType = getArrayType(input.type);\n    if (isTypeFelt(baseType) && isLongText(parameter)) {\n        return;\n    }\n    assert(Array.isArray(parameter), `Validate: arg ${input.name} should be an Array`);\n    switch(true){\n        case isTypeFelt(baseType):\n            parameter.forEach((param)=>validateFelt(param, input));\n            break;\n        case isTypeTuple(baseType):\n            parameter.forEach((it)=>validateTuple(it, {\n                    name: input.name,\n                    type: baseType\n                }));\n            break;\n        case isTypeArray(baseType):\n            parameter.forEach((param)=>validateArray(param, {\n                    name: \"\",\n                    type: baseType\n                }, structs, enums));\n            break;\n        case isTypeStruct(baseType, structs):\n            parameter.forEach((it)=>validateStruct(it, {\n                    name: input.name,\n                    type: baseType\n                }, structs));\n            break;\n        case isTypeEnum(baseType, enums):\n            parameter.forEach((it)=>validateEnum(it, {\n                    name: input.name,\n                    type: baseType\n                }));\n            break;\n        case isTypeUint(baseType) || isTypeLitteral(baseType):\n            parameter.forEach((param)=>validateUint(param, input));\n            break;\n        case isTypeBool(baseType):\n            parameter.forEach((param)=>validateBool(param, input));\n            break;\n        default:\n            throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`);\n    }\n};\nfunction validateFields(abiMethod, args, structs, enums) {\n    abiMethod.inputs.reduce((acc, input)=>{\n        const parameter = args[acc];\n        switch(true){\n            case isLen(input.name):\n                return acc;\n            case isTypeFelt(input.type):\n                validateFelt(parameter, input);\n                break;\n            case isTypeUint(input.type) || isTypeLitteral(input.type):\n                validateUint(parameter, input);\n                break;\n            case isTypeBool(input.type):\n                validateBool(parameter, input);\n                break;\n            case isTypeArray(input.type):\n                validateArray(parameter, input, structs, enums);\n                break;\n            case isTypeStruct(input.type, structs):\n                validateStruct(parameter, input, structs);\n                break;\n            case isTypeEnum(input.type, enums):\n                validateEnum(parameter, input);\n                break;\n            case isTypeTuple(input.type):\n                validateTuple(parameter, input);\n                break;\n            default:\n                throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`);\n        }\n        return acc + 1;\n    }, 0);\n}\n// src/utils/calldata/index.ts\nvar CallData = class {\n    constructor(abi){\n        this.structs = CallData.getAbiStruct(abi);\n        this.enums = CallData.getAbiEnum(abi);\n        this.parser = createAbiParser(abi);\n        this.abi = this.parser.getLegacyFormat();\n    }\n    /**\n   * Validate arguments passed to the method as corresponding to the ones in the abi\n   * @param type ValidateType - type of the method\n   * @param method string - name of the method\n   * @param args ArgsOrCalldata - arguments that are passed to the method\n   */ validate(type, method, args = []) {\n        if (type !== \"DEPLOY\" /* DEPLOY */ ) {\n            const invocableFunctionNames = this.abi.filter((abi)=>{\n                if (abi.type !== \"function\") return false;\n                const isView = abi.stateMutability === \"view\" || abi.state_mutability === \"view\";\n                return type === \"INVOKE\" /* INVOKE */  ? !isView : isView;\n            }).map((abi)=>abi.name);\n            assert(invocableFunctionNames.includes(method), `${type === \"INVOKE\" /* INVOKE */  ? \"invocable\" : \"viewable\"} method not found in abi`);\n        }\n        const abiMethod = this.abi.find((abi)=>type === \"DEPLOY\" /* DEPLOY */  ? abi.name === method && abi.type === \"constructor\" : abi.name === method && abi.type === \"function\");\n        if (isNoConstructorValid(method, args, abiMethod)) {\n            return;\n        }\n        const inputsLength = this.parser.methodInputsLength(abiMethod);\n        if (args.length !== inputsLength) {\n            throw Error(`Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`);\n        }\n        validateFields(abiMethod, args, this.structs, this.enums);\n    }\n    /**\n   * Compile contract callData with abi\n   * Parse the calldata by using input fields from the abi for that method\n   * @param method string - method name\n   * @param args RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).\n   * @return Calldata - parsed arguments in format that contract is expecting\n   * @example\n   * ```typescript\n   * const calldata = myCallData.compile(\"constructor\", [\"0x34a\", [1, 3n]]);\n   * ```\n   * ```typescript\n   * const calldata2 = myCallData.compile(\"constructor\", {list:[1, 3n], balance:\"0x34\"}); // wrong order is valid\n   * ```\n   */ compile(method, argsCalldata) {\n        const abiMethod = this.abi.find((abiFunction)=>abiFunction.name === method);\n        if (isNoConstructorValid(method, argsCalldata, abiMethod)) {\n            return [];\n        }\n        let args;\n        if (Array.isArray(argsCalldata)) {\n            args = argsCalldata;\n        } else {\n            const orderedObject = orderPropsByAbi(argsCalldata, abiMethod.inputs, this.structs, this.enums);\n            args = Object.values(orderedObject);\n            validateFields(abiMethod, args, this.structs, this.enums);\n        }\n        const argsIterator = args[Symbol.iterator]();\n        const callArray = abiMethod.inputs.reduce((acc, input)=>isLen(input.name) && !isCairo1Type(input.type) ? acc : acc.concat(parseCalldataField(argsIterator, input, this.structs, this.enums)), []);\n        Object.defineProperty(callArray, \"__compiled__\", {\n            enumerable: false,\n            writable: false,\n            value: true\n        });\n        return callArray;\n    }\n    /**\n   * Compile contract callData without abi\n   * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data\n   * @returns Calldata\n   */ static compile(rawArgs) {\n        const createTree = (obj)=>{\n            const getEntries = (o, prefix = \".\")=>{\n                const oe = Array.isArray(o) ? [\n                    o.length.toString(),\n                    ...o\n                ] : o;\n                return Object.entries(oe).flatMap(([k, v])=>{\n                    let value = v;\n                    if (isLongText(value)) value = splitLongString(value);\n                    if (k === \"entrypoint\") value = getSelectorFromName(value);\n                    const kk = Array.isArray(oe) && k === \"0\" ? \"$$len\" : k;\n                    if (isBigInt(value)) return [\n                        [\n                            `${prefix}${kk}`,\n                            felt(value)\n                        ]\n                    ];\n                    if (Object(value) === value) {\n                        const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));\n                        const keys = [\n                            ...Object.getOwnPropertyNames(value),\n                            ...methodsKeys\n                        ];\n                        if (keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n                            const myOption = value;\n                            const variantNb = myOption.isSome() ? 0 /* Some */  : 1 /* None */ ;\n                            if (myOption.isSome()) return getEntries({\n                                0: variantNb,\n                                1: myOption.unwrap()\n                            }, `${prefix}${kk}.`);\n                            return [\n                                [\n                                    `${prefix}${kk}`,\n                                    felt(variantNb)\n                                ]\n                            ];\n                        }\n                        if (keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n                            const myResult = value;\n                            const variantNb = myResult.isOk() ? 0 /* Ok */  : 1 /* Err */ ;\n                            return getEntries({\n                                0: variantNb,\n                                1: myResult.unwrap()\n                            }, `${prefix}${kk}.`);\n                        }\n                        if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n                            const myEnum = value;\n                            const activeVariant = myEnum.activeVariant();\n                            const listVariants = Object.keys(myEnum.variant);\n                            const activeVariantNb = listVariants.findIndex((variant)=>variant === activeVariant);\n                            if (typeof myEnum.unwrap() === \"object\" && Object.keys(myEnum.unwrap()).length === 0) {\n                                return [\n                                    [\n                                        `${prefix}${kk}`,\n                                        felt(activeVariantNb)\n                                    ]\n                                ];\n                            }\n                            return getEntries({\n                                0: activeVariantNb,\n                                1: myEnum.unwrap()\n                            }, `${prefix}${kk}.`);\n                        }\n                        return getEntries(value, `${prefix}${kk}.`);\n                    }\n                    return [\n                        [\n                            `${prefix}${kk}`,\n                            felt(value)\n                        ]\n                    ];\n                });\n            };\n            const result = Object.fromEntries(getEntries(obj));\n            return result;\n        };\n        let callTreeArray;\n        if (!Array.isArray(rawArgs)) {\n            const callTree = createTree(rawArgs);\n            callTreeArray = Object.values(callTree);\n        } else {\n            const callObj = {\n                ...rawArgs\n            };\n            const callTree = createTree(callObj);\n            callTreeArray = Object.values(callTree);\n        }\n        Object.defineProperty(callTreeArray, \"__compiled__\", {\n            enumerable: false,\n            writable: false,\n            value: true\n        });\n        return callTreeArray;\n    }\n    /**\n   * Parse elements of the response array and structuring them into response object\n   * @param method string - method name\n   * @param response string[] - response from the method\n   * @return Result - parsed response corresponding to the abi\n   */ parse(method, response) {\n        const { outputs } = this.abi.find((abi)=>abi.name === method);\n        const responseIterator = response.flat()[Symbol.iterator]();\n        const parsed = outputs.flat().reduce((acc, output, idx)=>{\n            const propName = output.name ?? idx;\n            acc[propName] = responseParser(responseIterator, output, this.structs, this.enums, acc);\n            if (acc[propName] && acc[`${propName}_len`]) {\n                delete acc[`${propName}_len`];\n            }\n            return acc;\n        }, {});\n        return Object.keys(parsed).length === 1 && 0 in parsed ? parsed[0] : parsed;\n    }\n    /**\n   * Format cairo method response data to native js values based on provided format schema\n   * @param method string - cairo method name\n   * @param response string[] - cairo method response\n   * @param format object - formatter object schema\n   * @returns Result - parsed and formatted response object\n   */ format(method, response, format) {\n        const parsed = this.parse(method, response);\n        return formatter(parsed, format);\n    }\n    /**\n   * Helper to extract structs from abi\n   * @param abi Abi\n   * @returns AbiStructs - structs from abi\n   */ static getAbiStruct(abi) {\n        return abi.filter((abiEntry)=>abiEntry.type === \"struct\").reduce((acc, abiEntry)=>({\n                ...acc,\n                [abiEntry.name]: abiEntry\n            }), {});\n    }\n    /**\n   * Helper to extract enums from abi\n   * @param abi Abi\n   * @returns AbiEnums - enums from abi\n   */ static getAbiEnum(abi) {\n        const fullEnumList = abi.filter((abiEntry)=>abiEntry.type === \"enum\").reduce((acc, abiEntry)=>({\n                ...acc,\n                [abiEntry.name]: abiEntry\n            }), {});\n        delete fullEnumList[\"core::bool\"];\n        return fullEnumList;\n    }\n    /**\n   * Helper: Compile HexCalldata | RawCalldata | RawArgs\n   * @param rawCalldata HexCalldata | RawCalldata | RawArgs\n   * @returns Calldata\n   */ static toCalldata(rawCalldata = []) {\n        return CallData.compile(rawCalldata);\n    }\n    /**\n   * Helper: Convert raw to HexCalldata\n   * @param raw HexCalldata | RawCalldata | RawArgs\n   * @returns HexCalldata\n   */ static toHex(raw = []) {\n        const calldata = CallData.compile(raw);\n        return calldata.map((it)=>toHex(it));\n    }\n};\n// src/utils/hash.ts\nvar hash_exports = {};\n__export(hash_exports, {\n    calculateContractAddressFromHash: ()=>calculateContractAddressFromHash,\n    calculateDeclareTransactionHash: ()=>calculateDeclareTransactionHash,\n    calculateDeployAccountTransactionHash: ()=>calculateDeployAccountTransactionHash,\n    calculateDeployTransactionHash: ()=>calculateDeployTransactionHash,\n    calculateTransactionHash: ()=>calculateTransactionHash,\n    calculateTransactionHashCommon: ()=>calculateTransactionHashCommon,\n    computeCompiledClassHash: ()=>computeCompiledClassHash,\n    computeContractClassHash: ()=>computeContractClassHash,\n    computeHashOnElements: ()=>computeHashOnElements,\n    computeLegacyContractClassHash: ()=>computeLegacyContractClassHash,\n    computeSierraContractClassHash: ()=>computeSierraContractClassHash,\n    default: ()=>computeHintedClassHash,\n    feeTransactionVersion: ()=>feeTransactionVersion,\n    feeTransactionVersion_2: ()=>feeTransactionVersion_2,\n    formatSpaces: ()=>formatSpaces,\n    getSelector: ()=>getSelector,\n    getSelectorFromName: ()=>getSelectorFromName,\n    getVersionsByType: ()=>getVersionsByType,\n    keccakBn: ()=>keccakBn,\n    poseidon: ()=>poseidon,\n    starknetKeccak: ()=>starknetKeccak,\n    transactionVersion: ()=>transactionVersion,\n    transactionVersion_2: ()=>transactionVersion_2\n});\nvar import_starknet2 = __webpack_require__(/*! @scure/starknet */ \"(ssr)/./node_modules/@scure/starknet/lib/index.js\");\n// src/utils/ec.ts\nvar ec_exports = {};\n__export(ec_exports, {\n    starkCurve: ()=>starkCurve,\n    weierstrass: ()=>weierstrass\n});\nvar starkCurve = __toESM(__webpack_require__(/*! @scure/starknet */ \"(ssr)/./node_modules/@scure/starknet/lib/index.js\"));\nvar weierstrass = __toESM(__webpack_require__(/*! @noble/curves/abstract/weierstrass */ \"(ssr)/./node_modules/@noble/curves/abstract/weierstrass.js\"));\n// src/utils/json.ts\nvar json_exports = {};\n__export(json_exports, {\n    parse: ()=>parse2,\n    parseAlwaysAsBig: ()=>parseAlwaysAsBig,\n    stringify: ()=>stringify2,\n    stringifyAlwaysAsBig: ()=>stringifyAlwaysAsBig\n});\nvar json = __toESM(__webpack_require__(/*! lossless-json */ \"(ssr)/./node_modules/lossless-json/lib/umd/lossless-json.js\"));\nvar parseIntAsNumberOrBigInt = (x)=>{\n    if (!json.isInteger(x)) return parseFloat(x);\n    const v = parseInt(x, 10);\n    return Number.isSafeInteger(v) ? v : BigInt(x);\n};\nvar parse2 = (x)=>json.parse(String(x), void 0, parseIntAsNumberOrBigInt);\nvar parseAlwaysAsBig = (x)=>json.parse(String(x), void 0, json.parseNumberAndBigInt);\nvar stringify2 = (value, replacer, space, numberStringifiers)=>json.stringify(value, replacer, space, numberStringifiers);\nvar stringifyAlwaysAsBig = stringify2;\n// src/utils/hash.ts\nvar poseidon = __toESM(__webpack_require__(/*! @noble/curves/abstract/poseidon */ \"(ssr)/./node_modules/@noble/curves/abstract/poseidon.js\"));\nvar transactionVersion = BN_TRANSACTION_VERSION_1;\nvar transactionVersion_2 = BN_TRANSACTION_VERSION_2;\nvar feeTransactionVersion = BN_FEE_TRANSACTION_VERSION_1;\nvar feeTransactionVersion_2 = BN_FEE_TRANSACTION_VERSION_2;\nfunction getVersionsByType(versionType) {\n    return versionType === \"fee\" ? {\n        v1: feeTransactionVersion,\n        v2: feeTransactionVersion_2\n    } : {\n        v1: transactionVersion,\n        v2: transactionVersion_2\n    };\n}\nfunction computeHashOnElements(data) {\n    return [\n        ...data,\n        data.length\n    ].reduce((x, y)=>starkCurve.pedersen(toBigInt(x), toBigInt(y)), 0).toString();\n}\nfunction calculateTransactionHashCommon(txHashPrefix, version, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData = []) {\n    const calldataHash = computeHashOnElements(calldata);\n    const dataToHash = [\n        txHashPrefix,\n        version,\n        contractAddress,\n        entryPointSelector,\n        calldataHash,\n        maxFee,\n        chainId,\n        ...additionalData\n    ];\n    return computeHashOnElements(dataToHash);\n}\nfunction calculateDeployTransactionHash(contractAddress, constructorCalldata, version, chainId, constructorName = \"constructor\") {\n    return calculateTransactionHashCommon(\"0x6465706c6f79\" /* DEPLOY */ , version, contractAddress, getSelectorFromName(constructorName), constructorCalldata, 0, chainId);\n}\nfunction calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash) {\n    return calculateTransactionHashCommon(\"0x6465636c617265\" /* DECLARE */ , version, senderAddress, 0, [\n        classHash\n    ], maxFee, chainId, [\n        nonce,\n        ...compiledClassHash ? [\n            compiledClassHash\n        ] : []\n    ]);\n}\nfunction calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, salt, version, maxFee, chainId, nonce) {\n    const calldata = [\n        classHash,\n        salt,\n        ...constructorCalldata\n    ];\n    return calculateTransactionHashCommon(\"0x6465706c6f795f6163636f756e74\" /* DEPLOY_ACCOUNT */ , version, contractAddress, 0, calldata, maxFee, chainId, [\n        nonce\n    ]);\n}\nfunction calculateTransactionHash(contractAddress, version, calldata, maxFee, chainId, nonce) {\n    return calculateTransactionHashCommon(\"0x696e766f6b65\" /* INVOKE */ , version, contractAddress, 0, calldata, maxFee, chainId, [\n        nonce\n    ]);\n}\nfunction calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const constructorCalldataHash = computeHashOnElements(compiledCalldata);\n    const CONTRACT_ADDRESS_PREFIX = felt(\"0x535441524b4e45545f434f4e54524143545f41444452455353\");\n    return computeHashOnElements([\n        CONTRACT_ADDRESS_PREFIX,\n        deployerAddress,\n        salt,\n        classHash,\n        constructorCalldataHash\n    ]);\n}\nfunction nullSkipReplacer(key, value) {\n    if (key === \"attributes\" || key === \"accessible_scopes\") {\n        return Array.isArray(value) && value.length === 0 ? void 0 : value;\n    }\n    if (key === \"debug_info\") {\n        return null;\n    }\n    return value === null ? void 0 : value;\n}\nfunction formatSpaces(json2) {\n    let insideQuotes = false;\n    const newString = [];\n    for (const char of json2){\n        if (char === '\"' && (newString.length > 0 && newString.slice(-1)[0] === \"\\\\\") === false) {\n            insideQuotes = !insideQuotes;\n        }\n        if (insideQuotes) {\n            newString.push(char);\n        } else {\n            newString.push(char === \":\" ? \": \" : char === \",\" ? \", \" : char);\n        }\n    }\n    return newString.join(\"\");\n}\nfunction computeHintedClassHash(compiledContract) {\n    const { abi, program } = compiledContract;\n    const contractClass = {\n        abi,\n        program\n    };\n    const serializedJson = formatSpaces(stringify2(contractClass, nullSkipReplacer));\n    return addHexPrefix(starkCurve.keccak(utf8ToArray(serializedJson)).toString(16));\n}\nfunction computeLegacyContractClassHash(contract) {\n    const compiledContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    const apiVersion = toHex(API_VERSION);\n    const externalEntryPointsHash = computeHashOnElements(compiledContract.entry_points_by_type.EXTERNAL.flatMap((e)=>[\n            e.selector,\n            e.offset\n        ]));\n    const l1HandlerEntryPointsHash = computeHashOnElements(compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e)=>[\n            e.selector,\n            e.offset\n        ]));\n    const constructorEntryPointHash = computeHashOnElements(compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e)=>[\n            e.selector,\n            e.offset\n        ]));\n    const builtinsHash = computeHashOnElements(compiledContract.program.builtins.map((s)=>encodeShortString(s)));\n    const hintedClassHash = computeHintedClassHash(compiledContract);\n    const dataHash = computeHashOnElements(compiledContract.program.data);\n    return computeHashOnElements([\n        apiVersion,\n        externalEntryPointsHash,\n        l1HandlerEntryPointsHash,\n        constructorEntryPointHash,\n        builtinsHash,\n        hintedClassHash,\n        dataHash\n    ]);\n}\nfunction hashBuiltins(builtins) {\n    return (0, import_starknet2.poseidonHashMany)(builtins.flatMap((it)=>{\n        return BigInt(encodeShortString(it));\n    }));\n}\nfunction hashEntryPoint(data) {\n    const base = data.flatMap((it)=>{\n        return [\n            BigInt(it.selector),\n            BigInt(it.offset),\n            hashBuiltins(it.builtins)\n        ];\n    });\n    return (0, import_starknet2.poseidonHashMany)(base);\n}\nfunction computeCompiledClassHash(casm) {\n    const COMPILED_CLASS_VERSION = \"COMPILED_CLASS_V1\";\n    const compiledClassVersion = BigInt(encodeShortString(COMPILED_CLASS_VERSION));\n    const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);\n    const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);\n    const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);\n    const bytecode = (0, import_starknet2.poseidonHashMany)(casm.bytecode.map((it)=>BigInt(it)));\n    return toHex((0, import_starknet2.poseidonHashMany)([\n        compiledClassVersion,\n        externalEntryPointsHash,\n        l1Handlers,\n        constructor,\n        bytecode\n    ]));\n}\nfunction hashEntryPointSierra(data) {\n    const base = data.flatMap((it)=>{\n        return [\n            BigInt(it.selector),\n            BigInt(it.function_idx)\n        ];\n    });\n    return (0, import_starknet2.poseidonHashMany)(base);\n}\nfunction hashAbi(sierra) {\n    const indentString = formatSpaces(stringify2(sierra.abi, null));\n    return BigInt(addHexPrefix(starkCurve.keccak(utf8ToArray(indentString)).toString(16)));\n}\nfunction computeSierraContractClassHash(sierra) {\n    const CONTRACT_CLASS_VERSION = \"CONTRACT_CLASS_V0.1.0\";\n    const compiledClassVersion = BigInt(encodeShortString(CONTRACT_CLASS_VERSION));\n    const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);\n    const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);\n    const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);\n    const abiHash = hashAbi(sierra);\n    const sierraProgram = (0, import_starknet2.poseidonHashMany)(sierra.sierra_program.map((it)=>BigInt(it)));\n    return toHex((0, import_starknet2.poseidonHashMany)([\n        compiledClassVersion,\n        externalEntryPointsHash,\n        l1Handlers,\n        constructor,\n        abiHash,\n        sierraProgram\n    ]));\n}\nfunction computeContractClassHash(contract) {\n    const compiledContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    if (\"sierra_program\" in compiledContract) {\n        return computeSierraContractClassHash(compiledContract);\n    }\n    return computeLegacyContractClassHash(compiledContract);\n}\n// src/utils/stark.ts\nvar stark_exports = {};\n__export(stark_exports, {\n    compressProgram: ()=>compressProgram,\n    decompressProgram: ()=>decompressProgram,\n    estimatedFeeToMaxFee: ()=>estimatedFeeToMaxFee,\n    formatSignature: ()=>formatSignature,\n    makeAddress: ()=>makeAddress,\n    randomAddress: ()=>randomAddress,\n    signatureToDecimalArray: ()=>signatureToDecimalArray,\n    signatureToHexArray: ()=>signatureToHexArray\n});\nvar import_starknet3 = __webpack_require__(/*! @scure/starknet */ \"(ssr)/./node_modules/@scure/starknet/lib/index.js\");\nvar import_pako = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/index.js\");\nfunction compressProgram(jsonProgram) {\n    const stringified = typeof jsonProgram === \"string\" ? jsonProgram : stringify2(jsonProgram);\n    const compressedProgram = (0, import_pako.gzip)(stringified);\n    return btoaUniversal(compressedProgram);\n}\nfunction decompressProgram(base642) {\n    if (Array.isArray(base642)) return base642;\n    const decompressed = arrayBufferToString((0, import_pako.ungzip)(atobUniversal(base642)));\n    return parse2(decompressed);\n}\nfunction randomAddress() {\n    const randomKeyPair = import_starknet3.utils.randomPrivateKey();\n    return (0, import_starknet3.getStarkKey)(randomKeyPair);\n}\nfunction makeAddress(input) {\n    return addHexPrefix(input).toLowerCase();\n}\nfunction formatSignature(sig) {\n    if (!sig) throw Error(\"formatSignature: provided signature is undefined\");\n    if (Array.isArray(sig)) {\n        return sig.map((it)=>toHex(it));\n    }\n    try {\n        const { r, s } = sig;\n        return [\n            toHex(r),\n            toHex(s)\n        ];\n    } catch (e) {\n        throw new Error(\"Signature need to be weierstrass.SignatureType or an array for custom\");\n    }\n}\nfunction signatureToDecimalArray(sig) {\n    return bigNumberishArrayToDecimalStringArray(formatSignature(sig));\n}\nfunction signatureToHexArray(sig) {\n    return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));\n}\nfunction estimatedFeeToMaxFee(estimatedFee, overhead = 0.5) {\n    const overHeadPercent = Math.round((1 + overhead) * 100);\n    return toBigInt(estimatedFee) * toBigInt(overHeadPercent) / 100n;\n}\n// src/utils/contract.ts\nfunction isSierra(contract) {\n    const compiledContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    return \"sierra_program\" in compiledContract;\n}\nfunction extractContractHashes(payload) {\n    const response = {\n        ...payload\n    };\n    if (isSierra(payload.contract)) {\n        if (!payload.compiledClassHash && payload.casm) {\n            response.compiledClassHash = computeCompiledClassHash(payload.casm);\n        }\n        if (!response.compiledClassHash) throw new Error(\"Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash\");\n    }\n    response.classHash = payload.classHash ?? computeContractClassHash(payload.contract);\n    if (!response.classHash) throw new Error(\"Extract classHash failed, provide (CompiledContract).json file or classHash\");\n    return response;\n}\nfunction contractClassResponseToLegacyCompiledContract(ccr) {\n    if (isSierra(ccr)) {\n        throw Error(\"ContractClassResponse need to be LegacyContractClass (cairo0 response class)\");\n    }\n    const contract = ccr;\n    return {\n        ...contract,\n        program: decompressProgram(contract.program)\n    };\n}\n// src/utils/fetchPonyfill.ts\nvar import_isomorphic_fetch = __toESM(__webpack_require__(/*! isomorphic-fetch */ \"(ssr)/./node_modules/isomorphic-fetch/fetch-npm-node.js\"));\nvar fetchPonyfill_default =  false || // use buildin fetch in browser if available\ntypeof global !== \"undefined\" && global.fetch || // use buildin fetch in node, react-native and service worker if available\nimport_isomorphic_fetch.default;\n// src/utils/provider.ts\nvar provider_exports = {};\n__export(provider_exports, {\n    createSierraContractClass: ()=>createSierraContractClass,\n    parseContract: ()=>parseContract,\n    wait: ()=>wait\n});\nfunction wait(delay) {\n    return new Promise((res)=>{\n        setTimeout(res, delay);\n    });\n}\nfunction createSierraContractClass(contract) {\n    const result = {\n        ...contract\n    };\n    delete result.sierra_program_debug_info;\n    result.abi = formatSpaces(stringify2(contract.abi));\n    result.sierra_program = formatSpaces(stringify2(contract.sierra_program));\n    result.sierra_program = compressProgram(result.sierra_program);\n    return result;\n}\nfunction parseContract(contract) {\n    const parsedContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    if (!isSierra(contract)) {\n        return {\n            ...parsedContract,\n            ...\"program\" in parsedContract && {\n                program: compressProgram(parsedContract.program)\n            }\n        };\n    }\n    return createSierraContractClass(parsedContract);\n}\n// src/utils/responseParser/rpc.ts\nvar RPCResponseParser = class {\n    parseGetBlockResponse(res) {\n        return {\n            timestamp: res.timestamp,\n            block_hash: \"block_hash\" in res ? res.block_hash : \"\",\n            block_number: \"block_number\" in res ? res.block_number : -1,\n            new_root: \"new_root\" in res ? res.new_root : \"\",\n            parent_hash: res.parent_hash,\n            status: \"status\" in res ? res.status : \"PENDING\" /* PENDING */ ,\n            transactions: res.transactions\n        };\n    }\n    parseGetTransactionResponse(res) {\n        return {\n            calldata: \"calldata\" in res ? res.calldata : [],\n            contract_address: \"contract_address\" in res ? res.contract_address : \"\",\n            sender_address: \"sender_address\" in res ? res.sender_address : \"\",\n            max_fee: \"max_fee\" in res ? res.max_fee : \"\",\n            nonce: \"nonce\" in res ? res.nonce : \"\",\n            signature: \"signature\" in res ? res.signature : [],\n            transaction_hash: res.transaction_hash,\n            version: res.version\n        };\n    }\n    parseFeeEstimateResponse(res) {\n        return {\n            overall_fee: toBigInt(res[0].overall_fee),\n            gas_consumed: toBigInt(res[0].gas_consumed),\n            gas_price: toBigInt(res[0].gas_price)\n        };\n    }\n    parseFeeEstimateBulkResponse(res) {\n        return res.map((val)=>({\n                overall_fee: toBigInt(val.overall_fee),\n                gas_consumed: toBigInt(val.gas_consumed),\n                gas_price: toBigInt(val.gas_price)\n            }));\n    }\n    parseCallContractResponse(res) {\n        return {\n            result: res\n        };\n    }\n    parseSimulateTransactionResponse(res) {\n        return res.map((it)=>{\n            return {\n                ...it,\n                suggestedMaxFee: estimatedFeeToMaxFee(BigInt(it.fee_estimation.overall_fee))\n            };\n        });\n    }\n    parseContractClassResponse(res) {\n        return {\n            ...res,\n            abi: typeof res.abi === \"string\" ? JSON.parse(res.abi) : res.abi\n        };\n    }\n};\n// src/provider/errors.ts\nfunction fixStack(target, fn = target.constructor) {\n    const { captureStackTrace } = Error;\n    captureStackTrace && captureStackTrace(target, fn);\n}\nfunction fixProto(target, prototype) {\n    const { setPrototypeOf } = Object;\n    setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;\n}\nvar CustomError = class extends Error {\n    constructor(message){\n        super(message);\n        Object.defineProperty(this, \"name\", {\n            value: new.target.name,\n            enumerable: false,\n            configurable: true\n        });\n        fixProto(this, new.target.prototype);\n        fixStack(this);\n    }\n};\nvar LibraryError = class extends CustomError {\n};\nvar GatewayError = class extends LibraryError {\n    constructor(message, errorCode){\n        super(message);\n        this.errorCode = errorCode;\n    }\n};\nvar HttpError = class extends LibraryError {\n    constructor(message, errorCode){\n        super(message);\n        this.errorCode = errorCode;\n    }\n};\n// src/utils/starknetId.ts\nvar starknetId_exports = {};\n__export(starknetId_exports, {\n    StarknetIdContract: ()=>StarknetIdContract,\n    getStarknetIdContract: ()=>getStarknetIdContract,\n    useDecoded: ()=>useDecoded,\n    useEncoded: ()=>useEncoded\n});\nvar basicAlphabet = \"abcdefghijklmnopqrstuvwxyz0123456789-\";\nvar basicSizePlusOne = BigInt(basicAlphabet.length + 1);\nvar bigAlphabet = \"这来\";\nvar basicAlphabetSize = BigInt(basicAlphabet.length);\nvar bigAlphabetSize = BigInt(bigAlphabet.length);\nvar bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);\nfunction extractStars(str) {\n    let k = 0;\n    while(str.endsWith(bigAlphabet[bigAlphabet.length - 1])){\n        str = str.substring(0, str.length - 1);\n        k += 1;\n    }\n    return [\n        str,\n        k\n    ];\n}\nfunction useDecoded(encoded) {\n    let decoded = \"\";\n    encoded.forEach((subdomain)=>{\n        while(subdomain !== ZERO){\n            const code = subdomain % basicSizePlusOne;\n            subdomain /= basicSizePlusOne;\n            if (code === BigInt(basicAlphabet.length)) {\n                const nextSubdomain = subdomain / bigAlphabetSizePlusOne;\n                if (nextSubdomain === ZERO) {\n                    const code2 = subdomain % bigAlphabetSizePlusOne;\n                    subdomain = nextSubdomain;\n                    if (code2 === ZERO) decoded += basicAlphabet[0];\n                    else decoded += bigAlphabet[Number(code2) - 1];\n                } else {\n                    const code2 = subdomain % bigAlphabetSize;\n                    decoded += bigAlphabet[Number(code2)];\n                    subdomain /= bigAlphabetSize;\n                }\n            } else decoded += basicAlphabet[Number(code)];\n        }\n        const [str, k] = extractStars(decoded);\n        if (k) decoded = str + (k % 2 === 0 ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) + bigAlphabet[0] + basicAlphabet[1] : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));\n        decoded += \".\";\n    });\n    if (!decoded) {\n        return decoded;\n    }\n    return decoded.concat(\"stark\");\n}\nfunction useEncoded(decoded) {\n    let encoded = BigInt(0);\n    let multiplier = BigInt(1);\n    if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {\n        const [str, k] = extractStars(decoded.substring(0, decoded.length - 2));\n        decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));\n    } else {\n        const [str, k] = extractStars(decoded);\n        if (k) decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));\n    }\n    for(let i = 0; i < decoded.length; i += 1){\n        const char = decoded[i];\n        const index = basicAlphabet.indexOf(char);\n        const bnIndex = BigInt(basicAlphabet.indexOf(char));\n        if (index !== -1) {\n            if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {\n                encoded += multiplier * basicAlphabetSize;\n                multiplier *= basicSizePlusOne;\n                multiplier *= basicSizePlusOne;\n            } else {\n                encoded += multiplier * bnIndex;\n                multiplier *= basicSizePlusOne;\n            }\n        } else if (bigAlphabet.indexOf(char) !== -1) {\n            encoded += multiplier * basicAlphabetSize;\n            multiplier *= basicSizePlusOne;\n            const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);\n            encoded += multiplier * BigInt(newid);\n            multiplier *= bigAlphabetSize;\n        }\n    }\n    return encoded;\n}\nvar StarknetIdContract = /* @__PURE__ */ ((StarknetIdContract2)=>{\n    StarknetIdContract2[\"MAINNET\"] = \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\";\n    StarknetIdContract2[\"TESTNET\"] = \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\";\n    return StarknetIdContract2;\n})(StarknetIdContract || {});\nfunction getStarknetIdContract(chainId) {\n    switch(chainId){\n        case \"0x534e5f4d41494e\" /* SN_MAIN */ :\n            return \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\" /* MAINNET */ ;\n        case \"0x534e5f474f45524c49\" /* SN_GOERLI */ :\n            return \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\" /* TESTNET */ ;\n        default:\n            throw new Error(\"Starknet.id is not yet deployed on this network\");\n    }\n}\n// src/provider/starknetId.ts\nasync function getStarkName(provider1, address, StarknetIdContract2) {\n    const chainId = await provider1.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    try {\n        const hexDomain = await provider1.callContract({\n            contractAddress: contract,\n            entrypoint: \"address_to_domain\",\n            calldata: CallData.compile({\n                address\n            })\n        });\n        const decimalDomain = hexDomain.result.map((element)=>BigInt(element)).slice(1);\n        const stringDomain = useDecoded(decimalDomain);\n        if (!stringDomain) {\n            throw Error(\"Starkname not found\");\n        }\n        return stringDomain;\n    } catch (e) {\n        if (e instanceof Error && e.message === \"Starkname not found\") {\n            throw e;\n        }\n        throw Error(\"Could not get stark name\");\n    }\n}\nasync function getAddressFromStarkName(provider1, name, StarknetIdContract2) {\n    const chainId = await provider1.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    try {\n        const addressData = await provider1.callContract({\n            contractAddress: contract,\n            entrypoint: \"domain_to_address\",\n            calldata: CallData.compile({\n                domain: [\n                    useEncoded(name.replace(\".stark\", \"\")).toString(10)\n                ]\n            })\n        });\n        return addressData.result[0];\n    } catch  {\n        throw Error(\"Could not get address from stark name\");\n    }\n}\n// src/provider/utils.ts\nvar validBlockTags = Object.values(BlockTag);\nvar Block = class {\n    constructor(_identifier){\n        this.hash = null;\n        this.number = null;\n        this.tag = null;\n        this.valueOf = ()=>this.number;\n        this.toString = ()=>this.hash;\n        this.setIdentifier(_identifier);\n    }\n    setIdentifier(__identifier) {\n        if (typeof __identifier === \"string\" && isHex(__identifier)) {\n            this.hash = __identifier;\n        } else if (typeof __identifier === \"bigint\") {\n            this.hash = toHex(__identifier);\n        } else if (typeof __identifier === \"number\") {\n            this.number = __identifier;\n        } else if (typeof __identifier === \"string\" && validBlockTags.includes(__identifier)) {\n            this.tag = __identifier;\n        } else {\n            this.tag = \"pending\" /* pending */ ;\n        }\n    }\n    // TODO: fix any\n    get queryIdentifier() {\n        if (this.number !== null) {\n            return `blockNumber=${this.number}`;\n        }\n        if (this.hash !== null) {\n            return `blockHash=${this.hash}`;\n        }\n        return `blockNumber=${this.tag}`;\n    }\n    // TODO: fix any\n    get identifier() {\n        if (this.number !== null) {\n            return {\n                block_number: this.number\n            };\n        }\n        if (this.hash !== null) {\n            return {\n                block_hash: this.hash\n            };\n        }\n        return this.tag;\n    }\n    set identifier(_identifier) {\n        this.setIdentifier(_identifier);\n    }\n    get sequencerIdentifier() {\n        return this.hash !== null ? {\n            blockHash: this.hash\n        } : {\n            blockNumber: this.number ?? this.tag\n        };\n    }\n};\n// src/provider/rpc.ts\nvar getDefaultNodeUrl = (networkName, mute = false)=>{\n    if (!mute) console.warn(\"Using default public node url, please provide nodeUrl in provider options!\");\n    const nodes = networkName === \"SN_MAIN\" /* SN_MAIN */  ? RPC_MAINNET_NODES : RPC_GOERLI_NODES;\n    const randIdx = Math.floor(Math.random() * nodes.length);\n    return nodes[randIdx];\n};\nvar defaultOptions = {\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    blockIdentifier: \"pending\" /* pending */ ,\n    retries: 200\n};\nvar RpcProvider = class {\n    constructor(optionsOrProvider){\n        this.responseParser = new RPCResponseParser();\n        /**\n     * @deprecated renamed to getBlockLatestAccepted(); (will be removed in next minor version)\n     */ this.getBlockHashAndNumber = this.getBlockLatestAccepted;\n        /**\n     * @deprecated renamed to getBlockStateUpdate();\n     */ this.getStateUpdate = this.getBlockStateUpdate;\n        /**\n     * Returns the execution traces of all transactions included in the given block\n     * @deprecated renamed to getBlockTransactionsTraces()\n     */ this.traceBlockTransactions = this.getBlockTransactionsTraces;\n        /**\n     * Get the number of transactions in a block given a block id\n     * @deprecated renamed to getBlockTransactionCount()\n     * @returns Number of transactions\n     */ this.getTransactionCount = this.getBlockTransactionCount;\n        /**\n     * @deprecated renamed to getTransactionTrace();\n     * For a given executed transaction, return the trace of its execution, including internal calls\n     */ this.traceTransaction = this.getTransactionTrace;\n        /**\n     * @deprecated renamed to simulateTransaction();\n     */ this.getSimulateTransaction = this.simulateTransaction;\n        const { nodeUrl, retries, headers, blockIdentifier, chainId } = optionsOrProvider || {};\n        if (Object.values(NetworkName).includes(nodeUrl)) {\n            this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider?.default);\n        } else if (nodeUrl) {\n            this.nodeUrl = nodeUrl;\n        } else {\n            this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider?.default);\n        }\n        this.retries = retries || defaultOptions.retries;\n        this.headers = {\n            ...defaultOptions.headers,\n            ...headers\n        };\n        this.blockIdentifier = blockIdentifier || defaultOptions.blockIdentifier;\n        this.chainId = chainId;\n    }\n    fetch(method, params, id = 0) {\n        const rpcRequestBody = {\n            id,\n            jsonrpc: \"2.0\",\n            method,\n            ...params && {\n                params\n            }\n        };\n        return fetchPonyfill_default(this.nodeUrl, {\n            method: \"POST\",\n            body: stringify2(rpcRequestBody),\n            headers: this.headers\n        });\n    }\n    errorHandler(method, params, rpcError, otherError) {\n        if (rpcError) {\n            const { code, message, data } = rpcError;\n            throw new LibraryError(`RPC: ${method} with params ${stringify2(params)}\n ${code}: ${message}: ${stringify2(data)}`);\n        }\n        if (otherError instanceof LibraryError) {\n            throw otherError;\n        }\n        if (otherError) {\n            throw Error(otherError.message);\n        }\n    }\n    async fetchEndpoint(method, params) {\n        try {\n            const rawResult = await this.fetch(method, params);\n            const { error, result } = await rawResult.json();\n            this.errorHandler(method, params, error);\n            return result;\n        } catch (error) {\n            this.errorHandler(method, params, error?.response?.data, error);\n            throw error;\n        }\n    }\n    async getChainId() {\n        this.chainId ?? (this.chainId = await this.fetchEndpoint(\"starknet_chainId\"));\n        return this.chainId;\n    }\n    /**\n   * NEW: Returns the version of the Starknet JSON-RPC specification being used\n   */ async getSpecVersion() {\n        return this.fetchEndpoint(\"starknet_specVersion\");\n    }\n    async getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getNonce\", {\n            contract_address,\n            block_id\n        });\n    }\n    /**\n   * @deprecated use getBlockWithTxHashes or getBlockWithTxs (will be removed on sequencer deprecation)\n   */ async getBlock(blockIdentifier = this.blockIdentifier) {\n        return this.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseGetBlockResponse);\n    }\n    /**\n   * Get the most recent accepted block hash and number\n   */ async getBlockLatestAccepted() {\n        return this.fetchEndpoint(\"starknet_blockHashAndNumber\");\n    }\n    /**\n   * @deprecated redundant use getBlockLatestAccepted();\n   * Get the most recent accepted block number\n   * @returns Number of the latest block\n   */ async getBlockNumber() {\n        return this.fetchEndpoint(\"starknet_blockNumber\");\n    }\n    async getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockWithTxHashes\", {\n            block_id\n        });\n    }\n    async getBlockWithTxs(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockWithTxs\", {\n            block_id\n        });\n    }\n    async getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getStateUpdate\", {\n            block_id\n        });\n    }\n    async getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_traceBlockTransactions\", {\n            block_id\n        });\n    }\n    async getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockTransactionCount\", {\n            block_id\n        });\n    }\n    /**\n   * Return transactions from pending block\n   * @deprecated Instead use getBlock(BlockTag.pending); (will be removed in next minor version)\n   */ async getPendingTransactions() {\n        const { transactions } = await this.getBlock(\"pending\" /* pending */ );\n        return Promise.all(transactions.map((it)=>this.getTransactionByHash(it)));\n    }\n    /**\n   * @deprecated use getTransactionByHash or getTransactionByBlockIdAndIndex (will be removed on sequencer deprecation)\n   */ async getTransaction(txHash) {\n        return this.getTransactionByHash(txHash).then(this.responseParser.parseGetTransactionResponse);\n    }\n    async getTransactionByHash(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_getTransactionByHash\", {\n            transaction_hash\n        });\n    }\n    async getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getTransactionByBlockIdAndIndex\", {\n            block_id,\n            index\n        });\n    }\n    async getTransactionReceipt(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_getTransactionReceipt\", {\n            transaction_hash\n        });\n    }\n    async getTransactionTrace(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_traceTransaction\", {\n            transaction_hash\n        });\n    }\n    /**\n   * NEW: Get the status of a transaction\n   */ async getTransactionStatus(transactionHash) {\n        const transaction_hash = toHex(transactionHash);\n        return this.fetchEndpoint(\"starknet_getTransactionStatus\", {\n            transaction_hash\n        });\n    }\n    /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */ async simulateTransaction(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false, skipFeeCharge = true }) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const simulationFlags = [];\n        if (skipValidate) simulationFlags.push(rpc_exports.ESimulationFlag.SKIP_VALIDATE);\n        if (skipFeeCharge) simulationFlags.push(rpc_exports.ESimulationFlag.SKIP_FEE_CHARGE);\n        return this.fetchEndpoint(\"starknet_simulateTransactions\", {\n            block_id,\n            transactions: invocations.map((it)=>this.buildTransaction(it)),\n            simulation_flags: simulationFlags\n        }).then(this.responseParser.parseSimulateTransactionResponse);\n    }\n    async waitForTransaction(txHash, options) {\n        const transactionHash = toHex(txHash);\n        let { retries } = this;\n        let onchain = false;\n        let isErrorState = false;\n        const retryInterval = options?.retryInterval ?? 5e3;\n        const errorStates = options?.errorStates ?? [\n            rpc_exports.ETransactionStatus.REJECTED,\n            rpc_exports.ETransactionExecutionStatus.REVERTED\n        ];\n        const successStates = options?.successStates ?? [\n            rpc_exports.ETransactionExecutionStatus.SUCCEEDED,\n            rpc_exports.ETransactionStatus.ACCEPTED_ON_L2,\n            rpc_exports.ETransactionStatus.ACCEPTED_ON_L1\n        ];\n        let txStatus;\n        while(!onchain){\n            await wait(retryInterval);\n            try {\n                txStatus = await this.getTransactionStatus(transactionHash);\n                const executionStatus = txStatus.execution_status;\n                const finalityStatus = txStatus.finality_status;\n                if (!finalityStatus) {\n                    const error = new Error(\"waiting for transaction status\");\n                    throw error;\n                }\n                if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {\n                    onchain = true;\n                } else if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n                    const message = `${executionStatus}: ${finalityStatus}`;\n                    const error = new Error(message);\n                    error.response = txStatus;\n                    isErrorState = true;\n                    throw error;\n                }\n            } catch (error) {\n                if (error instanceof Error && isErrorState) {\n                    throw error;\n                }\n                if (retries <= 0) {\n                    throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n                }\n            }\n            retries -= 1;\n        }\n        let txReceipt = null;\n        while(txReceipt === null){\n            try {\n                txReceipt = await this.getTransactionReceipt(transactionHash);\n            } catch (error) {\n                if (retries <= 0) {\n                    throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n                }\n            }\n            retries -= 1;\n            await wait(retryInterval);\n        }\n        return txReceipt;\n    }\n    async getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const parsedKey = toStorageKey(key);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getStorageAt\", {\n            contract_address,\n            key: parsedKey,\n            block_id\n        });\n    }\n    async getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClassHashAt\", {\n            block_id,\n            contract_address\n        });\n    }\n    async getClassByHash(classHash) {\n        return this.getClass(classHash);\n    }\n    async getClass(classHash, blockIdentifier = this.blockIdentifier) {\n        const class_hash = toHex(classHash);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClass\", {\n            class_hash,\n            block_id\n        }).then(this.responseParser.parseContractClassResponse);\n    }\n    async getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClassAt\", {\n            block_id,\n            contract_address\n        }).then(this.responseParser.parseContractClassResponse);\n    }\n    async getCode(_contractAddress, _blockIdentifier) {\n        throw new Error(\"RPC does not implement getCode function\");\n    }\n    async getContractVersion(contractAddress, classHash, { blockIdentifier = this.blockIdentifier, compiler = true } = {}) {\n        let contractClass;\n        if (contractAddress) {\n            contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n        } else if (classHash) {\n            contractClass = await this.getClass(classHash, blockIdentifier);\n        } else {\n            throw Error(\"getContractVersion require contractAddress or classHash\");\n        }\n        if (isSierra(contractClass)) {\n            if (compiler) {\n                const abiTest = getAbiContractVersion(contractClass.abi);\n                return {\n                    cairo: \"1\",\n                    compiler: abiTest.compiler\n                };\n            }\n            return {\n                cairo: \"1\",\n                compiler: void 0\n            };\n        }\n        return {\n            cairo: \"0\",\n            compiler: \"0\"\n        };\n    }\n    /**\n   * @deprecated use get*type*EstimateFee (will be refactored based on type after sequencer deprecation)\n   */ async getEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier) {\n        return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier);\n    }\n    async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const transaction1 = this.buildTransaction({\n            type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n            ...invocation,\n            ...invocationDetails\n        }, \"fee\");\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: [\n                transaction1\n            ],\n            block_id\n        }).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getDeclareEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const transaction1 = this.buildTransaction({\n            type: \"DECLARE\" /* DECLARE */ ,\n            ...invocation,\n            ...details\n        }, \"fee\");\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: [\n                transaction1\n            ],\n            block_id\n        }).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getDeployAccountEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const transaction1 = this.buildTransaction({\n            type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n            ...invocation,\n            ...details\n        }, \"fee\");\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: [\n                transaction1\n            ],\n            block_id\n        }).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getEstimateFeeBulk(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false }) {\n        if (skipValidate) {\n            console.warn(\"getEstimateFeeBulk RPC does not support skipValidate\");\n        }\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: invocations.map((it)=>this.buildTransaction(it, \"fee\")),\n            block_id\n        }).then(this.responseParser.parseFeeEstimateBulkResponse);\n    }\n    async invokeFunction(functionInvocation, details) {\n        return this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n            invoke_transaction: {\n                sender_address: functionInvocation.contractAddress,\n                calldata: CallData.toHex(functionInvocation.calldata),\n                type: rpc_exports.ETransactionType.INVOKE,\n                max_fee: toHex(details.maxFee || 0),\n                version: \"0x1\",\n                signature: signatureToHexArray(functionInvocation.signature),\n                nonce: toHex(details.nonce)\n            }\n        });\n    }\n    async declareContract({ contract, signature, senderAddress, compiledClassHash }, details) {\n        if (!isSierra(contract)) {\n            return this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n                declare_transaction: {\n                    type: rpc_exports.ETransactionType.DECLARE,\n                    contract_class: {\n                        program: contract.program,\n                        entry_points_by_type: contract.entry_points_by_type,\n                        abi: contract.abi\n                    },\n                    version: HEX_STR_TRANSACTION_VERSION_1,\n                    max_fee: toHex(details.maxFee || 0),\n                    signature: signatureToHexArray(signature),\n                    sender_address: senderAddress,\n                    nonce: toHex(details.nonce)\n                }\n            });\n        }\n        return this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n            declare_transaction: {\n                type: rpc_exports.ETransactionType.DECLARE,\n                contract_class: {\n                    sierra_program: decompressProgram(contract.sierra_program),\n                    contract_class_version: contract.contract_class_version,\n                    entry_points_by_type: contract.entry_points_by_type,\n                    abi: contract.abi\n                },\n                compiled_class_hash: compiledClassHash || \"\",\n                version: HEX_STR_TRANSACTION_VERSION_2,\n                max_fee: toHex(details.maxFee || 0),\n                signature: signatureToHexArray(signature),\n                sender_address: senderAddress,\n                nonce: toHex(details.nonce)\n            }\n        });\n    }\n    async deployAccountContract({ classHash, constructorCalldata, addressSalt, signature }, details) {\n        return this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n            deploy_account_transaction: {\n                constructor_calldata: CallData.toHex(constructorCalldata || []),\n                class_hash: toHex(classHash),\n                contract_address_salt: toHex(addressSalt || 0),\n                type: rpc_exports.ETransactionType.DEPLOY_ACCOUNT,\n                max_fee: toHex(details.maxFee || 0),\n                version: toHex(details.version || 0),\n                signature: signatureToHexArray(signature),\n                nonce: toHex(details.nonce)\n            }\n        });\n    }\n    async callContract(call, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const result = await this.fetchEndpoint(\"starknet_call\", {\n            request: {\n                contract_address: call.contractAddress,\n                entry_point_selector: getSelectorFromName(call.entrypoint),\n                calldata: CallData.toHex(call.calldata)\n            },\n            block_id\n        });\n        return this.responseParser.parseCallContractResponse(result);\n    }\n    /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */ async estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {\n        const { from_address, to_address, entry_point_selector, payload } = message;\n        const formattedMessage = {\n            from_address: toHex(from_address),\n            to_address: toHex(to_address),\n            entry_point_selector: getSelector(entry_point_selector),\n            payload: getHexStringArray(payload)\n        };\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_estimateMessageFee\", {\n            message: formattedMessage,\n            block_id\n        });\n    }\n    /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */ async getSyncingStats() {\n        return this.fetchEndpoint(\"starknet_syncing\");\n    }\n    /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */ async getEvents(eventFilter) {\n        return this.fetchEndpoint(\"starknet_getEvents\", {\n            filter: eventFilter\n        });\n    }\n    /**\n   * StarknetId Endpoint (get name from address)\n   */ async getStarkName(address, StarknetIdContract2) {\n        return getStarkName(this, address, StarknetIdContract2);\n    }\n    /**\n   * StarknetId Endpoint (get address from name)\n   */ async getAddressFromStarkName(name, StarknetIdContract2) {\n        return getAddressFromStarkName(this, name, StarknetIdContract2);\n    }\n    buildTransaction(invocation, versionType) {\n        const defaultVersions = getVersionsByType(versionType);\n        const details = {\n            signature: signatureToHexArray(invocation.signature),\n            nonce: toHex(invocation.nonce),\n            max_fee: toHex(invocation.maxFee || 0)\n        };\n        if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */ ) {\n            return {\n                type: rpc_exports.ETransactionType.INVOKE,\n                // Diff between sequencer and rpc invoke type\n                sender_address: invocation.contractAddress,\n                calldata: CallData.toHex(invocation.calldata),\n                version: toHex(invocation.version || defaultVersions.v1),\n                ...details\n            };\n        }\n        if (invocation.type === \"DECLARE\" /* DECLARE */ ) {\n            if (!isSierra(invocation.contract)) {\n                return {\n                    type: invocation.type,\n                    contract_class: invocation.contract,\n                    sender_address: invocation.senderAddress,\n                    version: toHex(invocation.version || defaultVersions.v1),\n                    ...details\n                };\n            }\n            return {\n                // compiled_class_hash\n                type: invocation.type,\n                contract_class: {\n                    ...invocation.contract,\n                    sierra_program: decompressProgram(invocation.contract.sierra_program)\n                },\n                compiled_class_hash: invocation.compiledClassHash || \"\",\n                sender_address: invocation.senderAddress,\n                version: toHex(invocation.version || defaultVersions.v2),\n                ...details\n            };\n        }\n        if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ) {\n            return {\n                type: invocation.type,\n                constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n                class_hash: toHex(invocation.classHash),\n                contract_address_salt: toHex(invocation.addressSalt || 0),\n                version: toHex(invocation.version || defaultVersions.v1),\n                ...details\n            };\n        }\n        throw Error(\"RPC buildTransaction received unknown TransactionType\");\n    }\n};\n// src/provider/sequencer.ts\nvar import_url_join2 = __toESM(__webpack_require__(/*! url-join */ \"(ssr)/./node_modules/url-join/lib/url-join.js\"));\n// src/utils/responseParser/index.ts\nvar ResponseParser = class {\n};\n// src/utils/responseParser/sequencer.ts\nvar SequencerAPIResponseParser = class extends ResponseParser {\n    parseGetBlockResponse(res) {\n        return {\n            ...res,\n            new_root: res.state_root,\n            parent_hash: res.parent_block_hash,\n            transactions: Object.values(res.transactions).map((value)=>\"transaction_hash\" in value && value.transaction_hash).filter(Boolean)\n        };\n    }\n    parseGetTransactionResponse(res) {\n        if (res.status === \"NOT_RECEIVED\" /* NOT_RECEIVED */  && res.finality_status === \"NOT_RECEIVED\" /* NOT_RECEIVED */ ) {\n            throw new LibraryError();\n        }\n        return {\n            ...res,\n            calldata: \"calldata\" in res.transaction ? res.transaction.calldata : [],\n            contract_class: \"contract_class\" in res.transaction ? res.transaction.contract_class : void 0,\n            entry_point_selector: \"entry_point_selector\" in res.transaction ? res.transaction.entry_point_selector : void 0,\n            max_fee: \"max_fee\" in res.transaction ? res.transaction.max_fee : void 0,\n            nonce: res.transaction.nonce,\n            sender_address: \"sender_address\" in res.transaction ? res.transaction.sender_address : void 0,\n            signature: \"signature\" in res.transaction ? res.transaction.signature : void 0,\n            transaction_hash: \"transaction_hash\" in res.transaction ? res.transaction.transaction_hash : void 0,\n            version: \"version\" in res.transaction ? res.transaction.version : void 0\n        };\n    }\n    parseGetTransactionReceiptResponse(res) {\n        return {\n            ...res,\n            messages_sent: res.l2_to_l1_messages,\n            ...\"revert_error\" in res && {\n                revert_reason: res.revert_error\n            }\n        };\n    }\n    parseFeeEstimateResponse(res) {\n        if (\"overall_fee\" in res) {\n            let gasInfo = {};\n            try {\n                gasInfo = {\n                    gas_consumed: toBigInt(res.gas_usage),\n                    gas_price: toBigInt(res.gas_price)\n                };\n            } catch  {}\n            return {\n                overall_fee: toBigInt(res.overall_fee),\n                ...gasInfo\n            };\n        }\n        return {\n            overall_fee: toBigInt(res.amount)\n        };\n    }\n    parseFeeEstimateBulkResponse(res) {\n        return [].concat(res).map((item)=>{\n            if (\"overall_fee\" in item) {\n                let gasInfo = {};\n                try {\n                    gasInfo = {\n                        gas_consumed: toBigInt(item.gas_usage),\n                        gas_price: toBigInt(item.gas_price)\n                    };\n                } catch  {}\n                return {\n                    overall_fee: toBigInt(item.overall_fee),\n                    ...gasInfo\n                };\n            }\n            return {\n                overall_fee: toBigInt(item.amount)\n            };\n        });\n    }\n    parseSimulateTransactionResponse(res) {\n        const suggestedMaxFee = \"overall_fee\" in res.fee_estimation ? res.fee_estimation.overall_fee : res.fee_estimation.amount;\n        return [\n            {\n                transaction_trace: res.trace,\n                fee_estimation: res.fee_estimation,\n                suggestedMaxFee: estimatedFeeToMaxFee(BigInt(suggestedMaxFee))\n            }\n        ];\n    }\n    parseCallContractResponse(res) {\n        return {\n            result: res.result\n        };\n    }\n    parseInvokeFunctionResponse(res) {\n        return {\n            transaction_hash: res.transaction_hash\n        };\n    }\n    parseDeployContractResponse(res) {\n        return {\n            transaction_hash: res.transaction_hash,\n            contract_address: res.address\n        };\n    }\n    parseDeclareContractResponse(res) {\n        return {\n            transaction_hash: res.transaction_hash,\n            class_hash: res.class_hash\n        };\n    }\n    parseGetStateUpdateResponse(res) {\n        const nonces = Object.entries(res.state_diff.nonces).map(([contract_address, nonce])=>({\n                contract_address,\n                nonce\n            }));\n        const storage_diffs = Object.entries(res.state_diff.storage_diffs).map(([address, storage_entries])=>({\n                address,\n                storage_entries\n            }));\n        return {\n            ...res,\n            state_diff: {\n                ...res.state_diff,\n                storage_diffs,\n                nonces\n            }\n        };\n    }\n    parseContractClassResponse(res) {\n        const response = isSierra(res) ? res : parseContract(res);\n        return {\n            ...response,\n            abi: typeof response.abi === \"string\" ? JSON.parse(response.abi) : response.abi\n        };\n    }\n};\n// src/utils/url.ts\nvar import_url_join = __toESM(__webpack_require__(/*! url-join */ \"(ssr)/./node_modules/url-join/lib/url-join.js\"));\nvar protocolAndDomainRE = /^(?:\\w+:)?\\/\\/(\\S+)$/;\nvar localhostDomainRE = /^localhost[:?\\d]*(?:[^:?\\d]\\S*)?$/;\nvar nonLocalhostDomainRE = /^[^\\s.]+\\.\\S{2,}$/;\nfunction isUrl(s) {\n    if (!s) {\n        return false;\n    }\n    if (typeof s !== \"string\") {\n        return false;\n    }\n    const match = s.match(protocolAndDomainRE);\n    if (!match) {\n        return false;\n    }\n    const everythingAfterProtocol = match[1];\n    if (!everythingAfterProtocol) {\n        return false;\n    }\n    if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {\n        return true;\n    }\n    return false;\n}\nfunction buildUrl(baseUrl, defaultPath, urlOrPath) {\n    return isUrl(urlOrPath) ? urlOrPath : (0, import_url_join.default)(baseUrl, urlOrPath ?? defaultPath);\n}\n// src/provider/sequencer.ts\nfunction isEmptyQueryObject(obj) {\n    return obj === void 0 || Object.keys(obj).length === 0 || Object.keys(obj).length === 1 && Object.entries(obj).every(([k, v])=>k === \"blockIdentifier\" && v === null);\n}\nvar defaultOptions2 = {\n    network: \"SN_GOERLI\" /* SN_GOERLI */ ,\n    blockIdentifier: \"pending\" /* pending */ \n};\nvar SequencerProvider = class {\n    constructor(optionsOrProvider = defaultOptions2){\n        this.responseParser = new SequencerAPIResponseParser();\n        if (\"network\" in optionsOrProvider) {\n            this.baseUrl = SequencerProvider.getNetworkFromName(optionsOrProvider.network);\n            this.feederGatewayUrl = buildUrl(this.baseUrl, \"feeder_gateway\");\n            this.gatewayUrl = buildUrl(this.baseUrl, \"gateway\");\n        } else {\n            this.baseUrl = optionsOrProvider.baseUrl;\n            this.feederGatewayUrl = buildUrl(this.baseUrl, \"feeder_gateway\", optionsOrProvider.feederGatewayUrl);\n            this.gatewayUrl = buildUrl(this.baseUrl, \"gateway\", optionsOrProvider.gatewayUrl);\n        }\n        this.chainId = optionsOrProvider?.chainId ?? SequencerProvider.getChainIdFromBaseUrl(this.baseUrl);\n        this.headers = optionsOrProvider.headers;\n        this.blockIdentifier = optionsOrProvider?.blockIdentifier || defaultOptions2.blockIdentifier;\n    }\n    static getNetworkFromName(name) {\n        switch(name){\n            case \"SN_MAIN\" /* SN_MAIN */ :\n            case \"0x534e5f4d41494e\" /* SN_MAIN */ :\n                return \"https://alpha-mainnet.starknet.io\" /* SN_MAIN */ ;\n            case \"SN_GOERLI\" /* SN_GOERLI */ :\n            case \"0x534e5f474f45524c49\" /* SN_GOERLI */ :\n                return \"https://alpha4.starknet.io\" /* SN_GOERLI */ ;\n            default:\n                throw new Error(\"Could not detect base url from NetworkName\");\n        }\n    }\n    static getChainIdFromBaseUrl(baseUrl) {\n        try {\n            const url = new URL(baseUrl);\n            if (url.host.includes(\"mainnet.starknet.io\")) {\n                return \"0x534e5f4d41494e\" /* SN_MAIN */ ;\n            }\n            return \"0x534e5f474f45524c49\" /* SN_GOERLI */ ;\n        } catch  {\n            console.error(`Could not parse baseUrl: ${baseUrl}`);\n            return \"0x534e5f474f45524c49\" /* SN_GOERLI */ ;\n        }\n    }\n    getFetchUrl(endpoint) {\n        const gatewayUrlEndpoints = [\n            \"add_transaction\"\n        ];\n        return gatewayUrlEndpoints.includes(endpoint) ? this.gatewayUrl : this.feederGatewayUrl;\n    }\n    getFetchMethod(endpoint) {\n        const postMethodEndpoints = [\n            \"add_transaction\",\n            \"call_contract\",\n            \"estimate_fee\",\n            \"estimate_message_fee\",\n            \"estimate_fee_bulk\",\n            \"simulate_transaction\"\n        ];\n        return postMethodEndpoints.includes(endpoint) ? \"POST\" : \"GET\";\n    }\n    getQueryString(query) {\n        if (isEmptyQueryObject(query)) {\n            return \"\";\n        }\n        const queryString = Object.entries(query).map(([key, value])=>{\n            if (key === \"blockIdentifier\") {\n                const block = new Block(value);\n                return `${block.queryIdentifier}`;\n            }\n            return `${key}=${value}`;\n        }).join(\"&\");\n        return `?${queryString}`;\n    }\n    getHeaders(method) {\n        if (method === \"POST\") {\n            return {\n                \"Content-Type\": \"application/json\",\n                ...this.headers\n            };\n        }\n        return this.headers;\n    }\n    // typesafe fetch\n    async fetchEndpoint(endpoint, ...[query, request]) {\n        const baseUrl = this.getFetchUrl(endpoint);\n        const method = this.getFetchMethod(endpoint);\n        const queryString = this.getQueryString(query);\n        const url = (0, import_url_join2.default)(baseUrl, endpoint, queryString);\n        return this.fetch(url, {\n            method,\n            body: request\n        });\n    }\n    async fetch(endpoint, options) {\n        const url = buildUrl(this.baseUrl, \"\", endpoint);\n        const method = options?.method ?? \"GET\";\n        const headers = this.getHeaders(method);\n        const body = stringify2(options?.body);\n        try {\n            const response = await fetchPonyfill_default(url, {\n                method,\n                body,\n                headers\n            });\n            const textResponse = await response.text();\n            if (!response.ok) {\n                let responseBody;\n                try {\n                    responseBody = parse2(textResponse);\n                } catch  {\n                    throw new HttpError(response.statusText, response.status);\n                }\n                throw new GatewayError(responseBody.message, responseBody.code);\n            }\n            const parseChoice = options?.parseAlwaysAsBigInt ? parseAlwaysAsBig : parse2;\n            return parseChoice(textResponse);\n        } catch (error) {\n            if (error instanceof Error && !(error instanceof LibraryError)) throw Error(`Could not ${method} from endpoint \\`${url}\\`: ${error.message}`);\n            throw error;\n        }\n    }\n    async getChainId() {\n        return Promise.resolve(this.chainId);\n    }\n    async callContract({ contractAddress, entrypoint: entryPointSelector, calldata = [] }, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"call_contract\", {\n            blockIdentifier\n        }, {\n            // TODO - determine best choice once both are fully supported in devnet\n            // signature: [],\n            // sender_address: contractAddress,\n            contract_address: contractAddress,\n            entry_point_selector: getSelectorFromName(entryPointSelector),\n            calldata: CallData.compile(calldata)\n        }).then(this.responseParser.parseCallContractResponse);\n    }\n    async getBlock(blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_block\", {\n            blockIdentifier\n        }).then(this.responseParser.parseGetBlockResponse);\n    }\n    async getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_nonce\", {\n            contractAddress,\n            blockIdentifier\n        });\n    }\n    async getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n        const parsedKey = toBigInt(key).toString(10);\n        return this.fetchEndpoint(\"get_storage_at\", {\n            blockIdentifier,\n            contractAddress,\n            key: parsedKey\n        });\n    }\n    async getTransaction(txHash) {\n        const txHashHex = toHex(txHash);\n        return this.fetchEndpoint(\"get_transaction\", {\n            transactionHash: txHashHex\n        }).then((result)=>{\n            if (Object.values(result).length === 1) throw new LibraryError(result.status);\n            return this.responseParser.parseGetTransactionResponse(result);\n        });\n    }\n    async getTransactionReceipt(txHash) {\n        const txHashHex = toHex(txHash);\n        return this.fetchEndpoint(\"get_transaction_receipt\", {\n            transactionHash: txHashHex\n        }).then(this.responseParser.parseGetTransactionReceiptResponse);\n    }\n    async getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_full_contract\", {\n            blockIdentifier,\n            contractAddress\n        }).then(this.responseParser.parseContractClassResponse);\n    }\n    async getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_class_hash_at\", {\n            blockIdentifier,\n            contractAddress\n        });\n    }\n    async getClassByHash(classHash, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_class_by_hash\", {\n            classHash,\n            blockIdentifier\n        }).then(this.responseParser.parseContractClassResponse);\n    }\n    async getCompiledClassByClassHash(classHash, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_compiled_class_by_class_hash\", {\n            classHash,\n            blockIdentifier\n        });\n    }\n    async getContractVersion(contractAddress, classHash, { blockIdentifier = this.blockIdentifier, compiler = true } = {}) {\n        let contractClass;\n        if (contractAddress) {\n            contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n        } else if (classHash) {\n            contractClass = await this.getClassByHash(classHash, blockIdentifier);\n        } else {\n            throw Error(\"getContractVersion require contractAddress or classHash\");\n        }\n        if (isSierra(contractClass)) {\n            if (compiler) {\n                const abiTest = getAbiContractVersion(contractClass.abi);\n                return {\n                    cairo: \"1\",\n                    compiler: abiTest.compiler\n                };\n            }\n            return {\n                cairo: \"1\",\n                compiler: void 0\n            };\n        }\n        return {\n            cairo: \"0\",\n            compiler: \"0\"\n        };\n    }\n    async invokeFunction(functionInvocation, details) {\n        return this.fetchEndpoint(\"add_transaction\", void 0, {\n            type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n            sender_address: functionInvocation.contractAddress,\n            calldata: CallData.compile(functionInvocation.calldata ?? []),\n            signature: signatureToDecimalArray(functionInvocation.signature),\n            nonce: toHex(details.nonce),\n            max_fee: toHex(details.maxFee || 0),\n            version: \"0x1\"\n        }).then(this.responseParser.parseInvokeFunctionResponse);\n    }\n    async deployAccountContract({ classHash, constructorCalldata, addressSalt, signature }, details) {\n        return this.fetchEndpoint(\"add_transaction\", void 0, {\n            type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n            contract_address_salt: addressSalt ?? randomAddress(),\n            constructor_calldata: CallData.compile(constructorCalldata ?? []),\n            class_hash: toHex(classHash),\n            max_fee: toHex(details.maxFee || 0),\n            version: toHex(details.version || 0),\n            nonce: toHex(details.nonce),\n            signature: signatureToDecimalArray(signature)\n        }).then(this.responseParser.parseDeployContractResponse);\n    }\n    async declareContract({ senderAddress, contract, signature, compiledClassHash }, details) {\n        if (!isSierra(contract)) {\n            return this.fetchEndpoint(\"add_transaction\", void 0, {\n                type: \"DECLARE\" /* DECLARE */ ,\n                contract_class: contract,\n                nonce: toHex(details.nonce),\n                signature: signatureToDecimalArray(signature),\n                sender_address: senderAddress,\n                max_fee: toHex(details.maxFee || 0),\n                version: toHex(transactionVersion)\n            }).then(this.responseParser.parseDeclareContractResponse);\n        }\n        return this.fetchEndpoint(\"add_transaction\", void 0, {\n            type: \"DECLARE\" /* DECLARE */ ,\n            sender_address: senderAddress,\n            compiled_class_hash: compiledClassHash,\n            contract_class: contract,\n            nonce: toHex(details.nonce),\n            signature: signatureToDecimalArray(signature),\n            max_fee: toHex(details.maxFee || 0),\n            version: toHex(transactionVersion_2)\n        }).then(this.responseParser.parseDeclareContractResponse);\n    }\n    async getEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n        return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate);\n    }\n    async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n        const transaction1 = this.buildTransaction({\n            type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n            ...invocation,\n            ...invocationDetails\n        }, \"fee\");\n        return this.fetchEndpoint(\"estimate_fee\", {\n            blockIdentifier,\n            skipValidate\n        }, transaction1).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getDeclareEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n        const transaction1 = this.buildTransaction({\n            type: \"DECLARE\" /* DECLARE */ ,\n            ...invocation,\n            ...details\n        }, \"fee\");\n        return this.fetchEndpoint(\"estimate_fee\", {\n            blockIdentifier,\n            skipValidate\n        }, transaction1).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getDeployAccountEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n        const transaction1 = this.buildTransaction({\n            type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n            ...invocation,\n            ...details\n        }, \"fee\");\n        return this.fetchEndpoint(\"estimate_fee\", {\n            blockIdentifier,\n            skipValidate\n        }, transaction1).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getEstimateFeeBulk(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false }) {\n        const transactions = invocations.map((it)=>this.buildTransaction(it, \"fee\"));\n        return this.fetchEndpoint(\"estimate_fee_bulk\", {\n            blockIdentifier,\n            skipValidate\n        }, transactions).then(this.responseParser.parseFeeEstimateBulkResponse);\n    }\n    async getCode(contractAddress, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_code\", {\n            contractAddress,\n            blockIdentifier\n        });\n    }\n    async waitForTransaction(txHash, options) {\n        let res;\n        let completed = false;\n        let retries = 0;\n        const retryInterval = options?.retryInterval ?? 5e3;\n        const errorStates = options?.errorStates ?? [\n            \"REJECTED\" /* REJECTED */ ,\n            \"NOT_RECEIVED\" /* NOT_RECEIVED */ ,\n            \"REVERTED\" /* REVERTED */ \n        ];\n        const successStates = options?.successStates ?? [\n            \"SUCCEEDED\" /* SUCCEEDED */ ,\n            \"ACCEPTED_ON_L1\" /* ACCEPTED_ON_L1 */ ,\n            \"ACCEPTED_ON_L2\" /* ACCEPTED_ON_L2 */ \n        ];\n        while(!completed){\n            await wait(retryInterval);\n            res = await this.getTransactionStatus(txHash);\n            if (\"NOT_RECEIVED\" /* NOT_RECEIVED */  === res.finality_status && retries < 3) {\n                retries += 1;\n            } else if (successStates.includes(res.finality_status) || successStates.includes(res.execution_status)) {\n                completed = true;\n            } else if (errorStates.includes(res.finality_status) || errorStates.includes(res.execution_status)) {\n                let message;\n                if (res.tx_failure_reason) {\n                    message = `${res.tx_status}: ${res.tx_failure_reason.code}\n${res.tx_failure_reason.error_message}`;\n                } else if (res.tx_revert_reason) {\n                    message = `${res.tx_status}: ${res.tx_revert_reason}`;\n                } else {\n                    message = res.tx_status;\n                }\n                const error = new Error(message);\n                error.response = res;\n                throw error;\n            }\n        }\n        const txReceipt = await this.getTransactionReceipt(txHash);\n        return txReceipt;\n    }\n    /**\n   * Gets the status of a transaction.\n   * @param txHash BigNumberish\n   * @returns GetTransactionStatusResponse - the transaction status object\n   */ async getTransactionStatus(txHash) {\n        const txHashHex = toHex(txHash);\n        return this.fetchEndpoint(\"get_transaction_status\", {\n            transactionHash: txHashHex\n        });\n    }\n    /**\n   * Gets the smart contract address on the goerli testnet.\n   * @returns GetContractAddressesResponse - starknet smart contract addresses\n   */ async getContractAddresses() {\n        return this.fetchEndpoint(\"get_contract_addresses\");\n    }\n    /**\n   * Gets the transaction trace from a tx id.\n   * @param txHash BigNumberish\n   * @returns TransactionTraceResponse - the transaction trace\n   */ async getTransactionTrace(txHash) {\n        const txHashHex = toHex(txHash);\n        return this.fetchEndpoint(\"get_transaction_trace\", {\n            transactionHash: txHashHex\n        });\n    }\n    async estimateMessageFee({ from_address, to_address, entry_point_selector, payload }, blockIdentifier = this.blockIdentifier) {\n        const validCallL1Handler = {\n            from_address: getDecimalString(from_address),\n            to_address: getHexString(to_address),\n            entry_point_selector: getSelector(entry_point_selector),\n            payload: getHexStringArray(payload)\n        };\n        return this.fetchEndpoint(\"estimate_message_fee\", {\n            blockIdentifier\n        }, validCallL1Handler);\n    }\n    /**\n   * Simulate transaction using Sequencer provider\n   * WARNING!: Sequencer will process only first element from invocations array\n   *\n   * @param invocations Array of invocations, but only first invocation will be processed\n   * @param blockIdentifier block identifier, default 'latest'\n   * @param skipValidate Skip Account __validate__ method\n   * @returns\n   */ async getSimulateTransaction(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false, skipExecute = false }) {\n        if (invocations.length > 1) {\n            console.warn(\"Sequencer simulate process only first element from invocations list\");\n        }\n        if (skipExecute) {\n            console.warn(\"Sequencer can't skip account __execute__\");\n        }\n        const transaction1 = this.buildTransaction(invocations[0]);\n        return this.fetchEndpoint(\"simulate_transaction\", {\n            blockIdentifier,\n            skipValidate: skipValidate ?? false\n        }, transaction1).then(this.responseParser.parseSimulateTransactionResponse);\n    }\n    async getStateUpdate(blockIdentifier = this.blockIdentifier) {\n        const args = new Block(blockIdentifier).sequencerIdentifier;\n        return this.fetchEndpoint(\"get_state_update\", {\n            ...args\n        }).then(this.responseParser.parseGetStateUpdateResponse);\n    }\n    // consider adding an optional trace retrieval parameter to the getBlock method\n    async getBlockTraces(blockIdentifier = this.blockIdentifier) {\n        const args = new Block(blockIdentifier).sequencerIdentifier;\n        return this.fetchEndpoint(\"get_block_traces\", {\n            ...args\n        });\n    }\n    async getStarkName(address, StarknetIdContract2) {\n        return getStarkName(this, address, StarknetIdContract2);\n    }\n    async getAddressFromStarkName(name, StarknetIdContract2) {\n        return getAddressFromStarkName(this, name, StarknetIdContract2);\n    }\n    /**\n   * Build Single AccountTransaction from Single AccountInvocation\n   * @param invocation AccountInvocationItem\n   * @param versionType 'fee' | 'transaction' - used to determine default versions\n   * @returns AccountTransactionItem\n   */ buildTransaction(invocation, versionType) {\n        const defaultVersions = getVersionsByType(versionType);\n        const details = {\n            signature: signatureToDecimalArray(invocation.signature),\n            nonce: toHex(invocation.nonce)\n        };\n        if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */ ) {\n            return {\n                type: invocation.type,\n                sender_address: invocation.contractAddress,\n                calldata: CallData.compile(invocation.calldata ?? []),\n                version: toHex(invocation.version || defaultVersions.v1),\n                ...details\n            };\n        }\n        if (invocation.type === \"DECLARE\" /* DECLARE */ ) {\n            if (!isSierra(invocation.contract)) {\n                return {\n                    type: invocation.type,\n                    contract_class: invocation.contract,\n                    sender_address: invocation.senderAddress,\n                    version: toHex(invocation.version || defaultVersions.v1),\n                    // fee from getDeclareEstimateFee use t.v. instead of feet.v.\n                    ...details\n                };\n            }\n            return {\n                type: invocation.type,\n                contract_class: invocation.contract,\n                compiled_class_hash: invocation.compiledClassHash,\n                sender_address: invocation.senderAddress,\n                version: toHex(invocation.version || defaultVersions.v2),\n                // fee on getDeclareEstimateFee use t.v. instead of feet.v.\n                ...details\n            };\n        }\n        if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ) {\n            return {\n                type: invocation.type,\n                constructor_calldata: CallData.compile(invocation.constructorCalldata || []),\n                class_hash: toHex(invocation.classHash),\n                contract_address_salt: toHex(invocation.addressSalt || 0),\n                version: toHex(invocation.version || defaultVersions.v1),\n                ...details\n            };\n        }\n        throw Error(\"Sequencer buildTransaction received unknown TransactionType\");\n    }\n};\n// src/provider/default.ts\nvar Provider = class {\n    constructor(providerOrOptions){\n        if (providerOrOptions instanceof Provider) {\n            this.provider = providerOrOptions.provider;\n        } else if (providerOrOptions instanceof RpcProvider || providerOrOptions instanceof SequencerProvider) {\n            this.provider = providerOrOptions;\n        } else if (providerOrOptions && \"rpc\" in providerOrOptions) {\n            this.provider = new RpcProvider(providerOrOptions.rpc);\n        } else if (providerOrOptions && \"sequencer\" in providerOrOptions) {\n            this.provider = new SequencerProvider(providerOrOptions.sequencer);\n        } else {\n            this.provider = new RpcProvider();\n        }\n    }\n    async getChainId() {\n        return this.provider.getChainId();\n    }\n    async getBlock(blockIdentifier) {\n        return this.provider.getBlock(blockIdentifier);\n    }\n    async getClassAt(contractAddress, blockIdentifier) {\n        return this.provider.getClassAt(contractAddress, blockIdentifier);\n    }\n    async getClassHashAt(contractAddress, blockIdentifier) {\n        return this.provider.getClassHashAt(contractAddress, blockIdentifier);\n    }\n    getClassByHash(classHash) {\n        return this.provider.getClassByHash(classHash);\n    }\n    async getEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier) {\n        return this.provider.getEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier);\n    }\n    async getInvokeEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier, skipValidate) {\n        return this.provider.getInvokeEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier, skipValidate);\n    }\n    async getEstimateFeeBulk(invocations, options) {\n        return this.provider.getEstimateFeeBulk(invocations, options);\n    }\n    async getNonceForAddress(contractAddress, blockIdentifier) {\n        return this.provider.getNonceForAddress(contractAddress, blockIdentifier);\n    }\n    async getStorageAt(contractAddress, key, blockIdentifier) {\n        return this.provider.getStorageAt(contractAddress, key, blockIdentifier);\n    }\n    async getTransaction(txHash) {\n        return this.provider.getTransaction(txHash);\n    }\n    async getTransactionReceipt(txHash) {\n        return this.provider.getTransactionReceipt(txHash);\n    }\n    async callContract(request, blockIdentifier) {\n        return this.provider.callContract(request, blockIdentifier);\n    }\n    async invokeFunction(functionInvocation, details) {\n        return this.provider.invokeFunction(functionInvocation, details);\n    }\n    async deployAccountContract(payload, details) {\n        return this.provider.deployAccountContract(payload, details);\n    }\n    async declareContract(transaction1, details) {\n        return this.provider.declareContract(transaction1, details);\n    }\n    async getDeclareEstimateFee(transaction1, details, blockIdentifier, skipValidate) {\n        return this.provider.getDeclareEstimateFee(transaction1, details, blockIdentifier, skipValidate);\n    }\n    getDeployAccountEstimateFee(transaction1, details, blockIdentifier, skipValidate) {\n        return this.provider.getDeployAccountEstimateFee(transaction1, details, blockIdentifier, skipValidate);\n    }\n    async getCode(contractAddress, blockIdentifier) {\n        return this.provider.getCode(contractAddress, blockIdentifier);\n    }\n    async waitForTransaction(txHash, options) {\n        return this.provider.waitForTransaction(txHash, options);\n    }\n    async getSimulateTransaction(invocations, options) {\n        return this.provider.getSimulateTransaction(invocations, options);\n    }\n    async getStateUpdate(blockIdentifier) {\n        return this.provider.getStateUpdate(blockIdentifier);\n    }\n    async getStarkName(address, StarknetIdContract2) {\n        return getStarkName(this, address, StarknetIdContract2);\n    }\n    async getAddressFromStarkName(name, StarknetIdContract2) {\n        return getAddressFromStarkName(this, name, StarknetIdContract2);\n    }\n    async getContractVersion(contractAddress, classHash, options) {\n        return this.provider.getContractVersion(contractAddress, classHash, options);\n    }\n};\n// src/signer/interface.ts\nvar SignerInterface = class {\n};\n// src/utils/transaction.ts\nvar transaction_exports = {};\n__export(transaction_exports, {\n    fromCallsToExecuteCalldata: ()=>fromCallsToExecuteCalldata,\n    fromCallsToExecuteCalldataWithNonce: ()=>fromCallsToExecuteCalldataWithNonce,\n    fromCallsToExecuteCalldata_cairo1: ()=>fromCallsToExecuteCalldata_cairo1,\n    getExecuteCalldata: ()=>getExecuteCalldata,\n    transformCallsToMulticallArrays: ()=>transformCallsToMulticallArrays,\n    transformCallsToMulticallArrays_cairo1: ()=>transformCallsToMulticallArrays_cairo1\n});\nvar transformCallsToMulticallArrays = (calls)=>{\n    const callArray = [];\n    const calldata = [];\n    calls.forEach((call)=>{\n        const data = CallData.compile(call.calldata || []);\n        callArray.push({\n            to: toBigInt(call.contractAddress).toString(10),\n            selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n            data_offset: calldata.length.toString(),\n            data_len: data.length.toString()\n        });\n        calldata.push(...data);\n    });\n    return {\n        callArray,\n        calldata: CallData.compile({\n            calldata\n        })\n    };\n};\nvar fromCallsToExecuteCalldata = (calls)=>{\n    const { callArray, calldata } = transformCallsToMulticallArrays(calls);\n    const compiledCalls = CallData.compile({\n        callArray\n    });\n    return [\n        ...compiledCalls,\n        ...calldata\n    ];\n};\nvar fromCallsToExecuteCalldataWithNonce = (calls, nonce)=>{\n    return [\n        ...fromCallsToExecuteCalldata(calls),\n        toBigInt(nonce).toString()\n    ];\n};\nvar transformCallsToMulticallArrays_cairo1 = (calls)=>{\n    const callArray = calls.map((call)=>({\n            to: toBigInt(call.contractAddress).toString(10),\n            selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n            calldata: CallData.compile(call.calldata || [])\n        }));\n    return callArray;\n};\nvar fromCallsToExecuteCalldata_cairo1 = (calls)=>{\n    const orderCalls = calls.map((call)=>({\n            contractAddress: call.contractAddress,\n            entrypoint: call.entrypoint,\n            calldata: Array.isArray(call.calldata) && \"__compiled__\" in call.calldata ? call.calldata : CallData.compile(call.calldata)\n        }));\n    return CallData.compile({\n        orderCalls\n    });\n};\nvar getExecuteCalldata = (calls, cairoVersion = \"0\")=>{\n    if (cairoVersion === \"1\") {\n        return fromCallsToExecuteCalldata_cairo1(calls);\n    }\n    return fromCallsToExecuteCalldata(calls);\n};\n// src/utils/typedData.ts\nvar typedData_exports = {};\n__export(typedData_exports, {\n    encodeData: ()=>encodeData,\n    encodeType: ()=>encodeType,\n    encodeValue: ()=>encodeValue,\n    getDependencies: ()=>getDependencies,\n    getMessageHash: ()=>getMessageHash,\n    getStructHash: ()=>getStructHash,\n    getTypeHash: ()=>getTypeHash,\n    isMerkleTreeType: ()=>isMerkleTreeType,\n    prepareSelector: ()=>prepareSelector\n});\n// src/utils/merkle.ts\nvar merkle_exports = {};\n__export(merkle_exports, {\n    MerkleTree: ()=>MerkleTree,\n    proofMerklePath: ()=>proofMerklePath\n});\nvar MerkleTree = class {\n    constructor(leafHashes){\n        this.branches = [];\n        this.leaves = leafHashes;\n        this.root = this.build(leafHashes);\n    }\n    /**\n   * Create Merkle tree\n   * @param leaves hex-string array\n   * @returns format: hex-string; Merkle tree root\n   */ build(leaves) {\n        if (leaves.length === 1) {\n            return leaves[0];\n        }\n        if (leaves.length !== this.leaves.length) {\n            this.branches.push(leaves);\n        }\n        const newLeaves = [];\n        for(let i = 0; i < leaves.length; i += 2){\n            if (i + 1 === leaves.length) {\n                newLeaves.push(MerkleTree.hash(leaves[i], \"0x0\"));\n            } else {\n                newLeaves.push(MerkleTree.hash(leaves[i], leaves[i + 1]));\n            }\n        }\n        return this.build(newLeaves);\n    }\n    /**\n   * Create pedersen hash from a and b\n   * @returns format: hex-string\n   */ static hash(a, b) {\n        const [aSorted, bSorted] = [\n            toBigInt(a),\n            toBigInt(b)\n        ].sort((x, y)=>x >= y ? 1 : -1);\n        return starkCurve.pedersen(aSorted, bSorted);\n    }\n    /**\n   * Return path to leaf\n   * @param leaf hex-string\n   * @param branch hex-string array\n   * @param hashPath hex-string array\n   * @returns format: hex-string array\n   */ getProof(leaf, branch = this.leaves, hashPath = []) {\n        const index = branch.indexOf(leaf);\n        if (index === -1) {\n            throw new Error(\"leaf not found\");\n        }\n        if (branch.length === 1) {\n            return hashPath;\n        }\n        const isLeft = index % 2 === 0;\n        const neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? \"0x0\";\n        const newHashPath = [\n            ...hashPath,\n            neededBranch\n        ];\n        const currentBranchLevelIndex = this.leaves.length === branch.length ? -1 : this.branches.findIndex((b)=>b.length === branch.length);\n        const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [\n            this.root\n        ];\n        return this.getProof(MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf), nextBranch, newHashPath);\n    }\n};\nfunction proofMerklePath(root, leaf, path) {\n    if (path.length === 0) {\n        return root === leaf;\n    }\n    const [next, ...rest] = path;\n    return proofMerklePath(root, MerkleTree.hash(leaf, next), rest);\n}\n// src/utils/typedData.ts\nfunction getHex(value) {\n    try {\n        return toHex(value);\n    } catch (e) {\n        if (typeof value === \"string\") {\n            return toHex(encodeShortString(value));\n        }\n        throw new Error(`Invalid BigNumberish: ${value}`);\n    }\n}\nvar validateTypedData = (data)=>{\n    const typedData1 = data;\n    const valid = Boolean(typedData1.types && typedData1.primaryType && typedData1.message);\n    return valid;\n};\nfunction prepareSelector(selector1) {\n    return isHex(selector1) ? selector1 : getSelectorFromName(selector1);\n}\nfunction isMerkleTreeType(type) {\n    return type.type === \"merkletree\";\n}\nvar getDependencies = (types1, type, dependencies = [])=>{\n    if (type[type.length - 1] === \"*\") {\n        type = type.slice(0, -1);\n    }\n    if (dependencies.includes(type)) {\n        return dependencies;\n    }\n    if (!types1[type]) {\n        return dependencies;\n    }\n    return [\n        type,\n        ...types1[type].reduce((previous, t)=>[\n                ...previous,\n                ...getDependencies(types1, t.type, previous).filter((dependency)=>!previous.includes(dependency))\n            ], [])\n    ];\n};\nfunction getMerkleTreeType(types1, ctx) {\n    if (ctx.parent && ctx.key) {\n        const parentType = types1[ctx.parent];\n        const merkleType = parentType.find((t)=>t.name === ctx.key);\n        const isMerkleTree = isMerkleTreeType(merkleType);\n        if (!isMerkleTree) {\n            throw new Error(`${ctx.key} is not a merkle tree`);\n        }\n        if (merkleType.contains.endsWith(\"*\")) {\n            throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);\n        }\n        return merkleType.contains;\n    }\n    return \"raw\";\n}\nvar encodeType = (types1, type)=>{\n    const [primary, ...dependencies] = getDependencies(types1, type);\n    const newTypes = !primary ? [] : [\n        primary,\n        ...dependencies.sort()\n    ];\n    return newTypes.map((dependency)=>{\n        return `${dependency}(${types1[dependency].map((t)=>`${t.name}:${t.type}`)})`;\n    }).join(\"\");\n};\nvar getTypeHash = (types1, type)=>{\n    return getSelectorFromName(encodeType(types1, type));\n};\nvar encodeValue = (types1, type, data, ctx = {})=>{\n    if (types1[type]) {\n        return [\n            type,\n            getStructHash(types1, type, data)\n        ];\n    }\n    if (Object.keys(types1).map((x)=>`${x}*`).includes(type)) {\n        const structHashes = data.map((struct)=>{\n            return getStructHash(types1, type.slice(0, -1), struct);\n        });\n        return [\n            type,\n            computeHashOnElements(structHashes)\n        ];\n    }\n    if (type === \"merkletree\") {\n        const merkleTreeType = getMerkleTreeType(types1, ctx);\n        const structHashes = data.map((struct)=>{\n            return encodeValue(types1, merkleTreeType, struct)[1];\n        });\n        const { root } = new MerkleTree(structHashes);\n        return [\n            \"felt\",\n            root\n        ];\n    }\n    if (type === \"felt*\") {\n        return [\n            \"felt*\",\n            computeHashOnElements(data)\n        ];\n    }\n    if (type === \"selector\") {\n        return [\n            \"felt\",\n            prepareSelector(data)\n        ];\n    }\n    return [\n        type,\n        getHex(data)\n    ];\n};\nvar encodeData = (types1, type, data)=>{\n    const [returnTypes, values] = types1[type].reduce(([ts, vs], field)=>{\n        if (data[field.name] === void 0 || data[field.name] === null) {\n            throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n        }\n        const value = data[field.name];\n        const [t, encodedValue] = encodeValue(types1, field.type, value, {\n            parent: type,\n            key: field.name\n        });\n        return [\n            [\n                ...ts,\n                t\n            ],\n            [\n                ...vs,\n                encodedValue\n            ]\n        ];\n    }, [\n        [\n            \"felt\"\n        ],\n        [\n            getTypeHash(types1, type)\n        ]\n    ]);\n    return [\n        returnTypes,\n        values\n    ];\n};\nvar getStructHash = (types1, type, data)=>{\n    return computeHashOnElements(encodeData(types1, type, data)[1]);\n};\nvar getMessageHash = (typedData1, account)=>{\n    if (!validateTypedData(typedData1)) {\n        throw new Error(\"Typed data does not match JSON schema\");\n    }\n    const message = [\n        encodeShortString(\"StarkNet Message\"),\n        getStructHash(typedData1.types, \"StarkNetDomain\", typedData1.domain),\n        account,\n        getStructHash(typedData1.types, typedData1.primaryType, typedData1.message)\n    ];\n    return computeHashOnElements(message);\n};\n// src/signer/default.ts\nvar Signer = class {\n    constructor(pk = starkCurve.utils.randomPrivateKey()){\n        this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex(pk);\n    }\n    async getPubKey() {\n        return starkCurve.getStarkKey(this.pk);\n    }\n    async signMessage(typedData1, accountAddress) {\n        const msgHash = getMessageHash(typedData1, accountAddress);\n        return starkCurve.sign(msgHash, this.pk);\n    }\n    async signTransaction(transactions, transactionsDetail, abis) {\n        if (abis && abis.length !== transactions.length) {\n            throw new Error(\"ABI must be provided for each transaction or no transaction\");\n        }\n        const calldata = getExecuteCalldata(transactions, transactionsDetail.cairoVersion);\n        const msgHash = calculateTransactionHash(transactionsDetail.walletAddress, transactionsDetail.version, calldata, transactionsDetail.maxFee, transactionsDetail.chainId, transactionsDetail.nonce);\n        return starkCurve.sign(msgHash, this.pk);\n    }\n    async signDeployAccountTransaction({ classHash, contractAddress, constructorCalldata, addressSalt, maxFee, version, chainId, nonce }) {\n        const msgHash = calculateDeployAccountTransactionHash(contractAddress, classHash, CallData.compile(constructorCalldata), addressSalt, version, maxFee, chainId, nonce);\n        return starkCurve.sign(msgHash, this.pk);\n    }\n    async signDeclareTransaction({ classHash, senderAddress, chainId, maxFee, version, nonce, compiledClassHash }) {\n        const msgHash = calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash);\n        return starkCurve.sign(msgHash, this.pk);\n    }\n};\n// src/utils/events.ts\nfunction parseUDCEvent(txReceipt) {\n    if (!txReceipt.events) {\n        throw new Error(\"UDC emitted event is empty\");\n    }\n    const event = txReceipt.events.find((it)=>cleanHex(it.from_address) === cleanHex(UDC.ADDRESS)) || {\n        data: []\n    };\n    return {\n        transaction_hash: txReceipt.transaction_hash,\n        contract_address: event.data[0],\n        address: event.data[0],\n        deployer: event.data[1],\n        unique: event.data[2],\n        classHash: event.data[3],\n        calldata_len: event.data[4],\n        calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),\n        salt: event.data[event.data.length - 1]\n    };\n}\n// src/account/default.ts\nvar Account = class extends Provider {\n    constructor(providerOrOptions, address, pkOrSigner, cairoVersion){\n        super(providerOrOptions);\n        this.deploySelf = this.deployAccount;\n        this.address = address.toLowerCase();\n        this.signer = typeof pkOrSigner === \"string\" || pkOrSigner instanceof Uint8Array ? new Signer(pkOrSigner) : pkOrSigner;\n        if (cairoVersion) {\n            this.cairoVersion = cairoVersion.toString();\n        }\n    }\n    async getNonce(blockIdentifier) {\n        return super.getNonceForAddress(this.address, blockIdentifier);\n    }\n    async getNonceSafe(nonce) {\n        try {\n            return toBigInt(nonce ?? await this.getNonce());\n        } catch (error) {\n            return 0n;\n        }\n    }\n    /**\n   * Retrieves the Cairo version from the network and sets `cairoVersion` if not already set in the constructor\n   * @param classHash if provided detects Cairo version from classHash, otherwise from the account address\n   */ async getCairoVersion(classHash) {\n        if (!this.cairoVersion) {\n            const { cairo: cairo1 } = classHash ? await super.getContractVersion(void 0, classHash) : await super.getContractVersion(this.address);\n            this.cairoVersion = cairo1;\n        }\n        return this.cairoVersion;\n    }\n    async estimateFee(calls, estimateFeeDetails) {\n        return this.estimateInvokeFee(calls, estimateFeeDetails);\n    }\n    async estimateInvokeFee(calls, { nonce: providedNonce, blockIdentifier, skipValidate } = {}) {\n        const transactions = Array.isArray(calls) ? calls : [\n            calls\n        ];\n        const nonce = toBigInt(providedNonce ?? await this.getNonce());\n        const version = toBigInt(feeTransactionVersion);\n        const chainId = await this.getChainId();\n        const signerDetails = {\n            walletAddress: this.address,\n            nonce,\n            maxFee: ZERO,\n            version,\n            chainId,\n            cairoVersion: await this.getCairoVersion()\n        };\n        const invocation = await this.buildInvocation(transactions, signerDetails);\n        const response = await super.getInvokeEstimateFee({\n            ...invocation\n        }, {\n            version,\n            nonce\n        }, blockIdentifier, skipValidate);\n        const suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);\n        return {\n            ...response,\n            suggestedMaxFee\n        };\n    }\n    async estimateDeclareFee({ contract, classHash: providedClassHash, casm, compiledClassHash }, { blockIdentifier, nonce: providedNonce, skipValidate } = {}) {\n        const nonce = toBigInt(providedNonce ?? await this.getNonce());\n        const version = !isSierra(contract) ? feeTransactionVersion : feeTransactionVersion_2;\n        const chainId = await this.getChainId();\n        const declareContractTransaction = await this.buildDeclarePayload({\n            classHash: providedClassHash,\n            contract,\n            casm,\n            compiledClassHash\n        }, {\n            nonce,\n            chainId,\n            version,\n            walletAddress: this.address,\n            maxFee: ZERO,\n            cairoVersion: void 0\n        });\n        const response = await super.getDeclareEstimateFee(declareContractTransaction, {\n            version,\n            nonce\n        }, blockIdentifier, skipValidate);\n        const suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);\n        return {\n            ...response,\n            suggestedMaxFee\n        };\n    }\n    async estimateAccountDeployFee({ classHash, addressSalt = 0, constructorCalldata = [], contractAddress: providedContractAddress }, { blockIdentifier, skipValidate } = {}) {\n        const version = toBigInt(feeTransactionVersion);\n        const nonce = ZERO;\n        const chainId = await this.getChainId();\n        const payload = await this.buildAccountDeployPayload({\n            classHash,\n            addressSalt,\n            constructorCalldata,\n            contractAddress: providedContractAddress\n        }, {\n            nonce,\n            chainId,\n            version,\n            walletAddress: this.address,\n            // unused parameter\n            maxFee: ZERO,\n            cairoVersion: void 0\n        });\n        const response = await super.getDeployAccountEstimateFee({\n            ...payload\n        }, {\n            version,\n            nonce\n        }, blockIdentifier, skipValidate);\n        const suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);\n        return {\n            ...response,\n            suggestedMaxFee\n        };\n    }\n    async estimateDeployFee(payload, transactionsDetail) {\n        const calls = this.buildUDCContractPayload(payload);\n        return this.estimateInvokeFee(calls, transactionsDetail);\n    }\n    async estimateFeeBulk(invocations, { nonce, blockIdentifier, skipValidate } = {}) {\n        const accountInvocations = await this.accountInvocationsFactory(invocations, {\n            versions: [\n                feeTransactionVersion,\n                feeTransactionVersion_2\n            ],\n            nonce,\n            blockIdentifier\n        });\n        const response = await super.getEstimateFeeBulk(accountInvocations, {\n            blockIdentifier,\n            skipValidate\n        });\n        return [].concat(response).map((elem)=>{\n            const suggestedMaxFee = estimatedFeeToMaxFee(elem.overall_fee);\n            return {\n                ...elem,\n                suggestedMaxFee\n            };\n        });\n    }\n    async buildInvocation(call, signerDetails) {\n        const calldata = getExecuteCalldata(call, await this.getCairoVersion());\n        const signature = await this.signer.signTransaction(call, signerDetails);\n        return {\n            contractAddress: this.address,\n            calldata,\n            signature\n        };\n    }\n    async execute(calls, abis = void 0, transactionsDetail = {}) {\n        const transactions = Array.isArray(calls) ? calls : [\n            calls\n        ];\n        const nonce = toBigInt(transactionsDetail.nonce ?? await this.getNonce());\n        const maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee({\n            type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n            payload: calls\n        }, transactionsDetail);\n        const version = toBigInt(transactionVersion);\n        const chainId = await this.getChainId();\n        const signerDetails = {\n            walletAddress: this.address,\n            nonce,\n            maxFee,\n            version,\n            chainId,\n            cairoVersion: await this.getCairoVersion()\n        };\n        const signature = await this.signer.signTransaction(transactions, signerDetails, abis);\n        const calldata = getExecuteCalldata(transactions, await this.getCairoVersion());\n        return this.invokeFunction({\n            contractAddress: this.address,\n            calldata,\n            signature\n        }, {\n            nonce,\n            maxFee,\n            version\n        });\n    }\n    /**\n   * First check if contract is already declared, if not declare it\n   * If contract already declared returned transaction_hash is ''.\n   * Method will pass even if contract is already declared\n   * @param transactionsDetail (optional)\n   */ async declareIfNot(payload, transactionsDetail = {}) {\n        const declareContractPayload = extractContractHashes(payload);\n        try {\n            await this.getClassByHash(declareContractPayload.classHash);\n        } catch (error) {\n            return this.declare(payload, transactionsDetail);\n        }\n        return {\n            transaction_hash: \"\",\n            class_hash: declareContractPayload.classHash\n        };\n    }\n    async declare(payload, transactionsDetail = {}) {\n        const declareContractPayload = extractContractHashes(payload);\n        const details = {};\n        details.nonce = toBigInt(transactionsDetail.nonce ?? await this.getNonce());\n        details.maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee({\n            type: \"DECLARE\" /* DECLARE */ ,\n            payload: declareContractPayload\n        }, transactionsDetail);\n        details.version = !isSierra(payload.contract) ? transactionVersion : transactionVersion_2;\n        details.chainId = await this.getChainId();\n        const declareContractTransaction = await this.buildDeclarePayload(declareContractPayload, {\n            ...details,\n            walletAddress: this.address,\n            cairoVersion: void 0\n        });\n        return this.declareContract(declareContractTransaction, details);\n    }\n    async deploy(payload, details) {\n        const params = [].concat(payload).map((it)=>{\n            const { classHash, salt, unique = true, constructorCalldata = [] } = it;\n            const compiledConstructorCallData = CallData.compile(constructorCalldata);\n            const deploySalt = salt ?? randomAddress();\n            return {\n                call: {\n                    contractAddress: UDC.ADDRESS,\n                    entrypoint: UDC.ENTRYPOINT,\n                    calldata: [\n                        classHash,\n                        deploySalt,\n                        toCairoBool(unique),\n                        compiledConstructorCallData.length,\n                        ...compiledConstructorCallData\n                    ]\n                },\n                address: calculateContractAddressFromHash(unique ? starkCurve.pedersen(this.address, deploySalt) : deploySalt, classHash, compiledConstructorCallData, unique ? UDC.ADDRESS : 0)\n            };\n        });\n        const calls = params.map((it)=>it.call);\n        const addresses = params.map((it)=>it.address);\n        const invokeResponse = await this.execute(calls, void 0, details);\n        return {\n            ...invokeResponse,\n            contract_address: addresses\n        };\n    }\n    async deployContract(payload, details) {\n        const deployTx = await this.deploy(payload, details);\n        const txReceipt = await this.waitForTransaction(deployTx.transaction_hash);\n        return parseUDCEvent(txReceipt);\n    }\n    async declareAndDeploy(payload, details) {\n        const { constructorCalldata, salt, unique } = payload;\n        let declare = await this.declareIfNot(payload, details);\n        if (declare.transaction_hash !== \"\") {\n            const tx = await this.waitForTransaction(declare.transaction_hash);\n            declare = {\n                ...declare,\n                ...tx\n            };\n        }\n        const deploy = await this.deployContract({\n            classHash: declare.class_hash,\n            salt,\n            unique,\n            constructorCalldata\n        }, details);\n        return {\n            declare: {\n                ...declare\n            },\n            deploy\n        };\n    }\n    async deployAccount({ classHash, constructorCalldata = [], addressSalt = 0, contractAddress: providedContractAddress }, transactionsDetail = {}) {\n        const version = toBigInt(transactionVersion);\n        const nonce = ZERO;\n        const chainId = await this.getChainId();\n        const compiledCalldata = CallData.compile(constructorCalldata);\n        const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n        const maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee({\n            type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n            payload: {\n                classHash,\n                constructorCalldata: compiledCalldata,\n                addressSalt,\n                contractAddress\n            }\n        }, transactionsDetail);\n        const signature = await this.signer.signDeployAccountTransaction({\n            classHash,\n            constructorCalldata: compiledCalldata,\n            contractAddress,\n            addressSalt,\n            chainId,\n            maxFee,\n            version,\n            nonce\n        });\n        return this.deployAccountContract({\n            classHash,\n            addressSalt,\n            constructorCalldata,\n            signature\n        }, {\n            nonce,\n            maxFee,\n            version\n        });\n    }\n    async signMessage(typedData1) {\n        return this.signer.signMessage(typedData1, this.address);\n    }\n    async hashMessage(typedData1) {\n        return getMessageHash(typedData1, this.address);\n    }\n    async verifyMessageHash(hash1, signature) {\n        try {\n            await this.callContract({\n                contractAddress: this.address,\n                entrypoint: \"isValidSignature\",\n                calldata: CallData.compile({\n                    hash: toBigInt(hash1).toString(),\n                    signature: formatSignature(signature)\n                })\n            });\n            return true;\n        } catch  {\n            return false;\n        }\n    }\n    async verifyMessage(typedData1, signature) {\n        const hash1 = await this.hashMessage(typedData1);\n        return this.verifyMessageHash(hash1, signature);\n    }\n    async getSuggestedMaxFee({ type, payload }, details) {\n        let feeEstimate;\n        switch(type){\n            case \"INVOKE_FUNCTION\" /* INVOKE */ :\n                feeEstimate = await this.estimateInvokeFee(payload, details);\n                break;\n            case \"DECLARE\" /* DECLARE */ :\n                feeEstimate = await this.estimateDeclareFee(payload, details);\n                break;\n            case \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ :\n                feeEstimate = await this.estimateAccountDeployFee(payload, details);\n                break;\n            case \"DEPLOY\" /* DEPLOY */ :\n                feeEstimate = await this.estimateDeployFee(payload, details);\n                break;\n            default:\n                feeEstimate = {\n                    suggestedMaxFee: ZERO,\n                    overall_fee: ZERO\n                };\n                break;\n        }\n        return feeEstimate.suggestedMaxFee;\n    }\n    /**\n   * will be renamed to buildDeclareContractTransaction\n   */ async buildDeclarePayload(payload, { nonce, chainId, version, walletAddress, maxFee }) {\n        const { classHash, contract, compiledClassHash } = extractContractHashes(payload);\n        const compressedCompiledContract = parseContract(contract);\n        const signature = await this.signer.signDeclareTransaction({\n            classHash,\n            compiledClassHash,\n            senderAddress: walletAddress,\n            chainId,\n            maxFee,\n            version,\n            nonce\n        });\n        return {\n            senderAddress: walletAddress,\n            signature,\n            contract: compressedCompiledContract,\n            compiledClassHash\n        };\n    }\n    async buildAccountDeployPayload({ classHash, addressSalt = 0, constructorCalldata = [], contractAddress: providedContractAddress }, { nonce, chainId, version, maxFee }) {\n        const compiledCalldata = CallData.compile(constructorCalldata);\n        const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n        const signature = await this.signer.signDeployAccountTransaction({\n            classHash,\n            contractAddress,\n            chainId,\n            maxFee,\n            version,\n            nonce,\n            addressSalt,\n            constructorCalldata: compiledCalldata\n        });\n        return {\n            classHash,\n            addressSalt,\n            constructorCalldata: compiledCalldata,\n            signature\n        };\n    }\n    buildUDCContractPayload(payload) {\n        const calls = [].concat(payload).map((it)=>{\n            const { classHash, salt = \"0\", unique = true, constructorCalldata = [] } = it;\n            const compiledConstructorCallData = CallData.compile(constructorCalldata);\n            return {\n                contractAddress: UDC.ADDRESS,\n                entrypoint: UDC.ENTRYPOINT,\n                calldata: [\n                    classHash,\n                    salt,\n                    toCairoBool(unique),\n                    compiledConstructorCallData.length,\n                    ...compiledConstructorCallData\n                ]\n            };\n        });\n        return calls;\n    }\n    async simulateTransaction(invocations, { nonce, blockIdentifier, skipValidate, skipExecute } = {}) {\n        const accountInvocations = await this.accountInvocationsFactory(invocations, {\n            versions: [\n                transactionVersion,\n                transactionVersion_2\n            ],\n            nonce,\n            blockIdentifier\n        });\n        return super.getSimulateTransaction(accountInvocations, {\n            blockIdentifier,\n            skipValidate,\n            skipExecute\n        });\n    }\n    async accountInvocationsFactory(invocations, { versions, nonce, blockIdentifier }) {\n        const version = versions[0];\n        const safeNonce = await this.getNonceSafe(nonce);\n        const chainId = await this.getChainId();\n        const tx0Payload = \"payload\" in invocations[0] ? invocations[0].payload : invocations[0];\n        const cairoVersion = invocations[0].type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */  ? await this.getCairoVersion(tx0Payload.classHash) : await this.getCairoVersion();\n        return Promise.all([].concat(invocations).map(async (transaction1, index)=>{\n            const txPayload = \"payload\" in transaction1 ? transaction1.payload : transaction1;\n            const signerDetails = {\n                walletAddress: this.address,\n                nonce: toBigInt(Number(safeNonce) + index),\n                maxFee: ZERO,\n                version,\n                chainId,\n                cairoVersion\n            };\n            const common = {\n                type: transaction1.type,\n                version,\n                nonce: toBigInt(Number(safeNonce) + index),\n                blockIdentifier\n            };\n            if (transaction1.type === \"INVOKE_FUNCTION\" /* INVOKE */ ) {\n                const payload = await this.buildInvocation([].concat(txPayload), signerDetails);\n                return {\n                    ...common,\n                    ...payload\n                };\n            }\n            if (transaction1.type === \"DECLARE\" /* DECLARE */ ) {\n                signerDetails.version = !isSierra(txPayload.contract) ? toBigInt(versions[0]) : toBigInt(versions[1]);\n                const payload = await this.buildDeclarePayload(txPayload, signerDetails);\n                return {\n                    ...common,\n                    ...payload,\n                    version: signerDetails.version\n                };\n            }\n            if (transaction1.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ) {\n                const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);\n                return {\n                    ...common,\n                    ...payload\n                };\n            }\n            if (transaction1.type === \"DEPLOY\" /* DEPLOY */ ) {\n                const calls = this.buildUDCContractPayload(txPayload);\n                const payload = await this.buildInvocation(calls, signerDetails);\n                return {\n                    ...common,\n                    ...payload,\n                    type: \"INVOKE_FUNCTION\" /* INVOKE */ \n                };\n            }\n            throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction1}`);\n        }));\n    }\n    async getStarkName(address = this.address, StarknetIdContract2) {\n        return super.getStarkName(address, StarknetIdContract2);\n    }\n};\n// src/provider/interface.ts\nvar ProviderInterface = class {\n};\n// src/provider/index.ts\nvar defaultProvider = new Provider({\n    rpc: {\n        default: true\n    }\n});\n// src/account/interface.ts\nvar AccountInterface = class extends ProviderInterface {\n};\n// src/utils/events/index.ts\nvar events_exports = {};\n__export(events_exports, {\n    getAbiEvents: ()=>getAbiEvents,\n    parseEvents: ()=>parseEvents\n});\nfunction getAbiEvents(abi) {\n    return abi.filter((abiEntry)=>abiEntry.type === \"event\" && (abiEntry.size || abiEntry.kind !== \"enum\")).reduce((acc, abiEntry)=>{\n        const entryName = abiEntry.name.slice(abiEntry.name.lastIndexOf(\":\") + 1);\n        const abiEntryMod = {\n            ...abiEntry\n        };\n        abiEntryMod.name = entryName;\n        return {\n            ...acc,\n            [addHexPrefix(starkCurve.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod\n        };\n    }, {});\n}\nfunction parseEvents(providerReceivedEvents, abiEvents, abiStructs, abiEnums) {\n    const ret = providerReceivedEvents.flat().reduce((acc, recEvent)=>{\n        const abiEvent = abiEvents[recEvent.keys[0]];\n        if (!abiEvent) {\n            return acc;\n        }\n        const parsedEvent = {};\n        parsedEvent[abiEvent.name] = {};\n        recEvent.keys.shift();\n        const keysIter = recEvent.keys[Symbol.iterator]();\n        const dataIter = recEvent.data[Symbol.iterator]();\n        const abiEventKeys = abiEvent.members?.filter((it)=>it.kind === \"key\") || abiEvent.keys;\n        const abiEventData = abiEvent.members?.filter((it)=>it.kind === \"data\") || abiEvent.data;\n        abiEventKeys.forEach((key)=>{\n            parsedEvent[abiEvent.name][key.name] = responseParser(keysIter, key, abiStructs, abiEnums, parsedEvent[abiEvent.name]);\n        });\n        abiEventData.forEach((data)=>{\n            parsedEvent[abiEvent.name][data.name] = responseParser(dataIter, data, abiStructs, abiEnums, parsedEvent[abiEvent.name]);\n        });\n        acc.push(parsedEvent);\n        return acc;\n    }, []);\n    return ret;\n}\n// src/contract/default.ts\nvar splitArgsAndOptions = (args)=>{\n    const options = [\n        \"blockIdentifier\",\n        \"parseRequest\",\n        \"parseResponse\",\n        \"formatResponse\",\n        \"maxFee\",\n        \"nonce\",\n        \"signature\",\n        \"addressSalt\"\n    ];\n    const lastArg = args[args.length - 1];\n    if (typeof lastArg === \"object\" && options.some((x)=>x in lastArg)) {\n        return {\n            args,\n            options: args.pop()\n        };\n    }\n    return {\n        args\n    };\n};\nfunction buildCall(contract, functionAbi) {\n    return async function(...args) {\n        const params = splitArgsAndOptions(args);\n        return contract.call(functionAbi.name, params.args, {\n            parseRequest: true,\n            parseResponse: true,\n            ...params.options\n        });\n    };\n}\nfunction buildInvoke(contract, functionAbi) {\n    return async function(...args) {\n        const params = splitArgsAndOptions(args);\n        return contract.invoke(functionAbi.name, params.args, {\n            parseRequest: true,\n            ...params.options\n        });\n    };\n}\nfunction buildDefault(contract, functionAbi) {\n    if (functionAbi.stateMutability === \"view\" || functionAbi.state_mutability === \"view\") {\n        return buildCall(contract, functionAbi);\n    }\n    return buildInvoke(contract, functionAbi);\n}\nfunction buildPopulate(contract, functionAbi) {\n    return function(...args) {\n        return contract.populate(functionAbi.name, args);\n    };\n}\nfunction buildEstimate(contract, functionAbi) {\n    return function(...args) {\n        return contract.estimate(functionAbi.name, args);\n    };\n}\nfunction getCalldata(args, callback) {\n    if (Array.isArray(args) && \"__compiled__\" in args) return args;\n    if (Array.isArray(args) && Array.isArray(args[0]) && \"__compiled__\" in args[0]) return args[0];\n    return callback();\n}\nvar Contract = class {\n    /**\n   * Contract class to handle contract methods\n   *\n   * @param abi - Abi of the contract object\n   * @param address (optional) - address to connect to\n   * @param providerOrAccount (optional) - Provider or Account to attach to\n   */ constructor(abi, address, providerOrAccount = defaultProvider){\n        this.address = address && address.toLowerCase();\n        this.providerOrAccount = providerOrAccount;\n        this.callData = new CallData(abi);\n        this.structs = CallData.getAbiStruct(abi);\n        this.events = getAbiEvents(abi);\n        const parser = createAbiParser(abi);\n        this.abi = parser.getLegacyFormat();\n        const options = {\n            enumerable: true,\n            value: {},\n            writable: false\n        };\n        Object.defineProperties(this, {\n            functions: {\n                enumerable: true,\n                value: {},\n                writable: false\n            },\n            callStatic: {\n                enumerable: true,\n                value: {},\n                writable: false\n            },\n            populateTransaction: {\n                enumerable: true,\n                value: {},\n                writable: false\n            },\n            estimateFee: {\n                enumerable: true,\n                value: {},\n                writable: false\n            }\n        });\n        this.abi.forEach((abiElement)=>{\n            if (abiElement.type !== \"function\") return;\n            const signature = abiElement.name;\n            if (!this[signature]) {\n                Object.defineProperty(this, signature, {\n                    ...options,\n                    value: buildDefault(this, abiElement)\n                });\n            }\n            if (!this.functions[signature]) {\n                Object.defineProperty(this.functions, signature, {\n                    ...options,\n                    value: buildDefault(this, abiElement)\n                });\n            }\n            if (!this.callStatic[signature]) {\n                Object.defineProperty(this.callStatic, signature, {\n                    ...options,\n                    value: buildCall(this, abiElement)\n                });\n            }\n            if (!this.populateTransaction[signature]) {\n                Object.defineProperty(this.populateTransaction, signature, {\n                    ...options,\n                    value: buildPopulate(this, abiElement)\n                });\n            }\n            if (!this.estimateFee[signature]) {\n                Object.defineProperty(this.estimateFee, signature, {\n                    ...options,\n                    value: buildEstimate(this, abiElement)\n                });\n            }\n        });\n    }\n    attach(address) {\n        this.address = address;\n    }\n    connect(providerOrAccount) {\n        this.providerOrAccount = providerOrAccount;\n    }\n    async deployed() {\n        if (this.deployTransactionHash) {\n            await this.providerOrAccount.waitForTransaction(this.deployTransactionHash);\n            this.deployTransactionHash = void 0;\n        }\n        return this;\n    }\n    async call(method, args = [], { parseRequest = true, parseResponse = true, formatResponse = void 0, blockIdentifier = void 0 } = {}) {\n        assert(this.address !== null, \"contract is not connected to an address\");\n        const calldata = getCalldata(args, ()=>{\n            if (parseRequest) {\n                this.callData.validate(\"CALL\" /* CALL */ , method, args);\n                return this.callData.compile(method, args);\n            }\n            console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n            return args;\n        });\n        return this.providerOrAccount.callContract({\n            contractAddress: this.address,\n            calldata,\n            entrypoint: method\n        }, blockIdentifier).then((x)=>{\n            if (!parseResponse) {\n                return x.result;\n            }\n            if (formatResponse) {\n                return this.callData.format(method, x.result, formatResponse);\n            }\n            return this.callData.parse(method, x.result);\n        });\n    }\n    invoke(method, args = [], { parseRequest = true, maxFee, nonce, signature } = {}) {\n        assert(this.address !== null, \"contract is not connected to an address\");\n        const calldata = getCalldata(args, ()=>{\n            if (parseRequest) {\n                this.callData.validate(\"INVOKE\" /* INVOKE */ , method, args);\n                return this.callData.compile(method, args);\n            }\n            console.warn(\"Invoke skipped parsing but provided rawArgs, possible malfunction request\");\n            return args;\n        });\n        const invocation = {\n            contractAddress: this.address,\n            calldata,\n            entrypoint: method\n        };\n        if (\"execute\" in this.providerOrAccount) {\n            return this.providerOrAccount.execute(invocation, void 0, {\n                maxFee,\n                nonce\n            });\n        }\n        if (!nonce) throw new Error(`Nonce is required when invoking a function without an account`);\n        console.warn(`Invoking ${method} without an account. This will not work on a public node.`);\n        return this.providerOrAccount.invokeFunction({\n            ...invocation,\n            signature\n        }, {\n            nonce\n        });\n    }\n    async estimate(method, args = []) {\n        assert(this.address !== null, \"contract is not connected to an address\");\n        if (!getCalldata(args, ()=>false)) {\n            this.callData.validate(\"INVOKE\" /* INVOKE */ , method, args);\n        }\n        const invocation = this.populate(method, args);\n        if (\"estimateInvokeFee\" in this.providerOrAccount) {\n            return this.providerOrAccount.estimateInvokeFee(invocation);\n        }\n        throw Error(\"Contract must be connected to the account contract to estimate\");\n    }\n    populate(method, args = []) {\n        const calldata = getCalldata(args, ()=>this.callData.compile(method, args));\n        return {\n            contractAddress: this.address,\n            entrypoint: method,\n            calldata\n        };\n    }\n    parseEvents(receipt) {\n        return parseEvents(receipt.events?.filter((event)=>cleanHex(event.from_address) === cleanHex(this.address), []) || [], this.events, this.structs, CallData.getAbiEnum(this.abi));\n    }\n    isCairo1() {\n        return cairo_exports.isCairo1Abi(this.abi);\n    }\n    async getVersion() {\n        return this.providerOrAccount.getContractVersion(this.address);\n    }\n    typed(tAbi) {\n        return this;\n    }\n};\n// src/contract/interface.ts\nvar ContractInterface = class {\n};\n// src/contract/contractFactory.ts\nvar ContractFactory = class {\n    /**\n   * @param params CFParams\n   *  - compiledContract: CompiledContract;\n   *  - account: AccountInterface;\n   *  - casm?: CairoAssembly;\n   *  - classHash?: string;\n   *  - compiledClassHash?: string;\n   *  - abi?: Abi;\n   */ constructor(params){\n        this.compiledContract = params.compiledContract;\n        this.account = params.account;\n        this.casm = params.casm;\n        this.abi = params.abi ?? params.compiledContract.abi;\n        this.classHash = params.classHash;\n        this.compiledClassHash = params.compiledClassHash;\n        this.CallData = new CallData(this.abi);\n    }\n    /**\n   * Deploys contract and returns new instance of the Contract\n   *\n   * If contract is not declared it will first declare it, and then deploy\n   */ async deploy(...args) {\n        const { args: param, options = {\n            parseRequest: true\n        } } = splitArgsAndOptions(args);\n        const constructorCalldata = getCalldata(param, ()=>{\n            if (options.parseRequest) {\n                this.CallData.validate(\"DEPLOY\" /* DEPLOY */ , \"constructor\", param);\n                return this.CallData.compile(\"constructor\", param);\n            }\n            console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n            return param;\n        });\n        const { deploy: { contract_address, transaction_hash } } = await this.account.declareAndDeploy({\n            contract: this.compiledContract,\n            casm: this.casm,\n            classHash: this.classHash,\n            compiledClassHash: this.compiledClassHash,\n            constructorCalldata,\n            salt: options.addressSalt\n        });\n        assert(Boolean(contract_address), \"Deployment of the contract failed\");\n        const contractInstance = new Contract(this.compiledContract.abi, contract_address, this.account);\n        contractInstance.deployTransactionHash = transaction_hash;\n        return contractInstance;\n    }\n    /**\n   * Attaches to new Account\n   *\n   * @param account - new Account to attach to\n   */ connect(account) {\n        this.account = account;\n        return this;\n    }\n    /**\n   * Attaches current abi and account to the new address\n   */ attach(address) {\n        return new Contract(this.abi, address, this.account);\n    }\n};\n// src/utils/address.ts\nvar import_utils4 = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/abstract/utils.js\");\nfunction addAddressPadding(address) {\n    return addHexPrefix(removeHexPrefix(toHex(address)).padStart(64, \"0\"));\n}\nfunction validateAndParseAddress(address) {\n    assertInRange(address, ZERO, MASK_251, \"Starknet Address\");\n    const result = addAddressPadding(address);\n    if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n        throw new Error(\"Invalid Address Format\");\n    }\n    return result;\n}\nfunction getChecksumAddress(address) {\n    const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split(\"\");\n    const hex = removeHexPrefix(keccakBn(address));\n    const hashed = (0, import_utils4.hexToBytes)(hex.padStart(64, \"0\"));\n    for(let i = 0; i < chars.length; i += 2){\n        if (hashed[i >> 1] >> 4 >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 15) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return addHexPrefix(chars.join(\"\"));\n}\nfunction validateChecksumAddress(address) {\n    return getChecksumAddress(address) === address;\n}\n// src/index.ts\nvar number = num_exports;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFdBQVdDLE9BQU9DLE1BQU07QUFDNUIsSUFBSUMsWUFBWUYsT0FBT0csY0FBYztBQUNyQyxJQUFJQyxtQkFBbUJKLE9BQU9LLHdCQUF3QjtBQUN0RCxJQUFJQyxvQkFBb0JOLE9BQU9PLG1CQUFtQjtBQUNsRCxJQUFJQyxlQUFlUixPQUFPUyxjQUFjO0FBQ3hDLElBQUlDLGVBQWVWLE9BQU9XLFNBQVMsQ0FBQ0MsY0FBYztBQUNsRCxJQUFJQyxXQUFXLENBQUNDLFFBQVFDO0lBQ3RCLElBQUssSUFBSUMsUUFBUUQsSUFDZmIsVUFBVVksUUFBUUUsTUFBTTtRQUFFQyxLQUFLRixHQUFHLENBQUNDLEtBQUs7UUFBRUUsWUFBWTtJQUFLO0FBQy9EO0FBQ0EsSUFBSUMsY0FBYyxDQUFDQyxJQUFJQyxNQUFNQyxRQUFRQztJQUNuQyxJQUFJRixRQUFRLE9BQU9BLFNBQVMsWUFBWSxPQUFPQSxTQUFTLFlBQVk7UUFDbEUsS0FBSyxJQUFJRyxPQUFPbEIsa0JBQWtCZSxNQUNoQyxJQUFJLENBQUNYLGFBQWFlLElBQUksQ0FBQ0wsSUFBSUksUUFBUUEsUUFBUUYsUUFDekNwQixVQUFVa0IsSUFBSUksS0FBSztZQUFFUCxLQUFLLElBQU1JLElBQUksQ0FBQ0csSUFBSTtZQUFFTixZQUFZLENBQUVLLENBQUFBLE9BQU9uQixpQkFBaUJpQixNQUFNRyxJQUFHLEtBQU1ELEtBQUtMLFVBQVU7UUFBQztJQUN0SDtJQUNBLE9BQU9FO0FBQ1Q7QUFDQSxJQUFJTSxVQUFVLENBQUNDLEtBQUtDLFlBQVlkLFNBQVlBLENBQUFBLFNBQVNhLE9BQU8sT0FBTzVCLFNBQVNTLGFBQWFtQixRQUFRLENBQUMsR0FBR1IsWUFDbkcsc0VBQXNFO0lBQ3RFLGlFQUFpRTtJQUNqRSxzRUFBc0U7SUFDdEUscUVBQXFFO0lBQ3JFUyxjQUFjLENBQUNELE9BQU8sQ0FBQ0Es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QUFHRixjQUFjdjVCLFVBQVUsRUFBRWpFLElBQUlELFFBQVEsQ0FBQyxJQUFJO0lBQzlELElBQUssSUFBSXNPLElBQUksR0FBR0EsSUFBSW92QixNQUFNdDlCLE1BQU0sRUFBRWtPLEtBQUssRUFBRztRQUN4QyxJQUFJcXZCLE1BQU0sQ0FBQ3J2QixLQUFLLEVBQUUsSUFBSSxLQUFLLEdBQUc7WUFDNUJvdkIsS0FBSyxDQUFDcHZCLEVBQUUsR0FBR292QixLQUFLLENBQUNwdkIsRUFBRSxDQUFDck4sV0FBVztRQUNqQztRQUNBLElBQUksQ0FBQzA4QixNQUFNLENBQUNydkIsS0FBSyxFQUFFLEdBQUcsRUFBQyxLQUFNLEdBQUc7WUFDOUJvdkIsS0FBSyxDQUFDcHZCLElBQUksRUFBRSxHQUFHb3ZCLEtBQUssQ0FBQ3B2QixJQUFJLEVBQUUsQ0FBQ3JOLFdBQVc7UUFDekM7SUFDRjtJQUNBLE9BQU9sRCxhQUFhMi9CLE1BQU0xOEIsSUFBSSxDQUFDO0FBQ2pDO0FBQ0EsU0FBU3ZFLHdCQUF3QnluQixPQUFPO0lBQ3RDLE9BQU8zcEIsbUJBQW1CMnBCLGFBQWFBO0FBQ3pDO0FBRUEsZUFBZTtBQUNmLElBQUkvb0IsU0FBU0Q7QUFDYiw2REFBNkQ7QUFDN0QsS0FBTXdCLENBQUFBLENBc0VOLEdBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmV0dGVyaGFjay8uL25vZGVfbW9kdWxlcy9zdGFya25ldC9kaXN0L2luZGV4LmpzPzU3YzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBzcmNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3JjX2V4cG9ydHMsIHtcbiAgQWNjb3VudDogKCkgPT4gQWNjb3VudCxcbiAgQWNjb3VudEludGVyZmFjZTogKCkgPT4gQWNjb3VudEludGVyZmFjZSxcbiAgQmxvY2tTdGF0dXM6ICgpID0+IEJsb2NrU3RhdHVzLFxuICBCbG9ja1RhZzogKCkgPT4gQmxvY2tUYWcsXG4gIENhaXJvQ3VzdG9tRW51bTogKCkgPT4gQ2Fpcm9DdXN0b21FbnVtLFxuICBDYWlyb09wdGlvbjogKCkgPT4gQ2Fpcm9PcHRpb24sXG4gIENhaXJvT3B0aW9uVmFyaWFudDogKCkgPT4gQ2Fpcm9PcHRpb25WYXJpYW50LFxuICBDYWlyb1Jlc3VsdDogKCkgPT4gQ2Fpcm9SZXN1bHQsXG4gIENhaXJvUmVzdWx0VmFyaWFudDogKCkgPT4gQ2Fpcm9SZXN1bHRWYXJpYW50LFxuICBDYWxsRGF0YTogKCkgPT4gQ2FsbERhdGEsXG4gIENvbnRyYWN0OiAoKSA9PiBDb250cmFjdCxcbiAgQ29udHJhY3RGYWN0b3J5OiAoKSA9PiBDb250cmFjdEZhY3RvcnksXG4gIENvbnRyYWN0SW50ZXJmYWNlOiAoKSA9PiBDb250cmFjdEludGVyZmFjZSxcbiAgQ3VzdG9tRXJyb3I6ICgpID0+IEN1c3RvbUVycm9yLFxuICBFbnRyeVBvaW50VHlwZTogKCkgPT4gRW50cnlQb2ludFR5cGUsXG4gIEdhdGV3YXlFcnJvcjogKCkgPT4gR2F0ZXdheUVycm9yLFxuICBIdHRwRXJyb3I6ICgpID0+IEh0dHBFcnJvcixcbiAgTGlicmFyeUVycm9yOiAoKSA9PiBMaWJyYXJ5RXJyb3IsXG4gIExpdHRlcmFsOiAoKSA9PiBMaXR0ZXJhbCxcbiAgUHJvdmlkZXI6ICgpID0+IFByb3ZpZGVyLFxuICBQcm92aWRlckludGVyZmFjZTogKCkgPT4gUHJvdmlkZXJJbnRlcmZhY2UsXG4gIFJQQzogKCkgPT4gcnBjX2V4cG9ydHMsXG4gIFJwY1Byb3ZpZGVyOiAoKSA9PiBScGNQcm92aWRlcixcbiAgU0lNVUxBVElPTl9GTEFHOiAoKSA9PiBTSU1VTEFUSU9OX0ZMQUcsXG4gIFNlcXVlbmNlcjogKCkgPT4gc2VxdWVuY2VyX2V4cG9ydHMsXG4gIFNlcXVlbmNlclByb3ZpZGVyOiAoKSA9PiBTZXF1ZW5jZXJQcm92aWRlcixcbiAgU2lnbmVyOiAoKSA9PiBTaWduZXIsXG4gIFNpZ25lckludGVyZmFjZTogKCkgPT4gU2lnbmVySW50ZXJmYWNlLFxuICBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czogKCkgPT4gVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMsXG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXM6ICgpID0+IFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMsXG4gIFRyYW5zYWN0aW9uU3RhdHVzOiAoKSA9PiBUcmFuc2FjdGlvblN0YXR1cyxcbiAgVHJhbnNhY3Rpb25UeXBlOiAoKSA9PiBUcmFuc2FjdGlvblR5cGUsXG4gIFVpbnQ6ICgpID0+IFVpbnQsXG4gIFZhbGlkYXRlVHlwZTogKCkgPT4gVmFsaWRhdGVUeXBlLFxuICBhZGRBZGRyZXNzUGFkZGluZzogKCkgPT4gYWRkQWRkcmVzc1BhZGRpbmcsXG4gIGJ1aWxkVXJsOiAoKSA9PiBidWlsZFVybCxcbiAgY2Fpcm86ICgpID0+IGNhaXJvX2V4cG9ydHMsXG4gIGNvbnN0YW50czogKCkgPT4gY29uc3RhbnRzX2V4cG9ydHMsXG4gIGNvbnRyYWN0Q2xhc3NSZXNwb25zZVRvTGVnYWN5Q29tcGlsZWRDb250cmFjdDogKCkgPT4gY29udHJhY3RDbGFzc1Jlc3BvbnNlVG9MZWdhY3lDb21waWxlZENvbnRyYWN0LFxuICBkZWZhdWx0UHJvdmlkZXI6ICgpID0+IGRlZmF1bHRQcm92aWRlcixcbiAgZWM6ICgpID0+IGVjX2V4cG9ydHMsXG4gIGVuY29kZTogKCkgPT4gZW5jb2RlX2V4cG9ydHMsXG4gIGV2ZW50czogKCkgPT4gZXZlbnRzX2V4cG9ydHMsXG4gIGV4dHJhY3RDb250cmFjdEhhc2hlczogKCkgPT4gZXh0cmFjdENvbnRyYWN0SGFzaGVzLFxuICBmaXhQcm90bzogKCkgPT4gZml4UHJvdG8sXG4gIGZpeFN0YWNrOiAoKSA9PiBmaXhTdGFjayxcbiAgZ2V0Q2FsbGRhdGE6ICgpID0+IGdldENhbGxkYXRhLFxuICBnZXRDaGVja3N1bUFkZHJlc3M6ICgpID0+IGdldENoZWNrc3VtQWRkcmVzcyxcbiAgZ2V0RGVmYXVsdE5vZGVVcmw6ICgpID0+IGdldERlZmF1bHROb2RlVXJsLFxuICBoYXNoOiAoKSA9PiBoYXNoX2V4cG9ydHMsXG4gIGlzU2llcnJhOiAoKSA9PiBpc1NpZXJyYSxcbiAgaXNVcmw6ICgpID0+IGlzVXJsLFxuICBqc29uOiAoKSA9PiBqc29uX2V4cG9ydHMsXG4gIG1lcmtsZTogKCkgPT4gbWVya2xlX2V4cG9ydHMsXG4gIG51bTogKCkgPT4gbnVtX2V4cG9ydHMsXG4gIG51bWJlcjogKCkgPT4gbnVtYmVyLFxuICBwYXJzZVVEQ0V2ZW50OiAoKSA9PiBwYXJzZVVEQ0V2ZW50LFxuICBwcm92aWRlcjogKCkgPT4gcHJvdmlkZXJfZXhwb3J0cyxcbiAgc2VsZWN0b3I6ICgpID0+IHNlbGVjdG9yX2V4cG9ydHMsXG4gIHNob3J0U3RyaW5nOiAoKSA9PiBzaG9ydFN0cmluZ19leHBvcnRzLFxuICBzcGxpdEFyZ3NBbmRPcHRpb25zOiAoKSA9PiBzcGxpdEFyZ3NBbmRPcHRpb25zLFxuICBzdGFyazogKCkgPT4gc3RhcmtfZXhwb3J0cyxcbiAgc3RhcmtuZXRJZDogKCkgPT4gc3RhcmtuZXRJZF9leHBvcnRzLFxuICB0cmFuc2FjdGlvbjogKCkgPT4gdHJhbnNhY3Rpb25fZXhwb3J0cyxcbiAgdHlwZWREYXRhOiAoKSA9PiB0eXBlZERhdGFfZXhwb3J0cyxcbiAgdHlwZXM6ICgpID0+IHR5cGVzX2V4cG9ydHMsXG4gIHVpbnQyNTY6ICgpID0+IHVpbnQyNTZfZXhwb3J0cyxcbiAgdmFsaWRhdGVBbmRQYXJzZUFkZHJlc3M6ICgpID0+IHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzLFxuICB2YWxpZGF0ZUNoZWNrc3VtQWRkcmVzczogKCkgPT4gdmFsaWRhdGVDaGVja3N1bUFkZHJlc3Ncbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoc3JjX2V4cG9ydHMpO1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgY29uc3RhbnRzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNvbnN0YW50c19leHBvcnRzLCB7XG4gIEFQSV9WRVJTSU9OOiAoKSA9PiBBUElfVkVSU0lPTixcbiAgQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMTogKCkgPT4gQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMSxcbiAgQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMjogKCkgPT4gQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMixcbiAgQk5fVFJBTlNBQ1RJT05fVkVSU0lPTl8xOiAoKSA9PiBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzEsXG4gIEJOX1RSQU5TQUNUSU9OX1ZFUlNJT05fMjogKCkgPT4gQk5fVFJBTlNBQ1RJT05fVkVSU0lPTl8yLFxuICBCYXNlVXJsOiAoKSA9PiBCYXNlVXJsLFxuICBIRVhfU1RSX1RSQU5TQUNUSU9OX1ZFUlNJT05fMTogKCkgPT4gSEVYX1NUUl9UUkFOU0FDVElPTl9WRVJTSU9OXzEsXG4gIEhFWF9TVFJfVFJBTlNBQ1RJT05fVkVSU0lPTl8yOiAoKSA9PiBIRVhfU1RSX1RSQU5TQUNUSU9OX1ZFUlNJT05fMixcbiAgSVNfQlJPV1NFUjogKCkgPT4gSVNfQlJPV1NFUixcbiAgTUFTS18yNTA6ICgpID0+IE1BU0tfMjUwLFxuICBNQVNLXzI1MTogKCkgPT4gTUFTS18yNTEsXG4gIE5ldHdvcmtOYW1lOiAoKSA9PiBOZXR3b3JrTmFtZSxcbiAgUlBDX0dPRVJMSV9OT0RFUzogKCkgPT4gUlBDX0dPRVJMSV9OT0RFUyxcbiAgUlBDX01BSU5ORVRfTk9ERVM6ICgpID0+IFJQQ19NQUlOTkVUX05PREVTLFxuICBTdGFya25ldENoYWluSWQ6ICgpID0+IFN0YXJrbmV0Q2hhaW5JZCxcbiAgVEVYVF9UT19GRUxUX01BWF9MRU46ICgpID0+IFRFWFRfVE9fRkVMVF9NQVhfTEVOLFxuICBUcmFuc2FjdGlvbkhhc2hQcmVmaXg6ICgpID0+IFRyYW5zYWN0aW9uSGFzaFByZWZpeCxcbiAgVURDOiAoKSA9PiBVREMsXG4gIFpFUk86ICgpID0+IFpFUk9cbn0pO1xuXG4vLyBzcmMvdXRpbHMvZW5jb2RlLnRzXG52YXIgZW5jb2RlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGVuY29kZV9leHBvcnRzLCB7XG4gIElTX0JST1dTRVI6ICgpID0+IElTX0JST1dTRVIsXG4gIGFkZEhleFByZWZpeDogKCkgPT4gYWRkSGV4UHJlZml4LFxuICBhcnJheUJ1ZmZlclRvU3RyaW5nOiAoKSA9PiBhcnJheUJ1ZmZlclRvU3RyaW5nLFxuICBhdG9iVW5pdmVyc2FsOiAoKSA9PiBhdG9iVW5pdmVyc2FsLFxuICBidG9hVW5pdmVyc2FsOiAoKSA9PiBidG9hVW5pdmVyc2FsLFxuICBidWYyaGV4OiAoKSA9PiBidWYyaGV4LFxuICBjYWxjQnl0ZUxlbmd0aDogKCkgPT4gY2FsY0J5dGVMZW5ndGgsXG4gIHBhZExlZnQ6ICgpID0+IHBhZExlZnQsXG4gIHBhc2NhbFRvU25ha2U6ICgpID0+IHBhc2NhbFRvU25ha2UsXG4gIHJlbW92ZUhleFByZWZpeDogKCkgPT4gcmVtb3ZlSGV4UHJlZml4LFxuICBzYW5pdGl6ZUJ5dGVzOiAoKSA9PiBzYW5pdGl6ZUJ5dGVzLFxuICBzYW5pdGl6ZUhleDogKCkgPT4gc2FuaXRpemVIZXgsXG4gIHN0cmluZ1RvQXJyYXlCdWZmZXI6ICgpID0+IHN0cmluZ1RvQXJyYXlCdWZmZXIsXG4gIHV0ZjhUb0FycmF5OiAoKSA9PiB1dGY4VG9BcnJheVxufSk7XG52YXIgaW1wb3J0X2Jhc2UgPSByZXF1aXJlKFwiQHNjdXJlL2Jhc2VcIik7XG52YXIgSVNfQlJPV1NFUiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG52YXIgU1RSSU5HX1pFUk8gPSBcIjBcIjtcbmZ1bmN0aW9uIGFycmF5QnVmZmVyVG9TdHJpbmcoYXJyYXkpIHtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFycmF5KS5yZWR1Y2UoKGRhdGEsIGJ5dGUpID0+IGRhdGEgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIHV0ZjhUb0FycmF5KHN0cikge1xuICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cik7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5QnVmZmVyKHN0cikge1xuICByZXR1cm4gdXRmOFRvQXJyYXkoc3RyKTtcbn1cbmZ1bmN0aW9uIGF0b2JVbml2ZXJzYWwoYSkge1xuICByZXR1cm4gaW1wb3J0X2Jhc2UuYmFzZTY0LmRlY29kZShhKTtcbn1cbmZ1bmN0aW9uIGJ0b2FVbml2ZXJzYWwoYikge1xuICByZXR1cm4gaW1wb3J0X2Jhc2UuYmFzZTY0LmVuY29kZShuZXcgVWludDhBcnJheShiKSk7XG59XG5mdW5jdGlvbiBidWYyaGV4KGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnJlZHVjZSgociwgeCkgPT4gciArIHgudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgXCJcIik7XG59XG5mdW5jdGlvbiByZW1vdmVIZXhQcmVmaXgoaGV4KSB7XG4gIHJldHVybiBoZXgucmVwbGFjZSgvXjB4L2ksIFwiXCIpO1xufVxuZnVuY3Rpb24gYWRkSGV4UHJlZml4KGhleCkge1xuICByZXR1cm4gYDB4JHtyZW1vdmVIZXhQcmVmaXgoaGV4KX1gO1xufVxuZnVuY3Rpb24gcGFkU3RyaW5nKHN0ciwgbGVuZ3RoLCBsZWZ0LCBwYWRkaW5nID0gU1RSSU5HX1pFUk8pIHtcbiAgY29uc3QgZGlmZiA9IGxlbmd0aCAtIHN0ci5sZW5ndGg7XG4gIGxldCByZXN1bHQgPSBzdHI7XG4gIGlmIChkaWZmID4gMCkge1xuICAgIGNvbnN0IHBhZCA9IHBhZGRpbmcucmVwZWF0KGRpZmYpO1xuICAgIHJlc3VsdCA9IGxlZnQgPyBwYWQgKyBzdHIgOiBzdHIgKyBwYWQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhZExlZnQoc3RyLCBsZW5ndGgsIHBhZGRpbmcgPSBTVFJJTkdfWkVSTykge1xuICByZXR1cm4gcGFkU3RyaW5nKHN0ciwgbGVuZ3RoLCB0cnVlLCBwYWRkaW5nKTtcbn1cbmZ1bmN0aW9uIGNhbGNCeXRlTGVuZ3RoKHN0ciwgYnl0ZVNpemUgPSA4KSB7XG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBzdHI7XG4gIGNvbnN0IHJlbWFpbmRlciA9IGxlbmd0aCAlIGJ5dGVTaXplO1xuICByZXR1cm4gcmVtYWluZGVyID8gKGxlbmd0aCAtIHJlbWFpbmRlcikgLyBieXRlU2l6ZSAqIGJ5dGVTaXplICsgYnl0ZVNpemUgOiBsZW5ndGg7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUJ5dGVzKHN0ciwgYnl0ZVNpemUgPSA4LCBwYWRkaW5nID0gU1RSSU5HX1pFUk8pIHtcbiAgcmV0dXJuIHBhZExlZnQoc3RyLCBjYWxjQnl0ZUxlbmd0aChzdHIsIGJ5dGVTaXplKSwgcGFkZGluZyk7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUhleChoZXgpIHtcbiAgaGV4ID0gcmVtb3ZlSGV4UHJlZml4KGhleCk7XG4gIGhleCA9IHNhbml0aXplQnl0ZXMoaGV4LCAyKTtcbiAgaWYgKGhleCkge1xuICAgIGhleCA9IGFkZEhleFByZWZpeChoZXgpO1xuICB9XG4gIHJldHVybiBoZXg7XG59XG52YXIgcGFzY2FsVG9TbmFrZSA9ICh0ZXh0KSA9PiAvW2Etel0vLnRlc3QodGV4dCkgPyB0ZXh0LnNwbGl0KC8oPz1bQS1aXSkvKS5qb2luKFwiX1wiKS50b1VwcGVyQ2FzZSgpIDogdGV4dDtcblxuLy8gc3JjL2NvbnN0YW50cy50c1xudmFyIFRFWFRfVE9fRkVMVF9NQVhfTEVOID0gMzE7XG52YXIgSEVYX1NUUl9UUkFOU0FDVElPTl9WRVJTSU9OXzEgPSBcIjB4MVwiO1xudmFyIEhFWF9TVFJfVFJBTlNBQ1RJT05fVkVSU0lPTl8yID0gXCIweDJcIjtcbnZhciBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzEgPSAxbjtcbnZhciBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzIgPSAybjtcbnZhciBCTl9GRUVfVFJBTlNBQ1RJT05fVkVSU0lPTl8xID0gMm4gKiogMTI4biArIEJOX1RSQU5TQUNUSU9OX1ZFUlNJT05fMTtcbnZhciBCTl9GRUVfVFJBTlNBQ1RJT05fVkVSU0lPTl8yID0gMm4gKiogMTI4biArIEJOX1RSQU5TQUNUSU9OX1ZFUlNJT05fMjtcbnZhciBaRVJPID0gMG47XG52YXIgTUFTS18yNTAgPSAybiAqKiAyNTBuIC0gMW47XG52YXIgTUFTS18yNTEgPSAybiAqKiAyNTFuO1xudmFyIEFQSV9WRVJTSU9OID0gWkVSTztcbnZhciBCYXNlVXJsID0gLyogQF9fUFVSRV9fICovICgoQmFzZVVybDIpID0+IHtcbiAgQmFzZVVybDJbXCJTTl9NQUlOXCJdID0gXCJodHRwczovL2FscGhhLW1haW5uZXQuc3RhcmtuZXQuaW9cIjtcbiAgQmFzZVVybDJbXCJTTl9HT0VSTElcIl0gPSBcImh0dHBzOi8vYWxwaGE0LnN0YXJrbmV0LmlvXCI7XG4gIHJldHVybiBCYXNlVXJsMjtcbn0pKEJhc2VVcmwgfHwge30pO1xudmFyIE5ldHdvcmtOYW1lID0gLyogQF9fUFVSRV9fICovICgoTmV0d29ya05hbWUyKSA9PiB7XG4gIE5ldHdvcmtOYW1lMltcIlNOX01BSU5cIl0gPSBcIlNOX01BSU5cIjtcbiAgTmV0d29ya05hbWUyW1wiU05fR09FUkxJXCJdID0gXCJTTl9HT0VSTElcIjtcbiAgcmV0dXJuIE5ldHdvcmtOYW1lMjtcbn0pKE5ldHdvcmtOYW1lIHx8IHt9KTtcbnZhciBTdGFya25ldENoYWluSWQgPSAvKiBAX19QVVJFX18gKi8gKChTdGFya25ldENoYWluSWQ0KSA9PiB7XG4gIFN0YXJrbmV0Q2hhaW5JZDRbXCJTTl9NQUlOXCJdID0gXCIweDUzNGU1ZjRkNDE0OTRlXCI7XG4gIFN0YXJrbmV0Q2hhaW5JZDRbXCJTTl9HT0VSTElcIl0gPSBcIjB4NTM0ZTVmNDc0ZjQ1NTI0YzQ5XCI7XG4gIHJldHVybiBTdGFya25ldENoYWluSWQ0O1xufSkoU3RhcmtuZXRDaGFpbklkIHx8IHt9KTtcbnZhciBUcmFuc2FjdGlvbkhhc2hQcmVmaXggPSAvKiBAX19QVVJFX18gKi8gKChUcmFuc2FjdGlvbkhhc2hQcmVmaXgyKSA9PiB7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJERUNMQVJFXCJdID0gXCIweDY0NjU2MzZjNjE3MjY1XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJERVBMT1lcIl0gPSBcIjB4NjQ2NTcwNmM2Zjc5XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJERVBMT1lfQUNDT1VOVFwiXSA9IFwiMHg2NDY1NzA2YzZmNzk1ZjYxNjM2MzZmNzU2ZTc0XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJJTlZPS0VcIl0gPSBcIjB4Njk2ZTc2NmY2YjY1XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJMMV9IQU5ETEVSXCJdID0gXCIweDZjMzE1ZjY4NjE2ZTY0NmM2NTcyXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvbkhhc2hQcmVmaXgyO1xufSkoVHJhbnNhY3Rpb25IYXNoUHJlZml4IHx8IHt9KTtcbnZhciBVREMgPSB7XG4gIEFERFJFU1M6IFwiMHgwNDFhNzhlNzQxZTVhZjJmZWMzNGI2OTU2NzliYzY4OTE3NDI0MzlmN2FmYjg0ODRlY2Q3NzY2NjYxYWQwMmJmXCIsXG4gIEVOVFJZUE9JTlQ6IFwiZGVwbG95Q29udHJhY3RcIlxufTtcbnZhciBSUENfR09FUkxJX05PREVTID0gW1xuICBcImh0dHBzOi8vc3RhcmtuZXQtdGVzdG5ldC5wdWJsaWMuYmxhc3RhcGkuaW8vcnBjL3YwLjVcIixcbiAgXCJodHRwczovL2xpbWl0ZWQtcnBjLm5ldGhlcm1pbmQuaW8vZ29lcmxpLWp1bm8vdjBfNVwiXG5dO1xudmFyIFJQQ19NQUlOTkVUX05PREVTID0gW1xuICBcImh0dHBzOi8vc3RhcmtuZXQtbWFpbm5ldC5wdWJsaWMuYmxhc3RhcGkuaW8vcnBjL3YwLjVcIixcbiAgXCJodHRwczovL2xpbWl0ZWQtcnBjLm5ldGhlcm1pbmQuaW8vbWFpbm5ldC1qdW5vL3YwXzVcIlxuXTtcblxuLy8gc3JjL3R5cGVzL2luZGV4LnRzXG52YXIgdHlwZXNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHlwZXNfZXhwb3J0cywge1xuICBCbG9ja1N0YXR1czogKCkgPT4gQmxvY2tTdGF0dXMsXG4gIEJsb2NrVGFnOiAoKSA9PiBCbG9ja1RhZyxcbiAgRW50cnlQb2ludFR5cGU6ICgpID0+IEVudHJ5UG9pbnRUeXBlLFxuICBMaXR0ZXJhbDogKCkgPT4gTGl0dGVyYWwsXG4gIFJQQzogKCkgPT4gcnBjX2V4cG9ydHMsXG4gIFNJTVVMQVRJT05fRkxBRzogKCkgPT4gU0lNVUxBVElPTl9GTEFHLFxuICBTZXF1ZW5jZXI6ICgpID0+IHNlcXVlbmNlcl9leHBvcnRzLFxuICBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czogKCkgPT4gVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMsXG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXM6ICgpID0+IFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMsXG4gIFRyYW5zYWN0aW9uU3RhdHVzOiAoKSA9PiBUcmFuc2FjdGlvblN0YXR1cyxcbiAgVHJhbnNhY3Rpb25UeXBlOiAoKSA9PiBUcmFuc2FjdGlvblR5cGUsXG4gIFVpbnQ6ICgpID0+IFVpbnQsXG4gIFZhbGlkYXRlVHlwZTogKCkgPT4gVmFsaWRhdGVUeXBlXG59KTtcblxuLy8gc3JjL3R5cGVzL2FjY291bnQudHNcbnZhciBTSU1VTEFUSU9OX0ZMQUcgPSAvKiBAX19QVVJFX18gKi8gKChTSU1VTEFUSU9OX0ZMQUcyKSA9PiB7XG4gIFNJTVVMQVRJT05fRkxBRzJbXCJTS0lQX1ZBTElEQVRFXCJdID0gXCJTS0lQX1ZBTElEQVRFXCI7XG4gIFNJTVVMQVRJT05fRkxBRzJbXCJTS0lQX0VYRUNVVEVcIl0gPSBcIlNLSVBfRVhFQ1VURVwiO1xuICByZXR1cm4gU0lNVUxBVElPTl9GTEFHMjtcbn0pKFNJTVVMQVRJT05fRkxBRyB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9jYWxsZGF0YS50c1xudmFyIFZhbGlkYXRlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFZhbGlkYXRlVHlwZTIpID0+IHtcbiAgVmFsaWRhdGVUeXBlMltcIkRFUExPWVwiXSA9IFwiREVQTE9ZXCI7XG4gIFZhbGlkYXRlVHlwZTJbXCJDQUxMXCJdID0gXCJDQUxMXCI7XG4gIFZhbGlkYXRlVHlwZTJbXCJJTlZPS0VcIl0gPSBcIklOVk9LRVwiO1xuICByZXR1cm4gVmFsaWRhdGVUeXBlMjtcbn0pKFZhbGlkYXRlVHlwZSB8fCB7fSk7XG52YXIgVWludCA9IC8qIEBfX1BVUkVfXyAqLyAoKFVpbnQyKSA9PiB7XG4gIFVpbnQyW1widThcIl0gPSBcImNvcmU6OmludGVnZXI6OnU4XCI7XG4gIFVpbnQyW1widTE2XCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1MTZcIjtcbiAgVWludDJbXCJ1MzJcIl0gPSBcImNvcmU6OmludGVnZXI6OnUzMlwiO1xuICBVaW50MltcInU2NFwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dTY0XCI7XG4gIFVpbnQyW1widTEyOFwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dTEyOFwiO1xuICBVaW50MltcInUyNTZcIl0gPSBcImNvcmU6OmludGVnZXI6OnUyNTZcIjtcbiAgcmV0dXJuIFVpbnQyO1xufSkoVWludCB8fCB7fSk7XG52YXIgTGl0dGVyYWwgPSAvKiBAX19QVVJFX18gKi8gKChMaXR0ZXJhbDIpID0+IHtcbiAgTGl0dGVyYWwyW1wiQ2xhc3NIYXNoXCJdID0gXCJjb3JlOjpzdGFya25ldDo6Y2xhc3NfaGFzaDo6Q2xhc3NIYXNoXCI7XG4gIExpdHRlcmFsMltcIkNvbnRyYWN0QWRkcmVzc1wiXSA9IFwiY29yZTo6c3RhcmtuZXQ6OmNvbnRyYWN0X2FkZHJlc3M6OkNvbnRyYWN0QWRkcmVzc1wiO1xuICByZXR1cm4gTGl0dGVyYWwyO1xufSkoTGl0dGVyYWwgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvbGliL2NvbnRyYWN0L2luZGV4LnRzXG52YXIgRW50cnlQb2ludFR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChFbnRyeVBvaW50VHlwZTIpID0+IHtcbiAgRW50cnlQb2ludFR5cGUyW1wiRVhURVJOQUxcIl0gPSBcIkVYVEVSTkFMXCI7XG4gIEVudHJ5UG9pbnRUeXBlMltcIkwxX0hBTkRMRVJcIl0gPSBcIkwxX0hBTkRMRVJcIjtcbiAgRW50cnlQb2ludFR5cGUyW1wiQ09OU1RSVUNUT1JcIl0gPSBcIkNPTlNUUlVDVE9SXCI7XG4gIHJldHVybiBFbnRyeVBvaW50VHlwZTI7XG59KShFbnRyeVBvaW50VHlwZSB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9saWIvaW5kZXgudHNcbnZhciBUcmFuc2FjdGlvblR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChUcmFuc2FjdGlvblR5cGUyKSA9PiB7XG4gIFRyYW5zYWN0aW9uVHlwZTJbXCJERUNMQVJFXCJdID0gXCJERUNMQVJFXCI7XG4gIFRyYW5zYWN0aW9uVHlwZTJbXCJERVBMT1lcIl0gPSBcIkRFUExPWVwiO1xuICBUcmFuc2FjdGlvblR5cGUyW1wiREVQTE9ZX0FDQ09VTlRcIl0gPSBcIkRFUExPWV9BQ0NPVU5UXCI7XG4gIFRyYW5zYWN0aW9uVHlwZTJbXCJJTlZPS0VcIl0gPSBcIklOVk9LRV9GVU5DVElPTlwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlMjtcbn0pKFRyYW5zYWN0aW9uVHlwZSB8fCB7fSk7XG52YXIgVHJhbnNhY3Rpb25TdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChUcmFuc2FjdGlvblN0YXR1czIpID0+IHtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiTk9UX1JFQ0VJVkVEXCJdID0gXCJOT1RfUkVDRUlWRURcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiUkVDRUlWRURcIl0gPSBcIlJFQ0VJVkVEXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wyXCJdID0gXCJBQ0NFUFRFRF9PTl9MMlwiO1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMVwiXSA9IFwiQUNDRVBURURfT05fTDFcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiUkVKRUNURURcIl0gPSBcIlJFSkVDVEVEXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIlJFVkVSVEVEXCJdID0gXCJSRVZFUlRFRFwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25TdGF0dXMyO1xufSkoVHJhbnNhY3Rpb25TdGF0dXMgfHwge30pO1xudmFyIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMikgPT4ge1xuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIk5PVF9SRUNFSVZFRFwiXSA9IFwiTk9UX1JFQ0VJVkVEXCI7XG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiUkVDRUlWRURcIl0gPSBcIlJFQ0VJVkVEXCI7XG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiQUNDRVBURURfT05fTDJcIl0gPSBcIkFDQ0VQVEVEX09OX0wyXCI7XG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMjtcbn0pKFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMgfHwge30pO1xudmFyIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyKSA9PiB7XG4gIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMltcIlJFSkVDVEVEXCJdID0gXCJSRUpFQ1RFRFwiO1xuICBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czJbXCJSRVZFUlRFRFwiXSA9IFwiUkVWRVJURURcIjtcbiAgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyW1wiU1VDQ0VFREVEXCJdID0gXCJTVUNDRUVERURcIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMjtcbn0pKFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzIHx8IHt9KTtcbnZhciBCbG9ja1N0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKEJsb2NrU3RhdHVzMikgPT4ge1xuICBCbG9ja1N0YXR1czJbXCJQRU5ESU5HXCJdID0gXCJQRU5ESU5HXCI7XG4gIEJsb2NrU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wxXCJdID0gXCJBQ0NFUFRFRF9PTl9MMVwiO1xuICBCbG9ja1N0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMlwiXSA9IFwiQUNDRVBURURfT05fTDJcIjtcbiAgQmxvY2tTdGF0dXMyW1wiUkVKRUNURURcIl0gPSBcIlJFSkVDVEVEXCI7XG4gIHJldHVybiBCbG9ja1N0YXR1czI7XG59KShCbG9ja1N0YXR1cyB8fCB7fSk7XG52YXIgQmxvY2tUYWcgPSAvKiBAX19QVVJFX18gKi8gKChCbG9ja1RhZzIpID0+IHtcbiAgQmxvY2tUYWcyW1wicGVuZGluZ1wiXSA9IFwicGVuZGluZ1wiO1xuICBCbG9ja1RhZzJbXCJsYXRlc3RcIl0gPSBcImxhdGVzdFwiO1xuICByZXR1cm4gQmxvY2tUYWcyO1xufSkoQmxvY2tUYWcgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvYXBpL3JwYy50c1xudmFyIHJwY19leHBvcnRzID0ge307XG5fX2V4cG9ydChycGNfZXhwb3J0cywge1xuICBFQmxvY2tUYWc6ICgpID0+IEVCbG9ja1RhZyxcbiAgRURhdGFBdmFpbGFiaWxpdHlNb2RlOiAoKSA9PiBFRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gIEVTaW11bGF0aW9uRmxhZzogKCkgPT4gRVNpbXVsYXRpb25GbGFnLFxuICBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyxcbiAgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzLFxuICBFVHJhbnNhY3Rpb25TdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvblN0YXR1cyxcbiAgRVRyYW5zYWN0aW9uVHlwZTogKCkgPT4gRVRyYW5zYWN0aW9uVHlwZSxcbiAgRXJyb3JzOiAoKSA9PiBlcnJvcnNfZXhwb3J0cyxcbiAgSlJQQzogKCkgPT4ganNvbnJwY19leHBvcnRzLFxuICBTUEVDOiAoKSA9PiBjb21wb25lbnRzX2V4cG9ydHNcbn0pO1xuXG4vLyBzcmMvdHlwZXMvYXBpL2pzb25ycGMvaW5kZXgudHNcbnZhciBqc29ucnBjX2V4cG9ydHMgPSB7fTtcblxuLy8gc3JjL3R5cGVzL2FwaS9ycGNzcGVjL2Vycm9ycy50c1xudmFyIGVycm9yc19leHBvcnRzID0ge307XG5cbi8vIHNyYy90eXBlcy9hcGkvcnBjc3BlYy9jb21wb25lbnRzLnRzXG52YXIgY29tcG9uZW50c19leHBvcnRzID0ge307XG5cbi8vIHNyYy90eXBlcy9hcGkvcnBjc3BlYy9ub25zcGVjLnRzXG52YXIgRVRyYW5zYWN0aW9uVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEVUcmFuc2FjdGlvblR5cGUyKSA9PiB7XG4gIEVUcmFuc2FjdGlvblR5cGUyW1wiREVDTEFSRVwiXSA9IFwiREVDTEFSRVwiO1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIkRFUExPWVwiXSA9IFwiREVQTE9ZXCI7XG4gIEVUcmFuc2FjdGlvblR5cGUyW1wiREVQTE9ZX0FDQ09VTlRcIl0gPSBcIkRFUExPWV9BQ0NPVU5UXCI7XG4gIEVUcmFuc2FjdGlvblR5cGUyW1wiSU5WT0tFXCJdID0gXCJJTlZPS0VcIjtcbiAgRVRyYW5zYWN0aW9uVHlwZTJbXCJMMV9IQU5ETEVSXCJdID0gXCJMMV9IQU5ETEVSXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25UeXBlMjtcbn0pKEVUcmFuc2FjdGlvblR5cGUgfHwge30pO1xudmFyIEVTaW11bGF0aW9uRmxhZyA9IC8qIEBfX1BVUkVfXyAqLyAoKEVTaW11bGF0aW9uRmxhZzIpID0+IHtcbiAgRVNpbXVsYXRpb25GbGFnMltcIlNLSVBfVkFMSURBVEVcIl0gPSBcIlNLSVBfVkFMSURBVEVcIjtcbiAgRVNpbXVsYXRpb25GbGFnMltcIlNLSVBfRkVFX0NIQVJHRVwiXSA9IFwiU0tJUF9GRUVfQ0hBUkdFXCI7XG4gIHJldHVybiBFU2ltdWxhdGlvbkZsYWcyO1xufSkoRVNpbXVsYXRpb25GbGFnIHx8IHt9KTtcbnZhciBFVHJhbnNhY3Rpb25TdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25TdGF0dXMyKSA9PiB7XG4gIEVUcmFuc2FjdGlvblN0YXR1czJbXCJSRUNFSVZFRFwiXSA9IFwiUkVDRUlWRURcIjtcbiAgRVRyYW5zYWN0aW9uU3RhdHVzMltcIlJFSkVDVEVEXCJdID0gXCJSRUpFQ1RFRFwiO1xuICBFVHJhbnNhY3Rpb25TdGF0dXMyW1wiQUNDRVBURURfT05fTDJcIl0gPSBcIkFDQ0VQVEVEX09OX0wyXCI7XG4gIEVUcmFuc2FjdGlvblN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMVwiXSA9IFwiQUNDRVBURURfT05fTDFcIjtcbiAgcmV0dXJuIEVUcmFuc2FjdGlvblN0YXR1czI7XG59KShFVHJhbnNhY3Rpb25TdGF0dXMgfHwge30pO1xudmFyIEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyKSA9PiB7XG4gIEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIkFDQ0VQVEVEX09OX0wyXCJdID0gXCJBQ0NFUFRFRF9PTl9MMlwiO1xuICBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMVwiXSA9IFwiQUNDRVBURURfT05fTDFcIjtcbiAgcmV0dXJuIEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMjtcbn0pKEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzIHx8IHt9KTtcbnZhciBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyKSA9PiB7XG4gIEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czJbXCJTVUNDRUVERURcIl0gPSBcIlNVQ0NFRURFRFwiO1xuICBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyW1wiUkVWRVJURURcIl0gPSBcIlJFVkVSVEVEXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyO1xufSkoRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzIHx8IHt9KTtcbnZhciBFQmxvY2tUYWcgPSAvKiBAX19QVVJFX18gKi8gKChFQmxvY2tUYWcyKSA9PiB7XG4gIEVCbG9ja1RhZzJbXCJMQVRFU1RcIl0gPSBcImxhdGVzdFwiO1xuICBFQmxvY2tUYWcyW1wiUEVORElOR1wiXSA9IFwicGVuZGluZ1wiO1xuICByZXR1cm4gRUJsb2NrVGFnMjtcbn0pKEVCbG9ja1RhZyB8fCB7fSk7XG52YXIgRURhdGFBdmFpbGFiaWxpdHlNb2RlID0gLyogQF9fUFVSRV9fICovICgoRURhdGFBdmFpbGFiaWxpdHlNb2RlMikgPT4ge1xuICBFRGF0YUF2YWlsYWJpbGl0eU1vZGUyW1wiTDFcIl0gPSBcIkwxXCI7XG4gIEVEYXRhQXZhaWxhYmlsaXR5TW9kZTJbXCJMMlwiXSA9IFwiTDJcIjtcbiAgcmV0dXJuIEVEYXRhQXZhaWxhYmlsaXR5TW9kZTI7XG59KShFRGF0YUF2YWlsYWJpbGl0eU1vZGUgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvYXBpL3NlcXVlbmNlci50c1xudmFyIHNlcXVlbmNlcl9leHBvcnRzID0ge307XG5cbi8vIHNyYy91dGlscy9hc3NlcnQudHNcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCBcIkFzc2VydGlvbiBmYWlsdXJlXCIpO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy9udW0udHNcbnZhciBudW1fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobnVtX2V4cG9ydHMsIHtcbiAgYXNzZXJ0SW5SYW5nZTogKCkgPT4gYXNzZXJ0SW5SYW5nZSxcbiAgYmlnTnVtYmVyaXNoQXJyYXlUb0RlY2ltYWxTdHJpbmdBcnJheTogKCkgPT4gYmlnTnVtYmVyaXNoQXJyYXlUb0RlY2ltYWxTdHJpbmdBcnJheSxcbiAgYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXk6ICgpID0+IGJpZ051bWJlcmlzaEFycmF5VG9IZXhhZGVjaW1hbFN0cmluZ0FycmF5LFxuICBjbGVhbkhleDogKCkgPT4gY2xlYW5IZXgsXG4gIGdldERlY2ltYWxTdHJpbmc6ICgpID0+IGdldERlY2ltYWxTdHJpbmcsXG4gIGdldEhleFN0cmluZzogKCkgPT4gZ2V0SGV4U3RyaW5nLFxuICBnZXRIZXhTdHJpbmdBcnJheTogKCkgPT4gZ2V0SGV4U3RyaW5nQXJyYXksXG4gIGhleFRvQnl0ZXM6ICgpID0+IGhleFRvQnl0ZXMsXG4gIGhleFRvRGVjaW1hbFN0cmluZzogKCkgPT4gaGV4VG9EZWNpbWFsU3RyaW5nLFxuICBpc0JpZ0ludDogKCkgPT4gaXNCaWdJbnQsXG4gIGlzSGV4OiAoKSA9PiBpc0hleCxcbiAgaXNTdHJpbmdXaG9sZU51bWJlcjogKCkgPT4gaXNTdHJpbmdXaG9sZU51bWJlcixcbiAgdG9CaWdJbnQ6ICgpID0+IHRvQmlnSW50LFxuICB0b0NhaXJvQm9vbDogKCkgPT4gdG9DYWlyb0Jvb2wsXG4gIHRvSGV4OiAoKSA9PiB0b0hleCxcbiAgdG9IZXhTdHJpbmc6ICgpID0+IHRvSGV4U3RyaW5nLFxuICB0b1N0b3JhZ2VLZXk6ICgpID0+IHRvU3RvcmFnZUtleVxufSk7XG52YXIgaW1wb3J0X3V0aWxzID0gcmVxdWlyZShcIkBub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvdXRpbHNcIik7XG5mdW5jdGlvbiBpc0hleChoZXgpIHtcbiAgcmV0dXJuIC9eMHhbMC05YS1mXSokL2kudGVzdChoZXgpO1xufVxuZnVuY3Rpb24gdG9CaWdJbnQodmFsdWUpIHtcbiAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0JpZ0ludCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiO1xufVxuZnVuY3Rpb24gdG9IZXgobnVtYmVyMikge1xuICByZXR1cm4gYWRkSGV4UHJlZml4KHRvQmlnSW50KG51bWJlcjIpLnRvU3RyaW5nKDE2KSk7XG59XG52YXIgdG9IZXhTdHJpbmcgPSB0b0hleDtcbmZ1bmN0aW9uIHRvU3RvcmFnZUtleShudW1iZXIyKSB7XG4gIGNvbnN0IHJlcyA9IGFkZEhleFByZWZpeCh0b0JpZ0ludChudW1iZXIyKS50b1N0cmluZygxNikucGFkU3RhcnQoNjQsIFwiMFwiKSk7XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBoZXhUb0RlY2ltYWxTdHJpbmcoaGV4KSB7XG4gIHJldHVybiBCaWdJbnQoYWRkSGV4UHJlZml4KGhleCkpLnRvU3RyaW5nKDEwKTtcbn1cbnZhciBjbGVhbkhleCA9IChoZXgpID0+IGhleC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL14oMHgpMCsvLCBcIiQxXCIpO1xuZnVuY3Rpb24gYXNzZXJ0SW5SYW5nZShpbnB1dCwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCwgaW5wdXROYW1lID0gXCJcIikge1xuICBjb25zdCBtZXNzYWdlU3VmZml4ID0gaW5wdXROYW1lID09PSBcIlwiID8gXCJpbnZhbGlkIGxlbmd0aFwiIDogYGludmFsaWQgJHtpbnB1dE5hbWV9IGxlbmd0aGA7XG4gIGNvbnN0IGlucHV0QmlnSW50ID0gQmlnSW50KGlucHV0KTtcbiAgY29uc3QgbG93ZXJCb3VuZEJpZ0ludCA9IEJpZ0ludChsb3dlckJvdW5kKTtcbiAgY29uc3QgdXBwZXJCb3VuZEJpZ0ludCA9IEJpZ0ludCh1cHBlckJvdW5kKTtcbiAgYXNzZXJ0KFxuICAgIGlucHV0QmlnSW50ID49IGxvd2VyQm91bmRCaWdJbnQgJiYgaW5wdXRCaWdJbnQgPD0gdXBwZXJCb3VuZEJpZ0ludCxcbiAgICBgTWVzc2FnZSBub3Qgc2lnbmFibGUsICR7bWVzc2FnZVN1ZmZpeH0uYFxuICApO1xufVxuZnVuY3Rpb24gYmlnTnVtYmVyaXNoQXJyYXlUb0RlY2ltYWxTdHJpbmdBcnJheShyYXdDYWxsZGF0YSkge1xuICByZXR1cm4gcmF3Q2FsbGRhdGEubWFwKCh4KSA9PiB0b0JpZ0ludCh4KS50b1N0cmluZygxMCkpO1xufVxuZnVuY3Rpb24gYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXkocmF3Q2FsbGRhdGEpIHtcbiAgcmV0dXJuIHJhd0NhbGxkYXRhLm1hcCgoeCkgPT4gdG9IZXgoeCkpO1xufVxudmFyIGlzU3RyaW5nV2hvbGVOdW1iZXIgPSAodmFsdWUpID0+IC9eXFxkKyQvLnRlc3QodmFsdWUpO1xuZnVuY3Rpb24gZ2V0RGVjaW1hbFN0cmluZyh2YWx1ZSkge1xuICBpZiAoaXNIZXgodmFsdWUpKSB7XG4gICAgcmV0dXJuIGhleFRvRGVjaW1hbFN0cmluZyh2YWx1ZSk7XG4gIH1cbiAgaWYgKGlzU3RyaW5nV2hvbGVOdW1iZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgJHt2YWx1ZX0gbmVlZCB0byBiZSBoZXgtc3RyaW5nIG9yIHdob2xlLW51bWJlci1zdHJpbmdgKTtcbn1cbmZ1bmN0aW9uIGdldEhleFN0cmluZyh2YWx1ZSkge1xuICBpZiAoaXNIZXgodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N0cmluZ1dob2xlTnVtYmVyKHZhbHVlKSkge1xuICAgIHJldHVybiB0b0hleFN0cmluZyh2YWx1ZSk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGAke3ZhbHVlfSBuZWVkIHRvIGJlIGhleC1zdHJpbmcgb3Igd2hvbGUtbnVtYmVyLXN0cmluZ2ApO1xufVxuZnVuY3Rpb24gZ2V0SGV4U3RyaW5nQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLm1hcCgoZWwpID0+IGdldEhleFN0cmluZyhlbCkpO1xufVxudmFyIHRvQ2Fpcm9Cb29sID0gKHZhbHVlKSA9PiAoK3ZhbHVlKS50b1N0cmluZygpO1xuZnVuY3Rpb24gaGV4VG9CeXRlcyh2YWx1ZSkge1xuICBpZiAoIWlzSGV4KHZhbHVlKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dmFsdWV9IG5lZWQgdG8gYmUgYSBoZXgtc3RyaW5nYCk7XG4gIGxldCBhZGFwdGVkVmFsdWUgPSByZW1vdmVIZXhQcmVmaXgodmFsdWUpO1xuICBpZiAoYWRhcHRlZFZhbHVlLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICBhZGFwdGVkVmFsdWUgPSBgMCR7YWRhcHRlZFZhbHVlfWA7XG4gIH1cbiAgcmV0dXJuICgwLCBpbXBvcnRfdXRpbHMuaGV4VG9CeXRlcykoYWRhcHRlZFZhbHVlKTtcbn1cblxuLy8gc3JjL3V0aWxzL3NlbGVjdG9yLnRzXG52YXIgc2VsZWN0b3JfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc2VsZWN0b3JfZXhwb3J0cywge1xuICBnZXRTZWxlY3RvcjogKCkgPT4gZ2V0U2VsZWN0b3IsXG4gIGdldFNlbGVjdG9yRnJvbU5hbWU6ICgpID0+IGdldFNlbGVjdG9yRnJvbU5hbWUsXG4gIGtlY2Nha0JuOiAoKSA9PiBrZWNjYWtCbixcbiAgc3RhcmtuZXRLZWNjYWs6ICgpID0+IHN0YXJrbmV0S2VjY2FrXG59KTtcbnZhciBpbXBvcnRfc3RhcmtuZXQgPSByZXF1aXJlKFwiQHNjdXJlL3N0YXJrbmV0XCIpO1xuZnVuY3Rpb24ga2VjY2FrQm4odmFsdWUpIHtcbiAgY29uc3QgaGV4V2l0aG91dFByZWZpeCA9IHJlbW92ZUhleFByZWZpeCh0b0hleChCaWdJbnQodmFsdWUpKSk7XG4gIGNvbnN0IGV2ZW5IZXggPSBoZXhXaXRob3V0UHJlZml4Lmxlbmd0aCAlIDIgPT09IDAgPyBoZXhXaXRob3V0UHJlZml4IDogYDAke2hleFdpdGhvdXRQcmVmaXh9YDtcbiAgcmV0dXJuIGFkZEhleFByZWZpeCgoMCwgaW1wb3J0X3N0YXJrbmV0LmtlY2NhaykoaGV4VG9CeXRlcyhhZGRIZXhQcmVmaXgoZXZlbkhleCkpKS50b1N0cmluZygxNikpO1xufVxuZnVuY3Rpb24ga2VjY2FrSGV4KHN0cikge1xuICByZXR1cm4gYWRkSGV4UHJlZml4KCgwLCBpbXBvcnRfc3RhcmtuZXQua2VjY2FrKSh1dGY4VG9BcnJheShzdHIpKS50b1N0cmluZygxNikpO1xufVxuZnVuY3Rpb24gc3RhcmtuZXRLZWNjYWsoc3RyKSB7XG4gIGNvbnN0IGhhc2ggPSBCaWdJbnQoa2VjY2FrSGV4KHN0cikpO1xuICByZXR1cm4gaGFzaCAmIE1BU0tfMjUwO1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0b3JGcm9tTmFtZShmdW5jTmFtZSkge1xuICByZXR1cm4gdG9IZXgoc3RhcmtuZXRLZWNjYWsoZnVuY05hbWUpKTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdG9yKHZhbHVlKSB7XG4gIGlmIChpc0hleCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3RyaW5nV2hvbGVOdW1iZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRvSGV4U3RyaW5nKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZ2V0U2VsZWN0b3JGcm9tTmFtZSh2YWx1ZSk7XG59XG5cbi8vIHNyYy91dGlscy9zaG9ydFN0cmluZy50c1xudmFyIHNob3J0U3RyaW5nX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNob3J0U3RyaW5nX2V4cG9ydHMsIHtcbiAgZGVjb2RlU2hvcnRTdHJpbmc6ICgpID0+IGRlY29kZVNob3J0U3RyaW5nLFxuICBlbmNvZGVTaG9ydFN0cmluZzogKCkgPT4gZW5jb2RlU2hvcnRTdHJpbmcsXG4gIGlzQVNDSUk6ICgpID0+IGlzQVNDSUksXG4gIGlzRGVjaW1hbFN0cmluZzogKCkgPT4gaXNEZWNpbWFsU3RyaW5nLFxuICBpc0xvbmdUZXh0OiAoKSA9PiBpc0xvbmdUZXh0LFxuICBpc1Nob3J0U3RyaW5nOiAoKSA9PiBpc1Nob3J0U3RyaW5nLFxuICBpc1Nob3J0VGV4dDogKCkgPT4gaXNTaG9ydFRleHQsXG4gIGlzVGV4dDogKCkgPT4gaXNUZXh0LFxuICBzcGxpdExvbmdTdHJpbmc6ICgpID0+IHNwbGl0TG9uZ1N0cmluZ1xufSk7XG5mdW5jdGlvbiBpc0FTQ0lJKHN0cikge1xuICByZXR1cm4gL15bXFx4MDAtXFx4N0ZdKiQvLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIGlzU2hvcnRTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBzdHIubGVuZ3RoIDw9IFRFWFRfVE9fRkVMVF9NQVhfTEVOO1xufVxuZnVuY3Rpb24gaXNEZWNpbWFsU3RyaW5nKHN0cikge1xuICByZXR1cm4gL15bMC05XSokL2kudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gaXNUZXh0KHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiAmJiAhaXNIZXgodmFsKSAmJiAhaXNTdHJpbmdXaG9sZU51bWJlcih2YWwpO1xufVxudmFyIGlzU2hvcnRUZXh0ID0gKHZhbCkgPT4gaXNUZXh0KHZhbCkgJiYgaXNTaG9ydFN0cmluZyh2YWwpO1xudmFyIGlzTG9uZ1RleHQgPSAodmFsKSA9PiBpc1RleHQodmFsKSAmJiAhaXNTaG9ydFN0cmluZyh2YWwpO1xuZnVuY3Rpb24gc3BsaXRMb25nU3RyaW5nKGxvbmdTdHIpIHtcbiAgY29uc3QgcmVnZXggPSBSZWdFeHAoYFteXXsxLCR7VEVYVF9UT19GRUxUX01BWF9MRU59fWAsIFwiZ1wiKTtcbiAgcmV0dXJuIGxvbmdTdHIubWF0Y2gocmVnZXgpIHx8IFtdO1xufVxuZnVuY3Rpb24gZW5jb2RlU2hvcnRTdHJpbmcoc3RyKSB7XG4gIGlmICghaXNBU0NJSShzdHIpKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IGlzIG5vdCBhbiBBU0NJSSBzdHJpbmdgKTtcbiAgaWYgKCFpc1Nob3J0U3RyaW5nKHN0cikpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gaXMgdG9vIGxvbmdgKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChzdHIucmVwbGFjZSgvLi9nLCAoY2hhcikgPT4gY2hhci5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkpO1xufVxuZnVuY3Rpb24gZGVjb2RlU2hvcnRTdHJpbmcoc3RyKSB7XG4gIGlmICghaXNBU0NJSShzdHIpKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IGlzIG5vdCBhbiBBU0NJSSBzdHJpbmdgKTtcbiAgaWYgKGlzSGV4KHN0cikpIHtcbiAgICByZXR1cm4gcmVtb3ZlSGV4UHJlZml4KHN0cikucmVwbGFjZSgvLnsyfS9nLCAoaGV4KSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleCwgMTYpKSk7XG4gIH1cbiAgaWYgKGlzRGVjaW1hbFN0cmluZyhzdHIpKSB7XG4gICAgcmV0dXJuIGRlY29kZVNob3J0U3RyaW5nKFwiMFhcIi5jb25jYXQoQmlnSW50KHN0cikudG9TdHJpbmcoMTYpKSk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gaXMgbm90IEhleCBvciBkZWNpbWFsYCk7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9jYWlyby50c1xudmFyIGNhaXJvX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNhaXJvX2V4cG9ydHMsIHtcbiAgZmVsdDogKCkgPT4gZmVsdCxcbiAgZ2V0QWJpQ29udHJhY3RWZXJzaW9uOiAoKSA9PiBnZXRBYmlDb250cmFjdFZlcnNpb24sXG4gIGdldEFycmF5VHlwZTogKCkgPT4gZ2V0QXJyYXlUeXBlLFxuICBpc0NhaXJvMUFiaTogKCkgPT4gaXNDYWlybzFBYmksXG4gIGlzQ2Fpcm8xVHlwZTogKCkgPT4gaXNDYWlybzFUeXBlLFxuICBpc0xlbjogKCkgPT4gaXNMZW4sXG4gIGlzVHlwZUFycmF5OiAoKSA9PiBpc1R5cGVBcnJheSxcbiAgaXNUeXBlQm9vbDogKCkgPT4gaXNUeXBlQm9vbCxcbiAgaXNUeXBlQ29udHJhY3RBZGRyZXNzOiAoKSA9PiBpc1R5cGVDb250cmFjdEFkZHJlc3MsXG4gIGlzVHlwZUVudW06ICgpID0+IGlzVHlwZUVudW0sXG4gIGlzVHlwZUV0aEFkZHJlc3M6ICgpID0+IGlzVHlwZUV0aEFkZHJlc3MsXG4gIGlzVHlwZUZlbHQ6ICgpID0+IGlzVHlwZUZlbHQsXG4gIGlzVHlwZUxpdHRlcmFsOiAoKSA9PiBpc1R5cGVMaXR0ZXJhbCxcbiAgaXNUeXBlTmFtZWRUdXBsZTogKCkgPT4gaXNUeXBlTmFtZWRUdXBsZSxcbiAgaXNUeXBlT3B0aW9uOiAoKSA9PiBpc1R5cGVPcHRpb24sXG4gIGlzVHlwZVJlc3VsdDogKCkgPT4gaXNUeXBlUmVzdWx0LFxuICBpc1R5cGVTdHJ1Y3Q6ICgpID0+IGlzVHlwZVN0cnVjdCxcbiAgaXNUeXBlVHVwbGU6ICgpID0+IGlzVHlwZVR1cGxlLFxuICBpc1R5cGVVaW50OiAoKSA9PiBpc1R5cGVVaW50LFxuICBpc1R5cGVVaW50MjU2OiAoKSA9PiBpc1R5cGVVaW50MjU2LFxuICB0dXBsZTogKCkgPT4gdHVwbGUsXG4gIHVpbnQyNTY6ICgpID0+IHVpbnQyNTZcbn0pO1xuXG4vLyBzcmMvdXRpbHMvdWludDI1Ni50c1xudmFyIHVpbnQyNTZfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodWludDI1Nl9leHBvcnRzLCB7XG4gIFVJTlRfMTI4X01BWDogKCkgPT4gVUlOVF8xMjhfTUFYLFxuICBVSU5UXzI1Nl9NQVg6ICgpID0+IFVJTlRfMjU2X01BWCxcbiAgYm5Ub1VpbnQyNTY6ICgpID0+IGJuVG9VaW50MjU2LFxuICBpc1VpbnQyNTY6ICgpID0+IGlzVWludDI1NixcbiAgdWludDI1NlRvQk46ICgpID0+IHVpbnQyNTZUb0JOXG59KTtcbnZhciBVSU5UXzEyOF9NQVggPSAoMW4gPDwgMTI4bikgLSAxbjtcbnZhciBVSU5UXzI1Nl9NQVggPSAoMW4gPDwgMjU2bikgLSAxbjtcbmZ1bmN0aW9uIHVpbnQyNTZUb0JOKHVpbnQyNTYyKSB7XG4gIHJldHVybiAodG9CaWdJbnQodWludDI1NjIuaGlnaCkgPDwgMTI4bikgKyB0b0JpZ0ludCh1aW50MjU2Mi5sb3cpO1xufVxuZnVuY3Rpb24gaXNVaW50MjU2KGJuKSB7XG4gIHJldHVybiB0b0JpZ0ludChibikgPD0gVUlOVF8yNTZfTUFYO1xufVxuZnVuY3Rpb24gYm5Ub1VpbnQyNTYoYm4pIHtcbiAgY29uc3QgYmkgPSB0b0JpZ0ludChibik7XG4gIGlmICghaXNVaW50MjU2KGJpKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgaXMgdG9vIGxhcmdlXCIpO1xuICByZXR1cm4ge1xuICAgIGxvdzogYWRkSGV4UHJlZml4KChiaSAmIFVJTlRfMTI4X01BWCkudG9TdHJpbmcoMTYpKSxcbiAgICBoaWdoOiBhZGRIZXhQcmVmaXgoKGJpID4+IDEyOG4pLnRvU3RyaW5nKDE2KSlcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2NhaXJvLnRzXG52YXIgaXNMZW4gPSAobmFtZSkgPT4gL19sZW4kLy50ZXN0KG5hbWUpO1xudmFyIGlzVHlwZUZlbHQgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJmZWx0XCIgfHwgdHlwZSA9PT0gXCJjb3JlOjpmZWx0MjUyXCI7XG52YXIgaXNUeXBlQXJyYXkgPSAodHlwZSkgPT4gL1xcKi8udGVzdCh0eXBlKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjphcnJheTo6QXJyYXk6OlwiKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjphcnJheTo6U3Bhbjo6XCIpO1xudmFyIGlzVHlwZVR1cGxlID0gKHR5cGUpID0+IC9eXFwoLipcXCkkL2kudGVzdCh0eXBlKTtcbnZhciBpc1R5cGVOYW1lZFR1cGxlID0gKHR5cGUpID0+IC9cXCguKlxcKS9pLnRlc3QodHlwZSkgJiYgdHlwZS5pbmNsdWRlcyhcIjpcIik7XG52YXIgaXNUeXBlU3RydWN0ID0gKHR5cGUsIHN0cnVjdHMpID0+IHR5cGUgaW4gc3RydWN0cztcbnZhciBpc1R5cGVFbnVtID0gKHR5cGUsIGVudW1zKSA9PiB0eXBlIGluIGVudW1zO1xudmFyIGlzVHlwZU9wdGlvbiA9ICh0eXBlKSA9PiB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpvcHRpb246Ok9wdGlvbjo6XCIpO1xudmFyIGlzVHlwZVJlc3VsdCA9ICh0eXBlKSA9PiB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpyZXN1bHQ6OlJlc3VsdDo6XCIpO1xudmFyIGlzVHlwZVVpbnQgPSAodHlwZSkgPT4gT2JqZWN0LnZhbHVlcyhVaW50KS5pbmNsdWRlcyh0eXBlKTtcbnZhciBpc1R5cGVMaXR0ZXJhbCA9ICh0eXBlKSA9PiBPYmplY3QudmFsdWVzKExpdHRlcmFsKS5pbmNsdWRlcyh0eXBlKTtcbnZhciBpc1R5cGVVaW50MjU2ID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiO1xudmFyIGlzVHlwZUJvb2wgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJjb3JlOjpib29sXCI7XG52YXIgaXNUeXBlQ29udHJhY3RBZGRyZXNzID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmNvbnRyYWN0X2FkZHJlc3M6OkNvbnRyYWN0QWRkcmVzc1wiO1xudmFyIGlzVHlwZUV0aEFkZHJlc3MgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIjtcbnZhciBpc0NhaXJvMVR5cGUgPSAodHlwZSkgPT4gdHlwZS5pbmNsdWRlcyhcIjo6XCIpO1xudmFyIGdldEFycmF5VHlwZSA9ICh0eXBlKSA9PiB7XG4gIGlmIChpc0NhaXJvMVR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gdHlwZS5zdWJzdHJpbmcodHlwZS5pbmRleE9mKFwiPFwiKSArIDEsIHR5cGUubGFzdEluZGV4T2YoXCI+XCIpKTtcbiAgfVxuICByZXR1cm4gdHlwZS5yZXBsYWNlKFwiKlwiLCBcIlwiKTtcbn07XG5mdW5jdGlvbiBpc0NhaXJvMUFiaShhYmkpIHtcbiAgY29uc3QgeyBjYWlybyB9ID0gZ2V0QWJpQ29udHJhY3RWZXJzaW9uKGFiaSk7XG4gIGlmIChjYWlybyA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZGV0ZXJtaW5lIENhaXJvIHZlcnNpb25cIik7XG4gIH1cbiAgcmV0dXJuIGNhaXJvID09PSBcIjFcIjtcbn1cbmZ1bmN0aW9uIGdldEFiaUNvbnRyYWN0VmVyc2lvbihhYmkpIHtcbiAgaWYgKGFiaS5maW5kKChpdCkgPT4gaXQudHlwZSA9PT0gXCJpbnRlcmZhY2VcIikpIHtcbiAgICByZXR1cm4geyBjYWlybzogXCIxXCIsIGNvbXBpbGVyOiBcIjJcIiB9O1xuICB9XG4gIGNvbnN0IHRlc3RGdW5jdGlvbiA9IGFiaS5maW5kKFxuICAgIChpdCkgPT4gaXQudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmIChpdC5pbnB1dHMubGVuZ3RoIHx8IGl0Lm91dHB1dHMubGVuZ3RoKVxuICApO1xuICBpZiAoIXRlc3RGdW5jdGlvbikge1xuICAgIHJldHVybiB7IGNhaXJvOiB2b2lkIDAsIGNvbXBpbGVyOiB2b2lkIDAgfTtcbiAgfVxuICBjb25zdCBpbyA9IHRlc3RGdW5jdGlvbi5pbnB1dHMubGVuZ3RoID8gdGVzdEZ1bmN0aW9uLmlucHV0cyA6IHRlc3RGdW5jdGlvbi5vdXRwdXRzO1xuICBpZiAoaXNDYWlybzFUeXBlKGlvWzBdLnR5cGUpKSB7XG4gICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogXCIxXCIgfTtcbiAgfVxuICByZXR1cm4geyBjYWlybzogXCIwXCIsIGNvbXBpbGVyOiBcIjBcIiB9O1xufVxudmFyIHVpbnQyNTYgPSAoaXQpID0+IHtcbiAgY29uc3QgYm4gPSBCaWdJbnQoaXQpO1xuICBpZiAoIWlzVWludDI1NihibikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIGlzIHRvbyBsYXJnZVwiKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIGxvdzogKGJuICYgVUlOVF8xMjhfTUFYKS50b1N0cmluZygxMCksXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBoaWdoOiAoYm4gPj4gMTI4bikudG9TdHJpbmcoMTApXG4gIH07XG59O1xudmFyIHR1cGxlID0gKC4uLmFyZ3MpID0+ICh7IC4uLmFyZ3MgfSk7XG5mdW5jdGlvbiBmZWx0KGl0KSB7XG4gIGlmIChpc0JpZ0ludChpdCkgfHwgdHlwZW9mIGl0ID09PSBcIm51bWJlclwiICYmIE51bWJlci5pc0ludGVnZXIoaXQpKSB7XG4gICAgcmV0dXJuIGl0LnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKGlzVGV4dChpdCkpIHtcbiAgICBpZiAoIWlzU2hvcnRTdHJpbmcoaXQpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHtpdH0gaXMgYSBsb25nIHN0cmluZyA+IDMxIGNoYXJzLCBmZWx0IGNhbiBzdG9yZSBzaG9ydCBzdHJpbmdzLCBzcGxpdCBpdCB0byBhcnJheSBvZiBzaG9ydCBzdHJpbmdzYFxuICAgICAgKTtcbiAgICBjb25zdCBlbmNvZGVkID0gZW5jb2RlU2hvcnRTdHJpbmcoaXQpO1xuICAgIHJldHVybiBCaWdJbnQoZW5jb2RlZCkudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAodHlwZW9mIGl0ID09PSBcInN0cmluZ1wiICYmIGlzSGV4KGl0KSkge1xuICAgIHJldHVybiBCaWdJbnQoaXQpLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBpdCA9PT0gXCJzdHJpbmdcIiAmJiBpc1N0cmluZ1dob2xlTnVtYmVyKGl0KSkge1xuICAgIHJldHVybiBpdDtcbiAgfVxuICBpZiAodHlwZW9mIGl0ID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiBgJHsraXR9YDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7aXR9IGNhbid0IGJlIGNvbXB1dGVkIGJ5IGZlbHQoKWApO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvZW51bS9DYWlyb0N1c3RvbUVudW0udHNcbnZhciBDYWlyb0N1c3RvbUVudW0gPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBAcGFyYW0gZW51bUNvbnRlbnQgYW4gb2JqZWN0IHdpdGggdGhlIHZhcmlhbnRzIGFzIGtleXMgYW5kIHRoZSBjb250ZW50IGFzIHZhbHVlLiBPbmx5IG9uZSBjb250ZW50IHNoYWxsIGJlIGRlZmluZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbnVtQ29udGVudCkge1xuICAgIGNvbnN0IHZhcmlhbnRzTGlzdCA9IE9iamVjdC52YWx1ZXMoZW51bUNvbnRlbnQpO1xuICAgIGlmICh2YXJpYW50c0xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIEVudW0gbXVzdCBoYXZlIGEgbGVhc3QgMSB2YXJpYW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBuYkFjdGl2ZVZhcmlhbnRzID0gdmFyaWFudHNMaXN0LmZpbHRlcihcbiAgICAgIChjb250ZW50KSA9PiB0eXBlb2YgY29udGVudCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICkubGVuZ3RoO1xuICAgIGlmIChuYkFjdGl2ZVZhcmlhbnRzICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIEVudW0gbXVzdCBoYXZlIGV4YWN0bHkgb25lIGFjdGl2ZSB2YXJpYW50XCIpO1xuICAgIH1cbiAgICB0aGlzLnZhcmlhbnQgPSBlbnVtQ29udGVudDtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHZhbGlkIHZhcmlhbnQgb2YgYSBDYWlybyBjdXN0b20gRW51bS5cbiAgICovXG4gIHVud3JhcCgpIHtcbiAgICBjb25zdCB2YXJpYW50cyA9IE9iamVjdC5lbnRyaWVzKHRoaXMudmFyaWFudCk7XG4gICAgY29uc3QgYWN0aXZlVmFyaWFudCA9IHZhcmlhbnRzLmZpbmQoKGl0ZW0pID0+IHR5cGVvZiBpdGVtWzFdICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgICBpZiAodHlwZW9mIGFjdGl2ZVZhcmlhbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVWYXJpYW50WzFdO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgdmFsaWQgdmFyaWFudCBvZiBhIENhaXJvIGN1c3RvbSBFbnVtLlxuICAgKi9cbiAgYWN0aXZlVmFyaWFudCgpIHtcbiAgICBjb25zdCB2YXJpYW50cyA9IE9iamVjdC5lbnRyaWVzKHRoaXMudmFyaWFudCk7XG4gICAgY29uc3QgYWN0aXZlVmFyaWFudCA9IHZhcmlhbnRzLmZpbmQoKGl0ZW0pID0+IHR5cGVvZiBpdGVtWzFdICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgICBpZiAodHlwZW9mIGFjdGl2ZVZhcmlhbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlVmFyaWFudFswXTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2VudW0vQ2Fpcm9PcHRpb24udHNcbnZhciBDYWlyb09wdGlvblZhcmlhbnQgPSAvKiBAX19QVVJFX18gKi8gKChDYWlyb09wdGlvblZhcmlhbnQyKSA9PiB7XG4gIENhaXJvT3B0aW9uVmFyaWFudDJbQ2Fpcm9PcHRpb25WYXJpYW50MltcIlNvbWVcIl0gPSAwXSA9IFwiU29tZVwiO1xuICBDYWlyb09wdGlvblZhcmlhbnQyW0NhaXJvT3B0aW9uVmFyaWFudDJbXCJOb25lXCJdID0gMV0gPSBcIk5vbmVcIjtcbiAgcmV0dXJuIENhaXJvT3B0aW9uVmFyaWFudDI7XG59KShDYWlyb09wdGlvblZhcmlhbnQgfHwge30pO1xudmFyIENhaXJvT3B0aW9uID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih2YXJpYW50LCBzb21lQ29udGVudCkge1xuICAgIGlmICghKHZhcmlhbnQgaW4gQ2Fpcm9PcHRpb25WYXJpYW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgdmFyaWFudCA6IHNob3VsZCBiZSBDYWlyb09wdGlvblZhcmlhbnQuU29tZSBvciAuTm9uZS5cIik7XG4gICAgfVxuICAgIGlmICh2YXJpYW50ID09PSAwIC8qIFNvbWUgKi8pIHtcbiAgICAgIGlmICh0eXBlb2Ygc29tZUNvbnRlbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgY3JlYXRpb24gb2YgYSBDYWlybyBPcHRpb24gd2l0aCBcIlNvbWVcIiB2YXJpYW50IG5lZWRzIGEgY29udGVudCBhcyBpbnB1dC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLlNvbWUgPSBzb21lQ29udGVudDtcbiAgICAgIHRoaXMuTm9uZSA9IHZvaWQgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5Tb21lID0gdm9pZCAwO1xuICAgICAgdGhpcy5Ob25lID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSB2YWxpZCB2YXJpYW50IG9mIGEgQ2Fpcm8gY3VzdG9tIEVudW0uXG4gICAqICBJZiBOb25lLCByZXR1cm5zICd1bmRlZmluZWQnLlxuICAgKi9cbiAgdW53cmFwKCkge1xuICAgIGlmICh0aGlzLk5vbmUpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLlNvbWU7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ2lzU29tZScuXG4gICAqL1xuICBpc1NvbWUoKSB7XG4gICAgcmV0dXJuICEodHlwZW9mIHRoaXMuU29tZSA9PT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ2lzTm9uZScuXG4gICAqL1xuICBpc05vbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuTm9uZSA9PT0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2VudW0vQ2Fpcm9SZXN1bHQudHNcbnZhciBDYWlyb1Jlc3VsdFZhcmlhbnQgPSAvKiBAX19QVVJFX18gKi8gKChDYWlyb1Jlc3VsdFZhcmlhbnQyKSA9PiB7XG4gIENhaXJvUmVzdWx0VmFyaWFudDJbQ2Fpcm9SZXN1bHRWYXJpYW50MltcIk9rXCJdID0gMF0gPSBcIk9rXCI7XG4gIENhaXJvUmVzdWx0VmFyaWFudDJbQ2Fpcm9SZXN1bHRWYXJpYW50MltcIkVyclwiXSA9IDFdID0gXCJFcnJcIjtcbiAgcmV0dXJuIENhaXJvUmVzdWx0VmFyaWFudDI7XG59KShDYWlyb1Jlc3VsdFZhcmlhbnQgfHwge30pO1xudmFyIENhaXJvUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih2YXJpYW50LCByZXN1bHRDb250ZW50KSB7XG4gICAgaWYgKCEodmFyaWFudCBpbiBDYWlyb1Jlc3VsdFZhcmlhbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyB2YXJpYW50IDogc2hvdWxkIGJlIENhaXJvUmVzdWx0VmFyaWFudC5PayBvciAuRXJyLlwiKTtcbiAgICB9XG4gICAgaWYgKHZhcmlhbnQgPT09IDAgLyogT2sgKi8pIHtcbiAgICAgIHRoaXMuT2sgPSByZXN1bHRDb250ZW50O1xuICAgICAgdGhpcy5FcnIgPSB2b2lkIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuT2sgPSB2b2lkIDA7XG4gICAgICB0aGlzLkVyciA9IHJlc3VsdENvbnRlbnQ7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgdmFsaWQgdmFyaWFudCBvZiBhIENhaXJvIFJlc3VsdC5cbiAgICovXG4gIHVud3JhcCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuT2sgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLk9rO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMuRXJyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5FcnI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJvdGggUmVzdWx0Lk9rIGFuZCAuRXJyIGFyZSB1bmRlZmluZWQuIE5vdCBhdXRob3JpemVkLlwiKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsaWQgdmFyaWFudCBpcyAnT2snLlxuICAgKi9cbiAgaXNPaygpIHtcbiAgICByZXR1cm4gISh0eXBlb2YgdGhpcy5PayA9PT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ2lzRXJyJy5cbiAgICovXG4gIGlzRXJyKCkge1xuICAgIHJldHVybiAhKHR5cGVvZiB0aGlzLkVyciA9PT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9mb3JtYXR0ZXIudHNcbnZhciBndWFyZCA9IHtcbiAgaXNCTjogKGRhdGEsIHR5cGUsIGtleSkgPT4ge1xuICAgIGlmICghaXNCaWdJbnQoZGF0YVtrZXldKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYERhdGEgYW5kIGZvcm1hdHRlciBtaXNtYXRjaCBvbiAke2tleX06JHt0eXBlW2tleV19LCBleHBlY3RlZCByZXNwb25zZSBkYXRhICR7a2V5fToke2RhdGFba2V5XX0gdG8gYmUgQk4gaW5zdGVhZCBpdCBpcyAke3R5cGVvZiBkYXRhW2tleV19YFxuICAgICAgKTtcbiAgfSxcbiAgdW5rbm93bjogKGRhdGEsIHR5cGUsIGtleSkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIGZvcm1hdHRlciB0eXBlIG9uICR7a2V5fToke3R5cGVba2V5XX0gZm9yIGRhdGEgJHtrZXl9OiR7ZGF0YVtrZXldfWApO1xuICB9XG59O1xuZnVuY3Rpb24gZm9ybWF0dGVyKGRhdGEsIHR5cGUsIHNhbWVUeXBlKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhkYXRhKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgZWxUeXBlID0gc2FtZVR5cGUgPz8gdHlwZVtrZXldO1xuICAgIGlmICghKGtleSBpbiB0eXBlKSAmJiAhc2FtZVR5cGUpIHtcbiAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBpZiAoZWxUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhW2tleV0pKSB7XG4gICAgICAgIGNvbnN0IGFycmF5U3RyID0gZm9ybWF0dGVyKFxuICAgICAgICAgIGRhdGFba2V5XSxcbiAgICAgICAgICBkYXRhW2tleV0ubWFwKChfKSA9PiBlbFR5cGUpXG4gICAgICAgICk7XG4gICAgICAgIGFjY1trZXldID0gT2JqZWN0LnZhbHVlcyhhcnJheVN0cikuam9pbihcIlwiKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGd1YXJkLmlzQk4oZGF0YSwgdHlwZSwga2V5KTtcbiAgICAgIGFjY1trZXldID0gZGVjb2RlU2hvcnRTdHJpbmcodmFsdWUpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKGVsVHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgZ3VhcmQuaXNCTihkYXRhLCB0eXBlLCBrZXkpO1xuICAgICAgYWNjW2tleV0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbFR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYWNjW2tleV0gPSBlbFR5cGUodmFsdWUpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWxUeXBlKSkge1xuICAgICAgY29uc3QgYXJyYXlPYmogPSBmb3JtYXR0ZXIoZGF0YVtrZXldLCBlbFR5cGUsIGVsVHlwZVswXSk7XG4gICAgICBhY2Nba2V5XSA9IE9iamVjdC52YWx1ZXMoYXJyYXlPYmopO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbFR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGFjY1trZXldID0gZm9ybWF0dGVyKGRhdGFba2V5XSwgZWxUeXBlKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGd1YXJkLnVua25vd24oZGF0YSwgdHlwZSwga2V5KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9wYXJzZXIvcGFyc2VyLTAtMS4xLjAudHNcbnZhciBBYmlQYXJzZXIxID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhYmkpIHtcbiAgICB0aGlzLmFiaSA9IGFiaTtcbiAgfVxuICAvKipcbiAgICogYWJpIG1ldGhvZCBpbnB1dHMgbGVuZ3RoIHdpdGhvdXQgJ19sZW4nIGlucHV0c1xuICAgKiBjYWlybyAwIHJlZHVjZXJcbiAgICogQHBhcmFtIGFiaU1ldGhvZCBGdW5jdGlvbkFiaVxuICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICovXG4gIG1ldGhvZElucHV0c0xlbmd0aChhYmlNZXRob2QpIHtcbiAgICByZXR1cm4gYWJpTWV0aG9kLmlucHV0cy5yZWR1Y2UoKGFjYywgaW5wdXQpID0+ICFpc0xlbihpbnB1dC5uYW1lKSA/IGFjYyArIDEgOiBhY2MsIDApO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgbWV0aG9kIGRlZmluaXRpb24gZnJvbSBhYmlcbiAgICogQHBhcmFtIG5hbWUgc3RyaW5nXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uQWJpIHwgdW5kZWZpbmVkXG4gICAqL1xuICBnZXRNZXRob2QobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFiaS5maW5kKChpdCkgPT4gaXQubmFtZSA9PT0gbmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBBYmkgaW4gbGVnYWN5IGZvcm1hdFxuICAgKiBAcmV0dXJucyBBYmlcbiAgICovXG4gIGdldExlZ2FjeUZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5hYmk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9wYXJzZXIvcGFyc2VyLTIuMC4wLnRzXG52YXIgQWJpUGFyc2VyMiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYWJpKSB7XG4gICAgdGhpcy5hYmkgPSBhYmk7XG4gIH1cbiAgLyoqXG4gICAqIGFiaSBtZXRob2QgaW5wdXRzIGxlbmd0aFxuICAgKiBAcGFyYW0gYWJpTWV0aG9kIEZ1bmN0aW9uQWJpXG4gICAqIEByZXR1cm5zIG51bWJlclxuICAgKi9cbiAgbWV0aG9kSW5wdXRzTGVuZ3RoKGFiaU1ldGhvZCkge1xuICAgIHJldHVybiBhYmlNZXRob2QuaW5wdXRzLmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogZ2V0IG1ldGhvZCBkZWZpbml0aW9uIGZyb20gYWJpXG4gICAqIEBwYXJhbSBuYW1lIHN0cmluZ1xuICAgKiBAcmV0dXJucyBGdW5jdGlvbkFiaSB8IHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0TWV0aG9kKG5hbWUpIHtcbiAgICBjb25zdCBpbnRmID0gdGhpcy5hYmkuZmluZCgoaXQpID0+IGl0LnR5cGUgPT09IFwiaW50ZXJmYWNlXCIpO1xuICAgIHJldHVybiBpbnRmLml0ZW1zLmZpbmQoKGl0KSA9PiBpdC5uYW1lID09PSBuYW1lKTtcbiAgfVxuICAvKipcbiAgICogR2V0IEFiaSBpbiBsZWdhY3kgZm9ybWF0XG4gICAqIEByZXR1cm5zIEFiaVxuICAgKi9cbiAgZ2V0TGVnYWN5Rm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLmFiaS5mbGF0TWFwKChlKSA9PiB7XG4gICAgICBpZiAoZS50eXBlID09PSBcImludGVyZmFjZVwiKSB7XG4gICAgICAgIHJldHVybiBlLml0ZW1zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9wYXJzZXIvaW5kZXgudHNcbmZ1bmN0aW9uIGNyZWF0ZUFiaVBhcnNlcihhYmkpIHtcbiAgY29uc3QgdmVyc2lvbiA9IGdldEFiaVZlcnNpb24oYWJpKTtcbiAgaWYgKHZlcnNpb24gPT09IDAgfHwgdmVyc2lvbiA9PT0gMSkge1xuICAgIHJldHVybiBuZXcgQWJpUGFyc2VyMShhYmkpO1xuICB9XG4gIGlmICh2ZXJzaW9uID09PSAyKSB7XG4gICAgcmV0dXJuIG5ldyBBYmlQYXJzZXIyKGFiaSk7XG4gIH1cbiAgdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIEFCSSB2ZXJzaW9uICR7dmVyc2lvbn1gKTtcbn1cbmZ1bmN0aW9uIGdldEFiaVZlcnNpb24oYWJpKSB7XG4gIGlmIChhYmkuZmluZCgoaXQpID0+IGl0LnR5cGUgPT09IFwiaW50ZXJmYWNlXCIpKVxuICAgIHJldHVybiAyO1xuICBpZiAoaXNDYWlybzFBYmkoYWJpKSlcbiAgICByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpc05vQ29uc3RydWN0b3JWYWxpZChtZXRob2QsIGFyZ3NDYWxsZGF0YSwgYWJpTWV0aG9kKSB7XG4gIHJldHVybiBtZXRob2QgPT09IFwiY29uc3RydWN0b3JcIiAmJiAhYWJpTWV0aG9kICYmICFhcmdzQ2FsbGRhdGEubGVuZ3RoO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvdHVwbGUudHNcbmZ1bmN0aW9uIHBhcnNlTmFtZWRUdXBsZShuYW1lZFR1cGxlKSB7XG4gIGNvbnN0IG5hbWUgPSBuYW1lZFR1cGxlLnN1YnN0cmluZygwLCBuYW1lZFR1cGxlLmluZGV4T2YoXCI6XCIpKTtcbiAgY29uc3QgdHlwZSA9IG5hbWVkVHVwbGUuc3Vic3RyaW5nKG5hbWUubGVuZ3RoICsgXCI6XCIubGVuZ3RoKTtcbiAgcmV0dXJuIHsgbmFtZSwgdHlwZSB9O1xufVxuZnVuY3Rpb24gcGFyc2VTdWJUdXBsZShzKSB7XG4gIGlmICghcy5pbmNsdWRlcyhcIihcIikpXG4gICAgcmV0dXJuIHsgc3ViVHVwbGU6IFtdLCByZXN1bHQ6IHMgfTtcbiAgY29uc3Qgc3ViVHVwbGUgPSBbXTtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBzLmxlbmd0aCkge1xuICAgIGlmIChzW2ldID09PSBcIihcIikge1xuICAgICAgbGV0IGNvdW50ZXIgPSAxO1xuICAgICAgY29uc3QgbEJyYWNrZXQgPSBpO1xuICAgICAgaSsrO1xuICAgICAgd2hpbGUgKGNvdW50ZXIpIHtcbiAgICAgICAgaWYgKHNbaV0gPT09IFwiKVwiKVxuICAgICAgICAgIGNvdW50ZXItLTtcbiAgICAgICAgaWYgKHNbaV0gPT09IFwiKFwiKVxuICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgc3ViVHVwbGUucHVzaChzLnN1YnN0cmluZyhsQnJhY2tldCwgaSkpO1xuICAgICAgcmVzdWx0ICs9IFwiIFwiO1xuICAgICAgaS0tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gc1tpXTtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3ViVHVwbGUsXG4gICAgcmVzdWx0XG4gIH07XG59XG5mdW5jdGlvbiBleHRyYWN0Q2Fpcm8wVHVwbGUodHlwZSkge1xuICBjb25zdCBjbGVhblR5cGUgPSB0eXBlLnJlcGxhY2UoL1xccy9nLCBcIlwiKS5zbGljZSgxLCAtMSk7XG4gIGNvbnN0IHsgc3ViVHVwbGUsIHJlc3VsdCB9ID0gcGFyc2VTdWJUdXBsZShjbGVhblR5cGUpO1xuICBsZXQgcmVjb21wb3NlZCA9IHJlc3VsdC5zcGxpdChcIixcIikubWFwKChpdCkgPT4ge1xuICAgIHJldHVybiBzdWJUdXBsZS5sZW5ndGggPyBpdC5yZXBsYWNlKFwiIFwiLCBzdWJUdXBsZS5zaGlmdCgpKSA6IGl0O1xuICB9KTtcbiAgaWYgKGlzVHlwZU5hbWVkVHVwbGUodHlwZSkpIHtcbiAgICByZWNvbXBvc2VkID0gcmVjb21wb3NlZC5yZWR1Y2UoKGFjYywgaXQpID0+IHtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KHBhcnNlTmFtZWRUdXBsZShpdCkpO1xuICAgIH0sIFtdKTtcbiAgfVxuICByZXR1cm4gcmVjb21wb3NlZDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RDYWlybzFUdXBsZSh0eXBlKSB7XG4gIGNvbnN0IGNsZWFuVHlwZSA9IHR5cGUucmVwbGFjZSgvXFxzL2csIFwiXCIpLnNsaWNlKDEsIC0xKTtcbiAgY29uc3QgeyBzdWJUdXBsZSwgcmVzdWx0IH0gPSBwYXJzZVN1YlR1cGxlKGNsZWFuVHlwZSk7XG4gIGNvbnN0IHJlY29tcG9zZWQgPSByZXN1bHQuc3BsaXQoXCIsXCIpLm1hcCgoaXQpID0+IHtcbiAgICByZXR1cm4gc3ViVHVwbGUubGVuZ3RoID8gaXQucmVwbGFjZShcIiBcIiwgc3ViVHVwbGUuc2hpZnQoKSkgOiBpdDtcbiAgfSk7XG4gIHJldHVybiByZWNvbXBvc2VkO1xufVxuZnVuY3Rpb24gZXh0cmFjdFR1cGxlTWVtYmVyVHlwZXModHlwZSkge1xuICBpZiAoaXNDYWlybzFUeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIGV4dHJhY3RDYWlybzFUdXBsZSh0eXBlKTtcbiAgfVxuICByZXR1cm4gZXh0cmFjdENhaXJvMFR1cGxlKHR5cGUpO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcHJvcGVydHlPcmRlci50c1xuZnVuY3Rpb24gZXJyb3JVMjU2KGtleSkge1xuICByZXR1cm4gRXJyb3IoXG4gICAgYFlvdXIgb2JqZWN0IGluY2x1ZGVzIHRoZSBwcm9wZXJ0eSA6ICR7a2V5fSwgY29udGFpbmluZyBhbiBVaW50MjU2IG9iamVjdCB3aXRob3V0IHRoZSAnbG93JyBhbmQgJ2hpZ2gnIGtleXMuYFxuICApO1xufVxuZnVuY3Rpb24gb3JkZXJQcm9wc0J5QWJpKHVub3JkZXJlZE9iamVjdCwgYWJpT2ZPYmplY3QsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGNvbnN0IG9yZGVySW5wdXQgPSAodW5vcmRlcmVkSXRlbSwgYWJpVHlwZSkgPT4ge1xuICAgIGlmIChpc1R5cGVBcnJheShhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIG9yZGVyQXJyYXkodW5vcmRlcmVkSXRlbSwgYWJpVHlwZSk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVFbnVtKGFiaVR5cGUsIGVudW1zKSkge1xuICAgICAgY29uc3QgYWJpT2JqID0gZW51bXNbYWJpVHlwZV07XG4gICAgICByZXR1cm4gb3JkZXJFbnVtKHVub3JkZXJlZEl0ZW0sIGFiaU9iaik7XG4gICAgfVxuICAgIGlmIChpc1R5cGVUdXBsZShhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIG9yZGVyVHVwbGUodW5vcmRlcmVkSXRlbSwgYWJpVHlwZSk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVFdGhBZGRyZXNzKGFiaVR5cGUpKSB7XG4gICAgICByZXR1cm4gdW5vcmRlcmVkSXRlbTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZVVpbnQyNTYoYWJpVHlwZSkpIHtcbiAgICAgIGNvbnN0IHUyNTYgPSB1bm9yZGVyZWRJdGVtO1xuICAgICAgaWYgKHR5cGVvZiB1MjU2ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiB1MjU2O1xuICAgICAgfVxuICAgICAgaWYgKCEoXCJsb3dcIiBpbiB1MjU2ICYmIFwiaGlnaFwiIGluIHUyNTYpKSB7XG4gICAgICAgIHRocm93IGVycm9yVTI1NihhYmlUeXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGxvdzogdTI1Ni5sb3csIGhpZ2g6IHUyNTYuaGlnaCB9O1xuICAgIH1cbiAgICBpZiAoaXNUeXBlU3RydWN0KGFiaVR5cGUsIHN0cnVjdHMpKSB7XG4gICAgICBjb25zdCBhYmlPZlN0cnVjdCA9IHN0cnVjdHNbYWJpVHlwZV0ubWVtYmVycztcbiAgICAgIHJldHVybiBvcmRlclN0cnVjdCh1bm9yZGVyZWRJdGVtLCBhYmlPZlN0cnVjdCk7XG4gICAgfVxuICAgIHJldHVybiB1bm9yZGVyZWRJdGVtO1xuICB9O1xuICBjb25zdCBvcmRlclN0cnVjdCA9ICh1bm9yZGVyZWRPYmplY3QyLCBhYmlPYmplY3QpID0+IHtcbiAgICBjb25zdCBvcmRlcmVkT2JqZWN0MiA9IGFiaU9iamVjdC5yZWR1Y2UoKG9yZGVyZWRPYmplY3QsIGFiaVBhcmFtKSA9PiB7XG4gICAgICBjb25zdCBzZXRQcm9wZXJ0eSA9ICh2YWx1ZSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9yZGVyZWRPYmplY3QsIGFiaVBhcmFtLm5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlID8/IHVub3JkZXJlZE9iamVjdDJbYWJpUGFyYW0ubmFtZV1cbiAgICAgIH0pO1xuICAgICAgaWYgKHVub3JkZXJlZE9iamVjdDJbYWJpUGFyYW0ubmFtZV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKGlzQ2Fpcm8xVHlwZShhYmlQYXJhbS50eXBlKSB8fCAhaXNMZW4oYWJpUGFyYW0ubmFtZSkpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgWW91ciBvYmplY3QgbmVlZHMgYSBwcm9wZXJ0eSB3aXRoIGtleSA6ICR7YWJpUGFyYW0ubmFtZX0gLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRQcm9wZXJ0eShvcmRlcklucHV0KHVub3JkZXJlZE9iamVjdDJbYWJpUGFyYW0ubmFtZV0sIGFiaVBhcmFtLnR5cGUpKTtcbiAgICAgIHJldHVybiBvcmRlcmVkT2JqZWN0O1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gb3JkZXJlZE9iamVjdDI7XG4gIH07XG4gIGZ1bmN0aW9uIG9yZGVyQXJyYXkobXlBcnJheSwgYWJpUGFyYW0pIHtcbiAgICBjb25zdCB0eXBlSW5BcnJheSA9IGdldEFycmF5VHlwZShhYmlQYXJhbSk7XG4gICAgaWYgKHR5cGVvZiBteUFycmF5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gbXlBcnJheTtcbiAgICB9XG4gICAgcmV0dXJuIG15QXJyYXkubWFwKChteUVsZW0pID0+IG9yZGVySW5wdXQobXlFbGVtLCB0eXBlSW5BcnJheSkpO1xuICB9XG4gIGZ1bmN0aW9uIG9yZGVyVHVwbGUodW5vcmRlcmVkT2JqZWN0MiwgYWJpUGFyYW0pIHtcbiAgICBjb25zdCB0eXBlTGlzdCA9IGV4dHJhY3RUdXBsZU1lbWJlclR5cGVzKGFiaVBhcmFtKTtcbiAgICBjb25zdCBvcmRlcmVkT2JqZWN0MiA9IHR5cGVMaXN0LnJlZHVjZSgob3JkZXJlZE9iamVjdCwgYWJpVHlwZUNhaXJvWCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IG15T2JqS2V5cyA9IE9iamVjdC5rZXlzKHVub3JkZXJlZE9iamVjdDIpO1xuICAgICAgY29uc3Qgc2V0UHJvcGVydHkgPSAodmFsdWUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcmRlcmVkT2JqZWN0LCBpbmRleC50b1N0cmluZygpLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSA/PyB1bm9yZGVyZWRPYmplY3QyW215T2JqS2V5c1tpbmRleF1dXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFiaVR5cGUgPSBhYmlUeXBlQ2Fpcm9YPy50eXBlID8gYWJpVHlwZUNhaXJvWC50eXBlIDogYWJpVHlwZUNhaXJvWDtcbiAgICAgIHNldFByb3BlcnR5KG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0MltteU9iaktleXNbaW5kZXhdXSwgYWJpVHlwZSkpO1xuICAgICAgcmV0dXJuIG9yZGVyZWRPYmplY3Q7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBvcmRlcmVkT2JqZWN0MjtcbiAgfVxuICBjb25zdCBvcmRlckVudW0gPSAodW5vcmRlcmVkT2JqZWN0MiwgYWJpT2JqZWN0KSA9PiB7XG4gICAgaWYgKGlzVHlwZVJlc3VsdChhYmlPYmplY3QubmFtZSkpIHtcbiAgICAgIGNvbnN0IHVub3JkZXJlZFJlc3VsdCA9IHVub3JkZXJlZE9iamVjdDI7XG4gICAgICBjb25zdCByZXN1bHRPa1R5cGUgPSBhYmlPYmplY3QubmFtZS5zdWJzdHJpbmcoXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmluZGV4T2YoXCI8XCIpICsgMSxcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUubGFzdEluZGV4T2YoXCIsXCIpXG4gICAgICApO1xuICAgICAgY29uc3QgcmVzdWx0RXJyVHlwZSA9IGFiaU9iamVjdC5uYW1lLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUuaW5kZXhPZihcIixcIikgKyAxLFxuICAgICAgICBhYmlPYmplY3QubmFtZS5sYXN0SW5kZXhPZihcIj5cIilcbiAgICAgICk7XG4gICAgICBpZiAodW5vcmRlcmVkUmVzdWx0LmlzT2soKSkge1xuICAgICAgICByZXR1cm4gbmV3IENhaXJvUmVzdWx0KFxuICAgICAgICAgIDAgLyogT2sgKi8sXG4gICAgICAgICAgb3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3QyLnVud3JhcCgpLCByZXN1bHRPa1R5cGUpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENhaXJvUmVzdWx0KFxuICAgICAgICAxIC8qIEVyciAqLyxcbiAgICAgICAgb3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3QyLnVud3JhcCgpLCByZXN1bHRFcnJUeXBlKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZU9wdGlvbihhYmlPYmplY3QubmFtZSkpIHtcbiAgICAgIGNvbnN0IHVub3JkZXJlZE9wdGlvbiA9IHVub3JkZXJlZE9iamVjdDI7XG4gICAgICBjb25zdCByZXN1bHRTb21lVHlwZSA9IGFiaU9iamVjdC5uYW1lLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUuaW5kZXhPZihcIjxcIikgKyAxLFxuICAgICAgICBhYmlPYmplY3QubmFtZS5sYXN0SW5kZXhPZihcIj5cIilcbiAgICAgICk7XG4gICAgICBpZiAodW5vcmRlcmVkT3B0aW9uLmlzU29tZSgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2Fpcm9PcHRpb24oXG4gICAgICAgICAgMCAvKiBTb21lICovLFxuICAgICAgICAgIG9yZGVySW5wdXQodW5vcmRlcmVkT3B0aW9uLnVud3JhcCgpLCByZXN1bHRTb21lVHlwZSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9PcHRpb24oMSAvKiBOb25lICovLCB7fSk7XG4gICAgfVxuICAgIGNvbnN0IHVub3JkZXJlZEN1c3RvbUVudW0gPSB1bm9yZGVyZWRPYmplY3QyO1xuICAgIGNvbnN0IHZhcmlhbnRzID0gT2JqZWN0LmVudHJpZXModW5vcmRlcmVkQ3VzdG9tRW51bS52YXJpYW50KTtcbiAgICBjb25zdCBuZXdFbnRyaWVzID0gdmFyaWFudHMubWFwKCh2YXJpYW50KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhcmlhbnRbMV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCB2YXJpYW50VHlwZSA9IGFiaU9iamVjdC50eXBlLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0LnR5cGUubGFzdEluZGV4T2YoXCI8XCIpICsgMSxcbiAgICAgICAgYWJpT2JqZWN0LnR5cGUubGFzdEluZGV4T2YoXCI+XCIpXG4gICAgICApO1xuICAgICAgaWYgKHZhcmlhbnRUeXBlID09PSBcIigpXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3ZhcmlhbnRbMF0sIG9yZGVySW5wdXQodW5vcmRlcmVkQ3VzdG9tRW51bS51bndyYXAoKSwgdmFyaWFudFR5cGUpXTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IENhaXJvQ3VzdG9tRW51bShPYmplY3QuZnJvbUVudHJpZXMobmV3RW50cmllcykpO1xuICB9O1xuICBjb25zdCBmaW5hbE9yZGVyZWRPYmplY3QgPSBhYmlPZk9iamVjdC5yZWR1Y2UoKG9yZGVyZWRPYmplY3QsIGFiaVBhcmFtKSA9PiB7XG4gICAgY29uc3Qgc2V0UHJvcGVydHkgPSAodmFsdWUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcmRlcmVkT2JqZWN0LCBhYmlQYXJhbS5uYW1lLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICBpZiAoaXNMZW4oYWJpUGFyYW0ubmFtZSkgJiYgIWlzQ2Fpcm8xVHlwZShhYmlQYXJhbS50eXBlKSkge1xuICAgICAgcmV0dXJuIG9yZGVyZWRPYmplY3Q7XG4gICAgfVxuICAgIHNldFByb3BlcnR5KG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0W2FiaVBhcmFtLm5hbWVdLCBhYmlQYXJhbS50eXBlKSk7XG4gICAgcmV0dXJuIG9yZGVyZWRPYmplY3Q7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIGZpbmFsT3JkZXJlZE9iamVjdDtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3JlcXVlc3RQYXJzZXIudHNcbmZ1bmN0aW9uIHBhcnNlQmFzZVR5cGVzKHR5cGUsIHZhbCkge1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZVVpbnQyNTYodHlwZSk6XG4gICAgICBjb25zdCBlbF91aW50MjU2ID0gdWludDI1Nih2YWwpO1xuICAgICAgcmV0dXJuIFtmZWx0KGVsX3VpbnQyNTYubG93KSwgZmVsdChlbF91aW50MjU2LmhpZ2gpXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZlbHQodmFsKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VUdXBsZShlbGVtZW50LCB0eXBlU3RyKSB7XG4gIGNvbnN0IG1lbWJlclR5cGVzID0gZXh0cmFjdFR1cGxlTWVtYmVyVHlwZXModHlwZVN0cik7XG4gIGNvbnN0IGVsZW1lbnRzID0gT2JqZWN0LnZhbHVlcyhlbGVtZW50KTtcbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCAhPT0gbWVtYmVyVHlwZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBgUGFyc2VUdXBsZTogcHJvdmlkZWQgYW5kIGV4cGVjdGVkIGFiaSB0dXBsZSBzaXplIGRvIG5vdCBtYXRjaC5cbiAgICAgIHByb3ZpZGVkOiAke2VsZW1lbnRzfSBcbiAgICAgIGV4cGVjdGVkOiAke21lbWJlclR5cGVzfWBcbiAgICApO1xuICB9XG4gIHJldHVybiBtZW1iZXJUeXBlcy5tYXAoKGl0LCBkeCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50OiBlbGVtZW50c1tkeF0sXG4gICAgICB0eXBlOiBpdC50eXBlID8/IGl0XG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZVVpbnQyNTYoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCB7IGxvdywgaGlnaCB9ID0gZWxlbWVudDtcbiAgICByZXR1cm4gW2ZlbHQobG93KSwgZmVsdChoaWdoKV07XG4gIH1cbiAgY29uc3QgZWxfdWludDI1NiA9IHVpbnQyNTYoZWxlbWVudCk7XG4gIHJldHVybiBbZmVsdChlbF91aW50MjU2LmxvdyksIGZlbHQoZWxfdWludDI1Ni5oaWdoKV07XG59XG5mdW5jdGlvbiBwYXJzZUNhbGxkYXRhVmFsdWUoZWxlbWVudCwgdHlwZSwgc3RydWN0cywgZW51bXMpIHtcbiAgaWYgKGVsZW1lbnQgPT09IHZvaWQgMCkge1xuICAgIHRocm93IEVycm9yKGBNaXNzaW5nIHBhcmFtZXRlciBmb3IgdHlwZSAke3R5cGV9YCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudCkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICByZXN1bHQucHVzaChmZWx0KGVsZW1lbnQubGVuZ3RoKSk7XG4gICAgY29uc3QgYXJyYXlUeXBlID0gZ2V0QXJyYXlUeXBlKHR5cGUpO1xuICAgIHJldHVybiBlbGVtZW50LnJlZHVjZSgoYWNjLCBpdCkgPT4ge1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQocGFyc2VDYWxsZGF0YVZhbHVlKGl0LCBhcnJheVR5cGUsIHN0cnVjdHMsIGVudW1zKSk7XG4gICAgfSwgcmVzdWx0KTtcbiAgfVxuICBpZiAoc3RydWN0c1t0eXBlXSAmJiBzdHJ1Y3RzW3R5cGVdLm1lbWJlcnMubGVuZ3RoKSB7XG4gICAgaWYgKGlzVHlwZVVpbnQyNTYodHlwZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZVVpbnQyNTYoZWxlbWVudCk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImNvcmU6OnN0YXJrbmV0OjpldGhfYWRkcmVzczo6RXRoQWRkcmVzc1wiKVxuICAgICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzKHR5cGUsIGVsZW1lbnQpO1xuICAgIGNvbnN0IHsgbWVtYmVycyB9ID0gc3RydWN0c1t0eXBlXTtcbiAgICBjb25zdCBzdWJFbGVtZW50ID0gZWxlbWVudDtcbiAgICByZXR1cm4gbWVtYmVycy5yZWR1Y2UoKGFjYywgaXQpID0+IHtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KHBhcnNlQ2FsbGRhdGFWYWx1ZShzdWJFbGVtZW50W2l0Lm5hbWVdLCBpdC50eXBlLCBzdHJ1Y3RzLCBlbnVtcykpO1xuICAgIH0sIFtdKTtcbiAgfVxuICBpZiAoaXNUeXBlVHVwbGUodHlwZSkpIHtcbiAgICBjb25zdCB0dXBsZWQgPSBwYXJzZVR1cGxlKGVsZW1lbnQsIHR5cGUpO1xuICAgIHJldHVybiB0dXBsZWQucmVkdWNlKChhY2MsIGl0KSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWREYXRhID0gcGFyc2VDYWxsZGF0YVZhbHVlKGl0LmVsZW1lbnQsIGl0LnR5cGUsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KHBhcnNlZERhdGEpO1xuICAgIH0sIFtdKTtcbiAgfVxuICBpZiAoaXNUeXBlVWludDI1Nih0eXBlKSkge1xuICAgIHJldHVybiBwYXJzZVVpbnQyNTYoZWxlbWVudCk7XG4gIH1cbiAgaWYgKGlzVHlwZUVudW0odHlwZSwgZW51bXMpKSB7XG4gICAgY29uc3QgeyB2YXJpYW50cyB9ID0gZW51bXNbdHlwZV07XG4gICAgaWYgKGlzVHlwZU9wdGlvbih0eXBlKSkge1xuICAgICAgY29uc3QgbXlPcHRpb24gPSBlbGVtZW50O1xuICAgICAgaWYgKG15T3B0aW9uLmlzU29tZSgpKSB7XG4gICAgICAgIGNvbnN0IGxpc3RUeXBlVmFyaWFudDIgPSB2YXJpYW50cy5maW5kKCh2YXJpYW50KSA9PiB2YXJpYW50Lm5hbWUgPT09IFwiU29tZVwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0VHlwZVZhcmlhbnQyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEVycm9yIGluIGFiaSA6IE9wdGlvbiBoYXMgbm8gJ1NvbWUnIHZhcmlhbnQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZVZhcmlhbnRTb21lID0gbGlzdFR5cGVWYXJpYW50Mi50eXBlO1xuICAgICAgICBpZiAodHlwZVZhcmlhbnRTb21lID09PSBcIigpXCIpIHtcbiAgICAgICAgICByZXR1cm4gMCAvKiBTb21lICovLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkUGFyYW1ldGVyMiA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShcbiAgICAgICAgICBteU9wdGlvbi51bndyYXAoKSxcbiAgICAgICAgICB0eXBlVmFyaWFudFNvbWUsXG4gICAgICAgICAgc3RydWN0cyxcbiAgICAgICAgICBlbnVtc1xuICAgICAgICApO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRQYXJhbWV0ZXIyKSkge1xuICAgICAgICAgIHJldHVybiBbMCAvKiBTb21lICovLnRvU3RyaW5nKCksIC4uLnBhcnNlZFBhcmFtZXRlcjJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbMCAvKiBTb21lICovLnRvU3RyaW5nKCksIHBhcnNlZFBhcmFtZXRlcjJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDEgLyogTm9uZSAqLy50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlUmVzdWx0KHR5cGUpKSB7XG4gICAgICBjb25zdCBteVJlc3VsdCA9IGVsZW1lbnQ7XG4gICAgICBpZiAobXlSZXN1bHQuaXNPaygpKSB7XG4gICAgICAgIGNvbnN0IGxpc3RUeXBlVmFyaWFudDMgPSB2YXJpYW50cy5maW5kKCh2YXJpYW50KSA9PiB2YXJpYW50Lm5hbWUgPT09IFwiT2tcIik7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdFR5cGVWYXJpYW50MyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFcnJvciBpbiBhYmkgOiBSZXN1bHQgaGFzIG5vICdPaycgdmFyaWFudC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlVmFyaWFudE9rID0gbGlzdFR5cGVWYXJpYW50My50eXBlO1xuICAgICAgICBpZiAodHlwZVZhcmlhbnRPayA9PT0gXCIoKVwiKSB7XG4gICAgICAgICAgcmV0dXJuIDAgLyogT2sgKi8udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRQYXJhbWV0ZXIzID0gcGFyc2VDYWxsZGF0YVZhbHVlKFxuICAgICAgICAgIG15UmVzdWx0LnVud3JhcCgpLFxuICAgICAgICAgIHR5cGVWYXJpYW50T2ssXG4gICAgICAgICAgc3RydWN0cyxcbiAgICAgICAgICBlbnVtc1xuICAgICAgICApO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRQYXJhbWV0ZXIzKSkge1xuICAgICAgICAgIHJldHVybiBbMCAvKiBPayAqLy50b1N0cmluZygpLCAuLi5wYXJzZWRQYXJhbWV0ZXIzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWzAgLyogT2sgKi8udG9TdHJpbmcoKSwgcGFyc2VkUGFyYW1ldGVyM107XG4gICAgICB9XG4gICAgICBjb25zdCBsaXN0VHlwZVZhcmlhbnQyID0gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBcIkVyclwiKTtcbiAgICAgIGlmICh0eXBlb2YgbGlzdFR5cGVWYXJpYW50MiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXJyb3IgaW4gYWJpIDogUmVzdWx0IGhhcyBubyAnRXJyJyB2YXJpYW50LmApO1xuICAgICAgfVxuICAgICAgY29uc3QgdHlwZVZhcmlhbnRFcnIgPSBsaXN0VHlwZVZhcmlhbnQyLnR5cGU7XG4gICAgICBpZiAodHlwZVZhcmlhbnRFcnIgPT09IFwiKClcIikge1xuICAgICAgICByZXR1cm4gMSAvKiBFcnIgKi8udG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnNlZFBhcmFtZXRlcjIgPSBwYXJzZUNhbGxkYXRhVmFsdWUobXlSZXN1bHQudW53cmFwKCksIHR5cGVWYXJpYW50RXJyLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRQYXJhbWV0ZXIyKSkge1xuICAgICAgICByZXR1cm4gWzEgLyogRXJyICovLnRvU3RyaW5nKCksIC4uLnBhcnNlZFBhcmFtZXRlcjJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFsxIC8qIEVyciAqLy50b1N0cmluZygpLCBwYXJzZWRQYXJhbWV0ZXIyXTtcbiAgICB9XG4gICAgY29uc3QgbXlFbnVtID0gZWxlbWVudDtcbiAgICBjb25zdCBhY3RpdmVWYXJpYW50ID0gbXlFbnVtLmFjdGl2ZVZhcmlhbnQoKTtcbiAgICBjb25zdCBsaXN0VHlwZVZhcmlhbnQgPSB2YXJpYW50cy5maW5kKCh2YXJpYW50KSA9PiB2YXJpYW50Lm5hbWUgPT09IGFjdGl2ZVZhcmlhbnQpO1xuICAgIGlmICh0eXBlb2YgbGlzdFR5cGVWYXJpYW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBFcnJvcihgTm90IGZpbmQgaW4gYWJpIDogRW51bSBoYXMgbm8gJyR7YWN0aXZlVmFyaWFudH0nIHZhcmlhbnQuYCk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGVBY3RpdmVWYXJpYW50ID0gbGlzdFR5cGVWYXJpYW50LnR5cGU7XG4gICAgY29uc3QgbnVtQWN0aXZlVmFyaWFudCA9IHZhcmlhbnRzLmZpbmRJbmRleCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBhY3RpdmVWYXJpYW50KTtcbiAgICBpZiAodHlwZUFjdGl2ZVZhcmlhbnQgPT09IFwiKClcIikge1xuICAgICAgcmV0dXJuIG51bUFjdGl2ZVZhcmlhbnQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkUGFyYW1ldGVyID0gcGFyc2VDYWxsZGF0YVZhbHVlKG15RW51bS51bndyYXAoKSwgdHlwZUFjdGl2ZVZhcmlhbnQsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRQYXJhbWV0ZXIpKSB7XG4gICAgICByZXR1cm4gW251bUFjdGl2ZVZhcmlhbnQudG9TdHJpbmcoKSwgLi4ucGFyc2VkUGFyYW1ldGVyXTtcbiAgICB9XG4gICAgcmV0dXJuIFtudW1BY3RpdmVWYXJpYW50LnRvU3RyaW5nKCksIHBhcnNlZFBhcmFtZXRlcl07XG4gIH1cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgRXJyb3IoYFBhcmFtZXRlciAke2VsZW1lbnR9IGRvIG5vdCBhbGlnbiB3aXRoIGFiaSBwYXJhbWV0ZXIgJHt0eXBlfWApO1xuICB9XG4gIHJldHVybiBwYXJzZUJhc2VUeXBlcyh0eXBlLCBlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2FsbGRhdGFGaWVsZChhcmdzSXRlcmF0b3IsIGlucHV0LCBzdHJ1Y3RzLCBlbnVtcykge1xuICBjb25zdCB7IG5hbWUsIHR5cGUgfSA9IGlucHV0O1xuICBsZXQgeyB2YWx1ZSB9ID0gYXJnc0l0ZXJhdG9yLm5leHQoKTtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc1R5cGVBcnJheSh0eXBlKTpcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgIWlzVGV4dCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEFCSSBleHBlY3RlZCBwYXJhbWV0ZXIgJHtuYW1lfSB0byBiZSBhcnJheSBvciBsb25nIHN0cmluZywgZ290ICR7dmFsdWV9YCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gc3BsaXRMb25nU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZUNhbGxkYXRhVmFsdWUodmFsdWUsIGlucHV0LnR5cGUsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIHR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCI6XG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXModHlwZSwgdmFsdWUpO1xuICAgIGNhc2UgKGlzVHlwZVN0cnVjdCh0eXBlLCBzdHJ1Y3RzKSB8fCBpc1R5cGVUdXBsZSh0eXBlKSB8fCBpc1R5cGVVaW50MjU2KHR5cGUpKTpcbiAgICAgIHJldHVybiBwYXJzZUNhbGxkYXRhVmFsdWUodmFsdWUsIHR5cGUsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIGlzVHlwZUVudW0odHlwZSwgZW51bXMpOlxuICAgICAgcmV0dXJuIHBhcnNlQ2FsbGRhdGFWYWx1ZShcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHN0cnVjdHMsXG4gICAgICAgIGVudW1zXG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXModHlwZSwgdmFsdWUpO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9yZXNwb25zZVBhcnNlci50c1xuZnVuY3Rpb24gcGFyc2VCYXNlVHlwZXMyKHR5cGUsIGl0KSB7XG4gIGxldCB0ZW1wO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZUJvb2wodHlwZSk6XG4gICAgICB0ZW1wID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIEJvb2xlYW4oQmlnSW50KHRlbXApKTtcbiAgICBjYXNlIGlzVHlwZVVpbnQyNTYodHlwZSk6XG4gICAgICBjb25zdCBsb3cgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICBjb25zdCBoaWdoID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIHVpbnQyNTZUb0JOKHsgbG93LCBoaWdoIH0pO1xuICAgIGNhc2UgdHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIjpcbiAgICAgIHRlbXAgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gQmlnSW50KHRlbXApO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0ZW1wID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIEJpZ0ludCh0ZW1wKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsZW1lbnQsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGlmIChlbGVtZW50LnR5cGUgPT09IFwiKClcIikge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBpZiAoaXNUeXBlVWludDI1NihlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgbG93ID0gcmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgY29uc3QgaGlnaCA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIHJldHVybiB1aW50MjU2VG9CTih7IGxvdywgaGlnaCB9KTtcbiAgfVxuICBpZiAoaXNUeXBlQXJyYXkoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IHBhcnNlZERhdGFBcnIgPSBbXTtcbiAgICBjb25zdCBlbCA9IHsgbmFtZTogXCJcIiwgdHlwZTogZ2V0QXJyYXlUeXBlKGVsZW1lbnQudHlwZSkgfTtcbiAgICBjb25zdCBsZW4gPSBCaWdJbnQocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIHdoaWxlIChwYXJzZWREYXRhQXJyLmxlbmd0aCA8IGxlbikge1xuICAgICAgcGFyc2VkRGF0YUFyci5wdXNoKHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbCwgc3RydWN0cywgZW51bXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZERhdGFBcnI7XG4gIH1cbiAgaWYgKHN0cnVjdHMgJiYgZWxlbWVudC50eXBlIGluIHN0cnVjdHMgJiYgc3RydWN0c1tlbGVtZW50LnR5cGVdKSB7XG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIikge1xuICAgICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzMihlbGVtZW50LnR5cGUsIHJlc3BvbnNlSXRlcmF0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gc3RydWN0c1tlbGVtZW50LnR5cGVdLm1lbWJlcnMucmVkdWNlKChhY2MsIGVsKSA9PiB7XG4gICAgICBhY2NbZWwubmFtZV0gPSBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgZWwsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9XG4gIGlmIChlbnVtcyAmJiBlbGVtZW50LnR5cGUgaW4gZW51bXMgJiYgZW51bXNbZWxlbWVudC50eXBlXSkge1xuICAgIGNvbnN0IHZhcmlhbnROdW0gPSBOdW1iZXIocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIGNvbnN0IHJhd0VudW0gPSBlbnVtc1tlbGVtZW50LnR5cGVdLnZhcmlhbnRzLnJlZHVjZSgoYWNjLCB2YXJpYW50LCBudW0pID0+IHtcbiAgICAgIGlmIChudW0gPT09IHZhcmlhbnROdW0pIHtcbiAgICAgICAgYWNjW3ZhcmlhbnQubmFtZV0gPSBwYXJzZVJlc3BvbnNlVmFsdWUoXG4gICAgICAgICAgcmVzcG9uc2VJdGVyYXRvcixcbiAgICAgICAgICB7IG5hbWU6IFwiXCIsIHR5cGU6IHZhcmlhbnQudHlwZSB9LFxuICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgZW51bXNcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGFjY1t2YXJpYW50Lm5hbWVdID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgaWYgKGVsZW1lbnQudHlwZS5zdGFydHNXaXRoKFwiY29yZTo6b3B0aW9uOjpPcHRpb25cIikpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB2YXJpYW50TnVtID09PSAwIC8qIFNvbWUgKi8gPyByYXdFbnVtLlNvbWUgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gbmV3IENhaXJvT3B0aW9uKHZhcmlhbnROdW0sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC50eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpyZXN1bHQ6OlJlc3VsdFwiKSkge1xuICAgICAgbGV0IGNvbnRlbnQ7XG4gICAgICBpZiAodmFyaWFudE51bSA9PT0gMCAvKiBPayAqLykge1xuICAgICAgICBjb250ZW50ID0gcmF3RW51bS5PaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRlbnQgPSByYXdFbnVtLkVycjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9SZXN1bHQodmFyaWFudE51bSwgY29udGVudCk7XG4gICAgfVxuICAgIGNvbnN0IGN1c3RvbUVudW0gPSBuZXcgQ2Fpcm9DdXN0b21FbnVtKHJhd0VudW0pO1xuICAgIHJldHVybiBjdXN0b21FbnVtO1xuICB9XG4gIGlmIChpc1R5cGVUdXBsZShlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgbWVtYmVyVHlwZXMgPSBleHRyYWN0VHVwbGVNZW1iZXJUeXBlcyhlbGVtZW50LnR5cGUpO1xuICAgIHJldHVybiBtZW1iZXJUeXBlcy5yZWR1Y2UoKGFjYywgaXQsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGl0Py5uYW1lID8gaXQubmFtZSA6IGlkeDtcbiAgICAgIGNvbnN0IHR5cGUgPSBpdD8udHlwZSA/IGl0LnR5cGUgOiBpdDtcbiAgICAgIGNvbnN0IGVsID0geyBuYW1lLCB0eXBlIH07XG4gICAgICBhY2NbbmFtZV0gPSBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgZWwsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9XG4gIGlmIChpc1R5cGVBcnJheShlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgcGFyc2VkRGF0YUFyciA9IFtdO1xuICAgIGNvbnN0IGVsID0geyBuYW1lOiBcIlwiLCB0eXBlOiBnZXRBcnJheVR5cGUoZWxlbWVudC50eXBlKSB9O1xuICAgIGNvbnN0IGxlbiA9IEJpZ0ludChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgd2hpbGUgKHBhcnNlZERhdGFBcnIubGVuZ3RoIDwgbGVuKSB7XG4gICAgICBwYXJzZWREYXRhQXJyLnB1c2gocGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcykpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkRGF0YUFycjtcbiAgfVxuICByZXR1cm4gcGFyc2VCYXNlVHlwZXMyKGVsZW1lbnQudHlwZSwgcmVzcG9uc2VJdGVyYXRvcik7XG59XG5mdW5jdGlvbiByZXNwb25zZVBhcnNlcihyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHN0cnVjdHMsIGVudW1zLCBwYXJzZWRSZXN1bHQpIHtcbiAgY29uc3QgeyBuYW1lLCB0eXBlIH0gPSBvdXRwdXQ7XG4gIGxldCB0ZW1wO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzTGVuKG5hbWUpOlxuICAgICAgdGVtcCA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIEJpZ0ludCh0ZW1wKTtcbiAgICBjYXNlIChzdHJ1Y3RzICYmIHR5cGUgaW4gc3RydWN0cyB8fCBpc1R5cGVUdXBsZSh0eXBlKSk6XG4gICAgICByZXR1cm4gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIG91dHB1dCwgc3RydWN0cywgZW51bXMpO1xuICAgIGNhc2UgKGVudW1zICYmIGlzVHlwZUVudW0odHlwZSwgZW51bXMpKTpcbiAgICAgIHJldHVybiBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgY2FzZSBpc1R5cGVBcnJheSh0eXBlKTpcbiAgICAgIGlmIChpc0NhaXJvMVR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnNlZERhdGFBcnIgPSBbXTtcbiAgICAgIGlmIChwYXJzZWRSZXN1bHQgJiYgcGFyc2VkUmVzdWx0W2Ake25hbWV9X2xlbmBdKSB7XG4gICAgICAgIGNvbnN0IGFyckxlbiA9IHBhcnNlZFJlc3VsdFtgJHtuYW1lfV9sZW5gXTtcbiAgICAgICAgd2hpbGUgKHBhcnNlZERhdGFBcnIubGVuZ3RoIDwgYXJyTGVuKSB7XG4gICAgICAgICAgcGFyc2VkRGF0YUFyci5wdXNoKFxuICAgICAgICAgICAgcGFyc2VSZXNwb25zZVZhbHVlKFxuICAgICAgICAgICAgICByZXNwb25zZUl0ZXJhdG9yLFxuICAgICAgICAgICAgICB7IG5hbWUsIHR5cGU6IG91dHB1dC50eXBlLnJlcGxhY2UoXCIqXCIsIFwiXCIpIH0sXG4gICAgICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgICAgIGVudW1zXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZERhdGFBcnI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlczIodHlwZSwgcmVzcG9uc2VJdGVyYXRvcik7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3ZhbGlkYXRlLnRzXG52YXIgdmFsaWRhdGVGZWx0ID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgcGFyYW1ldGVyID09PSBcImJpZ2ludFwiLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGEgZmVsdCB0eXBlZCBhcyAoU3RyaW5nLCBOdW1iZXIgb3IgQmlnSW50KWBcbiAgKTtcbiAgaWYgKHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwic3RyaW5nXCIgJiYgIWlzSGV4KHBhcmFtZXRlcikpXG4gICAgcmV0dXJuO1xuICBjb25zdCBwYXJhbSA9IEJpZ0ludChwYXJhbWV0ZXIudG9TdHJpbmcoMTApKTtcbiAgYXNzZXJ0KFxuICAgIC8vIGZyb20gOiBodHRwczovL2dpdGh1Yi5jb20vc3Rhcmt3YXJlLWxpYnMvc3RhcmtuZXQtc3BlY3MvYmxvYi8yOWJhYjY1MGJlNmIxODQ3YzkyZDQ0NjFkNGMzMzAwOGI1ZTUwYjFhL2FwaS9zdGFya25ldF9hcGlfb3BlbnJwYy5qc29uI0wxMjY2XG4gICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMjUybiAtIDFuLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeMjUyLTFdYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZVVpbnQgPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBpZiAodHlwZW9mIHBhcmFtZXRlciA9PT0gXCJudW1iZXJcIikge1xuICAgIGFzc2VydChcbiAgICAgIHBhcmFtZXRlciA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgIGBWYWxpZGF0aW9uOiBQYXJhbWV0ZXIgaXMgdG8gbGFyZ2UgdG8gYmUgdHlwZWQgYXMgTnVtYmVyIHVzZSAoQmlnSW50IG9yIFN0cmluZylgXG4gICAgKTtcbiAgfVxuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgcGFyYW1ldGVyID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwiYmlnaW50XCIgfHwgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiBcImxvd1wiIGluIHBhcmFtZXRlciAmJiBcImhpZ2hcIiBpbiBwYXJhbWV0ZXIsXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBvZiBjYWlybyB0eXBlICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIHR5cGUgKFN0cmluZywgTnVtYmVyIG9yIEJpZ0ludCksIGJ1dCBpcyAke3R5cGVvZiBwYXJhbWV0ZXJ9ICR7cGFyYW1ldGVyfS5gXG4gICk7XG4gIGNvbnN0IHBhcmFtID0gdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiA/IHVpbnQyNTZUb0JOKHBhcmFtZXRlcikgOiB0b0JpZ0ludChwYXJhbWV0ZXIpO1xuICBzd2l0Y2ggKGlucHV0LnR5cGUpIHtcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dThcIiAvKiB1OCAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMjU1bixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCAtIDI1NV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnUxNlwiIC8qIHUxNiAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gNjU1MzVuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCA2NTUzNV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnUzMlwiIC8qIHUzMiAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gNDI5NDk2NzI5NW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDQyOTQ5NjcyOTVdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1NjRcIiAvKiB1NjQgKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDY0biAtIDFuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjY0LTFdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1MTI4XCIgLyogdTEyOCAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMTI4biAtIDFuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjEyOC0xXWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiIC8qIHUyNTYgKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDI1Nm4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBpcyAke2lucHV0LnR5cGV9IDAgLSAyXjI1Ni0xYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjpzdGFya25ldDo6Y2xhc3NfaGFzaDo6Q2xhc3NIYXNoXCIgLyogQ2xhc3NIYXNoICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICAvLyBmcm9tIDogaHR0cHM6Ly9naXRodWIuY29tL3N0YXJrd2FyZS1saWJzL3N0YXJrbmV0LXNwZWNzL2Jsb2IvMjliYWI2NTBiZTZiMTg0N2M5MmQ0NDYxZDRjMzMwMDhiNWU1MGIxYS9hcGkvc3RhcmtuZXRfYXBpX29wZW5ycGMuanNvbiNMMTY3MFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAyNTJuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeMjUyLTFdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjpzdGFya25ldDo6Y29udHJhY3RfYWRkcmVzczo6Q29udHJhY3RBZGRyZXNzXCIgLyogQ29udHJhY3RBZGRyZXNzICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICAvLyBmcm9tIDogaHR0cHM6Ly9naXRodWIuY29tL3N0YXJrd2FyZS1saWJzL3N0YXJrbmV0LXNwZWNzL2Jsb2IvMjliYWI2NTBiZTZiMTg0N2M5MmQ0NDYxZDRjMzMwMDhiNWU1MGIxYS9hcGkvc3RhcmtuZXRfYXBpX29wZW5ycGMuanNvbiNMMTI0NVxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAyNTJuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeMjUyLTFdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxufTtcbnZhciB2YWxpZGF0ZUJvb2wgPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJib29sZWFuXCIsXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBvZiBjYWlybyB0eXBlICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIHR5cGUgKEJvb2xlYW4pYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZVN0cnVjdCA9IChwYXJhbWV0ZXIsIGlucHV0LCBzdHJ1Y3RzKSA9PiB7XG4gIGlmIChpbnB1dC50eXBlID09PSBcImNvcmU6OmludGVnZXI6OnUyNTZcIiAvKiB1MjU2ICovKSB7XG4gICAgdmFsaWRhdGVVaW50KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5wdXQudHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIikge1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiBwYXJhbWV0ZXIgIT09IFwib2JqZWN0XCIsXG4gICAgICBgRXRoQWRyZXNzIHR5cGUgaXMgd2FpdGluZyBhIEJpZ051bWJlcmlzaC4gR290ICR7cGFyYW1ldGVyfWBcbiAgICApO1xuICAgIGNvbnN0IHBhcmFtID0gQmlnSW50KHBhcmFtZXRlci50b1N0cmluZygxMCkpO1xuICAgIGFzc2VydChcbiAgICAgIC8vIGZyb20gOiBodHRwczovL2dpdGh1Yi5jb20vc3Rhcmt3YXJlLWxpYnMvc3RhcmtuZXQtc3BlY3MvYmxvYi8yOWJhYjY1MGJlNmIxODQ3YzkyZDQ0NjFkNGMzMzAwOGI1ZTUwYjFhL2FwaS9zdGFya25ldF9hcGlfb3BlbnJwYy5qc29uI0wxMjU5XG4gICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAxNjBuIC0gMW4sXG4gICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjE2MC0xXWBcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gaXMgY2Fpcm8gdHlwZSBzdHJ1Y3QgKCR7aW5wdXQudHlwZX0pLCBhbmQgc2hvdWxkIGJlIGRlZmluZWQgYXMganMgb2JqZWN0IChub3QgYXJyYXkpYFxuICApO1xuICBzdHJ1Y3RzW2lucHV0LnR5cGVdLm1lbWJlcnMuZm9yRWFjaCgoeyBuYW1lIH0pID0+IHtcbiAgICBhc3NlcnQoXG4gICAgICBPYmplY3Qua2V5cyhwYXJhbWV0ZXIpLmluY2x1ZGVzKG5hbWUpLFxuICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBzaG91bGQgaGF2ZSBhIHByb3BlcnR5ICR7bmFtZX1gXG4gICAgKTtcbiAgfSk7XG59O1xudmFyIHZhbGlkYXRlRW51bSA9IChwYXJhbWV0ZXIsIGlucHV0KSA9PiB7XG4gIGFzc2VydChcbiAgICB0eXBlb2YgcGFyYW1ldGVyID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHBhcmFtZXRlciksXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBpcyBjYWlybyB0eXBlIEVudW0gKCR7aW5wdXQudHlwZX0pLCBhbmQgc2hvdWxkIGJlIGRlZmluZWQgYXMganMgb2JqZWN0IChub3QgYXJyYXkpYFxuICApO1xuICBjb25zdCBtZXRob2RzS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXJhbWV0ZXIpKTtcbiAgY29uc3Qga2V5cyA9IFsuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwYXJhbWV0ZXIpLCAuLi5tZXRob2RzS2V5c107XG4gIGlmIChpc1R5cGVPcHRpb24oaW5wdXQudHlwZSkgJiYga2V5cy5pbmNsdWRlcyhcImlzU29tZVwiKSAmJiBrZXlzLmluY2x1ZGVzKFwiaXNOb25lXCIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc1R5cGVSZXN1bHQoaW5wdXQudHlwZSkgJiYga2V5cy5pbmNsdWRlcyhcImlzT2tcIikgJiYga2V5cy5pbmNsdWRlcyhcImlzRXJyXCIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChrZXlzLmluY2x1ZGVzKFwidmFyaWFudFwiKSAmJiBrZXlzLmluY2x1ZGVzKFwiYWN0aXZlVmFyaWFudFwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYFZhbGlkYXRlIEVudW06IGFyZ3VtZW50ICR7aW5wdXQubmFtZX0sIHR5cGUgJHtpbnB1dC50eXBlfSwgdmFsdWUgcmVjZWl2ZWQgJHtwYXJhbWV0ZXJ9LCBpcyBub3QgYW4gRW51bS5gXG4gICk7XG59O1xudmFyIHZhbGlkYXRlVHVwbGUgPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGEgdHVwbGUgKGRlZmluZWQgYXMgb2JqZWN0KWBcbiAgKTtcbn07XG52YXIgdmFsaWRhdGVBcnJheSA9IChwYXJhbWV0ZXIsIGlucHV0LCBzdHJ1Y3RzLCBlbnVtcykgPT4ge1xuICBjb25zdCBiYXNlVHlwZSA9IGdldEFycmF5VHlwZShpbnB1dC50eXBlKTtcbiAgaWYgKGlzVHlwZUZlbHQoYmFzZVR5cGUpICYmIGlzTG9uZ1RleHQocGFyYW1ldGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBhc3NlcnQoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXIpLCBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IHNob3VsZCBiZSBhbiBBcnJheWApO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZUZlbHQoYmFzZVR5cGUpOlxuICAgICAgcGFyYW1ldGVyLmZvckVhY2goKHBhcmFtKSA9PiB2YWxpZGF0ZUZlbHQocGFyYW0sIGlucHV0KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlzVHlwZVR1cGxlKGJhc2VUeXBlKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKChpdCkgPT4gdmFsaWRhdGVUdXBsZShpdCwgeyBuYW1lOiBpbnB1dC5uYW1lLCB0eXBlOiBiYXNlVHlwZSB9KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlzVHlwZUFycmF5KGJhc2VUeXBlKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKFxuICAgICAgICAocGFyYW0pID0+IHZhbGlkYXRlQXJyYXkocGFyYW0sIHsgbmFtZTogXCJcIiwgdHlwZTogYmFzZVR5cGUgfSwgc3RydWN0cywgZW51bXMpXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVTdHJ1Y3QoYmFzZVR5cGUsIHN0cnVjdHMpOlxuICAgICAgcGFyYW1ldGVyLmZvckVhY2goXG4gICAgICAgIChpdCkgPT4gdmFsaWRhdGVTdHJ1Y3QoaXQsIHsgbmFtZTogaW5wdXQubmFtZSwgdHlwZTogYmFzZVR5cGUgfSwgc3RydWN0cylcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlzVHlwZUVudW0oYmFzZVR5cGUsIGVudW1zKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKChpdCkgPT4gdmFsaWRhdGVFbnVtKGl0LCB7IG5hbWU6IGlucHV0Lm5hbWUsIHR5cGU6IGJhc2VUeXBlIH0pKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgKGlzVHlwZVVpbnQoYmFzZVR5cGUpIHx8IGlzVHlwZUxpdHRlcmFsKGJhc2VUeXBlKSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgocGFyYW0pID0+IHZhbGlkYXRlVWludChwYXJhbSwgaW5wdXQpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaXNUeXBlQm9vbChiYXNlVHlwZSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgocGFyYW0pID0+IHZhbGlkYXRlQm9vbChwYXJhbSwgaW5wdXQpKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBWYWxpZGF0ZSBVbmhhbmRsZWQ6IGFyZ3VtZW50ICR7aW5wdXQubmFtZX0sIHR5cGUgJHtpbnB1dC50eXBlfSwgdmFsdWUgJHtwYXJhbWV0ZXJ9YFxuICAgICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlRmllbGRzKGFiaU1ldGhvZCwgYXJncywgc3RydWN0cywgZW51bXMpIHtcbiAgYWJpTWV0aG9kLmlucHV0cy5yZWR1Y2UoKGFjYywgaW5wdXQpID0+IHtcbiAgICBjb25zdCBwYXJhbWV0ZXIgPSBhcmdzW2FjY107XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIGlzTGVuKGlucHV0Lm5hbWUpOlxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgY2FzZSBpc1R5cGVGZWx0KGlucHV0LnR5cGUpOlxuICAgICAgICB2YWxpZGF0ZUZlbHQocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAoaXNUeXBlVWludChpbnB1dC50eXBlKSB8fCBpc1R5cGVMaXR0ZXJhbChpbnB1dC50eXBlKSk6XG4gICAgICAgIHZhbGlkYXRlVWludChwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZUJvb2woaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlQm9vbChwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZUFycmF5KGlucHV0LnR5cGUpOlxuICAgICAgICB2YWxpZGF0ZUFycmF5KHBhcmFtZXRlciwgaW5wdXQsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZVN0cnVjdChpbnB1dC50eXBlLCBzdHJ1Y3RzKTpcbiAgICAgICAgdmFsaWRhdGVTdHJ1Y3QocGFyYW1ldGVyLCBpbnB1dCwgc3RydWN0cyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVFbnVtKGlucHV0LnR5cGUsIGVudW1zKTpcbiAgICAgICAgdmFsaWRhdGVFbnVtKHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlVHVwbGUoaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlVHVwbGUocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBWYWxpZGF0ZSBVbmhhbmRsZWQ6IGFyZ3VtZW50ICR7aW5wdXQubmFtZX0sIHR5cGUgJHtpbnB1dC50eXBlfSwgdmFsdWUgJHtwYXJhbWV0ZXJ9YFxuICAgICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gYWNjICsgMTtcbiAgfSwgMCk7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9pbmRleC50c1xudmFyIENhbGxEYXRhID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhYmkpIHtcbiAgICB0aGlzLnN0cnVjdHMgPSBDYWxsRGF0YS5nZXRBYmlTdHJ1Y3QoYWJpKTtcbiAgICB0aGlzLmVudW1zID0gQ2FsbERhdGEuZ2V0QWJpRW51bShhYmkpO1xuICAgIHRoaXMucGFyc2VyID0gY3JlYXRlQWJpUGFyc2VyKGFiaSk7XG4gICAgdGhpcy5hYmkgPSB0aGlzLnBhcnNlci5nZXRMZWdhY3lGb3JtYXQoKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kIGFzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9uZXMgaW4gdGhlIGFiaVxuICAgKiBAcGFyYW0gdHlwZSBWYWxpZGF0ZVR5cGUgLSB0eXBlIG9mIHRoZSBtZXRob2RcbiAgICogQHBhcmFtIG1ldGhvZCBzdHJpbmcgLSBuYW1lIG9mIHRoZSBtZXRob2RcbiAgICogQHBhcmFtIGFyZ3MgQXJnc09yQ2FsbGRhdGEgLSBhcmd1bWVudHMgdGhhdCBhcmUgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAgICovXG4gIHZhbGlkYXRlKHR5cGUsIG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gICAgaWYgKHR5cGUgIT09IFwiREVQTE9ZXCIgLyogREVQTE9ZICovKSB7XG4gICAgICBjb25zdCBpbnZvY2FibGVGdW5jdGlvbk5hbWVzID0gdGhpcy5hYmkuZmlsdGVyKChhYmkpID0+IHtcbiAgICAgICAgaWYgKGFiaS50eXBlICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBpc1ZpZXcgPSBhYmkuc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBhYmkuc3RhdGVfbXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCI7XG4gICAgICAgIHJldHVybiB0eXBlID09PSBcIklOVk9LRVwiIC8qIElOVk9LRSAqLyA/ICFpc1ZpZXcgOiBpc1ZpZXc7XG4gICAgICB9KS5tYXAoKGFiaSkgPT4gYWJpLm5hbWUpO1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBpbnZvY2FibGVGdW5jdGlvbk5hbWVzLmluY2x1ZGVzKG1ldGhvZCksXG4gICAgICAgIGAke3R5cGUgPT09IFwiSU5WT0tFXCIgLyogSU5WT0tFICovID8gXCJpbnZvY2FibGVcIiA6IFwidmlld2FibGVcIn0gbWV0aG9kIG5vdCBmb3VuZCBpbiBhYmlgXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBhYmlNZXRob2QgPSB0aGlzLmFiaS5maW5kKFxuICAgICAgKGFiaSkgPT4gdHlwZSA9PT0gXCJERVBMT1lcIiAvKiBERVBMT1kgKi8gPyBhYmkubmFtZSA9PT0gbWV0aG9kICYmIGFiaS50eXBlID09PSBcImNvbnN0cnVjdG9yXCIgOiBhYmkubmFtZSA9PT0gbWV0aG9kICYmIGFiaS50eXBlID09PSBcImZ1bmN0aW9uXCJcbiAgICApO1xuICAgIGlmIChpc05vQ29uc3RydWN0b3JWYWxpZChtZXRob2QsIGFyZ3MsIGFiaU1ldGhvZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRzTGVuZ3RoID0gdGhpcy5wYXJzZXIubWV0aG9kSW5wdXRzTGVuZ3RoKGFiaU1ldGhvZCk7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSBpbnB1dHNMZW5ndGgpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzLCBleHBlY3RlZCAke2lucHV0c0xlbmd0aH0gYXJndW1lbnRzLCBidXQgZ290ICR7YXJncy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG4gICAgdmFsaWRhdGVGaWVsZHMoYWJpTWV0aG9kLCBhcmdzLCB0aGlzLnN0cnVjdHMsIHRoaXMuZW51bXMpO1xuICB9XG4gIC8qKlxuICAgKiBDb21waWxlIGNvbnRyYWN0IGNhbGxEYXRhIHdpdGggYWJpXG4gICAqIFBhcnNlIHRoZSBjYWxsZGF0YSBieSB1c2luZyBpbnB1dCBmaWVsZHMgZnJvbSB0aGUgYWJpIGZvciB0aGF0IG1ldGhvZFxuICAgKiBAcGFyYW0gbWV0aG9kIHN0cmluZyAtIG1ldGhvZCBuYW1lXG4gICAqIEBwYXJhbSBhcmdzIFJhd0FyZ3MgLSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBtZXRob2QuIENhbiBiZSBhbiBhcnJheSBvZiBhcmd1bWVudHMgKGluIHRoZSBvcmRlciBvZiBhYmkgZGVmaW5pdGlvbiksIG9yIGFuIG9iamVjdCBjb25zdHJ1Y3RlZCBpbiBjb25mb3JtaXR5IHdpdGggYWJpIChpbiB0aGlzIGNhc2UsIHRoZSBwYXJhbWV0ZXIgY2FuIGJlIGluIGEgd3Jvbmcgb3JkZXIpLlxuICAgKiBAcmV0dXJuIENhbGxkYXRhIC0gcGFyc2VkIGFyZ3VtZW50cyBpbiBmb3JtYXQgdGhhdCBjb250cmFjdCBpcyBleHBlY3RpbmdcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBjYWxsZGF0YSA9IG15Q2FsbERhdGEuY29tcGlsZShcImNvbnN0cnVjdG9yXCIsIFtcIjB4MzRhXCIsIFsxLCAzbl1dKTtcbiAgICogYGBgXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgY2FsbGRhdGEyID0gbXlDYWxsRGF0YS5jb21waWxlKFwiY29uc3RydWN0b3JcIiwge2xpc3Q6WzEsIDNuXSwgYmFsYW5jZTpcIjB4MzRcIn0pOyAvLyB3cm9uZyBvcmRlciBpcyB2YWxpZFxuICAgKiBgYGBcbiAgICovXG4gIGNvbXBpbGUobWV0aG9kLCBhcmdzQ2FsbGRhdGEpIHtcbiAgICBjb25zdCBhYmlNZXRob2QgPSB0aGlzLmFiaS5maW5kKChhYmlGdW5jdGlvbikgPT4gYWJpRnVuY3Rpb24ubmFtZSA9PT0gbWV0aG9kKTtcbiAgICBpZiAoaXNOb0NvbnN0cnVjdG9yVmFsaWQobWV0aG9kLCBhcmdzQ2FsbGRhdGEsIGFiaU1ldGhvZCkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IGFyZ3M7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnc0NhbGxkYXRhKSkge1xuICAgICAgYXJncyA9IGFyZ3NDYWxsZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JkZXJlZE9iamVjdCA9IG9yZGVyUHJvcHNCeUFiaShcbiAgICAgICAgYXJnc0NhbGxkYXRhLFxuICAgICAgICBhYmlNZXRob2QuaW5wdXRzLFxuICAgICAgICB0aGlzLnN0cnVjdHMsXG4gICAgICAgIHRoaXMuZW51bXNcbiAgICAgICk7XG4gICAgICBhcmdzID0gT2JqZWN0LnZhbHVlcyhvcmRlcmVkT2JqZWN0KTtcbiAgICAgIHZhbGlkYXRlRmllbGRzKGFiaU1ldGhvZCwgYXJncywgdGhpcy5zdHJ1Y3RzLCB0aGlzLmVudW1zKTtcbiAgICB9XG4gICAgY29uc3QgYXJnc0l0ZXJhdG9yID0gYXJnc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgY2FsbEFycmF5ID0gYWJpTWV0aG9kLmlucHV0cy5yZWR1Y2UoXG4gICAgICAoYWNjLCBpbnB1dCkgPT4gaXNMZW4oaW5wdXQubmFtZSkgJiYgIWlzQ2Fpcm8xVHlwZShpbnB1dC50eXBlKSA/IGFjYyA6IGFjYy5jb25jYXQocGFyc2VDYWxsZGF0YUZpZWxkKGFyZ3NJdGVyYXRvciwgaW5wdXQsIHRoaXMuc3RydWN0cywgdGhpcy5lbnVtcykpLFxuICAgICAgW11cbiAgICApO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjYWxsQXJyYXksIFwiX19jb21waWxlZF9fXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gY2FsbEFycmF5O1xuICB9XG4gIC8qKlxuICAgKiBDb21waWxlIGNvbnRyYWN0IGNhbGxEYXRhIHdpdGhvdXQgYWJpXG4gICAqIEBwYXJhbSByYXdBcmdzIFJhd0FyZ3MgcmVwcmVzZW50aW5nIGNhaXJvIG1ldGhvZCBhcmd1bWVudHMgb3Igc3RyaW5nIGFycmF5IG9mIGNvbXBpbGVkIGRhdGFcbiAgICogQHJldHVybnMgQ2FsbGRhdGFcbiAgICovXG4gIHN0YXRpYyBjb21waWxlKHJhd0FyZ3MpIHtcbiAgICBjb25zdCBjcmVhdGVUcmVlID0gKG9iaikgPT4ge1xuICAgICAgY29uc3QgZ2V0RW50cmllcyA9IChvLCBwcmVmaXggPSBcIi5cIikgPT4ge1xuICAgICAgICBjb25zdCBvZSA9IEFycmF5LmlzQXJyYXkobykgPyBbby5sZW5ndGgudG9TdHJpbmcoKSwgLi4ub10gOiBvO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2UpLmZsYXRNYXAoKFtrLCB2XSkgPT4ge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHY7XG4gICAgICAgICAgaWYgKGlzTG9uZ1RleHQodmFsdWUpKVxuICAgICAgICAgICAgdmFsdWUgPSBzcGxpdExvbmdTdHJpbmcodmFsdWUpO1xuICAgICAgICAgIGlmIChrID09PSBcImVudHJ5cG9pbnRcIilcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0U2VsZWN0b3JGcm9tTmFtZSh2YWx1ZSk7XG4gICAgICAgICAgY29uc3Qga2sgPSBBcnJheS5pc0FycmF5KG9lKSAmJiBrID09PSBcIjBcIiA/IFwiJCRsZW5cIiA6IGs7XG4gICAgICAgICAgaWYgKGlzQmlnSW50KHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBbW2Ake3ByZWZpeH0ke2trfWAsIGZlbHQodmFsdWUpXV07XG4gICAgICAgICAgaWYgKE9iamVjdCh2YWx1ZSkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBtZXRob2RzS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkpO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IFsuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSksIC4uLm1ldGhvZHNLZXlzXTtcbiAgICAgICAgICAgIGlmIChrZXlzLmluY2x1ZGVzKFwiaXNTb21lXCIpICYmIGtleXMuaW5jbHVkZXMoXCJpc05vbmVcIikpIHtcbiAgICAgICAgICAgICAgY29uc3QgbXlPcHRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgY29uc3QgdmFyaWFudE5iID0gbXlPcHRpb24uaXNTb21lKCkgPyAwIC8qIFNvbWUgKi8gOiAxIC8qIE5vbmUgKi87XG4gICAgICAgICAgICAgIGlmIChteU9wdGlvbi5pc1NvbWUoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RW50cmllcyh7IDA6IHZhcmlhbnROYiwgMTogbXlPcHRpb24udW53cmFwKCkgfSwgYCR7cHJlZml4fSR7a2t9LmApO1xuICAgICAgICAgICAgICByZXR1cm4gW1tgJHtwcmVmaXh9JHtra31gLCBmZWx0KHZhcmlhbnROYildXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlzLmluY2x1ZGVzKFwiaXNPa1wiKSAmJiBrZXlzLmluY2x1ZGVzKFwiaXNFcnJcIikpIHtcbiAgICAgICAgICAgICAgY29uc3QgbXlSZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgY29uc3QgdmFyaWFudE5iID0gbXlSZXN1bHQuaXNPaygpID8gMCAvKiBPayAqLyA6IDEgLyogRXJyICovO1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0RW50cmllcyh7IDA6IHZhcmlhbnROYiwgMTogbXlSZXN1bHQudW53cmFwKCkgfSwgYCR7cHJlZml4fSR7a2t9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleXMuaW5jbHVkZXMoXCJ2YXJpYW50XCIpICYmIGtleXMuaW5jbHVkZXMoXCJhY3RpdmVWYXJpYW50XCIpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG15RW51bSA9IHZhbHVlO1xuICAgICAgICAgICAgICBjb25zdCBhY3RpdmVWYXJpYW50ID0gbXlFbnVtLmFjdGl2ZVZhcmlhbnQoKTtcbiAgICAgICAgICAgICAgY29uc3QgbGlzdFZhcmlhbnRzID0gT2JqZWN0LmtleXMobXlFbnVtLnZhcmlhbnQpO1xuICAgICAgICAgICAgICBjb25zdCBhY3RpdmVWYXJpYW50TmIgPSBsaXN0VmFyaWFudHMuZmluZEluZGV4KFxuICAgICAgICAgICAgICAgICh2YXJpYW50KSA9PiB2YXJpYW50ID09PSBhY3RpdmVWYXJpYW50XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbXlFbnVtLnVud3JhcCgpID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKG15RW51bS51bndyYXAoKSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtbYCR7cHJlZml4fSR7a2t9YCwgZmVsdChhY3RpdmVWYXJpYW50TmIpXV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGdldEVudHJpZXMoeyAwOiBhY3RpdmVWYXJpYW50TmIsIDE6IG15RW51bS51bndyYXAoKSB9LCBgJHtwcmVmaXh9JHtra30uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0RW50cmllcyh2YWx1ZSwgYCR7cHJlZml4fSR7a2t9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW1tgJHtwcmVmaXh9JHtra31gLCBmZWx0KHZhbHVlKV1dO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuZnJvbUVudHJpZXMoZ2V0RW50cmllcyhvYmopKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBsZXQgY2FsbFRyZWVBcnJheTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmF3QXJncykpIHtcbiAgICAgIGNvbnN0IGNhbGxUcmVlID0gY3JlYXRlVHJlZShyYXdBcmdzKTtcbiAgICAgIGNhbGxUcmVlQXJyYXkgPSBPYmplY3QudmFsdWVzKGNhbGxUcmVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2FsbE9iaiA9IHsgLi4ucmF3QXJncyB9O1xuICAgICAgY29uc3QgY2FsbFRyZWUgPSBjcmVhdGVUcmVlKGNhbGxPYmopO1xuICAgICAgY2FsbFRyZWVBcnJheSA9IE9iamVjdC52YWx1ZXMoY2FsbFRyZWUpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2FsbFRyZWVBcnJheSwgXCJfX2NvbXBpbGVkX19cIiwge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBjYWxsVHJlZUFycmF5O1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBlbGVtZW50cyBvZiB0aGUgcmVzcG9uc2UgYXJyYXkgYW5kIHN0cnVjdHVyaW5nIHRoZW0gaW50byByZXNwb25zZSBvYmplY3RcbiAgICogQHBhcmFtIG1ldGhvZCBzdHJpbmcgLSBtZXRob2QgbmFtZVxuICAgKiBAcGFyYW0gcmVzcG9uc2Ugc3RyaW5nW10gLSByZXNwb25zZSBmcm9tIHRoZSBtZXRob2RcbiAgICogQHJldHVybiBSZXN1bHQgLSBwYXJzZWQgcmVzcG9uc2UgY29ycmVzcG9uZGluZyB0byB0aGUgYWJpXG4gICAqL1xuICBwYXJzZShtZXRob2QsIHJlc3BvbnNlKSB7XG4gICAgY29uc3QgeyBvdXRwdXRzIH0gPSB0aGlzLmFiaS5maW5kKChhYmkpID0+IGFiaS5uYW1lID09PSBtZXRob2QpO1xuICAgIGNvbnN0IHJlc3BvbnNlSXRlcmF0b3IgPSByZXNwb25zZS5mbGF0KClbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IHBhcnNlZCA9IG91dHB1dHMuZmxhdCgpLnJlZHVjZSgoYWNjLCBvdXRwdXQsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgcHJvcE5hbWUgPSBvdXRwdXQubmFtZSA/PyBpZHg7XG4gICAgICBhY2NbcHJvcE5hbWVdID0gcmVzcG9uc2VQYXJzZXIocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCB0aGlzLnN0cnVjdHMsIHRoaXMuZW51bXMsIGFjYyk7XG4gICAgICBpZiAoYWNjW3Byb3BOYW1lXSAmJiBhY2NbYCR7cHJvcE5hbWV9X2xlbmBdKSB7XG4gICAgICAgIGRlbGV0ZSBhY2NbYCR7cHJvcE5hbWV9X2xlbmBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcnNlZCkubGVuZ3RoID09PSAxICYmIDAgaW4gcGFyc2VkID8gcGFyc2VkWzBdIDogcGFyc2VkO1xuICB9XG4gIC8qKlxuICAgKiBGb3JtYXQgY2Fpcm8gbWV0aG9kIHJlc3BvbnNlIGRhdGEgdG8gbmF0aXZlIGpzIHZhbHVlcyBiYXNlZCBvbiBwcm92aWRlZCBmb3JtYXQgc2NoZW1hXG4gICAqIEBwYXJhbSBtZXRob2Qgc3RyaW5nIC0gY2Fpcm8gbWV0aG9kIG5hbWVcbiAgICogQHBhcmFtIHJlc3BvbnNlIHN0cmluZ1tdIC0gY2Fpcm8gbWV0aG9kIHJlc3BvbnNlXG4gICAqIEBwYXJhbSBmb3JtYXQgb2JqZWN0IC0gZm9ybWF0dGVyIG9iamVjdCBzY2hlbWFcbiAgICogQHJldHVybnMgUmVzdWx0IC0gcGFyc2VkIGFuZCBmb3JtYXR0ZWQgcmVzcG9uc2Ugb2JqZWN0XG4gICAqL1xuICBmb3JtYXQobWV0aG9kLCByZXNwb25zZSwgZm9ybWF0KSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZShtZXRob2QsIHJlc3BvbnNlKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyKHBhcnNlZCwgZm9ybWF0KTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyIHRvIGV4dHJhY3Qgc3RydWN0cyBmcm9tIGFiaVxuICAgKiBAcGFyYW0gYWJpIEFiaVxuICAgKiBAcmV0dXJucyBBYmlTdHJ1Y3RzIC0gc3RydWN0cyBmcm9tIGFiaVxuICAgKi9cbiAgc3RhdGljIGdldEFiaVN0cnVjdChhYmkpIHtcbiAgICByZXR1cm4gYWJpLmZpbHRlcigoYWJpRW50cnkpID0+IGFiaUVudHJ5LnR5cGUgPT09IFwic3RydWN0XCIpLnJlZHVjZShcbiAgICAgIChhY2MsIGFiaUVudHJ5KSA9PiAoe1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIFthYmlFbnRyeS5uYW1lXTogYWJpRW50cnlcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZXh0cmFjdCBlbnVtcyBmcm9tIGFiaVxuICAgKiBAcGFyYW0gYWJpIEFiaVxuICAgKiBAcmV0dXJucyBBYmlFbnVtcyAtIGVudW1zIGZyb20gYWJpXG4gICAqL1xuICBzdGF0aWMgZ2V0QWJpRW51bShhYmkpIHtcbiAgICBjb25zdCBmdWxsRW51bUxpc3QgPSBhYmkuZmlsdGVyKChhYmlFbnRyeSkgPT4gYWJpRW50cnkudHlwZSA9PT0gXCJlbnVtXCIpLnJlZHVjZShcbiAgICAgIChhY2MsIGFiaUVudHJ5KSA9PiAoe1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIFthYmlFbnRyeS5uYW1lXTogYWJpRW50cnlcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICAgIGRlbGV0ZSBmdWxsRW51bUxpc3RbXCJjb3JlOjpib29sXCJdO1xuICAgIHJldHVybiBmdWxsRW51bUxpc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlcjogQ29tcGlsZSBIZXhDYWxsZGF0YSB8IFJhd0NhbGxkYXRhIHwgUmF3QXJnc1xuICAgKiBAcGFyYW0gcmF3Q2FsbGRhdGEgSGV4Q2FsbGRhdGEgfCBSYXdDYWxsZGF0YSB8IFJhd0FyZ3NcbiAgICogQHJldHVybnMgQ2FsbGRhdGFcbiAgICovXG4gIHN0YXRpYyB0b0NhbGxkYXRhKHJhd0NhbGxkYXRhID0gW10pIHtcbiAgICByZXR1cm4gQ2FsbERhdGEuY29tcGlsZShyYXdDYWxsZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlcjogQ29udmVydCByYXcgdG8gSGV4Q2FsbGRhdGFcbiAgICogQHBhcmFtIHJhdyBIZXhDYWxsZGF0YSB8IFJhd0NhbGxkYXRhIHwgUmF3QXJnc1xuICAgKiBAcmV0dXJucyBIZXhDYWxsZGF0YVxuICAgKi9cbiAgc3RhdGljIHRvSGV4KHJhdyA9IFtdKSB7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKHJhdyk7XG4gICAgcmV0dXJuIGNhbGxkYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9oYXNoLnRzXG52YXIgaGFzaF9leHBvcnRzID0ge307XG5fX2V4cG9ydChoYXNoX2V4cG9ydHMsIHtcbiAgY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2g6ICgpID0+IGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoLFxuICBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoLFxuICBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoLFxuICBjYWxjdWxhdGVEZXBsb3lUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZURlcGxveVRyYW5zYWN0aW9uSGFzaCxcbiAgY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2gsXG4gIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbjogKCkgPT4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uLFxuICBjb21wdXRlQ29tcGlsZWRDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVDb21waWxlZENsYXNzSGFzaCxcbiAgY29tcHV0ZUNvbnRyYWN0Q2xhc3NIYXNoOiAoKSA9PiBjb21wdXRlQ29udHJhY3RDbGFzc0hhc2gsXG4gIGNvbXB1dGVIYXNoT25FbGVtZW50czogKCkgPT4gY29tcHV0ZUhhc2hPbkVsZW1lbnRzLFxuICBjb21wdXRlTGVnYWN5Q29udHJhY3RDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVMZWdhY3lDb250cmFjdENsYXNzSGFzaCxcbiAgY29tcHV0ZVNpZXJyYUNvbnRyYWN0Q2xhc3NIYXNoOiAoKSA9PiBjb21wdXRlU2llcnJhQ29udHJhY3RDbGFzc0hhc2gsXG4gIGRlZmF1bHQ6ICgpID0+IGNvbXB1dGVIaW50ZWRDbGFzc0hhc2gsXG4gIGZlZVRyYW5zYWN0aW9uVmVyc2lvbjogKCkgPT4gZmVlVHJhbnNhY3Rpb25WZXJzaW9uLFxuICBmZWVUcmFuc2FjdGlvblZlcnNpb25fMjogKCkgPT4gZmVlVHJhbnNhY3Rpb25WZXJzaW9uXzIsXG4gIGZvcm1hdFNwYWNlczogKCkgPT4gZm9ybWF0U3BhY2VzLFxuICBnZXRTZWxlY3RvcjogKCkgPT4gZ2V0U2VsZWN0b3IsXG4gIGdldFNlbGVjdG9yRnJvbU5hbWU6ICgpID0+IGdldFNlbGVjdG9yRnJvbU5hbWUsXG4gIGdldFZlcnNpb25zQnlUeXBlOiAoKSA9PiBnZXRWZXJzaW9uc0J5VHlwZSxcbiAga2VjY2FrQm46ICgpID0+IGtlY2Nha0JuLFxuICBwb3NlaWRvbjogKCkgPT4gcG9zZWlkb24sXG4gIHN0YXJrbmV0S2VjY2FrOiAoKSA9PiBzdGFya25ldEtlY2NhayxcbiAgdHJhbnNhY3Rpb25WZXJzaW9uOiAoKSA9PiB0cmFuc2FjdGlvblZlcnNpb24sXG4gIHRyYW5zYWN0aW9uVmVyc2lvbl8yOiAoKSA9PiB0cmFuc2FjdGlvblZlcnNpb25fMlxufSk7XG52YXIgaW1wb3J0X3N0YXJrbmV0MiA9IHJlcXVpcmUoXCJAc2N1cmUvc3RhcmtuZXRcIik7XG5cbi8vIHNyYy91dGlscy9lYy50c1xudmFyIGVjX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGVjX2V4cG9ydHMsIHtcbiAgc3RhcmtDdXJ2ZTogKCkgPT4gc3RhcmtDdXJ2ZSxcbiAgd2VpZXJzdHJhc3M6ICgpID0+IHdlaWVyc3RyYXNzXG59KTtcbnZhciBzdGFya0N1cnZlID0gX190b0VTTShyZXF1aXJlKFwiQHNjdXJlL3N0YXJrbmV0XCIpKTtcbnZhciB3ZWllcnN0cmFzcyA9IF9fdG9FU00ocmVxdWlyZShcIkBub2JsZS9jdXJ2ZXMvYWJzdHJhY3Qvd2VpZXJzdHJhc3NcIikpO1xuXG4vLyBzcmMvdXRpbHMvanNvbi50c1xudmFyIGpzb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoanNvbl9leHBvcnRzLCB7XG4gIHBhcnNlOiAoKSA9PiBwYXJzZTIsXG4gIHBhcnNlQWx3YXlzQXNCaWc6ICgpID0+IHBhcnNlQWx3YXlzQXNCaWcsXG4gIHN0cmluZ2lmeTogKCkgPT4gc3RyaW5naWZ5MixcbiAgc3RyaW5naWZ5QWx3YXlzQXNCaWc6ICgpID0+IHN0cmluZ2lmeUFsd2F5c0FzQmlnXG59KTtcbnZhciBqc29uID0gX190b0VTTShyZXF1aXJlKFwibG9zc2xlc3MtanNvblwiKSk7XG52YXIgcGFyc2VJbnRBc051bWJlck9yQmlnSW50ID0gKHgpID0+IHtcbiAgaWYgKCFqc29uLmlzSW50ZWdlcih4KSlcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh4KTtcbiAgY29uc3QgdiA9IHBhcnNlSW50KHgsIDEwKTtcbiAgcmV0dXJuIE51bWJlci5pc1NhZmVJbnRlZ2VyKHYpID8gdiA6IEJpZ0ludCh4KTtcbn07XG52YXIgcGFyc2UyID0gKHgpID0+IGpzb24ucGFyc2UoU3RyaW5nKHgpLCB2b2lkIDAsIHBhcnNlSW50QXNOdW1iZXJPckJpZ0ludCk7XG52YXIgcGFyc2VBbHdheXNBc0JpZyA9ICh4KSA9PiBqc29uLnBhcnNlKFN0cmluZyh4KSwgdm9pZCAwLCBqc29uLnBhcnNlTnVtYmVyQW5kQmlnSW50KTtcbnZhciBzdHJpbmdpZnkyID0gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UsIG51bWJlclN0cmluZ2lmaWVycykgPT4ganNvbi5zdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSwgbnVtYmVyU3RyaW5naWZpZXJzKTtcbnZhciBzdHJpbmdpZnlBbHdheXNBc0JpZyA9IHN0cmluZ2lmeTI7XG5cbi8vIHNyYy91dGlscy9oYXNoLnRzXG52YXIgcG9zZWlkb24gPSBfX3RvRVNNKHJlcXVpcmUoXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3Bvc2VpZG9uXCIpKTtcbnZhciB0cmFuc2FjdGlvblZlcnNpb24gPSBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzE7XG52YXIgdHJhbnNhY3Rpb25WZXJzaW9uXzIgPSBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzI7XG52YXIgZmVlVHJhbnNhY3Rpb25WZXJzaW9uID0gQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMTtcbnZhciBmZWVUcmFuc2FjdGlvblZlcnNpb25fMiA9IEJOX0ZFRV9UUkFOU0FDVElPTl9WRVJTSU9OXzI7XG5mdW5jdGlvbiBnZXRWZXJzaW9uc0J5VHlwZSh2ZXJzaW9uVHlwZSkge1xuICByZXR1cm4gdmVyc2lvblR5cGUgPT09IFwiZmVlXCIgPyB7IHYxOiBmZWVUcmFuc2FjdGlvblZlcnNpb24sIHYyOiBmZWVUcmFuc2FjdGlvblZlcnNpb25fMiB9IDogeyB2MTogdHJhbnNhY3Rpb25WZXJzaW9uLCB2MjogdHJhbnNhY3Rpb25WZXJzaW9uXzIgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVIYXNoT25FbGVtZW50cyhkYXRhKSB7XG4gIHJldHVybiBbLi4uZGF0YSwgZGF0YS5sZW5ndGhdLnJlZHVjZSgoeCwgeSkgPT4gc3RhcmtDdXJ2ZS5wZWRlcnNlbih0b0JpZ0ludCh4KSwgdG9CaWdJbnQoeSkpLCAwKS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uKHR4SGFzaFByZWZpeCwgdmVyc2lvbiwgY29udHJhY3RBZGRyZXNzLCBlbnRyeVBvaW50U2VsZWN0b3IsIGNhbGxkYXRhLCBtYXhGZWUsIGNoYWluSWQsIGFkZGl0aW9uYWxEYXRhID0gW10pIHtcbiAgY29uc3QgY2FsbGRhdGFIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGNhbGxkYXRhKTtcbiAgY29uc3QgZGF0YVRvSGFzaCA9IFtcbiAgICB0eEhhc2hQcmVmaXgsXG4gICAgdmVyc2lvbixcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgZW50cnlQb2ludFNlbGVjdG9yLFxuICAgIGNhbGxkYXRhSGFzaCxcbiAgICBtYXhGZWUsXG4gICAgY2hhaW5JZCxcbiAgICAuLi5hZGRpdGlvbmFsRGF0YVxuICBdO1xuICByZXR1cm4gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGRhdGFUb0hhc2gpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRGVwbG95VHJhbnNhY3Rpb25IYXNoKGNvbnRyYWN0QWRkcmVzcywgY29uc3RydWN0b3JDYWxsZGF0YSwgdmVyc2lvbiwgY2hhaW5JZCwgY29uc3RydWN0b3JOYW1lID0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24oXG4gICAgXCIweDY0NjU3MDZjNmY3OVwiIC8qIERFUExPWSAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICBnZXRTZWxlY3RvckZyb21OYW1lKGNvbnN0cnVjdG9yTmFtZSksXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICAwLFxuICAgIGNoYWluSWRcbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2goY2xhc3NIYXNoLCBzZW5kZXJBZGRyZXNzLCB2ZXJzaW9uLCBtYXhGZWUsIGNoYWluSWQsIG5vbmNlLCBjb21waWxlZENsYXNzSGFzaCkge1xuICByZXR1cm4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uKFxuICAgIFwiMHg2NDY1NjM2YzYxNzI2NVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgdmVyc2lvbixcbiAgICBzZW5kZXJBZGRyZXNzLFxuICAgIDAsXG4gICAgW2NsYXNzSGFzaF0sXG4gICAgbWF4RmVlLFxuICAgIGNoYWluSWQsXG4gICAgW25vbmNlLCAuLi5jb21waWxlZENsYXNzSGFzaCA/IFtjb21waWxlZENsYXNzSGFzaF0gOiBbXV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2goY29udHJhY3RBZGRyZXNzLCBjbGFzc0hhc2gsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIHNhbHQsIHZlcnNpb24sIG1heEZlZSwgY2hhaW5JZCwgbm9uY2UpIHtcbiAgY29uc3QgY2FsbGRhdGEgPSBbY2xhc3NIYXNoLCBzYWx0LCAuLi5jb25zdHJ1Y3RvckNhbGxkYXRhXTtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbihcbiAgICBcIjB4NjQ2NTcwNmM2Zjc5NWY2MTYzNjM2Zjc1NmU3NFwiIC8qIERFUExPWV9BQ0NPVU5UICovLFxuICAgIHZlcnNpb24sXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIDAsXG4gICAgY2FsbGRhdGEsXG4gICAgbWF4RmVlLFxuICAgIGNoYWluSWQsXG4gICAgW25vbmNlXVxuICApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoKGNvbnRyYWN0QWRkcmVzcywgdmVyc2lvbiwgY2FsbGRhdGEsIG1heEZlZSwgY2hhaW5JZCwgbm9uY2UpIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbihcbiAgICBcIjB4Njk2ZTc2NmY2YjY1XCIgLyogSU5WT0tFICovLFxuICAgIHZlcnNpb24sXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIDAsXG4gICAgY2FsbGRhdGEsXG4gICAgbWF4RmVlLFxuICAgIGNoYWluSWQsXG4gICAgW25vbmNlXVxuICApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2goc2FsdCwgY2xhc3NIYXNoLCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBkZXBsb3llckFkZHJlc3MpIHtcbiAgY29uc3QgY29tcGlsZWRDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gIGNvbnN0IGNvbnN0cnVjdG9yQ2FsbGRhdGFIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGNvbXBpbGVkQ2FsbGRhdGEpO1xuICBjb25zdCBDT05UUkFDVF9BRERSRVNTX1BSRUZJWCA9IGZlbHQoXCIweDUzNTQ0MTUyNGI0ZTQ1NTQ1ZjQzNGY0ZTU0NTI0MTQzNTQ1ZjQxNDQ0NDUyNDU1MzUzXCIpO1xuICByZXR1cm4gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKFtcbiAgICBDT05UUkFDVF9BRERSRVNTX1BSRUZJWCxcbiAgICBkZXBsb3llckFkZHJlc3MsXG4gICAgc2FsdCxcbiAgICBjbGFzc0hhc2gsXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YUhhc2hcbiAgXSk7XG59XG5mdW5jdGlvbiBudWxsU2tpcFJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PT0gXCJhdHRyaWJ1dGVzXCIgfHwga2V5ID09PSBcImFjY2Vzc2libGVfc2NvcGVzXCIpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwID8gdm9pZCAwIDogdmFsdWU7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJkZWJ1Z19pbmZvXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFNwYWNlcyhqc29uMikge1xuICBsZXQgaW5zaWRlUXVvdGVzID0gZmFsc2U7XG4gIGNvbnN0IG5ld1N0cmluZyA9IFtdO1xuICBmb3IgKGNvbnN0IGNoYXIgb2YganNvbjIpIHtcbiAgICBpZiAoY2hhciA9PT0gJ1wiJyAmJiAobmV3U3RyaW5nLmxlbmd0aCA+IDAgJiYgbmV3U3RyaW5nLnNsaWNlKC0xKVswXSA9PT0gXCJcXFxcXCIpID09PSBmYWxzZSkge1xuICAgICAgaW5zaWRlUXVvdGVzID0gIWluc2lkZVF1b3RlcztcbiAgICB9XG4gICAgaWYgKGluc2lkZVF1b3Rlcykge1xuICAgICAgbmV3U3RyaW5nLnB1c2goY2hhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0cmluZy5wdXNoKGNoYXIgPT09IFwiOlwiID8gXCI6IFwiIDogY2hhciA9PT0gXCIsXCIgPyBcIiwgXCIgOiBjaGFyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld1N0cmluZy5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUhpbnRlZENsYXNzSGFzaChjb21waWxlZENvbnRyYWN0KSB7XG4gIGNvbnN0IHsgYWJpLCBwcm9ncmFtIH0gPSBjb21waWxlZENvbnRyYWN0O1xuICBjb25zdCBjb250cmFjdENsYXNzID0geyBhYmksIHByb2dyYW0gfTtcbiAgY29uc3Qgc2VyaWFsaXplZEpzb24gPSBmb3JtYXRTcGFjZXMoc3RyaW5naWZ5Mihjb250cmFjdENsYXNzLCBudWxsU2tpcFJlcGxhY2VyKSk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoc3RhcmtDdXJ2ZS5rZWNjYWsodXRmOFRvQXJyYXkoc2VyaWFsaXplZEpzb24pKS50b1N0cmluZygxNikpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUxlZ2FjeUNvbnRyYWN0Q2xhc3NIYXNoKGNvbnRyYWN0KSB7XG4gIGNvbnN0IGNvbXBpbGVkQ29udHJhY3QgPSB0eXBlb2YgY29udHJhY3QgPT09IFwic3RyaW5nXCIgPyBwYXJzZTIoY29udHJhY3QpIDogY29udHJhY3Q7XG4gIGNvbnN0IGFwaVZlcnNpb24gPSB0b0hleChBUElfVkVSU0lPTik7XG4gIGNvbnN0IGV4dGVybmFsRW50cnlQb2ludHNIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKFxuICAgIGNvbXBpbGVkQ29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUuRVhURVJOQUwuZmxhdE1hcCgoZSkgPT4gW2Uuc2VsZWN0b3IsIGUub2Zmc2V0XSlcbiAgKTtcbiAgY29uc3QgbDFIYW5kbGVyRW50cnlQb2ludHNIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKFxuICAgIGNvbXBpbGVkQ29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUuTDFfSEFORExFUi5mbGF0TWFwKChlKSA9PiBbZS5zZWxlY3RvciwgZS5vZmZzZXRdKVxuICApO1xuICBjb25zdCBjb25zdHJ1Y3RvckVudHJ5UG9pbnRIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKFxuICAgIGNvbXBpbGVkQ29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUuQ09OU1RSVUNUT1IuZmxhdE1hcCgoZSkgPT4gW2Uuc2VsZWN0b3IsIGUub2Zmc2V0XSlcbiAgKTtcbiAgY29uc3QgYnVpbHRpbnNIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKFxuICAgIGNvbXBpbGVkQ29udHJhY3QucHJvZ3JhbS5idWlsdGlucy5tYXAoKHMpID0+IGVuY29kZVNob3J0U3RyaW5nKHMpKVxuICApO1xuICBjb25zdCBoaW50ZWRDbGFzc0hhc2ggPSBjb21wdXRlSGludGVkQ2xhc3NIYXNoKGNvbXBpbGVkQ29udHJhY3QpO1xuICBjb25zdCBkYXRhSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50cyhjb21waWxlZENvbnRyYWN0LnByb2dyYW0uZGF0YSk7XG4gIHJldHVybiBjb21wdXRlSGFzaE9uRWxlbWVudHMoW1xuICAgIGFwaVZlcnNpb24sXG4gICAgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2gsXG4gICAgbDFIYW5kbGVyRW50cnlQb2ludHNIYXNoLFxuICAgIGNvbnN0cnVjdG9yRW50cnlQb2ludEhhc2gsXG4gICAgYnVpbHRpbnNIYXNoLFxuICAgIGhpbnRlZENsYXNzSGFzaCxcbiAgICBkYXRhSGFzaFxuICBdKTtcbn1cbmZ1bmN0aW9uIGhhc2hCdWlsdGlucyhidWlsdGlucykge1xuICByZXR1cm4gKDAsIGltcG9ydF9zdGFya25ldDIucG9zZWlkb25IYXNoTWFueSkoXG4gICAgYnVpbHRpbnMuZmxhdE1hcCgoaXQpID0+IHtcbiAgICAgIHJldHVybiBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoaXQpKTtcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gaGFzaEVudHJ5UG9pbnQoZGF0YSkge1xuICBjb25zdCBiYXNlID0gZGF0YS5mbGF0TWFwKChpdCkgPT4ge1xuICAgIHJldHVybiBbQmlnSW50KGl0LnNlbGVjdG9yKSwgQmlnSW50KGl0Lm9mZnNldCksIGhhc2hCdWlsdGlucyhpdC5idWlsdGlucyldO1xuICB9KTtcbiAgcmV0dXJuICgwLCBpbXBvcnRfc3RhcmtuZXQyLnBvc2VpZG9uSGFzaE1hbnkpKGJhc2UpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUNvbXBpbGVkQ2xhc3NIYXNoKGNhc20pIHtcbiAgY29uc3QgQ09NUElMRURfQ0xBU1NfVkVSU0lPTiA9IFwiQ09NUElMRURfQ0xBU1NfVjFcIjtcbiAgY29uc3QgY29tcGlsZWRDbGFzc1ZlcnNpb24gPSBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoQ09NUElMRURfQ0xBU1NfVkVSU0lPTikpO1xuICBjb25zdCBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCA9IGhhc2hFbnRyeVBvaW50KGNhc20uZW50cnlfcG9pbnRzX2J5X3R5cGUuRVhURVJOQUwpO1xuICBjb25zdCBsMUhhbmRsZXJzID0gaGFzaEVudHJ5UG9pbnQoY2FzbS5lbnRyeV9wb2ludHNfYnlfdHlwZS5MMV9IQU5ETEVSKTtcbiAgY29uc3QgY29uc3RydWN0b3IgPSBoYXNoRW50cnlQb2ludChjYXNtLmVudHJ5X3BvaW50c19ieV90eXBlLkNPTlNUUlVDVE9SKTtcbiAgY29uc3QgYnl0ZWNvZGUgPSAoMCwgaW1wb3J0X3N0YXJrbmV0Mi5wb3NlaWRvbkhhc2hNYW55KShjYXNtLmJ5dGVjb2RlLm1hcCgoaXQpID0+IEJpZ0ludChpdCkpKTtcbiAgcmV0dXJuIHRvSGV4KFxuICAgICgwLCBpbXBvcnRfc3RhcmtuZXQyLnBvc2VpZG9uSGFzaE1hbnkpKFtcbiAgICAgIGNvbXBpbGVkQ2xhc3NWZXJzaW9uLFxuICAgICAgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2gsXG4gICAgICBsMUhhbmRsZXJzLFxuICAgICAgY29uc3RydWN0b3IsXG4gICAgICBieXRlY29kZVxuICAgIF0pXG4gICk7XG59XG5mdW5jdGlvbiBoYXNoRW50cnlQb2ludFNpZXJyYShkYXRhKSB7XG4gIGNvbnN0IGJhc2UgPSBkYXRhLmZsYXRNYXAoKGl0KSA9PiB7XG4gICAgcmV0dXJuIFtCaWdJbnQoaXQuc2VsZWN0b3IpLCBCaWdJbnQoaXQuZnVuY3Rpb25faWR4KV07XG4gIH0pO1xuICByZXR1cm4gKDAsIGltcG9ydF9zdGFya25ldDIucG9zZWlkb25IYXNoTWFueSkoYmFzZSk7XG59XG5mdW5jdGlvbiBoYXNoQWJpKHNpZXJyYSkge1xuICBjb25zdCBpbmRlbnRTdHJpbmcgPSBmb3JtYXRTcGFjZXMoc3RyaW5naWZ5MihzaWVycmEuYWJpLCBudWxsKSk7XG4gIHJldHVybiBCaWdJbnQoYWRkSGV4UHJlZml4KHN0YXJrQ3VydmUua2VjY2FrKHV0ZjhUb0FycmF5KGluZGVudFN0cmluZykpLnRvU3RyaW5nKDE2KSkpO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNpZXJyYUNvbnRyYWN0Q2xhc3NIYXNoKHNpZXJyYSkge1xuICBjb25zdCBDT05UUkFDVF9DTEFTU19WRVJTSU9OID0gXCJDT05UUkFDVF9DTEFTU19WMC4xLjBcIjtcbiAgY29uc3QgY29tcGlsZWRDbGFzc1ZlcnNpb24gPSBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoQ09OVFJBQ1RfQ0xBU1NfVkVSU0lPTikpO1xuICBjb25zdCBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCA9IGhhc2hFbnRyeVBvaW50U2llcnJhKHNpZXJyYS5lbnRyeV9wb2ludHNfYnlfdHlwZS5FWFRFUk5BTCk7XG4gIGNvbnN0IGwxSGFuZGxlcnMgPSBoYXNoRW50cnlQb2ludFNpZXJyYShzaWVycmEuZW50cnlfcG9pbnRzX2J5X3R5cGUuTDFfSEFORExFUik7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gaGFzaEVudHJ5UG9pbnRTaWVycmEoc2llcnJhLmVudHJ5X3BvaW50c19ieV90eXBlLkNPTlNUUlVDVE9SKTtcbiAgY29uc3QgYWJpSGFzaCA9IGhhc2hBYmkoc2llcnJhKTtcbiAgY29uc3Qgc2llcnJhUHJvZ3JhbSA9ICgwLCBpbXBvcnRfc3RhcmtuZXQyLnBvc2VpZG9uSGFzaE1hbnkpKHNpZXJyYS5zaWVycmFfcHJvZ3JhbS5tYXAoKGl0KSA9PiBCaWdJbnQoaXQpKSk7XG4gIHJldHVybiB0b0hleChcbiAgICAoMCwgaW1wb3J0X3N0YXJrbmV0Mi5wb3NlaWRvbkhhc2hNYW55KShbXG4gICAgICBjb21waWxlZENsYXNzVmVyc2lvbixcbiAgICAgIGV4dGVybmFsRW50cnlQb2ludHNIYXNoLFxuICAgICAgbDFIYW5kbGVycyxcbiAgICAgIGNvbnN0cnVjdG9yLFxuICAgICAgYWJpSGFzaCxcbiAgICAgIHNpZXJyYVByb2dyYW1cbiAgICBdKVxuICApO1xufVxuZnVuY3Rpb24gY29tcHV0ZUNvbnRyYWN0Q2xhc3NIYXNoKGNvbnRyYWN0KSB7XG4gIGNvbnN0IGNvbXBpbGVkQ29udHJhY3QgPSB0eXBlb2YgY29udHJhY3QgPT09IFwic3RyaW5nXCIgPyBwYXJzZTIoY29udHJhY3QpIDogY29udHJhY3Q7XG4gIGlmIChcInNpZXJyYV9wcm9ncmFtXCIgaW4gY29tcGlsZWRDb250cmFjdCkge1xuICAgIHJldHVybiBjb21wdXRlU2llcnJhQ29udHJhY3RDbGFzc0hhc2goY29tcGlsZWRDb250cmFjdCk7XG4gIH1cbiAgcmV0dXJuIGNvbXB1dGVMZWdhY3lDb250cmFjdENsYXNzSGFzaChjb21waWxlZENvbnRyYWN0KTtcbn1cblxuLy8gc3JjL3V0aWxzL3N0YXJrLnRzXG52YXIgc3RhcmtfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3RhcmtfZXhwb3J0cywge1xuICBjb21wcmVzc1Byb2dyYW06ICgpID0+IGNvbXByZXNzUHJvZ3JhbSxcbiAgZGVjb21wcmVzc1Byb2dyYW06ICgpID0+IGRlY29tcHJlc3NQcm9ncmFtLFxuICBlc3RpbWF0ZWRGZWVUb01heEZlZTogKCkgPT4gZXN0aW1hdGVkRmVlVG9NYXhGZWUsXG4gIGZvcm1hdFNpZ25hdHVyZTogKCkgPT4gZm9ybWF0U2lnbmF0dXJlLFxuICBtYWtlQWRkcmVzczogKCkgPT4gbWFrZUFkZHJlc3MsXG4gIHJhbmRvbUFkZHJlc3M6ICgpID0+IHJhbmRvbUFkZHJlc3MsXG4gIHNpZ25hdHVyZVRvRGVjaW1hbEFycmF5OiAoKSA9PiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheSxcbiAgc2lnbmF0dXJlVG9IZXhBcnJheTogKCkgPT4gc2lnbmF0dXJlVG9IZXhBcnJheVxufSk7XG52YXIgaW1wb3J0X3N0YXJrbmV0MyA9IHJlcXVpcmUoXCJAc2N1cmUvc3RhcmtuZXRcIik7XG52YXIgaW1wb3J0X3Bha28gPSByZXF1aXJlKFwicGFrb1wiKTtcbmZ1bmN0aW9uIGNvbXByZXNzUHJvZ3JhbShqc29uUHJvZ3JhbSkge1xuICBjb25zdCBzdHJpbmdpZmllZCA9IHR5cGVvZiBqc29uUHJvZ3JhbSA9PT0gXCJzdHJpbmdcIiA/IGpzb25Qcm9ncmFtIDogc3RyaW5naWZ5Mihqc29uUHJvZ3JhbSk7XG4gIGNvbnN0IGNvbXByZXNzZWRQcm9ncmFtID0gKDAsIGltcG9ydF9wYWtvLmd6aXApKHN0cmluZ2lmaWVkKTtcbiAgcmV0dXJuIGJ0b2FVbml2ZXJzYWwoY29tcHJlc3NlZFByb2dyYW0pO1xufVxuZnVuY3Rpb24gZGVjb21wcmVzc1Byb2dyYW0oYmFzZTY0Mikge1xuICBpZiAoQXJyYXkuaXNBcnJheShiYXNlNjQyKSlcbiAgICByZXR1cm4gYmFzZTY0MjtcbiAgY29uc3QgZGVjb21wcmVzc2VkID0gYXJyYXlCdWZmZXJUb1N0cmluZygoMCwgaW1wb3J0X3Bha28udW5nemlwKShhdG9iVW5pdmVyc2FsKGJhc2U2NDIpKSk7XG4gIHJldHVybiBwYXJzZTIoZGVjb21wcmVzc2VkKTtcbn1cbmZ1bmN0aW9uIHJhbmRvbUFkZHJlc3MoKSB7XG4gIGNvbnN0IHJhbmRvbUtleVBhaXIgPSBpbXBvcnRfc3RhcmtuZXQzLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgcmV0dXJuICgwLCBpbXBvcnRfc3RhcmtuZXQzLmdldFN0YXJrS2V5KShyYW5kb21LZXlQYWlyKTtcbn1cbmZ1bmN0aW9uIG1ha2VBZGRyZXNzKGlucHV0KSB7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoaW5wdXQpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBmb3JtYXRTaWduYXR1cmUoc2lnKSB7XG4gIGlmICghc2lnKVxuICAgIHRocm93IEVycm9yKFwiZm9ybWF0U2lnbmF0dXJlOiBwcm92aWRlZCBzaWduYXR1cmUgaXMgdW5kZWZpbmVkXCIpO1xuICBpZiAoQXJyYXkuaXNBcnJheShzaWcpKSB7XG4gICAgcmV0dXJuIHNpZy5tYXAoKGl0KSA9PiB0b0hleChpdCkpO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgeyByLCBzIH0gPSBzaWc7XG4gICAgcmV0dXJuIFt0b0hleChyKSwgdG9IZXgocyldO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbmF0dXJlIG5lZWQgdG8gYmUgd2VpZXJzdHJhc3MuU2lnbmF0dXJlVHlwZSBvciBhbiBhcnJheSBmb3IgY3VzdG9tXCIpO1xuICB9XG59XG5mdW5jdGlvbiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheShzaWcpIHtcbiAgcmV0dXJuIGJpZ051bWJlcmlzaEFycmF5VG9EZWNpbWFsU3RyaW5nQXJyYXkoZm9ybWF0U2lnbmF0dXJlKHNpZykpO1xufVxuZnVuY3Rpb24gc2lnbmF0dXJlVG9IZXhBcnJheShzaWcpIHtcbiAgcmV0dXJuIGJpZ051bWJlcmlzaEFycmF5VG9IZXhhZGVjaW1hbFN0cmluZ0FycmF5KGZvcm1hdFNpZ25hdHVyZShzaWcpKTtcbn1cbmZ1bmN0aW9uIGVzdGltYXRlZEZlZVRvTWF4RmVlKGVzdGltYXRlZEZlZSwgb3ZlcmhlYWQgPSAwLjUpIHtcbiAgY29uc3Qgb3ZlckhlYWRQZXJjZW50ID0gTWF0aC5yb3VuZCgoMSArIG92ZXJoZWFkKSAqIDEwMCk7XG4gIHJldHVybiB0b0JpZ0ludChlc3RpbWF0ZWRGZWUpICogdG9CaWdJbnQob3ZlckhlYWRQZXJjZW50KSAvIDEwMG47XG59XG5cbi8vIHNyYy91dGlscy9jb250cmFjdC50c1xuZnVuY3Rpb24gaXNTaWVycmEoY29udHJhY3QpIHtcbiAgY29uc3QgY29tcGlsZWRDb250cmFjdCA9IHR5cGVvZiBjb250cmFjdCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlMihjb250cmFjdCkgOiBjb250cmFjdDtcbiAgcmV0dXJuIFwic2llcnJhX3Byb2dyYW1cIiBpbiBjb21waWxlZENvbnRyYWN0O1xufVxuZnVuY3Rpb24gZXh0cmFjdENvbnRyYWN0SGFzaGVzKHBheWxvYWQpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSB7IC4uLnBheWxvYWQgfTtcbiAgaWYgKGlzU2llcnJhKHBheWxvYWQuY29udHJhY3QpKSB7XG4gICAgaWYgKCFwYXlsb2FkLmNvbXBpbGVkQ2xhc3NIYXNoICYmIHBheWxvYWQuY2FzbSkge1xuICAgICAgcmVzcG9uc2UuY29tcGlsZWRDbGFzc0hhc2ggPSBjb21wdXRlQ29tcGlsZWRDbGFzc0hhc2gocGF5bG9hZC5jYXNtKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5jb21waWxlZENsYXNzSGFzaClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJFeHRyYWN0IGNvbXBpbGVkQ2xhc3NIYXNoIGZhaWxlZCwgcHJvdmlkZSAoQ2Fpcm9Bc3NlbWJseSkuY2FzbSBmaWxlIG9yIGNvbXBpbGVkQ2xhc3NIYXNoXCJcbiAgICAgICk7XG4gIH1cbiAgcmVzcG9uc2UuY2xhc3NIYXNoID0gcGF5bG9hZC5jbGFzc0hhc2ggPz8gY29tcHV0ZUNvbnRyYWN0Q2xhc3NIYXNoKHBheWxvYWQuY29udHJhY3QpO1xuICBpZiAoIXJlc3BvbnNlLmNsYXNzSGFzaClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHRyYWN0IGNsYXNzSGFzaCBmYWlsZWQsIHByb3ZpZGUgKENvbXBpbGVkQ29udHJhY3QpLmpzb24gZmlsZSBvciBjbGFzc0hhc2hcIik7XG4gIHJldHVybiByZXNwb25zZTtcbn1cbmZ1bmN0aW9uIGNvbnRyYWN0Q2xhc3NSZXNwb25zZVRvTGVnYWN5Q29tcGlsZWRDb250cmFjdChjY3IpIHtcbiAgaWYgKGlzU2llcnJhKGNjcikpIHtcbiAgICB0aHJvdyBFcnJvcihcIkNvbnRyYWN0Q2xhc3NSZXNwb25zZSBuZWVkIHRvIGJlIExlZ2FjeUNvbnRyYWN0Q2xhc3MgKGNhaXJvMCByZXNwb25zZSBjbGFzcylcIik7XG4gIH1cbiAgY29uc3QgY29udHJhY3QgPSBjY3I7XG4gIHJldHVybiB7IC4uLmNvbnRyYWN0LCBwcm9ncmFtOiBkZWNvbXByZXNzUHJvZ3JhbShjb250cmFjdC5wcm9ncmFtKSB9O1xufVxuXG4vLyBzcmMvdXRpbHMvZmV0Y2hQb255ZmlsbC50c1xudmFyIGltcG9ydF9pc29tb3JwaGljX2ZldGNoID0gX190b0VTTShyZXF1aXJlKFwiaXNvbW9ycGhpYy1mZXRjaFwiKSk7XG52YXIgZmV0Y2hQb255ZmlsbF9kZWZhdWx0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZmV0Y2ggfHwgLy8gdXNlIGJ1aWxkaW4gZmV0Y2ggaW4gYnJvd3NlciBpZiBhdmFpbGFibGVcbnR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmZldGNoIHx8IC8vIHVzZSBidWlsZGluIGZldGNoIGluIG5vZGUsIHJlYWN0LW5hdGl2ZSBhbmQgc2VydmljZSB3b3JrZXIgaWYgYXZhaWxhYmxlXG5pbXBvcnRfaXNvbW9ycGhpY19mZXRjaC5kZWZhdWx0O1xuXG4vLyBzcmMvdXRpbHMvcHJvdmlkZXIudHNcbnZhciBwcm92aWRlcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChwcm92aWRlcl9leHBvcnRzLCB7XG4gIGNyZWF0ZVNpZXJyYUNvbnRyYWN0Q2xhc3M6ICgpID0+IGNyZWF0ZVNpZXJyYUNvbnRyYWN0Q2xhc3MsXG4gIHBhcnNlQ29udHJhY3Q6ICgpID0+IHBhcnNlQ29udHJhY3QsXG4gIHdhaXQ6ICgpID0+IHdhaXRcbn0pO1xuZnVuY3Rpb24gd2FpdChkZWxheSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgIHNldFRpbWVvdXQocmVzLCBkZWxheSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzcyhjb250cmFjdCkge1xuICBjb25zdCByZXN1bHQgPSB7IC4uLmNvbnRyYWN0IH07XG4gIGRlbGV0ZSByZXN1bHQuc2llcnJhX3Byb2dyYW1fZGVidWdfaW5mbztcbiAgcmVzdWx0LmFiaSA9IGZvcm1hdFNwYWNlcyhzdHJpbmdpZnkyKGNvbnRyYWN0LmFiaSkpO1xuICByZXN1bHQuc2llcnJhX3Byb2dyYW0gPSBmb3JtYXRTcGFjZXMoc3RyaW5naWZ5Mihjb250cmFjdC5zaWVycmFfcHJvZ3JhbSkpO1xuICByZXN1bHQuc2llcnJhX3Byb2dyYW0gPSBjb21wcmVzc1Byb2dyYW0ocmVzdWx0LnNpZXJyYV9wcm9ncmFtKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29udHJhY3QoY29udHJhY3QpIHtcbiAgY29uc3QgcGFyc2VkQ29udHJhY3QgPSB0eXBlb2YgY29udHJhY3QgPT09IFwic3RyaW5nXCIgPyBwYXJzZTIoY29udHJhY3QpIDogY29udHJhY3Q7XG4gIGlmICghaXNTaWVycmEoY29udHJhY3QpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnBhcnNlZENvbnRyYWN0LFxuICAgICAgLi4uXCJwcm9ncmFtXCIgaW4gcGFyc2VkQ29udHJhY3QgJiYgeyBwcm9ncmFtOiBjb21wcmVzc1Byb2dyYW0ocGFyc2VkQ29udHJhY3QucHJvZ3JhbSkgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVNpZXJyYUNvbnRyYWN0Q2xhc3MocGFyc2VkQ29udHJhY3QpO1xufVxuXG4vLyBzcmMvdXRpbHMvcmVzcG9uc2VQYXJzZXIvcnBjLnRzXG52YXIgUlBDUmVzcG9uc2VQYXJzZXIgPSBjbGFzcyB7XG4gIHBhcnNlR2V0QmxvY2tSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGltZXN0YW1wOiByZXMudGltZXN0YW1wLFxuICAgICAgYmxvY2tfaGFzaDogXCJibG9ja19oYXNoXCIgaW4gcmVzID8gcmVzLmJsb2NrX2hhc2ggOiBcIlwiLFxuICAgICAgYmxvY2tfbnVtYmVyOiBcImJsb2NrX251bWJlclwiIGluIHJlcyA/IHJlcy5ibG9ja19udW1iZXIgOiAtMSxcbiAgICAgIG5ld19yb290OiBcIm5ld19yb290XCIgaW4gcmVzID8gcmVzLm5ld19yb290IDogXCJcIixcbiAgICAgIHBhcmVudF9oYXNoOiByZXMucGFyZW50X2hhc2gsXG4gICAgICBzdGF0dXM6IFwic3RhdHVzXCIgaW4gcmVzID8gcmVzLnN0YXR1cyA6IFwiUEVORElOR1wiIC8qIFBFTkRJTkcgKi8sXG4gICAgICB0cmFuc2FjdGlvbnM6IHJlcy50cmFuc2FjdGlvbnNcbiAgICB9O1xuICB9XG4gIHBhcnNlR2V0VHJhbnNhY3Rpb25SZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2FsbGRhdGE6IFwiY2FsbGRhdGFcIiBpbiByZXMgPyByZXMuY2FsbGRhdGEgOiBbXSxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IFwiY29udHJhY3RfYWRkcmVzc1wiIGluIHJlcyA/IHJlcy5jb250cmFjdF9hZGRyZXNzIDogXCJcIixcbiAgICAgIHNlbmRlcl9hZGRyZXNzOiBcInNlbmRlcl9hZGRyZXNzXCIgaW4gcmVzID8gcmVzLnNlbmRlcl9hZGRyZXNzIDogXCJcIixcbiAgICAgIG1heF9mZWU6IFwibWF4X2ZlZVwiIGluIHJlcyA/IHJlcy5tYXhfZmVlIDogXCJcIixcbiAgICAgIG5vbmNlOiBcIm5vbmNlXCIgaW4gcmVzID8gcmVzLm5vbmNlIDogXCJcIixcbiAgICAgIHNpZ25hdHVyZTogXCJzaWduYXR1cmVcIiBpbiByZXMgPyByZXMuc2lnbmF0dXJlIDogW10sXG4gICAgICB0cmFuc2FjdGlvbl9oYXNoOiByZXMudHJhbnNhY3Rpb25faGFzaCxcbiAgICAgIHZlcnNpb246IHJlcy52ZXJzaW9uXG4gICAgfTtcbiAgfVxuICBwYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG92ZXJhbGxfZmVlOiB0b0JpZ0ludChyZXNbMF0ub3ZlcmFsbF9mZWUpLFxuICAgICAgZ2FzX2NvbnN1bWVkOiB0b0JpZ0ludChyZXNbMF0uZ2FzX2NvbnN1bWVkKSxcbiAgICAgIGdhc19wcmljZTogdG9CaWdJbnQocmVzWzBdLmdhc19wcmljZSlcbiAgICB9O1xuICB9XG4gIHBhcnNlRmVlRXN0aW1hdGVCdWxrUmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHJlcy5tYXAoKHZhbCkgPT4gKHtcbiAgICAgIG92ZXJhbGxfZmVlOiB0b0JpZ0ludCh2YWwub3ZlcmFsbF9mZWUpLFxuICAgICAgZ2FzX2NvbnN1bWVkOiB0b0JpZ0ludCh2YWwuZ2FzX2NvbnN1bWVkKSxcbiAgICAgIGdhc19wcmljZTogdG9CaWdJbnQodmFsLmdhc19wcmljZSlcbiAgICB9KSk7XG4gIH1cbiAgcGFyc2VDYWxsQ29udHJhY3RSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiByZXNcbiAgICB9O1xuICB9XG4gIHBhcnNlU2ltdWxhdGVUcmFuc2FjdGlvblJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiByZXMubWFwKChpdCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaXQsXG4gICAgICAgIHN1Z2dlc3RlZE1heEZlZTogZXN0aW1hdGVkRmVlVG9NYXhGZWUoQmlnSW50KGl0LmZlZV9lc3RpbWF0aW9uLm92ZXJhbGxfZmVlKSlcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgcGFyc2VDb250cmFjdENsYXNzUmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlcyxcbiAgICAgIGFiaTogdHlwZW9mIHJlcy5hYmkgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKHJlcy5hYmkpIDogcmVzLmFiaVxuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9lcnJvcnMudHNcbmZ1bmN0aW9uIGZpeFN0YWNrKHRhcmdldCwgZm4gPSB0YXJnZXQuY29uc3RydWN0b3IpIHtcbiAgY29uc3QgeyBjYXB0dXJlU3RhY2tUcmFjZSB9ID0gRXJyb3I7XG4gIGNhcHR1cmVTdGFja1RyYWNlICYmIGNhcHR1cmVTdGFja1RyYWNlKHRhcmdldCwgZm4pO1xufVxuZnVuY3Rpb24gZml4UHJvdG8odGFyZ2V0LCBwcm90b3R5cGUpIHtcbiAgY29uc3QgeyBzZXRQcm90b3R5cGVPZiB9ID0gT2JqZWN0O1xuICBzZXRQcm90b3R5cGVPZiA/IHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG90eXBlKSA6IHRhcmdldC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG59XG52YXIgQ3VzdG9tRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgdmFsdWU6IG5ldy50YXJnZXQubmFtZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgZml4UHJvdG8odGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIGZpeFN0YWNrKHRoaXMpO1xuICB9XG59O1xudmFyIExpYnJhcnlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQ3VzdG9tRXJyb3Ige1xufTtcbnZhciBHYXRld2F5RXJyb3IgPSBjbGFzcyBleHRlbmRzIExpYnJhcnlFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGVycm9yQ29kZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuZXJyb3JDb2RlID0gZXJyb3JDb2RlO1xuICB9XG59O1xudmFyIEh0dHBFcnJvciA9IGNsYXNzIGV4dGVuZHMgTGlicmFyeUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgZXJyb3JDb2RlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvckNvZGUgPSBlcnJvckNvZGU7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9zdGFya25ldElkLnRzXG52YXIgc3RhcmtuZXRJZF9leHBvcnRzID0ge307XG5fX2V4cG9ydChzdGFya25ldElkX2V4cG9ydHMsIHtcbiAgU3RhcmtuZXRJZENvbnRyYWN0OiAoKSA9PiBTdGFya25ldElkQ29udHJhY3QsXG4gIGdldFN0YXJrbmV0SWRDb250cmFjdDogKCkgPT4gZ2V0U3RhcmtuZXRJZENvbnRyYWN0LFxuICB1c2VEZWNvZGVkOiAoKSA9PiB1c2VEZWNvZGVkLFxuICB1c2VFbmNvZGVkOiAoKSA9PiB1c2VFbmNvZGVkXG59KTtcbnZhciBiYXNpY0FscGhhYmV0ID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXCI7XG52YXIgYmFzaWNTaXplUGx1c09uZSA9IEJpZ0ludChiYXNpY0FscGhhYmV0Lmxlbmd0aCArIDEpO1xudmFyIGJpZ0FscGhhYmV0ID0gXCJcXHU4RkQ5XFx1Njc2NVwiO1xudmFyIGJhc2ljQWxwaGFiZXRTaXplID0gQmlnSW50KGJhc2ljQWxwaGFiZXQubGVuZ3RoKTtcbnZhciBiaWdBbHBoYWJldFNpemUgPSBCaWdJbnQoYmlnQWxwaGFiZXQubGVuZ3RoKTtcbnZhciBiaWdBbHBoYWJldFNpemVQbHVzT25lID0gQmlnSW50KGJpZ0FscGhhYmV0Lmxlbmd0aCArIDEpO1xuZnVuY3Rpb24gZXh0cmFjdFN0YXJzKHN0cikge1xuICBsZXQgayA9IDA7XG4gIHdoaWxlIChzdHIuZW5kc1dpdGgoYmlnQWxwaGFiZXRbYmlnQWxwaGFiZXQubGVuZ3RoIC0gMV0pKSB7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSk7XG4gICAgayArPSAxO1xuICB9XG4gIHJldHVybiBbc3RyLCBrXTtcbn1cbmZ1bmN0aW9uIHVzZURlY29kZWQoZW5jb2RlZCkge1xuICBsZXQgZGVjb2RlZCA9IFwiXCI7XG4gIGVuY29kZWQuZm9yRWFjaCgoc3ViZG9tYWluKSA9PiB7XG4gICAgd2hpbGUgKHN1YmRvbWFpbiAhPT0gWkVSTykge1xuICAgICAgY29uc3QgY29kZSA9IHN1YmRvbWFpbiAlIGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICBzdWJkb21haW4gLz0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIGlmIChjb2RlID09PSBCaWdJbnQoYmFzaWNBbHBoYWJldC5sZW5ndGgpKSB7XG4gICAgICAgIGNvbnN0IG5leHRTdWJkb21haW4gPSBzdWJkb21haW4gLyBiaWdBbHBoYWJldFNpemVQbHVzT25lO1xuICAgICAgICBpZiAobmV4dFN1YmRvbWFpbiA9PT0gWkVSTykge1xuICAgICAgICAgIGNvbnN0IGNvZGUyID0gc3ViZG9tYWluICUgYmlnQWxwaGFiZXRTaXplUGx1c09uZTtcbiAgICAgICAgICBzdWJkb21haW4gPSBuZXh0U3ViZG9tYWluO1xuICAgICAgICAgIGlmIChjb2RlMiA9PT0gWkVSTylcbiAgICAgICAgICAgIGRlY29kZWQgKz0gYmFzaWNBbHBoYWJldFswXTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWNvZGVkICs9IGJpZ0FscGhhYmV0W051bWJlcihjb2RlMikgLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBjb2RlMiA9IHN1YmRvbWFpbiAlIGJpZ0FscGhhYmV0U2l6ZTtcbiAgICAgICAgICBkZWNvZGVkICs9IGJpZ0FscGhhYmV0W051bWJlcihjb2RlMildO1xuICAgICAgICAgIHN1YmRvbWFpbiAvPSBiaWdBbHBoYWJldFNpemU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICBkZWNvZGVkICs9IGJhc2ljQWxwaGFiZXRbTnVtYmVyKGNvZGUpXTtcbiAgICB9XG4gICAgY29uc3QgW3N0ciwga10gPSBleHRyYWN0U3RhcnMoZGVjb2RlZCk7XG4gICAgaWYgKGspXG4gICAgICBkZWNvZGVkID0gc3RyICsgKGsgJSAyID09PSAwID8gYmlnQWxwaGFiZXRbYmlnQWxwaGFiZXQubGVuZ3RoIC0gMV0ucmVwZWF0KGsgLyAyIC0gMSkgKyBiaWdBbHBoYWJldFswXSArIGJhc2ljQWxwaGFiZXRbMV0gOiBiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXS5yZXBlYXQoKGsgLSAxKSAvIDIgKyAxKSk7XG4gICAgZGVjb2RlZCArPSBcIi5cIjtcbiAgfSk7XG4gIGlmICghZGVjb2RlZCkge1xuICAgIHJldHVybiBkZWNvZGVkO1xuICB9XG4gIHJldHVybiBkZWNvZGVkLmNvbmNhdChcInN0YXJrXCIpO1xufVxuZnVuY3Rpb24gdXNlRW5jb2RlZChkZWNvZGVkKSB7XG4gIGxldCBlbmNvZGVkID0gQmlnSW50KDApO1xuICBsZXQgbXVsdGlwbGllciA9IEJpZ0ludCgxKTtcbiAgaWYgKGRlY29kZWQuZW5kc1dpdGgoYmlnQWxwaGFiZXRbMF0gKyBiYXNpY0FscGhhYmV0WzFdKSkge1xuICAgIGNvbnN0IFtzdHIsIGtdID0gZXh0cmFjdFN0YXJzKGRlY29kZWQuc3Vic3RyaW5nKDAsIGRlY29kZWQubGVuZ3RoIC0gMikpO1xuICAgIGRlY29kZWQgPSBzdHIgKyBiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXS5yZXBlYXQoMiAqIChrICsgMSkpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtzdHIsIGtdID0gZXh0cmFjdFN0YXJzKGRlY29kZWQpO1xuICAgIGlmIChrKVxuICAgICAgZGVjb2RlZCA9IHN0ciArIGJpZ0FscGhhYmV0W2JpZ0FscGhhYmV0Lmxlbmd0aCAtIDFdLnJlcGVhdCgxICsgMiAqIChrIC0gMSkpO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb2RlZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGNoYXIgPSBkZWNvZGVkW2ldO1xuICAgIGNvbnN0IGluZGV4ID0gYmFzaWNBbHBoYWJldC5pbmRleE9mKGNoYXIpO1xuICAgIGNvbnN0IGJuSW5kZXggPSBCaWdJbnQoYmFzaWNBbHBoYWJldC5pbmRleE9mKGNoYXIpKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoaSA9PT0gZGVjb2RlZC5sZW5ndGggLSAxICYmIGRlY29kZWRbaV0gPT09IGJhc2ljQWxwaGFiZXRbMF0pIHtcbiAgICAgICAgZW5jb2RlZCArPSBtdWx0aXBsaWVyICogYmFzaWNBbHBoYWJldFNpemU7XG4gICAgICAgIG11bHRpcGxpZXIgKj0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgICAgbXVsdGlwbGllciAqPSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5jb2RlZCArPSBtdWx0aXBsaWVyICogYm5JbmRleDtcbiAgICAgICAgbXVsdGlwbGllciAqPSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYmlnQWxwaGFiZXQuaW5kZXhPZihjaGFyKSAhPT0gLTEpIHtcbiAgICAgIGVuY29kZWQgKz0gbXVsdGlwbGllciAqIGJhc2ljQWxwaGFiZXRTaXplO1xuICAgICAgbXVsdGlwbGllciAqPSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgY29uc3QgbmV3aWQgPSAoaSA9PT0gZGVjb2RlZC5sZW5ndGggLSAxID8gMSA6IDApICsgYmlnQWxwaGFiZXQuaW5kZXhPZihjaGFyKTtcbiAgICAgIGVuY29kZWQgKz0gbXVsdGlwbGllciAqIEJpZ0ludChuZXdpZCk7XG4gICAgICBtdWx0aXBsaWVyICo9IGJpZ0FscGhhYmV0U2l6ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG52YXIgU3RhcmtuZXRJZENvbnRyYWN0ID0gLyogQF9fUFVSRV9fICovICgoU3RhcmtuZXRJZENvbnRyYWN0MikgPT4ge1xuICBTdGFya25ldElkQ29udHJhY3QyW1wiTUFJTk5FVFwiXSA9IFwiMHg2YWM1OTdmODExNmY4ODZmYTFjOTdhMjNmYTRlMDgyOTk5NzVlY2FmNmI1OTg4NzNjYTY3OTJiOWJiZmI2NzhcIjtcbiAgU3RhcmtuZXRJZENvbnRyYWN0MltcIlRFU1RORVRcIl0gPSBcIjB4M2JhYjI2OGU5MzJkMmNlY2QxOTQ2ZjEwMGFlNjdjZTNkZmY5ZmQyMzQxMTllYTJmNmRhNTdkMTZkMjlmY2VcIjtcbiAgcmV0dXJuIFN0YXJrbmV0SWRDb250cmFjdDI7XG59KShTdGFya25ldElkQ29udHJhY3QgfHwge30pO1xuZnVuY3Rpb24gZ2V0U3RhcmtuZXRJZENvbnRyYWN0KGNoYWluSWQpIHtcbiAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgY2FzZSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovOlxuICAgICAgcmV0dXJuIFwiMHg2YWM1OTdmODExNmY4ODZmYTFjOTdhMjNmYTRlMDgyOTk5NzVlY2FmNmI1OTg4NzNjYTY3OTJiOWJiZmI2NzhcIiAvKiBNQUlOTkVUICovO1xuICAgIGNhc2UgXCIweDUzNGU1ZjQ3NGY0NTUyNGM0OVwiIC8qIFNOX0dPRVJMSSAqLzpcbiAgICAgIHJldHVybiBcIjB4M2JhYjI2OGU5MzJkMmNlY2QxOTQ2ZjEwMGFlNjdjZTNkZmY5ZmQyMzQxMTllYTJmNmRhNTdkMTZkMjlmY2VcIiAvKiBURVNUTkVUICovO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGFya25ldC5pZCBpcyBub3QgeWV0IGRlcGxveWVkIG9uIHRoaXMgbmV0d29ya1wiKTtcbiAgfVxufVxuXG4vLyBzcmMvcHJvdmlkZXIvc3RhcmtuZXRJZC50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0U3RhcmtOYW1lKHByb3ZpZGVyLCBhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gIGNvbnN0IGNoYWluSWQgPSBhd2FpdCBwcm92aWRlci5nZXRDaGFpbklkKCk7XG4gIGNvbnN0IGNvbnRyYWN0ID0gU3RhcmtuZXRJZENvbnRyYWN0MiA/PyBnZXRTdGFya25ldElkQ29udHJhY3QoY2hhaW5JZCk7XG4gIHRyeSB7XG4gICAgY29uc3QgaGV4RG9tYWluID0gYXdhaXQgcHJvdmlkZXIuY2FsbENvbnRyYWN0KHtcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogY29udHJhY3QsXG4gICAgICBlbnRyeXBvaW50OiBcImFkZHJlc3NfdG9fZG9tYWluXCIsXG4gICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZSh7XG4gICAgICAgIGFkZHJlc3NcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgY29uc3QgZGVjaW1hbERvbWFpbiA9IGhleERvbWFpbi5yZXN1bHQubWFwKChlbGVtZW50KSA9PiBCaWdJbnQoZWxlbWVudCkpLnNsaWNlKDEpO1xuICAgIGNvbnN0IHN0cmluZ0RvbWFpbiA9IHVzZURlY29kZWQoZGVjaW1hbERvbWFpbik7XG4gICAgaWYgKCFzdHJpbmdEb21haW4pIHtcbiAgICAgIHRocm93IEVycm9yKFwiU3RhcmtuYW1lIG5vdCBmb3VuZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ0RvbWFpbjtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlID09PSBcIlN0YXJrbmFtZSBub3QgZm91bmRcIikge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IHN0YXJrIG5hbWVcIik7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFkZHJlc3NGcm9tU3RhcmtOYW1lKHByb3ZpZGVyLCBuYW1lLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gIGNvbnN0IGNoYWluSWQgPSBhd2FpdCBwcm92aWRlci5nZXRDaGFpbklkKCk7XG4gIGNvbnN0IGNvbnRyYWN0ID0gU3RhcmtuZXRJZENvbnRyYWN0MiA/PyBnZXRTdGFya25ldElkQ29udHJhY3QoY2hhaW5JZCk7XG4gIHRyeSB7XG4gICAgY29uc3QgYWRkcmVzc0RhdGEgPSBhd2FpdCBwcm92aWRlci5jYWxsQ29udHJhY3Qoe1xuICAgICAgY29udHJhY3RBZGRyZXNzOiBjb250cmFjdCxcbiAgICAgIGVudHJ5cG9pbnQ6IFwiZG9tYWluX3RvX2FkZHJlc3NcIixcbiAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHtcbiAgICAgICAgZG9tYWluOiBbdXNlRW5jb2RlZChuYW1lLnJlcGxhY2UoXCIuc3RhcmtcIiwgXCJcIikpLnRvU3RyaW5nKDEwKV1cbiAgICAgIH0pXG4gICAgfSk7XG4gICAgcmV0dXJuIGFkZHJlc3NEYXRhLnJlc3VsdFswXTtcbiAgfSBjYXRjaCB7XG4gICAgdGhyb3cgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IGFkZHJlc3MgZnJvbSBzdGFyayBuYW1lXCIpO1xuICB9XG59XG5cbi8vIHNyYy9wcm92aWRlci91dGlscy50c1xudmFyIHZhbGlkQmxvY2tUYWdzID0gT2JqZWN0LnZhbHVlcyhCbG9ja1RhZyk7XG52YXIgQmxvY2sgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9pZGVudGlmaWVyKSB7XG4gICAgdGhpcy5oYXNoID0gbnVsbDtcbiAgICB0aGlzLm51bWJlciA9IG51bGw7XG4gICAgdGhpcy50YWcgPSBudWxsO1xuICAgIHRoaXMudmFsdWVPZiA9ICgpID0+IHRoaXMubnVtYmVyO1xuICAgIHRoaXMudG9TdHJpbmcgPSAoKSA9PiB0aGlzLmhhc2g7XG4gICAgdGhpcy5zZXRJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcbiAgfVxuICBzZXRJZGVudGlmaWVyKF9faWRlbnRpZmllcikge1xuICAgIGlmICh0eXBlb2YgX19pZGVudGlmaWVyID09PSBcInN0cmluZ1wiICYmIGlzSGV4KF9faWRlbnRpZmllcikpIHtcbiAgICAgIHRoaXMuaGFzaCA9IF9faWRlbnRpZmllcjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfX2lkZW50aWZpZXIgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIHRoaXMuaGFzaCA9IHRvSGV4KF9faWRlbnRpZmllcik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgX19pZGVudGlmaWVyID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0aGlzLm51bWJlciA9IF9faWRlbnRpZmllcjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfX2lkZW50aWZpZXIgPT09IFwic3RyaW5nXCIgJiYgdmFsaWRCbG9ja1RhZ3MuaW5jbHVkZXMoX19pZGVudGlmaWVyKSkge1xuICAgICAgdGhpcy50YWcgPSBfX2lkZW50aWZpZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFnID0gXCJwZW5kaW5nXCIgLyogcGVuZGluZyAqLztcbiAgICB9XG4gIH1cbiAgLy8gVE9ETzogZml4IGFueVxuICBnZXQgcXVlcnlJZGVudGlmaWVyKCkge1xuICAgIGlmICh0aGlzLm51bWJlciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGBibG9ja051bWJlcj0ke3RoaXMubnVtYmVyfWA7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBgYmxvY2tIYXNoPSR7dGhpcy5oYXNofWA7XG4gICAgfVxuICAgIHJldHVybiBgYmxvY2tOdW1iZXI9JHt0aGlzLnRhZ31gO1xuICB9XG4gIC8vIFRPRE86IGZpeCBhbnlcbiAgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgaWYgKHRoaXMubnVtYmVyICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBibG9ja19udW1iZXI6IHRoaXMubnVtYmVyIH07XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IGJsb2NrX2hhc2g6IHRoaXMuaGFzaCB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50YWc7XG4gIH1cbiAgc2V0IGlkZW50aWZpZXIoX2lkZW50aWZpZXIpIHtcbiAgICB0aGlzLnNldElkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuICB9XG4gIGdldCBzZXF1ZW5jZXJJZGVudGlmaWVyKCkge1xuICAgIHJldHVybiB0aGlzLmhhc2ggIT09IG51bGwgPyB7IGJsb2NrSGFzaDogdGhpcy5oYXNoIH0gOiB7IGJsb2NrTnVtYmVyOiB0aGlzLm51bWJlciA/PyB0aGlzLnRhZyB9O1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvcnBjLnRzXG52YXIgZ2V0RGVmYXVsdE5vZGVVcmwgPSAobmV0d29ya05hbWUsIG11dGUgPSBmYWxzZSkgPT4ge1xuICBpZiAoIW11dGUpXG4gICAgY29uc29sZS53YXJuKFwiVXNpbmcgZGVmYXVsdCBwdWJsaWMgbm9kZSB1cmwsIHBsZWFzZSBwcm92aWRlIG5vZGVVcmwgaW4gcHJvdmlkZXIgb3B0aW9ucyFcIik7XG4gIGNvbnN0IG5vZGVzID0gbmV0d29ya05hbWUgPT09IFwiU05fTUFJTlwiIC8qIFNOX01BSU4gKi8gPyBSUENfTUFJTk5FVF9OT0RFUyA6IFJQQ19HT0VSTElfTk9ERVM7XG4gIGNvbnN0IHJhbmRJZHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2Rlcy5sZW5ndGgpO1xuICByZXR1cm4gbm9kZXNbcmFuZElkeF07XG59O1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gIGJsb2NrSWRlbnRpZmllcjogXCJwZW5kaW5nXCIgLyogcGVuZGluZyAqLyxcbiAgcmV0cmllczogMjAwXG59O1xudmFyIFJwY1Byb3ZpZGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zT3JQcm92aWRlcikge1xuICAgIHRoaXMucmVzcG9uc2VQYXJzZXIgPSBuZXcgUlBDUmVzcG9uc2VQYXJzZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCByZW5hbWVkIHRvIGdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQoKTsgKHdpbGwgYmUgcmVtb3ZlZCBpbiBuZXh0IG1pbm9yIHZlcnNpb24pXG4gICAgICovXG4gICAgdGhpcy5nZXRCbG9ja0hhc2hBbmROdW1iZXIgPSB0aGlzLmdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQ7XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byBnZXRCbG9ja1N0YXRlVXBkYXRlKCk7XG4gICAgICovXG4gICAgdGhpcy5nZXRTdGF0ZVVwZGF0ZSA9IHRoaXMuZ2V0QmxvY2tTdGF0ZVVwZGF0ZTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBleGVjdXRpb24gdHJhY2VzIG9mIGFsbCB0cmFuc2FjdGlvbnMgaW5jbHVkZWQgaW4gdGhlIGdpdmVuIGJsb2NrXG4gICAgICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byBnZXRCbG9ja1RyYW5zYWN0aW9uc1RyYWNlcygpXG4gICAgICovXG4gICAgdGhpcy50cmFjZUJsb2NrVHJhbnNhY3Rpb25zID0gdGhpcy5nZXRCbG9ja1RyYW5zYWN0aW9uc1RyYWNlcztcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbnMgaW4gYSBibG9jayBnaXZlbiBhIGJsb2NrIGlkXG4gICAgICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byBnZXRCbG9ja1RyYW5zYWN0aW9uQ291bnQoKVxuICAgICAqIEByZXR1cm5zIE51bWJlciBvZiB0cmFuc2FjdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmdldFRyYW5zYWN0aW9uQ291bnQgPSB0aGlzLmdldEJsb2NrVHJhbnNhY3Rpb25Db3VudDtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCByZW5hbWVkIHRvIGdldFRyYW5zYWN0aW9uVHJhY2UoKTtcbiAgICAgKiBGb3IgYSBnaXZlbiBleGVjdXRlZCB0cmFuc2FjdGlvbiwgcmV0dXJuIHRoZSB0cmFjZSBvZiBpdHMgZXhlY3V0aW9uLCBpbmNsdWRpbmcgaW50ZXJuYWwgY2FsbHNcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNlVHJhbnNhY3Rpb24gPSB0aGlzLmdldFRyYW5zYWN0aW9uVHJhY2U7XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byBzaW11bGF0ZVRyYW5zYWN0aW9uKCk7XG4gICAgICovXG4gICAgdGhpcy5nZXRTaW11bGF0ZVRyYW5zYWN0aW9uID0gdGhpcy5zaW11bGF0ZVRyYW5zYWN0aW9uO1xuICAgIGNvbnN0IHsgbm9kZVVybCwgcmV0cmllcywgaGVhZGVycywgYmxvY2tJZGVudGlmaWVyLCBjaGFpbklkIH0gPSBvcHRpb25zT3JQcm92aWRlciB8fCB7fTtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhOZXR3b3JrTmFtZSkuaW5jbHVkZXMobm9kZVVybCkpIHtcbiAgICAgIHRoaXMubm9kZVVybCA9IGdldERlZmF1bHROb2RlVXJsKG5vZGVVcmwsIG9wdGlvbnNPclByb3ZpZGVyPy5kZWZhdWx0KTtcbiAgICB9IGVsc2UgaWYgKG5vZGVVcmwpIHtcbiAgICAgIHRoaXMubm9kZVVybCA9IG5vZGVVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm9kZVVybCA9IGdldERlZmF1bHROb2RlVXJsKHZvaWQgMCwgb3B0aW9uc09yUHJvdmlkZXI/LmRlZmF1bHQpO1xuICAgIH1cbiAgICB0aGlzLnJldHJpZXMgPSByZXRyaWVzIHx8IGRlZmF1bHRPcHRpb25zLnJldHJpZXM7XG4gICAgdGhpcy5oZWFkZXJzID0geyAuLi5kZWZhdWx0T3B0aW9ucy5oZWFkZXJzLCAuLi5oZWFkZXJzIH07XG4gICAgdGhpcy5ibG9ja0lkZW50aWZpZXIgPSBibG9ja0lkZW50aWZpZXIgfHwgZGVmYXVsdE9wdGlvbnMuYmxvY2tJZGVudGlmaWVyO1xuICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gIH1cbiAgZmV0Y2gobWV0aG9kLCBwYXJhbXMsIGlkID0gMCkge1xuICAgIGNvbnN0IHJwY1JlcXVlc3RCb2R5ID0ge1xuICAgICAgaWQsXG4gICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgbWV0aG9kLFxuICAgICAgLi4ucGFyYW1zICYmIHsgcGFyYW1zIH1cbiAgICB9O1xuICAgIHJldHVybiBmZXRjaFBvbnlmaWxsX2RlZmF1bHQodGhpcy5ub2RlVXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogc3RyaW5naWZ5MihycGNSZXF1ZXN0Qm9keSksXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICB9KTtcbiAgfVxuICBlcnJvckhhbmRsZXIobWV0aG9kLCBwYXJhbXMsIHJwY0Vycm9yLCBvdGhlckVycm9yKSB7XG4gICAgaWYgKHJwY0Vycm9yKSB7XG4gICAgICBjb25zdCB7IGNvZGUsIG1lc3NhZ2UsIGRhdGEgfSA9IHJwY0Vycm9yO1xuICAgICAgdGhyb3cgbmV3IExpYnJhcnlFcnJvcihcbiAgICAgICAgYFJQQzogJHttZXRob2R9IHdpdGggcGFyYW1zICR7c3RyaW5naWZ5MihwYXJhbXMpfVxuICR7Y29kZX06ICR7bWVzc2FnZX06ICR7c3RyaW5naWZ5MihkYXRhKX1gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob3RoZXJFcnJvciBpbnN0YW5jZW9mIExpYnJhcnlFcnJvcikge1xuICAgICAgdGhyb3cgb3RoZXJFcnJvcjtcbiAgICB9XG4gICAgaWYgKG90aGVyRXJyb3IpIHtcbiAgICAgIHRocm93IEVycm9yKG90aGVyRXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZldGNoRW5kcG9pbnQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmF3UmVzdWx0ID0gYXdhaXQgdGhpcy5mZXRjaChtZXRob2QsIHBhcmFtcyk7XG4gICAgICBjb25zdCB7IGVycm9yLCByZXN1bHQgfSA9IGF3YWl0IHJhd1Jlc3VsdC5qc29uKCk7XG4gICAgICB0aGlzLmVycm9ySGFuZGxlcihtZXRob2QsIHBhcmFtcywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5lcnJvckhhbmRsZXIobWV0aG9kLCBwYXJhbXMsIGVycm9yPy5yZXNwb25zZT8uZGF0YSwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldENoYWluSWQoKSB7XG4gICAgdGhpcy5jaGFpbklkID8/ICh0aGlzLmNoYWluSWQgPSBhd2FpdCB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9jaGFpbklkXCIpKTtcbiAgICByZXR1cm4gdGhpcy5jaGFpbklkO1xuICB9XG4gIC8qKlxuICAgKiBORVc6IFJldHVybnMgdGhlIHZlcnNpb24gb2YgdGhlIFN0YXJrbmV0IEpTT04tUlBDIHNwZWNpZmljYXRpb24gYmVpbmcgdXNlZFxuICAgKi9cbiAgYXN5bmMgZ2V0U3BlY1ZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3NwZWNWZXJzaW9uXCIpO1xuICB9XG4gIGFzeW5jIGdldE5vbmNlRm9yQWRkcmVzcyhjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXROb25jZVwiLCB7XG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGdldEJsb2NrV2l0aFR4SGFzaGVzIG9yIGdldEJsb2NrV2l0aFR4cyAod2lsbCBiZSByZW1vdmVkIG9uIHNlcXVlbmNlciBkZXByZWNhdGlvbilcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QmxvY2tXaXRoVHhIYXNoZXMoYmxvY2tJZGVudGlmaWVyKS50aGVuKFxuICAgICAgdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUdldEJsb2NrUmVzcG9uc2VcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vc3QgcmVjZW50IGFjY2VwdGVkIGJsb2NrIGhhc2ggYW5kIG51bWJlclxuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYmxvY2tIYXNoQW5kTnVtYmVyXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCByZWR1bmRhbnQgdXNlIGdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQoKTtcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBibG9jayBudW1iZXJcbiAgICogQHJldHVybnMgTnVtYmVyIG9mIHRoZSBsYXRlc3QgYmxvY2tcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9ibG9ja051bWJlclwiKTtcbiAgfVxuICBhc3luYyBnZXRCbG9ja1dpdGhUeEhhc2hlcyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0QmxvY2tXaXRoVHhIYXNoZXNcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBhc3luYyBnZXRCbG9ja1dpdGhUeHMoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldEJsb2NrV2l0aFR4c1wiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGFzeW5jIGdldEJsb2NrU3RhdGVVcGRhdGUoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFN0YXRlVXBkYXRlXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tUcmFuc2FjdGlvbnNUcmFjZXMoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3RyYWNlQmxvY2tUcmFuc2FjdGlvbnNcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBhc3luYyBnZXRCbG9ja1RyYW5zYWN0aW9uQ291bnQoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudFwiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdHJhbnNhY3Rpb25zIGZyb20gcGVuZGluZyBibG9ja1xuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkIHVzZSBnZXRCbG9jayhCbG9ja1RhZy5wZW5kaW5nKTsgKHdpbGwgYmUgcmVtb3ZlZCBpbiBuZXh0IG1pbm9yIHZlcnNpb24pXG4gICAqL1xuICBhc3luYyBnZXRQZW5kaW5nVHJhbnNhY3Rpb25zKCkge1xuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBhd2FpdCB0aGlzLmdldEJsb2NrKFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi8pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbCh0cmFuc2FjdGlvbnMubWFwKChpdCkgPT4gdGhpcy5nZXRUcmFuc2FjdGlvbkJ5SGFzaChpdCkpKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGdldFRyYW5zYWN0aW9uQnlIYXNoIG9yIGdldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXggKHdpbGwgYmUgcmVtb3ZlZCBvbiBzZXF1ZW5jZXIgZGVwcmVjYXRpb24pXG4gICAqL1xuICBhc3luYyBnZXRUcmFuc2FjdGlvbih0eEhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2FjdGlvbkJ5SGFzaCh0eEhhc2gpLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUdldFRyYW5zYWN0aW9uUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uQnlIYXNoKHR4SGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0eEhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvbkJ5SGFzaFwiLCB7XG4gICAgICB0cmFuc2FjdGlvbl9oYXNoXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSWRBbmRJbmRleChibG9ja0lkZW50aWZpZXIsIGluZGV4KSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tJZEFuZEluZGV4XCIsIHsgYmxvY2tfaWQsIGluZGV4IH0pO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsIHsgdHJhbnNhY3Rpb25faGFzaCB9KTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvblRyYWNlKHR4SGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0eEhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF90cmFjZVRyYW5zYWN0aW9uXCIsIHsgdHJhbnNhY3Rpb25faGFzaCB9KTtcbiAgfVxuICAvKipcbiAgICogTkVXOiBHZXQgdGhlIHN0YXR1cyBvZiBhIHRyYW5zYWN0aW9uXG4gICAqL1xuICBhc3luYyBnZXRUcmFuc2FjdGlvblN0YXR1cyh0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHJhbnNhY3Rpb25IYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25TdGF0dXNcIiwgeyB0cmFuc2FjdGlvbl9oYXNoIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gaW52b2NhdGlvbnMgQWNjb3VudEludm9jYXRpb25zXG4gICAqIEBwYXJhbSBzaW11bGF0ZVRyYW5zYWN0aW9uT3B0aW9ucyBibG9ja0lkZW50aWZpZXIgYW5kIGZsYWdzIHRvIHNraXAgdmFsaWRhdGlvbiBhbmQgZmVlIGNoYXJnZTxici8+XG4gICAqIC0gYmxvY2tJZGVudGlmaWVyPGJyLz5cbiAgICogLSBza2lwVmFsaWRhdGUgKGRlZmF1bHQgZmFsc2UpPGJyLz5cbiAgICogLSBza2lwRmVlQ2hhcmdlIChkZWZhdWx0IHRydWUpPGJyLz5cbiAgICovXG4gIGFzeW5jIHNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIHtcbiAgICBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcixcbiAgICBza2lwVmFsaWRhdGUgPSBmYWxzZSxcbiAgICBza2lwRmVlQ2hhcmdlID0gdHJ1ZVxuICB9KSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIGNvbnN0IHNpbXVsYXRpb25GbGFncyA9IFtdO1xuICAgIGlmIChza2lwVmFsaWRhdGUpXG4gICAgICBzaW11bGF0aW9uRmxhZ3MucHVzaChycGNfZXhwb3J0cy5FU2ltdWxhdGlvbkZsYWcuU0tJUF9WQUxJREFURSk7XG4gICAgaWYgKHNraXBGZWVDaGFyZ2UpXG4gICAgICBzaW11bGF0aW9uRmxhZ3MucHVzaChycGNfZXhwb3J0cy5FU2ltdWxhdGlvbkZsYWcuU0tJUF9GRUVfQ0hBUkdFKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc2ltdWxhdGVUcmFuc2FjdGlvbnNcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICB0cmFuc2FjdGlvbnM6IGludm9jYXRpb25zLm1hcCgoaXQpID0+IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihpdCkpLFxuICAgICAgc2ltdWxhdGlvbl9mbGFnczogc2ltdWxhdGlvbkZsYWdzXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlU2ltdWxhdGVUcmFuc2FjdGlvblJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyB3YWl0Rm9yVHJhbnNhY3Rpb24odHhIYXNoLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25IYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICBsZXQgeyByZXRyaWVzIH0gPSB0aGlzO1xuICAgIGxldCBvbmNoYWluID0gZmFsc2U7XG4gICAgbGV0IGlzRXJyb3JTdGF0ZSA9IGZhbHNlO1xuICAgIGNvbnN0IHJldHJ5SW50ZXJ2YWwgPSBvcHRpb25zPy5yZXRyeUludGVydmFsID8/IDVlMztcbiAgICBjb25zdCBlcnJvclN0YXRlcyA9IG9wdGlvbnM/LmVycm9yU3RhdGVzID8/IFtcbiAgICAgIHJwY19leHBvcnRzLkVUcmFuc2FjdGlvblN0YXR1cy5SRUpFQ1RFRCxcbiAgICAgIHJwY19leHBvcnRzLkVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cy5SRVZFUlRFRFxuICAgIF07XG4gICAgY29uc3Qgc3VjY2Vzc1N0YXRlcyA9IG9wdGlvbnM/LnN1Y2Nlc3NTdGF0ZXMgPz8gW1xuICAgICAgcnBjX2V4cG9ydHMuRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzLlNVQ0NFRURFRCxcbiAgICAgIHJwY19leHBvcnRzLkVUcmFuc2FjdGlvblN0YXR1cy5BQ0NFUFRFRF9PTl9MMixcbiAgICAgIHJwY19leHBvcnRzLkVUcmFuc2FjdGlvblN0YXR1cy5BQ0NFUFRFRF9PTl9MMVxuICAgIF07XG4gICAgbGV0IHR4U3RhdHVzO1xuICAgIHdoaWxlICghb25jaGFpbikge1xuICAgICAgYXdhaXQgd2FpdChyZXRyeUludGVydmFsKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHR4U3RhdHVzID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblN0YXR1cyh0cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICBjb25zdCBleGVjdXRpb25TdGF0dXMgPSB0eFN0YXR1cy5leGVjdXRpb25fc3RhdHVzO1xuICAgICAgICBjb25zdCBmaW5hbGl0eVN0YXR1cyA9IHR4U3RhdHVzLmZpbmFsaXR5X3N0YXR1cztcbiAgICAgICAgaWYgKCFmaW5hbGl0eVN0YXR1cykge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwid2FpdGluZyBmb3IgdHJhbnNhY3Rpb24gc3RhdHVzXCIpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWNjZXNzU3RhdGVzLmluY2x1ZGVzKGV4ZWN1dGlvblN0YXR1cykgfHwgc3VjY2Vzc1N0YXRlcy5pbmNsdWRlcyhmaW5hbGl0eVN0YXR1cykpIHtcbiAgICAgICAgICBvbmNoYWluID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvclN0YXRlcy5pbmNsdWRlcyhleGVjdXRpb25TdGF0dXMpIHx8IGVycm9yU3RhdGVzLmluY2x1ZGVzKGZpbmFsaXR5U3RhdHVzKSkge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgJHtleGVjdXRpb25TdGF0dXN9OiAke2ZpbmFsaXR5U3RhdHVzfWA7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgZXJyb3IucmVzcG9uc2UgPSB0eFN0YXR1cztcbiAgICAgICAgICBpc0Vycm9yU3RhdGUgPSB0cnVlO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBpc0Vycm9yU3RhdGUpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0cmllcyA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB3YWl0Rm9yVHJhbnNhY3Rpb24gdGltZWQtb3V0IHdpdGggcmV0cmllcyAke3RoaXMucmV0cmllc31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0cmllcyAtPSAxO1xuICAgIH1cbiAgICBsZXQgdHhSZWNlaXB0ID0gbnVsbDtcbiAgICB3aGlsZSAodHhSZWNlaXB0ID09PSBudWxsKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0eFJlY2VpcHQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHJldHJpZXMgPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgd2FpdEZvclRyYW5zYWN0aW9uIHRpbWVkLW91dCB3aXRoIHJldHJpZXMgJHt0aGlzLnJldHJpZXN9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHJpZXMgLT0gMTtcbiAgICAgIGF3YWl0IHdhaXQocmV0cnlJbnRlcnZhbCk7XG4gICAgfVxuICAgIHJldHVybiB0eFJlY2VpcHQ7XG4gIH1cbiAgYXN5bmMgZ2V0U3RvcmFnZUF0KGNvbnRyYWN0QWRkcmVzcywga2V5LCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IHBhcnNlZEtleSA9IHRvU3RvcmFnZUtleShrZXkpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0U3RvcmFnZUF0XCIsIHtcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3MsXG4gICAgICBrZXk6IHBhcnNlZEtleSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3NIYXNoQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Q2xhc3NIYXNoQXRcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICBjb250cmFjdF9hZGRyZXNzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3NCeUhhc2goY2xhc3NIYXNoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2xhc3MoY2xhc3NIYXNoKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzcyhjbGFzc0hhc2gsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY2xhc3NfaGFzaCA9IHRvSGV4KGNsYXNzSGFzaCk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRDbGFzc1wiLCB7XG4gICAgICBjbGFzc19oYXNoLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VDb250cmFjdENsYXNzUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Q2xhc3NBdFwiLCB7XG4gICAgICBibG9ja19pZCxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3NcbiAgICB9KS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VDb250cmFjdENsYXNzUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldENvZGUoX2NvbnRyYWN0QWRkcmVzcywgX2Jsb2NrSWRlbnRpZmllcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJQQyBkb2VzIG5vdCBpbXBsZW1lbnQgZ2V0Q29kZSBmdW5jdGlvblwiKTtcbiAgfVxuICBhc3luYyBnZXRDb250cmFjdFZlcnNpb24oY29udHJhY3RBZGRyZXNzLCBjbGFzc0hhc2gsIHsgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIsIGNvbXBpbGVyID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBsZXQgY29udHJhY3RDbGFzcztcbiAgICBpZiAoY29udHJhY3RBZGRyZXNzKSB7XG4gICAgICBjb250cmFjdENsYXNzID0gYXdhaXQgdGhpcy5nZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgICB9IGVsc2UgaWYgKGNsYXNzSGFzaCkge1xuICAgICAgY29udHJhY3RDbGFzcyA9IGF3YWl0IHRoaXMuZ2V0Q2xhc3MoY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcImdldENvbnRyYWN0VmVyc2lvbiByZXF1aXJlIGNvbnRyYWN0QWRkcmVzcyBvciBjbGFzc0hhc2hcIik7XG4gICAgfVxuICAgIGlmIChpc1NpZXJyYShjb250cmFjdENsYXNzKSkge1xuICAgICAgaWYgKGNvbXBpbGVyKSB7XG4gICAgICAgIGNvbnN0IGFiaVRlc3QgPSBnZXRBYmlDb250cmFjdFZlcnNpb24oY29udHJhY3RDbGFzcy5hYmkpO1xuICAgICAgICByZXR1cm4geyBjYWlybzogXCIxXCIsIGNvbXBpbGVyOiBhYmlUZXN0LmNvbXBpbGVyIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBjYWlybzogXCIxXCIsIGNvbXBpbGVyOiB2b2lkIDAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2Fpcm86IFwiMFwiLCBjb21waWxlcjogXCIwXCIgfTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGdldCp0eXBlKkVzdGltYXRlRmVlICh3aWxsIGJlIHJlZmFjdG9yZWQgYmFzZWQgb24gdHlwZSBhZnRlciBzZXF1ZW5jZXIgZGVwcmVjYXRpb24pXG4gICAqL1xuICBhc3luYyBnZXRFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnZva2VFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRJbnZva2VFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovLFxuICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAuLi5pbnZvY2F0aW9uRGV0YWlsc1xuICAgICAgfSxcbiAgICAgIFwiZmVlXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9lc3RpbWF0ZUZlZVwiLCB7XG4gICAgICByZXF1ZXN0OiBbdHJhbnNhY3Rpb25dLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXREZWNsYXJlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgZGV0YWlscywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgICAgIC4uLmludm9jYXRpb24sXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH0sXG4gICAgICBcImZlZVwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVGZWVcIiwge1xuICAgICAgcmVxdWVzdDogW3RyYW5zYWN0aW9uXSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RGVwbG95QWNjb3VudEVzdGltYXRlRmVlKGludm9jYXRpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uKFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8sXG4gICAgICAgIC4uLmludm9jYXRpb24sXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH0sXG4gICAgICBcImZlZVwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVGZWVcIiwge1xuICAgICAgcmVxdWVzdDogW3RyYW5zYWN0aW9uXSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWVCdWxrKGludm9jYXRpb25zLCB7IGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSBmYWxzZSB9KSB7XG4gICAgaWYgKHNraXBWYWxpZGF0ZSkge1xuICAgICAgY29uc29sZS53YXJuKFwiZ2V0RXN0aW1hdGVGZWVCdWxrIFJQQyBkb2VzIG5vdCBzdXBwb3J0IHNraXBWYWxpZGF0ZVwiKTtcbiAgICB9XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9lc3RpbWF0ZUZlZVwiLCB7XG4gICAgICByZXF1ZXN0OiBpbnZvY2F0aW9ucy5tYXAoKGl0KSA9PiB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oaXQsIFwiZmVlXCIpKSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVCdWxrUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGludm9rZUZ1bmN0aW9uKGZ1bmN0aW9uSW52b2NhdGlvbiwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGRJbnZva2VUcmFuc2FjdGlvblwiLCB7XG4gICAgICBpbnZva2VfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGZ1bmN0aW9uSW52b2NhdGlvbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChmdW5jdGlvbkludm9jYXRpb24uY2FsbGRhdGEpLFxuICAgICAgICB0eXBlOiBycGNfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLklOVk9LRSxcbiAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgIHZlcnNpb246IFwiMHgxXCIsXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShmdW5jdGlvbkludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZGVjbGFyZUNvbnRyYWN0KHsgY29udHJhY3QsIHNpZ25hdHVyZSwgc2VuZGVyQWRkcmVzcywgY29tcGlsZWRDbGFzc0hhc2ggfSwgZGV0YWlscykge1xuICAgIGlmICghaXNTaWVycmEoY29udHJhY3QpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVjbGFyZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IHJwY19leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuREVDTEFSRSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgICAgcHJvZ3JhbTogY29udHJhY3QucHJvZ3JhbSxcbiAgICAgICAgICAgIGVudHJ5X3BvaW50c19ieV90eXBlOiBjb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZSxcbiAgICAgICAgICAgIGFiaTogY29udHJhY3QuYWJpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2ZXJzaW9uOiBIRVhfU1RSX1RSQU5TQUNUSU9OX1ZFUlNJT05fMSxcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGREZWNsYXJlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgZGVjbGFyZV90cmFuc2FjdGlvbjoge1xuICAgICAgICB0eXBlOiBycGNfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkUsXG4gICAgICAgIGNvbnRyYWN0X2NsYXNzOiB7XG4gICAgICAgICAgc2llcnJhX3Byb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzc192ZXJzaW9uOiBjb250cmFjdC5jb250cmFjdF9jbGFzc192ZXJzaW9uLFxuICAgICAgICAgIGVudHJ5X3BvaW50c19ieV90eXBlOiBjb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZSxcbiAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICB9LFxuICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBjb21waWxlZENsYXNzSGFzaCB8fCBcIlwiLFxuICAgICAgICB2ZXJzaW9uOiBIRVhfU1RSX1RSQU5TQUNUSU9OX1ZFUlNJT05fMixcbiAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZGVwbG95QWNjb3VudENvbnRyYWN0KHsgY2xhc3NIYXNoLCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBhZGRyZXNzU2FsdCwgc2lnbmF0dXJlIH0sIGRldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uXCIsIHtcbiAgICAgIGRlcGxveV9hY2NvdW50X3RyYW5zYWN0aW9uOiB7XG4gICAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgY2xhc3NfaGFzaDogdG9IZXgoY2xhc3NIYXNoKSxcbiAgICAgICAgY29udHJhY3RfYWRkcmVzc19zYWx0OiB0b0hleChhZGRyZXNzU2FsdCB8fCAwKSxcbiAgICAgICAgdHlwZTogcnBjX2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERVBMT1lfQUNDT1VOVCxcbiAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGRldGFpbHMudmVyc2lvbiB8fCAwKSxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNhbGxDb250cmFjdChjYWxsLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9jYWxsXCIsIHtcbiAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgY29udHJhY3RfYWRkcmVzczogY2FsbC5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGVudHJ5X3BvaW50X3NlbGVjdG9yOiBnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCksXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjYWxsLmNhbGxkYXRhKVxuICAgICAgfSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VDYWxsQ29udHJhY3RSZXNwb25zZShyZXN1bHQpO1xuICB9XG4gIC8qKlxuICAgKiBORVc6IEVzdGltYXRlIHRoZSBmZWUgZm9yIGEgbWVzc2FnZSBmcm9tIEwxXG4gICAqIEBwYXJhbSBtZXNzYWdlIE1lc3NhZ2UgRnJvbSBMMVxuICAgKi9cbiAgYXN5bmMgZXN0aW1hdGVNZXNzYWdlRmVlKG1lc3NhZ2UsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgeyBmcm9tX2FkZHJlc3MsIHRvX2FkZHJlc3MsIGVudHJ5X3BvaW50X3NlbGVjdG9yLCBwYXlsb2FkIH0gPSBtZXNzYWdlO1xuICAgIGNvbnN0IGZvcm1hdHRlZE1lc3NhZ2UgPSB7XG4gICAgICBmcm9tX2FkZHJlc3M6IHRvSGV4KGZyb21fYWRkcmVzcyksXG4gICAgICB0b19hZGRyZXNzOiB0b0hleCh0b19hZGRyZXNzKSxcbiAgICAgIGVudHJ5X3BvaW50X3NlbGVjdG9yOiBnZXRTZWxlY3RvcihlbnRyeV9wb2ludF9zZWxlY3RvciksXG4gICAgICBwYXlsb2FkOiBnZXRIZXhTdHJpbmdBcnJheShwYXlsb2FkKVxuICAgIH07XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9lc3RpbWF0ZU1lc3NhZ2VGZWVcIiwge1xuICAgICAgbWVzc2FnZTogZm9ybWF0dGVkTWVzc2FnZSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IGFib3V0IHRoZSBzeW5jIHN0YXR1cywgb3IgZmFsc2UgaWYgdGhlIG5vZGUgaXMgbm90IHN5bmNoaW5nXG4gICAqIEByZXR1cm5zIE9iamVjdCB3aXRoIHRoZSBzdGF0cyBkYXRhXG4gICAqL1xuICBhc3luYyBnZXRTeW5jaW5nU3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3N5bmNpbmdcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGV2ZW50cyBtYXRjaGluZyB0aGUgZ2l2ZW4gZmlsdGVyXG4gICAqIEByZXR1cm5zIGV2ZW50cyBhbmQgdGhlIHBhZ2luYXRpb24gb2YgdGhlIGV2ZW50c1xuICAgKi9cbiAgYXN5bmMgZ2V0RXZlbnRzKGV2ZW50RmlsdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldEV2ZW50c1wiLCB7IGZpbHRlcjogZXZlbnRGaWx0ZXIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJrbmV0SWQgRW5kcG9pbnQgKGdldCBuYW1lIGZyb20gYWRkcmVzcylcbiAgICovXG4gIGFzeW5jIGdldFN0YXJrTmFtZShhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgcmV0dXJuIGdldFN0YXJrTmFtZSh0aGlzLCBhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKTtcbiAgfVxuICAvKipcbiAgICogU3RhcmtuZXRJZCBFbmRwb2ludCAoZ2V0IGFkZHJlc3MgZnJvbSBuYW1lKVxuICAgKi9cbiAgYXN5bmMgZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUobmFtZSwgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBnZXRBZGRyZXNzRnJvbVN0YXJrTmFtZSh0aGlzLCBuYW1lLCBTdGFya25ldElkQ29udHJhY3QyKTtcbiAgfVxuICBidWlsZFRyYW5zYWN0aW9uKGludm9jYXRpb24sIHZlcnNpb25UeXBlKSB7XG4gICAgY29uc3QgZGVmYXVsdFZlcnNpb25zID0gZ2V0VmVyc2lvbnNCeVR5cGUodmVyc2lvblR5cGUpO1xuICAgIGNvbnN0IGRldGFpbHMgPSB7XG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoaW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgbm9uY2U6IHRvSGV4KGludm9jYXRpb24ubm9uY2UpLFxuICAgICAgbWF4X2ZlZTogdG9IZXgoaW52b2NhdGlvbi5tYXhGZWUgfHwgMClcbiAgICB9O1xuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBycGNfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLklOVk9LRSxcbiAgICAgICAgLy8gRGlmZiBiZXR3ZWVuIHNlcXVlbmNlciBhbmQgcnBjIGludm9rZSB0eXBlXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGludm9jYXRpb24uY2FsbGRhdGEpLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYxKSxcbiAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGludm9jYXRpb24udHlwZSA9PT0gXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLykge1xuICAgICAgaWYgKCFpc1NpZXJyYShpbnZvY2F0aW9uLmNvbnRyYWN0KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczogaW52b2NhdGlvbi5jb250cmFjdCxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogaW52b2NhdGlvbi5zZW5kZXJBZGRyZXNzLFxuICAgICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjEpLFxuICAgICAgICAgIC4uLmRldGFpbHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIGNvbXBpbGVkX2NsYXNzX2hhc2hcbiAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgIC4uLmludm9jYXRpb24uY29udHJhY3QsXG4gICAgICAgICAgc2llcnJhX3Byb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGludm9jYXRpb24uY29udHJhY3Quc2llcnJhX3Byb2dyYW0pXG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGludm9jYXRpb24uY29tcGlsZWRDbGFzc0hhc2ggfHwgXCJcIixcbiAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MiksXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICBjb25zdHJ1Y3Rvcl9jYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoaW52b2NhdGlvbi5jb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgY2xhc3NfaGFzaDogdG9IZXgoaW52b2NhdGlvbi5jbGFzc0hhc2gpLFxuICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGludm9jYXRpb24uYWRkcmVzc1NhbHQgfHwgMCksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjEpLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIlJQQyBidWlsZFRyYW5zYWN0aW9uIHJlY2VpdmVkIHVua25vd24gVHJhbnNhY3Rpb25UeXBlXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvc2VxdWVuY2VyLnRzXG52YXIgaW1wb3J0X3VybF9qb2luMiA9IF9fdG9FU00ocmVxdWlyZShcInVybC1qb2luXCIpKTtcblxuLy8gc3JjL3V0aWxzL3Jlc3BvbnNlUGFyc2VyL2luZGV4LnRzXG52YXIgUmVzcG9uc2VQYXJzZXIgPSBjbGFzcyB7XG59O1xuXG4vLyBzcmMvdXRpbHMvcmVzcG9uc2VQYXJzZXIvc2VxdWVuY2VyLnRzXG52YXIgU2VxdWVuY2VyQVBJUmVzcG9uc2VQYXJzZXIgPSBjbGFzcyBleHRlbmRzIFJlc3BvbnNlUGFyc2VyIHtcbiAgcGFyc2VHZXRCbG9ja1Jlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXMsXG4gICAgICBuZXdfcm9vdDogcmVzLnN0YXRlX3Jvb3QsXG4gICAgICBwYXJlbnRfaGFzaDogcmVzLnBhcmVudF9ibG9ja19oYXNoLFxuICAgICAgdHJhbnNhY3Rpb25zOiBPYmplY3QudmFsdWVzKHJlcy50cmFuc2FjdGlvbnMpLm1hcCgodmFsdWUpID0+IFwidHJhbnNhY3Rpb25faGFzaFwiIGluIHZhbHVlICYmIHZhbHVlLnRyYW5zYWN0aW9uX2hhc2gpLmZpbHRlcihCb29sZWFuKVxuICAgIH07XG4gIH1cbiAgcGFyc2VHZXRUcmFuc2FjdGlvblJlc3BvbnNlKHJlcykge1xuICAgIGlmIChyZXMuc3RhdHVzID09PSBcIk5PVF9SRUNFSVZFRFwiIC8qIE5PVF9SRUNFSVZFRCAqLyAmJiByZXMuZmluYWxpdHlfc3RhdHVzID09PSBcIk5PVF9SRUNFSVZFRFwiIC8qIE5PVF9SRUNFSVZFRCAqLykge1xuICAgICAgdGhyb3cgbmV3IExpYnJhcnlFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzLFxuICAgICAgY2FsbGRhdGE6IFwiY2FsbGRhdGFcIiBpbiByZXMudHJhbnNhY3Rpb24gPyByZXMudHJhbnNhY3Rpb24uY2FsbGRhdGEgOiBbXSxcbiAgICAgIGNvbnRyYWN0X2NsYXNzOiBcImNvbnRyYWN0X2NsYXNzXCIgaW4gcmVzLnRyYW5zYWN0aW9uID8gcmVzLnRyYW5zYWN0aW9uLmNvbnRyYWN0X2NsYXNzIDogdm9pZCAwLFxuICAgICAgZW50cnlfcG9pbnRfc2VsZWN0b3I6IFwiZW50cnlfcG9pbnRfc2VsZWN0b3JcIiBpbiByZXMudHJhbnNhY3Rpb24gPyByZXMudHJhbnNhY3Rpb24uZW50cnlfcG9pbnRfc2VsZWN0b3IgOiB2b2lkIDAsXG4gICAgICBtYXhfZmVlOiBcIm1heF9mZWVcIiBpbiByZXMudHJhbnNhY3Rpb24gPyByZXMudHJhbnNhY3Rpb24ubWF4X2ZlZSA6IHZvaWQgMCxcbiAgICAgIG5vbmNlOiByZXMudHJhbnNhY3Rpb24ubm9uY2UsXG4gICAgICBzZW5kZXJfYWRkcmVzczogXCJzZW5kZXJfYWRkcmVzc1wiIGluIHJlcy50cmFuc2FjdGlvbiA/IHJlcy50cmFuc2FjdGlvbi5zZW5kZXJfYWRkcmVzcyA6IHZvaWQgMCxcbiAgICAgIHNpZ25hdHVyZTogXCJzaWduYXR1cmVcIiBpbiByZXMudHJhbnNhY3Rpb24gPyByZXMudHJhbnNhY3Rpb24uc2lnbmF0dXJlIDogdm9pZCAwLFxuICAgICAgdHJhbnNhY3Rpb25faGFzaDogXCJ0cmFuc2FjdGlvbl9oYXNoXCIgaW4gcmVzLnRyYW5zYWN0aW9uID8gcmVzLnRyYW5zYWN0aW9uLnRyYW5zYWN0aW9uX2hhc2ggOiB2b2lkIDAsXG4gICAgICB2ZXJzaW9uOiBcInZlcnNpb25cIiBpbiByZXMudHJhbnNhY3Rpb24gPyByZXMudHJhbnNhY3Rpb24udmVyc2lvbiA6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgcGFyc2VHZXRUcmFuc2FjdGlvblJlY2VpcHRSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzLFxuICAgICAgbWVzc2FnZXNfc2VudDogcmVzLmwyX3RvX2wxX21lc3NhZ2VzLFxuICAgICAgLi4uXCJyZXZlcnRfZXJyb3JcIiBpbiByZXMgJiYgeyByZXZlcnRfcmVhc29uOiByZXMucmV2ZXJ0X2Vycm9yIH1cbiAgICB9O1xuICB9XG4gIHBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZShyZXMpIHtcbiAgICBpZiAoXCJvdmVyYWxsX2ZlZVwiIGluIHJlcykge1xuICAgICAgbGV0IGdhc0luZm8gPSB7fTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGdhc0luZm8gPSB7XG4gICAgICAgICAgZ2FzX2NvbnN1bWVkOiB0b0JpZ0ludChyZXMuZ2FzX3VzYWdlKSxcbiAgICAgICAgICBnYXNfcHJpY2U6IHRvQmlnSW50KHJlcy5nYXNfcHJpY2UpXG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG92ZXJhbGxfZmVlOiB0b0JpZ0ludChyZXMub3ZlcmFsbF9mZWUpLFxuICAgICAgICAuLi5nYXNJbmZvXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgb3ZlcmFsbF9mZWU6IHRvQmlnSW50KHJlcy5hbW91bnQpXG4gICAgfTtcbiAgfVxuICBwYXJzZUZlZUVzdGltYXRlQnVsa1Jlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiBbXS5jb25jYXQocmVzKS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgIGlmIChcIm92ZXJhbGxfZmVlXCIgaW4gaXRlbSkge1xuICAgICAgICBsZXQgZ2FzSW5mbyA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGdhc0luZm8gPSB7XG4gICAgICAgICAgICBnYXNfY29uc3VtZWQ6IHRvQmlnSW50KGl0ZW0uZ2FzX3VzYWdlKSxcbiAgICAgICAgICAgIGdhc19wcmljZTogdG9CaWdJbnQoaXRlbS5nYXNfcHJpY2UpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvdmVyYWxsX2ZlZTogdG9CaWdJbnQoaXRlbS5vdmVyYWxsX2ZlZSksXG4gICAgICAgICAgLi4uZ2FzSW5mb1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3ZlcmFsbF9mZWU6IHRvQmlnSW50KGl0ZW0uYW1vdW50KVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBwYXJzZVNpbXVsYXRlVHJhbnNhY3Rpb25SZXNwb25zZShyZXMpIHtcbiAgICBjb25zdCBzdWdnZXN0ZWRNYXhGZWUgPSBcIm92ZXJhbGxfZmVlXCIgaW4gcmVzLmZlZV9lc3RpbWF0aW9uID8gcmVzLmZlZV9lc3RpbWF0aW9uLm92ZXJhbGxfZmVlIDogcmVzLmZlZV9lc3RpbWF0aW9uLmFtb3VudDtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0cmFuc2FjdGlvbl90cmFjZTogcmVzLnRyYWNlLFxuICAgICAgICBmZWVfZXN0aW1hdGlvbjogcmVzLmZlZV9lc3RpbWF0aW9uLFxuICAgICAgICBzdWdnZXN0ZWRNYXhGZWU6IGVzdGltYXRlZEZlZVRvTWF4RmVlKEJpZ0ludChzdWdnZXN0ZWRNYXhGZWUpKVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgcGFyc2VDYWxsQ29udHJhY3RSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiByZXMucmVzdWx0XG4gICAgfTtcbiAgfVxuICBwYXJzZUludm9rZUZ1bmN0aW9uUmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zYWN0aW9uX2hhc2g6IHJlcy50cmFuc2FjdGlvbl9oYXNoXG4gICAgfTtcbiAgfVxuICBwYXJzZURlcGxveUNvbnRyYWN0UmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zYWN0aW9uX2hhc2g6IHJlcy50cmFuc2FjdGlvbl9oYXNoLFxuICAgICAgY29udHJhY3RfYWRkcmVzczogcmVzLmFkZHJlc3NcbiAgICB9O1xuICB9XG4gIHBhcnNlRGVjbGFyZUNvbnRyYWN0UmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zYWN0aW9uX2hhc2g6IHJlcy50cmFuc2FjdGlvbl9oYXNoLFxuICAgICAgY2xhc3NfaGFzaDogcmVzLmNsYXNzX2hhc2hcbiAgICB9O1xuICB9XG4gIHBhcnNlR2V0U3RhdGVVcGRhdGVSZXNwb25zZShyZXMpIHtcbiAgICBjb25zdCBub25jZXMgPSBPYmplY3QuZW50cmllcyhyZXMuc3RhdGVfZGlmZi5ub25jZXMpLm1hcCgoW2NvbnRyYWN0X2FkZHJlc3MsIG5vbmNlXSkgPT4gKHtcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3MsXG4gICAgICBub25jZVxuICAgIH0pKTtcbiAgICBjb25zdCBzdG9yYWdlX2RpZmZzID0gT2JqZWN0LmVudHJpZXMocmVzLnN0YXRlX2RpZmYuc3RvcmFnZV9kaWZmcykubWFwKFxuICAgICAgKFthZGRyZXNzLCBzdG9yYWdlX2VudHJpZXNdKSA9PiAoeyBhZGRyZXNzLCBzdG9yYWdlX2VudHJpZXMgfSlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXMsXG4gICAgICBzdGF0ZV9kaWZmOiB7XG4gICAgICAgIC4uLnJlcy5zdGF0ZV9kaWZmLFxuICAgICAgICBzdG9yYWdlX2RpZmZzLFxuICAgICAgICBub25jZXNcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlKHJlcykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gaXNTaWVycmEocmVzKSA/IHJlcyA6IHBhcnNlQ29udHJhY3QocmVzKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICBhYmk6IHR5cGVvZiByZXNwb25zZS5hYmkgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKHJlc3BvbnNlLmFiaSkgOiByZXNwb25zZS5hYmlcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvdXJsLnRzXG52YXIgaW1wb3J0X3VybF9qb2luID0gX190b0VTTShyZXF1aXJlKFwidXJsLWpvaW5cIikpO1xudmFyIHByb3RvY29sQW5kRG9tYWluUkUgPSAvXig/Olxcdys6KT9cXC9cXC8oXFxTKykkLztcbnZhciBsb2NhbGhvc3REb21haW5SRSA9IC9ebG9jYWxob3N0Wzo/XFxkXSooPzpbXjo/XFxkXVxcUyopPyQvO1xudmFyIG5vbkxvY2FsaG9zdERvbWFpblJFID0gL15bXlxccy5dK1xcLlxcU3syLH0kLztcbmZ1bmN0aW9uIGlzVXJsKHMpIHtcbiAgaWYgKCFzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgcyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBtYXRjaCA9IHMubWF0Y2gocHJvdG9jb2xBbmREb21haW5SRSk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZXZlcnl0aGluZ0FmdGVyUHJvdG9jb2wgPSBtYXRjaFsxXTtcbiAgaWYgKCFldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobG9jYWxob3N0RG9tYWluUkUudGVzdChldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCkgfHwgbm9uTG9jYWxob3N0RG9tYWluUkUudGVzdChldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBidWlsZFVybChiYXNlVXJsLCBkZWZhdWx0UGF0aCwgdXJsT3JQYXRoKSB7XG4gIHJldHVybiBpc1VybCh1cmxPclBhdGgpID8gdXJsT3JQYXRoIDogKDAsIGltcG9ydF91cmxfam9pbi5kZWZhdWx0KShiYXNlVXJsLCB1cmxPclBhdGggPz8gZGVmYXVsdFBhdGgpO1xufVxuXG4vLyBzcmMvcHJvdmlkZXIvc2VxdWVuY2VyLnRzXG5mdW5jdGlvbiBpc0VtcHR5UXVlcnlPYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogPT09IHZvaWQgMCB8fCBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMCB8fCBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMSAmJiBPYmplY3QuZW50cmllcyhvYmopLmV2ZXJ5KChbaywgdl0pID0+IGsgPT09IFwiYmxvY2tJZGVudGlmaWVyXCIgJiYgdiA9PT0gbnVsbCk7XG59XG52YXIgZGVmYXVsdE9wdGlvbnMyID0ge1xuICBuZXR3b3JrOiBcIlNOX0dPRVJMSVwiIC8qIFNOX0dPRVJMSSAqLyxcbiAgYmxvY2tJZGVudGlmaWVyOiBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovXG59O1xudmFyIFNlcXVlbmNlclByb3ZpZGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zT3JQcm92aWRlciA9IGRlZmF1bHRPcHRpb25zMikge1xuICAgIHRoaXMucmVzcG9uc2VQYXJzZXIgPSBuZXcgU2VxdWVuY2VyQVBJUmVzcG9uc2VQYXJzZXIoKTtcbiAgICBpZiAoXCJuZXR3b3JrXCIgaW4gb3B0aW9uc09yUHJvdmlkZXIpIHtcbiAgICAgIHRoaXMuYmFzZVVybCA9IFNlcXVlbmNlclByb3ZpZGVyLmdldE5ldHdvcmtGcm9tTmFtZShvcHRpb25zT3JQcm92aWRlci5uZXR3b3JrKTtcbiAgICAgIHRoaXMuZmVlZGVyR2F0ZXdheVVybCA9IGJ1aWxkVXJsKHRoaXMuYmFzZVVybCwgXCJmZWVkZXJfZ2F0ZXdheVwiKTtcbiAgICAgIHRoaXMuZ2F0ZXdheVVybCA9IGJ1aWxkVXJsKHRoaXMuYmFzZVVybCwgXCJnYXRld2F5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJhc2VVcmwgPSBvcHRpb25zT3JQcm92aWRlci5iYXNlVXJsO1xuICAgICAgdGhpcy5mZWVkZXJHYXRld2F5VXJsID0gYnVpbGRVcmwoXG4gICAgICAgIHRoaXMuYmFzZVVybCxcbiAgICAgICAgXCJmZWVkZXJfZ2F0ZXdheVwiLFxuICAgICAgICBvcHRpb25zT3JQcm92aWRlci5mZWVkZXJHYXRld2F5VXJsXG4gICAgICApO1xuICAgICAgdGhpcy5nYXRld2F5VXJsID0gYnVpbGRVcmwodGhpcy5iYXNlVXJsLCBcImdhdGV3YXlcIiwgb3B0aW9uc09yUHJvdmlkZXIuZ2F0ZXdheVVybCk7XG4gICAgfVxuICAgIHRoaXMuY2hhaW5JZCA9IG9wdGlvbnNPclByb3ZpZGVyPy5jaGFpbklkID8/IFNlcXVlbmNlclByb3ZpZGVyLmdldENoYWluSWRGcm9tQmFzZVVybCh0aGlzLmJhc2VVcmwpO1xuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnNPclByb3ZpZGVyLmhlYWRlcnM7XG4gICAgdGhpcy5ibG9ja0lkZW50aWZpZXIgPSBvcHRpb25zT3JQcm92aWRlcj8uYmxvY2tJZGVudGlmaWVyIHx8IGRlZmF1bHRPcHRpb25zMi5ibG9ja0lkZW50aWZpZXI7XG4gIH1cbiAgc3RhdGljIGdldE5ldHdvcmtGcm9tTmFtZShuYW1lKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwiU05fTUFJTlwiIC8qIFNOX01BSU4gKi86XG4gICAgICBjYXNlIFwiMHg1MzRlNWY0ZDQxNDk0ZVwiIC8qIFNOX01BSU4gKi86XG4gICAgICAgIHJldHVybiBcImh0dHBzOi8vYWxwaGEtbWFpbm5ldC5zdGFya25ldC5pb1wiIC8qIFNOX01BSU4gKi87XG4gICAgICBjYXNlIFwiU05fR09FUkxJXCIgLyogU05fR09FUkxJICovOlxuICAgICAgY2FzZSBcIjB4NTM0ZTVmNDc0ZjQ1NTI0YzQ5XCIgLyogU05fR09FUkxJICovOlxuICAgICAgICByZXR1cm4gXCJodHRwczovL2FscGhhNC5zdGFya25ldC5pb1wiIC8qIFNOX0dPRVJMSSAqLztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBkZXRlY3QgYmFzZSB1cmwgZnJvbSBOZXR3b3JrTmFtZVwiKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldENoYWluSWRGcm9tQmFzZVVybChiYXNlVXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgICBpZiAodXJsLmhvc3QuaW5jbHVkZXMoXCJtYWlubmV0LnN0YXJrbmV0LmlvXCIpKSB7XG4gICAgICAgIHJldHVybiBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiMHg1MzRlNWY0NzRmNDU1MjRjNDlcIiAvKiBTTl9HT0VSTEkgKi87XG4gICAgfSBjYXRjaCB7XG4gICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3QgcGFyc2UgYmFzZVVybDogJHtiYXNlVXJsfWApO1xuICAgICAgcmV0dXJuIFwiMHg1MzRlNWY0NzRmNDU1MjRjNDlcIiAvKiBTTl9HT0VSTEkgKi87XG4gICAgfVxuICB9XG4gIGdldEZldGNoVXJsKGVuZHBvaW50KSB7XG4gICAgY29uc3QgZ2F0ZXdheVVybEVuZHBvaW50cyA9IFtcImFkZF90cmFuc2FjdGlvblwiXTtcbiAgICByZXR1cm4gZ2F0ZXdheVVybEVuZHBvaW50cy5pbmNsdWRlcyhlbmRwb2ludCkgPyB0aGlzLmdhdGV3YXlVcmwgOiB0aGlzLmZlZWRlckdhdGV3YXlVcmw7XG4gIH1cbiAgZ2V0RmV0Y2hNZXRob2QoZW5kcG9pbnQpIHtcbiAgICBjb25zdCBwb3N0TWV0aG9kRW5kcG9pbnRzID0gW1xuICAgICAgXCJhZGRfdHJhbnNhY3Rpb25cIixcbiAgICAgIFwiY2FsbF9jb250cmFjdFwiLFxuICAgICAgXCJlc3RpbWF0ZV9mZWVcIixcbiAgICAgIFwiZXN0aW1hdGVfbWVzc2FnZV9mZWVcIixcbiAgICAgIFwiZXN0aW1hdGVfZmVlX2J1bGtcIixcbiAgICAgIFwic2ltdWxhdGVfdHJhbnNhY3Rpb25cIlxuICAgIF07XG4gICAgcmV0dXJuIHBvc3RNZXRob2RFbmRwb2ludHMuaW5jbHVkZXMoZW5kcG9pbnQpID8gXCJQT1NUXCIgOiBcIkdFVFwiO1xuICB9XG4gIGdldFF1ZXJ5U3RyaW5nKHF1ZXJ5KSB7XG4gICAgaWYgKGlzRW1wdHlRdWVyeU9iamVjdChxdWVyeSkpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IE9iamVjdC5lbnRyaWVzKHF1ZXJ5KS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gXCJibG9ja0lkZW50aWZpZXJcIikge1xuICAgICAgICBjb25zdCBibG9jayA9IG5ldyBCbG9jayh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBgJHtibG9jay5xdWVyeUlkZW50aWZpZXJ9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgJHtrZXl9PSR7dmFsdWV9YDtcbiAgICB9KS5qb2luKFwiJlwiKTtcbiAgICByZXR1cm4gYD8ke3F1ZXJ5U3RyaW5nfWA7XG4gIH1cbiAgZ2V0SGVhZGVycyhtZXRob2QpIHtcbiAgICBpZiAobWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLnRoaXMuaGVhZGVyc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGVhZGVycztcbiAgfVxuICAvLyB0eXBlc2FmZSBmZXRjaFxuICBhc3luYyBmZXRjaEVuZHBvaW50KGVuZHBvaW50LCAuLi5bcXVlcnksIHJlcXVlc3RdKSB7XG4gICAgY29uc3QgYmFzZVVybCA9IHRoaXMuZ2V0RmV0Y2hVcmwoZW5kcG9pbnQpO1xuICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMuZ2V0RmV0Y2hNZXRob2QoZW5kcG9pbnQpO1xuICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gdGhpcy5nZXRRdWVyeVN0cmluZyhxdWVyeSk7XG4gICAgY29uc3QgdXJsID0gKDAsIGltcG9ydF91cmxfam9pbjIuZGVmYXVsdCkoYmFzZVVybCwgZW5kcG9pbnQsIHF1ZXJ5U3RyaW5nKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIGJvZHk6IHJlcXVlc3RcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmZXRjaChlbmRwb2ludCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHVybCA9IGJ1aWxkVXJsKHRoaXMuYmFzZVVybCwgXCJcIiwgZW5kcG9pbnQpO1xuICAgIGNvbnN0IG1ldGhvZCA9IG9wdGlvbnM/Lm1ldGhvZCA/PyBcIkdFVFwiO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmdldEhlYWRlcnMobWV0aG9kKTtcbiAgICBjb25zdCBib2R5ID0gc3RyaW5naWZ5MihvcHRpb25zPy5ib2R5KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFBvbnlmaWxsX2RlZmF1bHQodXJsLCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgYm9keSxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfSk7XG4gICAgICBjb25zdCB0ZXh0UmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGxldCByZXNwb25zZUJvZHk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzcG9uc2VCb2R5ID0gcGFyc2UyKHRleHRSZXNwb25zZSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHRocm93IG5ldyBIdHRwRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgR2F0ZXdheUVycm9yKHJlc3BvbnNlQm9keS5tZXNzYWdlLCByZXNwb25zZUJvZHkuY29kZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZUNob2ljZSA9IG9wdGlvbnM/LnBhcnNlQWx3YXlzQXNCaWdJbnQgPyBwYXJzZUFsd2F5c0FzQmlnIDogcGFyc2UyO1xuICAgICAgcmV0dXJuIHBhcnNlQ2hvaWNlKHRleHRSZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBMaWJyYXJ5RXJyb3IpKVxuICAgICAgICB0aHJvdyBFcnJvcihgQ291bGQgbm90ICR7bWV0aG9kfSBmcm9tIGVuZHBvaW50IFxcYCR7dXJsfVxcYDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldENoYWluSWQoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmNoYWluSWQpO1xuICB9XG4gIGFzeW5jIGNhbGxDb250cmFjdCh7IGNvbnRyYWN0QWRkcmVzcywgZW50cnlwb2ludDogZW50cnlQb2ludFNlbGVjdG9yLCBjYWxsZGF0YSA9IFtdIH0sIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcbiAgICAgIFwiY2FsbF9jb250cmFjdFwiLFxuICAgICAgeyBibG9ja0lkZW50aWZpZXIgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETyAtIGRldGVybWluZSBiZXN0IGNob2ljZSBvbmNlIGJvdGggYXJlIGZ1bGx5IHN1cHBvcnRlZCBpbiBkZXZuZXRcbiAgICAgICAgLy8gc2lnbmF0dXJlOiBbXSxcbiAgICAgICAgLy8gc2VuZGVyX2FkZHJlc3M6IGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgY29udHJhY3RfYWRkcmVzczogY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcjogZ2V0U2VsZWN0b3JGcm9tTmFtZShlbnRyeVBvaW50U2VsZWN0b3IpLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZShjYWxsZGF0YSlcbiAgICAgIH1cbiAgICApLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUNhbGxDb250cmFjdFJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRCbG9jayhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfYmxvY2tcIiwgeyBibG9ja0lkZW50aWZpZXIgfSkudGhlbihcbiAgICAgIHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VHZXRCbG9ja1Jlc3BvbnNlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXROb25jZUZvckFkZHJlc3MoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfbm9uY2VcIiwgeyBjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciB9KTtcbiAgfVxuICBhc3luYyBnZXRTdG9yYWdlQXQoY29udHJhY3RBZGRyZXNzLCBrZXksIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgcGFyc2VkS2V5ID0gdG9CaWdJbnQoa2V5KS50b1N0cmluZygxMCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF9zdG9yYWdlX2F0XCIsIHtcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGtleTogcGFyc2VkS2V5XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24odHhIYXNoKSB7XG4gICAgY29uc3QgdHhIYXNoSGV4ID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X3RyYW5zYWN0aW9uXCIsIHsgdHJhbnNhY3Rpb25IYXNoOiB0eEhhc2hIZXggfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhyZXN1bHQpLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgdGhyb3cgbmV3IExpYnJhcnlFcnJvcihyZXN1bHQuc3RhdHVzKTtcbiAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0VHJhbnNhY3Rpb25SZXNwb25zZShyZXN1bHQpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICBjb25zdCB0eEhhc2hIZXggPSB0b0hleCh0eEhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfdHJhbnNhY3Rpb25fcmVjZWlwdFwiLCB7IHRyYW5zYWN0aW9uSGFzaDogdHhIYXNoSGV4IH0pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0VHJhbnNhY3Rpb25SZWNlaXB0UmVzcG9uc2VcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfZnVsbF9jb250cmFjdFwiLCB7IGJsb2NrSWRlbnRpZmllciwgY29udHJhY3RBZGRyZXNzIH0pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzc0hhc2hBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF9jbGFzc19oYXNoX2F0XCIsIHsgYmxvY2tJZGVudGlmaWVyLCBjb250cmFjdEFkZHJlc3MgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3NCeUhhc2goY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfY2xhc3NfYnlfaGFzaFwiLCB7IGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyIH0pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRDb21waWxlZENsYXNzQnlDbGFzc0hhc2goY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfY29tcGlsZWRfY2xhc3NfYnlfY2xhc3NfaGFzaFwiLCB7IGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyIH0pO1xuICB9XG4gIGFzeW5jIGdldENvbnRyYWN0VmVyc2lvbihjb250cmFjdEFkZHJlc3MsIGNsYXNzSGFzaCwgeyBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgY29tcGlsZXIgPSB0cnVlIH0gPSB7fSkge1xuICAgIGxldCBjb250cmFjdENsYXNzO1xuICAgIGlmIChjb250cmFjdEFkZHJlc3MpIHtcbiAgICAgIGNvbnRyYWN0Q2xhc3MgPSBhd2FpdCB0aGlzLmdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpO1xuICAgIH0gZWxzZSBpZiAoY2xhc3NIYXNoKSB7XG4gICAgICBjb250cmFjdENsYXNzID0gYXdhaXQgdGhpcy5nZXRDbGFzc0J5SGFzaChjbGFzc0hhc2gsIGJsb2NrSWRlbnRpZmllcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiZ2V0Q29udHJhY3RWZXJzaW9uIHJlcXVpcmUgY29udHJhY3RBZGRyZXNzIG9yIGNsYXNzSGFzaFwiKTtcbiAgICB9XG4gICAgaWYgKGlzU2llcnJhKGNvbnRyYWN0Q2xhc3MpKSB7XG4gICAgICBpZiAoY29tcGlsZXIpIHtcbiAgICAgICAgY29uc3QgYWJpVGVzdCA9IGdldEFiaUNvbnRyYWN0VmVyc2lvbihjb250cmFjdENsYXNzLmFiaSk7XG4gICAgICAgIHJldHVybiB7IGNhaXJvOiBcIjFcIiwgY29tcGlsZXI6IGFiaVRlc3QuY29tcGlsZXIgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGNhaXJvOiBcIjFcIiwgY29tcGlsZXI6IHZvaWQgMCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBjYWlybzogXCIwXCIsIGNvbXBpbGVyOiBcIjBcIiB9O1xuICB9XG4gIGFzeW5jIGludm9rZUZ1bmN0aW9uKGZ1bmN0aW9uSW52b2NhdGlvbiwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJhZGRfdHJhbnNhY3Rpb25cIiwgdm9pZCAwLCB7XG4gICAgICB0eXBlOiBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLyxcbiAgICAgIHNlbmRlcl9hZGRyZXNzOiBmdW5jdGlvbkludm9jYXRpb24uY29udHJhY3RBZGRyZXNzLFxuICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoZnVuY3Rpb25JbnZvY2F0aW9uLmNhbGxkYXRhID8/IFtdKSxcbiAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXkoZnVuY3Rpb25JbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSksXG4gICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgIHZlcnNpb246IFwiMHgxXCJcbiAgICB9KS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VJbnZva2VGdW5jdGlvblJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBkZXBsb3lBY2NvdW50Q29udHJhY3QoeyBjbGFzc0hhc2gsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIGFkZHJlc3NTYWx0LCBzaWduYXR1cmUgfSwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJhZGRfdHJhbnNhY3Rpb25cIiwgdm9pZCAwLCB7XG4gICAgICB0eXBlOiBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8sXG4gICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IGFkZHJlc3NTYWx0ID8/IHJhbmRvbUFkZHJlc3MoKSxcbiAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEgPz8gW10pLFxuICAgICAgY2xhc3NfaGFzaDogdG9IZXgoY2xhc3NIYXNoKSxcbiAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgdmVyc2lvbjogdG9IZXgoZGV0YWlscy52ZXJzaW9uIHx8IDApLFxuICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpLFxuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheShzaWduYXR1cmUpXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRGVwbG95Q29udHJhY3RSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZGVjbGFyZUNvbnRyYWN0KHsgc2VuZGVyQWRkcmVzcywgY29udHJhY3QsIHNpZ25hdHVyZSwgY29tcGlsZWRDbGFzc0hhc2ggfSwgZGV0YWlscykge1xuICAgIGlmICghaXNTaWVycmEoY29udHJhY3QpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiYWRkX3RyYW5zYWN0aW9uXCIsIHZvaWQgMCwge1xuICAgICAgICB0eXBlOiBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovLFxuICAgICAgICBjb250cmFjdF9jbGFzczogY29udHJhY3QsXG4gICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheShzaWduYXR1cmUpLFxuICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KHRyYW5zYWN0aW9uVmVyc2lvbilcbiAgICAgIH0pLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZURlY2xhcmVDb250cmFjdFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImFkZF90cmFuc2FjdGlvblwiLCB2b2lkIDAsIHtcbiAgICAgIHR5cGU6IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGNvbXBpbGVkQ2xhc3NIYXNoLFxuICAgICAgY29udHJhY3RfY2xhc3M6IGNvbnRyYWN0LFxuICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpLFxuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheShzaWduYXR1cmUpLFxuICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICB2ZXJzaW9uOiB0b0hleCh0cmFuc2FjdGlvblZlcnNpb25fMilcbiAgICB9KS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VEZWNsYXJlQ29udHJhY3RSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzLmdldEludm9rZUVzdGltYXRlRmVlKGludm9jYXRpb24sIGludm9jYXRpb25EZXRhaWxzLCBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSk7XG4gIH1cbiAgYXN5bmMgZ2V0SW52b2tlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uKFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLyxcbiAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgLi4uaW52b2NhdGlvbkRldGFpbHNcbiAgICAgIH0sXG4gICAgICBcImZlZVwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZXN0aW1hdGVfZmVlXCIsIHsgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgfSwgdHJhbnNhY3Rpb24pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0RGVjbGFyZUVzdGltYXRlRmVlKGludm9jYXRpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uKFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovLFxuICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9LFxuICAgICAgXCJmZWVcIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImVzdGltYXRlX2ZlZVwiLCB7IGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH0sIHRyYW5zYWN0aW9uKS50aGVuKFxuICAgICAgdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlUmVzcG9uc2VcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldERlcGxveUFjY291bnRFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBkZXRhaWxzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gZmFsc2UpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovLFxuICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9LFxuICAgICAgXCJmZWVcIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImVzdGltYXRlX2ZlZVwiLCB7IGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH0sIHRyYW5zYWN0aW9uKS50aGVuKFxuICAgICAgdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlUmVzcG9uc2VcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlQnVsayhpbnZvY2F0aW9ucywgeyBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gZmFsc2UgfSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IGludm9jYXRpb25zLm1hcCgoaXQpID0+IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihpdCwgXCJmZWVcIikpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXG4gICAgICBcImVzdGltYXRlX2ZlZV9idWxrXCIsXG4gICAgICB7IGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH0sXG4gICAgICB0cmFuc2FjdGlvbnNcbiAgICApLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlQnVsa1Jlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRDb2RlKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X2NvZGVcIiwgeyBjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciB9KTtcbiAgfVxuICBhc3luYyB3YWl0Rm9yVHJhbnNhY3Rpb24odHhIYXNoLCBvcHRpb25zKSB7XG4gICAgbGV0IHJlcztcbiAgICBsZXQgY29tcGxldGVkID0gZmFsc2U7XG4gICAgbGV0IHJldHJpZXMgPSAwO1xuICAgIGNvbnN0IHJldHJ5SW50ZXJ2YWwgPSBvcHRpb25zPy5yZXRyeUludGVydmFsID8/IDVlMztcbiAgICBjb25zdCBlcnJvclN0YXRlcyA9IG9wdGlvbnM/LmVycm9yU3RhdGVzID8/IFtcbiAgICAgIFwiUkVKRUNURURcIiAvKiBSRUpFQ1RFRCAqLyxcbiAgICAgIFwiTk9UX1JFQ0VJVkVEXCIgLyogTk9UX1JFQ0VJVkVEICovLFxuICAgICAgXCJSRVZFUlRFRFwiIC8qIFJFVkVSVEVEICovXG4gICAgXTtcbiAgICBjb25zdCBzdWNjZXNzU3RhdGVzID0gb3B0aW9ucz8uc3VjY2Vzc1N0YXRlcyA/PyBbXG4gICAgICBcIlNVQ0NFRURFRFwiIC8qIFNVQ0NFRURFRCAqLyxcbiAgICAgIFwiQUNDRVBURURfT05fTDFcIiAvKiBBQ0NFUFRFRF9PTl9MMSAqLyxcbiAgICAgIFwiQUNDRVBURURfT05fTDJcIiAvKiBBQ0NFUFRFRF9PTl9MMiAqL1xuICAgIF07XG4gICAgd2hpbGUgKCFjb21wbGV0ZWQpIHtcbiAgICAgIGF3YWl0IHdhaXQocmV0cnlJbnRlcnZhbCk7XG4gICAgICByZXMgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uU3RhdHVzKHR4SGFzaCk7XG4gICAgICBpZiAoXCJOT1RfUkVDRUlWRURcIiAvKiBOT1RfUkVDRUlWRUQgKi8gPT09IHJlcy5maW5hbGl0eV9zdGF0dXMgJiYgcmV0cmllcyA8IDMpIHtcbiAgICAgICAgcmV0cmllcyArPSAxO1xuICAgICAgfSBlbHNlIGlmIChzdWNjZXNzU3RhdGVzLmluY2x1ZGVzKHJlcy5maW5hbGl0eV9zdGF0dXMpIHx8IHN1Y2Nlc3NTdGF0ZXMuaW5jbHVkZXMocmVzLmV4ZWN1dGlvbl9zdGF0dXMpKSB7XG4gICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yU3RhdGVzLmluY2x1ZGVzKHJlcy5maW5hbGl0eV9zdGF0dXMpIHx8IGVycm9yU3RhdGVzLmluY2x1ZGVzKHJlcy5leGVjdXRpb25fc3RhdHVzKSkge1xuICAgICAgICBsZXQgbWVzc2FnZTtcbiAgICAgICAgaWYgKHJlcy50eF9mYWlsdXJlX3JlYXNvbikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBgJHtyZXMudHhfc3RhdHVzfTogJHtyZXMudHhfZmFpbHVyZV9yZWFzb24uY29kZX1cbiR7cmVzLnR4X2ZhaWx1cmVfcmVhc29uLmVycm9yX21lc3NhZ2V9YDtcbiAgICAgICAgfSBlbHNlIGlmIChyZXMudHhfcmV2ZXJ0X3JlYXNvbikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBgJHtyZXMudHhfc3RhdHVzfTogJHtyZXMudHhfcmV2ZXJ0X3JlYXNvbn1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lc3NhZ2UgPSByZXMudHhfc3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5yZXNwb25zZSA9IHJlcztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHR4UmVjZWlwdCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCk7XG4gICAgcmV0dXJuIHR4UmVjZWlwdDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgc3RhdHVzIG9mIGEgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB0eEhhc2ggQmlnTnVtYmVyaXNoXG4gICAqIEByZXR1cm5zIEdldFRyYW5zYWN0aW9uU3RhdHVzUmVzcG9uc2UgLSB0aGUgdHJhbnNhY3Rpb24gc3RhdHVzIG9iamVjdFxuICAgKi9cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25TdGF0dXModHhIYXNoKSB7XG4gICAgY29uc3QgdHhIYXNoSGV4ID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X3RyYW5zYWN0aW9uX3N0YXR1c1wiLCB7IHRyYW5zYWN0aW9uSGFzaDogdHhIYXNoSGV4IH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzbWFydCBjb250cmFjdCBhZGRyZXNzIG9uIHRoZSBnb2VybGkgdGVzdG5ldC5cbiAgICogQHJldHVybnMgR2V0Q29udHJhY3RBZGRyZXNzZXNSZXNwb25zZSAtIHN0YXJrbmV0IHNtYXJ0IGNvbnRyYWN0IGFkZHJlc3Nlc1xuICAgKi9cbiAgYXN5bmMgZ2V0Q29udHJhY3RBZGRyZXNzZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF9jb250cmFjdF9hZGRyZXNzZXNcIik7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRyYW5zYWN0aW9uIHRyYWNlIGZyb20gYSB0eCBpZC5cbiAgICogQHBhcmFtIHR4SGFzaCBCaWdOdW1iZXJpc2hcbiAgICogQHJldHVybnMgVHJhbnNhY3Rpb25UcmFjZVJlc3BvbnNlIC0gdGhlIHRyYW5zYWN0aW9uIHRyYWNlXG4gICAqL1xuICBhc3luYyBnZXRUcmFuc2FjdGlvblRyYWNlKHR4SGFzaCkge1xuICAgIGNvbnN0IHR4SGFzaEhleCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF90cmFuc2FjdGlvbl90cmFjZVwiLCB7IHRyYW5zYWN0aW9uSGFzaDogdHhIYXNoSGV4IH0pO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlTWVzc2FnZUZlZSh7IGZyb21fYWRkcmVzcywgdG9fYWRkcmVzcywgZW50cnlfcG9pbnRfc2VsZWN0b3IsIHBheWxvYWQgfSwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCB2YWxpZENhbGxMMUhhbmRsZXIgPSB7XG4gICAgICBmcm9tX2FkZHJlc3M6IGdldERlY2ltYWxTdHJpbmcoZnJvbV9hZGRyZXNzKSxcbiAgICAgIHRvX2FkZHJlc3M6IGdldEhleFN0cmluZyh0b19hZGRyZXNzKSxcbiAgICAgIGVudHJ5X3BvaW50X3NlbGVjdG9yOiBnZXRTZWxlY3RvcihlbnRyeV9wb2ludF9zZWxlY3RvciksXG4gICAgICBwYXlsb2FkOiBnZXRIZXhTdHJpbmdBcnJheShwYXlsb2FkKVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImVzdGltYXRlX21lc3NhZ2VfZmVlXCIsIHsgYmxvY2tJZGVudGlmaWVyIH0sIHZhbGlkQ2FsbEwxSGFuZGxlcik7XG4gIH1cbiAgLyoqXG4gICAqIFNpbXVsYXRlIHRyYW5zYWN0aW9uIHVzaW5nIFNlcXVlbmNlciBwcm92aWRlclxuICAgKiBXQVJOSU5HITogU2VxdWVuY2VyIHdpbGwgcHJvY2VzcyBvbmx5IGZpcnN0IGVsZW1lbnQgZnJvbSBpbnZvY2F0aW9ucyBhcnJheVxuICAgKlxuICAgKiBAcGFyYW0gaW52b2NhdGlvbnMgQXJyYXkgb2YgaW52b2NhdGlvbnMsIGJ1dCBvbmx5IGZpcnN0IGludm9jYXRpb24gd2lsbCBiZSBwcm9jZXNzZWRcbiAgICogQHBhcmFtIGJsb2NrSWRlbnRpZmllciBibG9jayBpZGVudGlmaWVyLCBkZWZhdWx0ICdsYXRlc3QnXG4gICAqIEBwYXJhbSBza2lwVmFsaWRhdGUgU2tpcCBBY2NvdW50IF9fdmFsaWRhdGVfXyBtZXRob2RcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGdldFNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIHtcbiAgICBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcixcbiAgICBza2lwVmFsaWRhdGUgPSBmYWxzZSxcbiAgICBza2lwRXhlY3V0ZSA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAoaW52b2NhdGlvbnMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc29sZS53YXJuKFwiU2VxdWVuY2VyIHNpbXVsYXRlIHByb2Nlc3Mgb25seSBmaXJzdCBlbGVtZW50IGZyb20gaW52b2NhdGlvbnMgbGlzdFwiKTtcbiAgICB9XG4gICAgaWYgKHNraXBFeGVjdXRlKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJTZXF1ZW5jZXIgY2FuJ3Qgc2tpcCBhY2NvdW50IF9fZXhlY3V0ZV9fXCIpO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihpbnZvY2F0aW9uc1swXSk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcbiAgICAgIFwic2ltdWxhdGVfdHJhbnNhY3Rpb25cIixcbiAgICAgIHtcbiAgICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgICBza2lwVmFsaWRhdGU6IHNraXBWYWxpZGF0ZSA/PyBmYWxzZVxuICAgICAgfSxcbiAgICAgIHRyYW5zYWN0aW9uXG4gICAgKS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VTaW11bGF0ZVRyYW5zYWN0aW9uUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldFN0YXRlVXBkYXRlKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYXJncyA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLnNlcXVlbmNlcklkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF9zdGF0ZV91cGRhdGVcIiwgeyAuLi5hcmdzIH0pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0U3RhdGVVcGRhdGVSZXNwb25zZVxuICAgICk7XG4gIH1cbiAgLy8gY29uc2lkZXIgYWRkaW5nIGFuIG9wdGlvbmFsIHRyYWNlIHJldHJpZXZhbCBwYXJhbWV0ZXIgdG8gdGhlIGdldEJsb2NrIG1ldGhvZFxuICBhc3luYyBnZXRCbG9ja1RyYWNlcyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGFyZ3MgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5zZXF1ZW5jZXJJZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfYmxvY2tfdHJhY2VzXCIsIHsgLi4uYXJncyB9KTtcbiAgfVxuICBhc3luYyBnZXRTdGFya05hbWUoYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBnZXRTdGFya05hbWUodGhpcywgYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mik7XG4gIH1cbiAgYXN5bmMgZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUobmFtZSwgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBnZXRBZGRyZXNzRnJvbVN0YXJrTmFtZSh0aGlzLCBuYW1lLCBTdGFya25ldElkQ29udHJhY3QyKTtcbiAgfVxuICAvKipcbiAgICogQnVpbGQgU2luZ2xlIEFjY291bnRUcmFuc2FjdGlvbiBmcm9tIFNpbmdsZSBBY2NvdW50SW52b2NhdGlvblxuICAgKiBAcGFyYW0gaW52b2NhdGlvbiBBY2NvdW50SW52b2NhdGlvbkl0ZW1cbiAgICogQHBhcmFtIHZlcnNpb25UeXBlICdmZWUnIHwgJ3RyYW5zYWN0aW9uJyAtIHVzZWQgdG8gZGV0ZXJtaW5lIGRlZmF1bHQgdmVyc2lvbnNcbiAgICogQHJldHVybnMgQWNjb3VudFRyYW5zYWN0aW9uSXRlbVxuICAgKi9cbiAgYnVpbGRUcmFuc2FjdGlvbihpbnZvY2F0aW9uLCB2ZXJzaW9uVHlwZSkge1xuICAgIGNvbnN0IGRlZmF1bHRWZXJzaW9ucyA9IGdldFZlcnNpb25zQnlUeXBlKHZlcnNpb25UeXBlKTtcbiAgICBjb25zdCBkZXRhaWxzID0ge1xuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheShpbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICBub25jZTogdG9IZXgoaW52b2NhdGlvbi5ub25jZSlcbiAgICB9O1xuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoaW52b2NhdGlvbi5jYWxsZGF0YSA/PyBbXSksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjEpLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovKSB7XG4gICAgICBpZiAoIWlzU2llcnJhKGludm9jYXRpb24uY29udHJhY3QpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICAgIGNvbnRyYWN0X2NsYXNzOiBpbnZvY2F0aW9uLmNvbnRyYWN0LFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLnNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MSksXG4gICAgICAgICAgLy8gZmVlIGZyb20gZ2V0RGVjbGFyZUVzdGltYXRlRmVlIHVzZSB0LnYuIGluc3RlYWQgb2YgZmVldC52LlxuICAgICAgICAgIC4uLmRldGFpbHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29udHJhY3RfY2xhc3M6IGludm9jYXRpb24uY29udHJhY3QsXG4gICAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGludm9jYXRpb24uY29tcGlsZWRDbGFzc0hhc2gsXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLnNlbmRlckFkZHJlc3MsXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjIpLFxuICAgICAgICAvLyBmZWUgb24gZ2V0RGVjbGFyZUVzdGltYXRlRmVlIHVzZSB0LnYuIGluc3RlYWQgb2YgZmVldC52LlxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29uc3RydWN0b3JfY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoaW52b2NhdGlvbi5jb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgY2xhc3NfaGFzaDogdG9IZXgoaW52b2NhdGlvbi5jbGFzc0hhc2gpLFxuICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGludm9jYXRpb24uYWRkcmVzc1NhbHQgfHwgMCksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjEpLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIlNlcXVlbmNlciBidWlsZFRyYW5zYWN0aW9uIHJlY2VpdmVkIHVua25vd24gVHJhbnNhY3Rpb25UeXBlXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvZGVmYXVsdC50c1xudmFyIFByb3ZpZGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihwcm92aWRlck9yT3B0aW9ucykge1xuICAgIGlmIChwcm92aWRlck9yT3B0aW9ucyBpbnN0YW5jZW9mIFByb3ZpZGVyKSB7XG4gICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXJPck9wdGlvbnMucHJvdmlkZXI7XG4gICAgfSBlbHNlIGlmIChwcm92aWRlck9yT3B0aW9ucyBpbnN0YW5jZW9mIFJwY1Byb3ZpZGVyIHx8IHByb3ZpZGVyT3JPcHRpb25zIGluc3RhbmNlb2YgU2VxdWVuY2VyUHJvdmlkZXIpIHtcbiAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlck9yT3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKHByb3ZpZGVyT3JPcHRpb25zICYmIFwicnBjXCIgaW4gcHJvdmlkZXJPck9wdGlvbnMpIHtcbiAgICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgUnBjUHJvdmlkZXIocHJvdmlkZXJPck9wdGlvbnMucnBjKTtcbiAgICB9IGVsc2UgaWYgKHByb3ZpZGVyT3JPcHRpb25zICYmIFwic2VxdWVuY2VyXCIgaW4gcHJvdmlkZXJPck9wdGlvbnMpIHtcbiAgICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgU2VxdWVuY2VyUHJvdmlkZXIocHJvdmlkZXJPck9wdGlvbnMuc2VxdWVuY2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm92aWRlciA9IG5ldyBScGNQcm92aWRlcigpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldENoYWluSWQoKTtcbiAgfVxuICBhc3luYyBnZXRCbG9jayhibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRCbG9jayhibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzc0hhc2hBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldENsYXNzSGFzaEF0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBnZXRDbGFzc0J5SGFzaChjbGFzc0hhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRDbGFzc0J5SGFzaChjbGFzc0hhc2gpO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlKGludm9jYXRpb25XaXRoVHhUeXBlLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbldpdGhUeFR5cGUsIGludm9jYXRpb25EZXRhaWxzLCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldEludm9rZUVzdGltYXRlRmVlKGludm9jYXRpb25XaXRoVHhUeXBlLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRJbnZva2VFc3RpbWF0ZUZlZShcbiAgICAgIGludm9jYXRpb25XaXRoVHhUeXBlLFxuICAgICAgaW52b2NhdGlvbkRldGFpbHMsXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGVcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlQnVsayhpbnZvY2F0aW9ucywgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldEVzdGltYXRlRmVlQnVsayhpbnZvY2F0aW9ucywgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2VGb3JBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0Tm9uY2VGb3JBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRTdG9yYWdlQXQoY29udHJhY3RBZGRyZXNzLCBrZXksIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldFN0b3JhZ2VBdChjb250cmFjdEFkZHJlc3MsIGtleSwgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvbih0eEhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0eEhhc2gpO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgfVxuICBhc3luYyBjYWxsQ29udHJhY3QocmVxdWVzdCwgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuY2FsbENvbnRyYWN0KHJlcXVlc3QsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgaW52b2tlRnVuY3Rpb24oZnVuY3Rpb25JbnZvY2F0aW9uLCBkZXRhaWxzKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuaW52b2tlRnVuY3Rpb24oZnVuY3Rpb25JbnZvY2F0aW9uLCBkZXRhaWxzKTtcbiAgfVxuICBhc3luYyBkZXBsb3lBY2NvdW50Q29udHJhY3QocGF5bG9hZCwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmRlcGxveUFjY291bnRDb250cmFjdChwYXlsb2FkLCBkZXRhaWxzKTtcbiAgfVxuICBhc3luYyBkZWNsYXJlQ29udHJhY3QodHJhbnNhY3Rpb24sIGRldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5kZWNsYXJlQ29udHJhY3QodHJhbnNhY3Rpb24sIGRldGFpbHMpO1xuICB9XG4gIGFzeW5jIGdldERlY2xhcmVFc3RpbWF0ZUZlZSh0cmFuc2FjdGlvbiwgZGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXREZWNsYXJlRXN0aW1hdGVGZWUodHJhbnNhY3Rpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKTtcbiAgfVxuICBnZXREZXBsb3lBY2NvdW50RXN0aW1hdGVGZWUodHJhbnNhY3Rpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0RGVwbG95QWNjb3VudEVzdGltYXRlRmVlKFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICBkZXRhaWxzLFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRDb2RlKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0Q29kZShjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKHR4SGFzaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvbih0eEhhc2gsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGdldFNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRTaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBnZXRTdGF0ZVVwZGF0ZShibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRTdGF0ZVVwZGF0ZShibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldFN0YXJrTmFtZShhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgcmV0dXJuIGdldFN0YXJrTmFtZSh0aGlzLCBhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKTtcbiAgfVxuICBhc3luYyBnZXRBZGRyZXNzRnJvbVN0YXJrTmFtZShuYW1lLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgcmV0dXJuIGdldEFkZHJlc3NGcm9tU3RhcmtOYW1lKHRoaXMsIG5hbWUsIFN0YXJrbmV0SWRDb250cmFjdDIpO1xuICB9XG4gIGFzeW5jIGdldENvbnRyYWN0VmVyc2lvbihjb250cmFjdEFkZHJlc3MsIGNsYXNzSGFzaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldENvbnRyYWN0VmVyc2lvbihjb250cmFjdEFkZHJlc3MsIGNsYXNzSGFzaCwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXIvaW50ZXJmYWNlLnRzXG52YXIgU2lnbmVySW50ZXJmYWNlID0gY2xhc3Mge1xufTtcblxuLy8gc3JjL3V0aWxzL3RyYW5zYWN0aW9uLnRzXG52YXIgdHJhbnNhY3Rpb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHJhbnNhY3Rpb25fZXhwb3J0cywge1xuICBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YTogKCkgPT4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEsXG4gIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhV2l0aE5vbmNlOiAoKSA9PiBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZSxcbiAgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xOiAoKSA9PiBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YV9jYWlybzEsXG4gIGdldEV4ZWN1dGVDYWxsZGF0YTogKCkgPT4gZ2V0RXhlY3V0ZUNhbGxkYXRhLFxuICB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzOiAoKSA9PiB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzLFxuICB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzX2NhaXJvMTogKCkgPT4gdHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5c19jYWlybzFcbn0pO1xudmFyIHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXMgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgY2FsbEFycmF5ID0gW107XG4gIGNvbnN0IGNhbGxkYXRhID0gW107XG4gIGNhbGxzLmZvckVhY2goKGNhbGwpID0+IHtcbiAgICBjb25zdCBkYXRhID0gQ2FsbERhdGEuY29tcGlsZShjYWxsLmNhbGxkYXRhIHx8IFtdKTtcbiAgICBjYWxsQXJyYXkucHVzaCh7XG4gICAgICB0bzogdG9CaWdJbnQoY2FsbC5jb250cmFjdEFkZHJlc3MpLnRvU3RyaW5nKDEwKSxcbiAgICAgIHNlbGVjdG9yOiB0b0JpZ0ludChnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCkpLnRvU3RyaW5nKDEwKSxcbiAgICAgIGRhdGFfb2Zmc2V0OiBjYWxsZGF0YS5sZW5ndGgudG9TdHJpbmcoKSxcbiAgICAgIGRhdGFfbGVuOiBkYXRhLmxlbmd0aC50b1N0cmluZygpXG4gICAgfSk7XG4gICAgY2FsbGRhdGEucHVzaCguLi5kYXRhKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2FsbEFycmF5LFxuICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHsgY2FsbGRhdGEgfSlcbiAgfTtcbn07XG52YXIgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgeyBjYWxsQXJyYXksIGNhbGxkYXRhIH0gPSB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzKGNhbGxzKTtcbiAgY29uc3QgY29tcGlsZWRDYWxscyA9IENhbGxEYXRhLmNvbXBpbGUoeyBjYWxsQXJyYXkgfSk7XG4gIHJldHVybiBbLi4uY29tcGlsZWRDYWxscywgLi4uY2FsbGRhdGFdO1xufTtcbnZhciBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZSA9IChjYWxscywgbm9uY2UpID0+IHtcbiAgcmV0dXJuIFsuLi5mcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YShjYWxscyksIHRvQmlnSW50KG5vbmNlKS50b1N0cmluZygpXTtcbn07XG52YXIgdHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5c19jYWlybzEgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgY2FsbEFycmF5ID0gY2FsbHMubWFwKChjYWxsKSA9PiAoe1xuICAgIHRvOiB0b0JpZ0ludChjYWxsLmNvbnRyYWN0QWRkcmVzcykudG9TdHJpbmcoMTApLFxuICAgIHNlbGVjdG9yOiB0b0JpZ0ludChnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCkpLnRvU3RyaW5nKDEwKSxcbiAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZShjYWxsLmNhbGxkYXRhIHx8IFtdKVxuICB9KSk7XG4gIHJldHVybiBjYWxsQXJyYXk7XG59O1xudmFyIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMSA9IChjYWxscykgPT4ge1xuICBjb25zdCBvcmRlckNhbGxzID0gY2FsbHMubWFwKChjYWxsKSA9PiAoe1xuICAgIGNvbnRyYWN0QWRkcmVzczogY2FsbC5jb250cmFjdEFkZHJlc3MsXG4gICAgZW50cnlwb2ludDogY2FsbC5lbnRyeXBvaW50LFxuICAgIGNhbGxkYXRhOiBBcnJheS5pc0FycmF5KGNhbGwuY2FsbGRhdGEpICYmIFwiX19jb21waWxlZF9fXCIgaW4gY2FsbC5jYWxsZGF0YSA/IGNhbGwuY2FsbGRhdGEgOiBDYWxsRGF0YS5jb21waWxlKGNhbGwuY2FsbGRhdGEpXG4gICAgLy8gUmF3QXJnc09iamVjdCB8IFJhd0FyZ3NBcnJheSB0eXBlXG4gIH0pKTtcbiAgcmV0dXJuIENhbGxEYXRhLmNvbXBpbGUoeyBvcmRlckNhbGxzIH0pO1xufTtcbnZhciBnZXRFeGVjdXRlQ2FsbGRhdGEgPSAoY2FsbHMsIGNhaXJvVmVyc2lvbiA9IFwiMFwiKSA9PiB7XG4gIGlmIChjYWlyb1ZlcnNpb24gPT09IFwiMVwiKSB7XG4gICAgcmV0dXJuIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMShjYWxscyk7XG4gIH1cbiAgcmV0dXJuIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhKGNhbGxzKTtcbn07XG5cbi8vIHNyYy91dGlscy90eXBlZERhdGEudHNcbnZhciB0eXBlZERhdGFfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHlwZWREYXRhX2V4cG9ydHMsIHtcbiAgZW5jb2RlRGF0YTogKCkgPT4gZW5jb2RlRGF0YSxcbiAgZW5jb2RlVHlwZTogKCkgPT4gZW5jb2RlVHlwZSxcbiAgZW5jb2RlVmFsdWU6ICgpID0+IGVuY29kZVZhbHVlLFxuICBnZXREZXBlbmRlbmNpZXM6ICgpID0+IGdldERlcGVuZGVuY2llcyxcbiAgZ2V0TWVzc2FnZUhhc2g6ICgpID0+IGdldE1lc3NhZ2VIYXNoLFxuICBnZXRTdHJ1Y3RIYXNoOiAoKSA9PiBnZXRTdHJ1Y3RIYXNoLFxuICBnZXRUeXBlSGFzaDogKCkgPT4gZ2V0VHlwZUhhc2gsXG4gIGlzTWVya2xlVHJlZVR5cGU6ICgpID0+IGlzTWVya2xlVHJlZVR5cGUsXG4gIHByZXBhcmVTZWxlY3RvcjogKCkgPT4gcHJlcGFyZVNlbGVjdG9yXG59KTtcblxuLy8gc3JjL3V0aWxzL21lcmtsZS50c1xudmFyIG1lcmtsZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChtZXJrbGVfZXhwb3J0cywge1xuICBNZXJrbGVUcmVlOiAoKSA9PiBNZXJrbGVUcmVlLFxuICBwcm9vZk1lcmtsZVBhdGg6ICgpID0+IHByb29mTWVya2xlUGF0aFxufSk7XG52YXIgTWVya2xlVHJlZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobGVhZkhhc2hlcykge1xuICAgIHRoaXMuYnJhbmNoZXMgPSBbXTtcbiAgICB0aGlzLmxlYXZlcyA9IGxlYWZIYXNoZXM7XG4gICAgdGhpcy5yb290ID0gdGhpcy5idWlsZChsZWFmSGFzaGVzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIE1lcmtsZSB0cmVlXG4gICAqIEBwYXJhbSBsZWF2ZXMgaGV4LXN0cmluZyBhcnJheVxuICAgKiBAcmV0dXJucyBmb3JtYXQ6IGhleC1zdHJpbmc7IE1lcmtsZSB0cmVlIHJvb3RcbiAgICovXG4gIGJ1aWxkKGxlYXZlcykge1xuICAgIGlmIChsZWF2ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gbGVhdmVzWzBdO1xuICAgIH1cbiAgICBpZiAobGVhdmVzLmxlbmd0aCAhPT0gdGhpcy5sZWF2ZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmJyYW5jaGVzLnB1c2gobGVhdmVzKTtcbiAgICB9XG4gICAgY29uc3QgbmV3TGVhdmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWF2ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGlmIChpICsgMSA9PT0gbGVhdmVzLmxlbmd0aCkge1xuICAgICAgICBuZXdMZWF2ZXMucHVzaChNZXJrbGVUcmVlLmhhc2gobGVhdmVzW2ldLCBcIjB4MFwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdMZWF2ZXMucHVzaChNZXJrbGVUcmVlLmhhc2gobGVhdmVzW2ldLCBsZWF2ZXNbaSArIDFdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJ1aWxkKG5ld0xlYXZlcyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBwZWRlcnNlbiBoYXNoIGZyb20gYSBhbmQgYlxuICAgKiBAcmV0dXJucyBmb3JtYXQ6IGhleC1zdHJpbmdcbiAgICovXG4gIHN0YXRpYyBoYXNoKGEsIGIpIHtcbiAgICBjb25zdCBbYVNvcnRlZCwgYlNvcnRlZF0gPSBbdG9CaWdJbnQoYSksIHRvQmlnSW50KGIpXS5zb3J0KCh4LCB5KSA9PiB4ID49IHkgPyAxIDogLTEpO1xuICAgIHJldHVybiBzdGFya0N1cnZlLnBlZGVyc2VuKGFTb3J0ZWQsIGJTb3J0ZWQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gcGF0aCB0byBsZWFmXG4gICAqIEBwYXJhbSBsZWFmIGhleC1zdHJpbmdcbiAgICogQHBhcmFtIGJyYW5jaCBoZXgtc3RyaW5nIGFycmF5XG4gICAqIEBwYXJhbSBoYXNoUGF0aCBoZXgtc3RyaW5nIGFycmF5XG4gICAqIEByZXR1cm5zIGZvcm1hdDogaGV4LXN0cmluZyBhcnJheVxuICAgKi9cbiAgZ2V0UHJvb2YobGVhZiwgYnJhbmNoID0gdGhpcy5sZWF2ZXMsIGhhc2hQYXRoID0gW10pIHtcbiAgICBjb25zdCBpbmRleCA9IGJyYW5jaC5pbmRleE9mKGxlYWYpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImxlYWYgbm90IGZvdW5kXCIpO1xuICAgIH1cbiAgICBpZiAoYnJhbmNoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGhhc2hQYXRoO1xuICAgIH1cbiAgICBjb25zdCBpc0xlZnQgPSBpbmRleCAlIDIgPT09IDA7XG4gICAgY29uc3QgbmVlZGVkQnJhbmNoID0gKGlzTGVmdCA/IGJyYW5jaFtpbmRleCArIDFdIDogYnJhbmNoW2luZGV4IC0gMV0pID8/IFwiMHgwXCI7XG4gICAgY29uc3QgbmV3SGFzaFBhdGggPSBbLi4uaGFzaFBhdGgsIG5lZWRlZEJyYW5jaF07XG4gICAgY29uc3QgY3VycmVudEJyYW5jaExldmVsSW5kZXggPSB0aGlzLmxlYXZlcy5sZW5ndGggPT09IGJyYW5jaC5sZW5ndGggPyAtMSA6IHRoaXMuYnJhbmNoZXMuZmluZEluZGV4KChiKSA9PiBiLmxlbmd0aCA9PT0gYnJhbmNoLmxlbmd0aCk7XG4gICAgY29uc3QgbmV4dEJyYW5jaCA9IHRoaXMuYnJhbmNoZXNbY3VycmVudEJyYW5jaExldmVsSW5kZXggKyAxXSA/PyBbdGhpcy5yb290XTtcbiAgICByZXR1cm4gdGhpcy5nZXRQcm9vZihcbiAgICAgIE1lcmtsZVRyZWUuaGFzaChpc0xlZnQgPyBsZWFmIDogbmVlZGVkQnJhbmNoLCBpc0xlZnQgPyBuZWVkZWRCcmFuY2ggOiBsZWFmKSxcbiAgICAgIG5leHRCcmFuY2gsXG4gICAgICBuZXdIYXNoUGF0aFxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBwcm9vZk1lcmtsZVBhdGgocm9vdCwgbGVhZiwgcGF0aCkge1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gcm9vdCA9PT0gbGVhZjtcbiAgfVxuICBjb25zdCBbbmV4dCwgLi4ucmVzdF0gPSBwYXRoO1xuICByZXR1cm4gcHJvb2ZNZXJrbGVQYXRoKHJvb3QsIE1lcmtsZVRyZWUuaGFzaChsZWFmLCBuZXh0KSwgcmVzdCk7XG59XG5cbi8vIHNyYy91dGlscy90eXBlZERhdGEudHNcbmZ1bmN0aW9uIGdldEhleCh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0b0hleCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdG9IZXgoZW5jb2RlU2hvcnRTdHJpbmcodmFsdWUpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEJpZ051bWJlcmlzaDogJHt2YWx1ZX1gKTtcbiAgfVxufVxudmFyIHZhbGlkYXRlVHlwZWREYXRhID0gKGRhdGEpID0+IHtcbiAgY29uc3QgdHlwZWREYXRhID0gZGF0YTtcbiAgY29uc3QgdmFsaWQgPSBCb29sZWFuKHR5cGVkRGF0YS50eXBlcyAmJiB0eXBlZERhdGEucHJpbWFyeVR5cGUgJiYgdHlwZWREYXRhLm1lc3NhZ2UpO1xuICByZXR1cm4gdmFsaWQ7XG59O1xuZnVuY3Rpb24gcHJlcGFyZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIHJldHVybiBpc0hleChzZWxlY3RvcikgPyBzZWxlY3RvciA6IGdldFNlbGVjdG9yRnJvbU5hbWUoc2VsZWN0b3IpO1xufVxuZnVuY3Rpb24gaXNNZXJrbGVUcmVlVHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLnR5cGUgPT09IFwibWVya2xldHJlZVwiO1xufVxudmFyIGdldERlcGVuZGVuY2llcyA9ICh0eXBlcywgdHlwZSwgZGVwZW5kZW5jaWVzID0gW10pID0+IHtcbiAgaWYgKHR5cGVbdHlwZS5sZW5ndGggLSAxXSA9PT0gXCIqXCIpIHtcbiAgICB0eXBlID0gdHlwZS5zbGljZSgwLCAtMSk7XG4gIH1cbiAgaWYgKGRlcGVuZGVuY2llcy5pbmNsdWRlcyh0eXBlKSkge1xuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cbiAgaWYgKCF0eXBlc1t0eXBlXSkge1xuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cbiAgcmV0dXJuIFtcbiAgICB0eXBlLFxuICAgIC4uLnR5cGVzW3R5cGVdLnJlZHVjZShcbiAgICAgIChwcmV2aW91cywgdCkgPT4gW1xuICAgICAgICAuLi5wcmV2aW91cyxcbiAgICAgICAgLi4uZ2V0RGVwZW5kZW5jaWVzKHR5cGVzLCB0LnR5cGUsIHByZXZpb3VzKS5maWx0ZXIoXG4gICAgICAgICAgKGRlcGVuZGVuY3kpID0+ICFwcmV2aW91cy5pbmNsdWRlcyhkZXBlbmRlbmN5KVxuICAgICAgICApXG4gICAgICBdLFxuICAgICAgW11cbiAgICApXG4gIF07XG59O1xuZnVuY3Rpb24gZ2V0TWVya2xlVHJlZVR5cGUodHlwZXMsIGN0eCkge1xuICBpZiAoY3R4LnBhcmVudCAmJiBjdHgua2V5KSB7XG4gICAgY29uc3QgcGFyZW50VHlwZSA9IHR5cGVzW2N0eC5wYXJlbnRdO1xuICAgIGNvbnN0IG1lcmtsZVR5cGUgPSBwYXJlbnRUeXBlLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gY3R4LmtleSk7XG4gICAgY29uc3QgaXNNZXJrbGVUcmVlID0gaXNNZXJrbGVUcmVlVHlwZShtZXJrbGVUeXBlKTtcbiAgICBpZiAoIWlzTWVya2xlVHJlZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2N0eC5rZXl9IGlzIG5vdCBhIG1lcmtsZSB0cmVlYCk7XG4gICAgfVxuICAgIGlmIChtZXJrbGVUeXBlLmNvbnRhaW5zLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXJrbGUgdHJlZSBjb250YWluIHByb3BlcnR5IG11c3Qgbm90IGJlIGFuIGFycmF5IGJ1dCB3YXMgZ2l2ZW4gJHtjdHgua2V5fWApO1xuICAgIH1cbiAgICByZXR1cm4gbWVya2xlVHlwZS5jb250YWlucztcbiAgfVxuICByZXR1cm4gXCJyYXdcIjtcbn1cbnZhciBlbmNvZGVUeXBlID0gKHR5cGVzLCB0eXBlKSA9PiB7XG4gIGNvbnN0IFtwcmltYXJ5LCAuLi5kZXBlbmRlbmNpZXNdID0gZ2V0RGVwZW5kZW5jaWVzKHR5cGVzLCB0eXBlKTtcbiAgY29uc3QgbmV3VHlwZXMgPSAhcHJpbWFyeSA/IFtdIDogW3ByaW1hcnksIC4uLmRlcGVuZGVuY2llcy5zb3J0KCldO1xuICByZXR1cm4gbmV3VHlwZXMubWFwKChkZXBlbmRlbmN5KSA9PiB7XG4gICAgcmV0dXJuIGAke2RlcGVuZGVuY3l9KCR7dHlwZXNbZGVwZW5kZW5jeV0ubWFwKCh0KSA9PiBgJHt0Lm5hbWV9OiR7dC50eXBlfWApfSlgO1xuICB9KS5qb2luKFwiXCIpO1xufTtcbnZhciBnZXRUeXBlSGFzaCA9ICh0eXBlcywgdHlwZSkgPT4ge1xuICByZXR1cm4gZ2V0U2VsZWN0b3JGcm9tTmFtZShlbmNvZGVUeXBlKHR5cGVzLCB0eXBlKSk7XG59O1xudmFyIGVuY29kZVZhbHVlID0gKHR5cGVzLCB0eXBlLCBkYXRhLCBjdHggPSB7fSkgPT4ge1xuICBpZiAodHlwZXNbdHlwZV0pIHtcbiAgICByZXR1cm4gW3R5cGUsIGdldFN0cnVjdEhhc2godHlwZXMsIHR5cGUsIGRhdGEpXTtcbiAgfVxuICBpZiAoT2JqZWN0LmtleXModHlwZXMpLm1hcCgoeCkgPT4gYCR7eH0qYCkuaW5jbHVkZXModHlwZSkpIHtcbiAgICBjb25zdCBzdHJ1Y3RIYXNoZXMgPSBkYXRhLm1hcCgoc3RydWN0KSA9PiB7XG4gICAgICByZXR1cm4gZ2V0U3RydWN0SGFzaCh0eXBlcywgdHlwZS5zbGljZSgwLCAtMSksIHN0cnVjdCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFt0eXBlLCBjb21wdXRlSGFzaE9uRWxlbWVudHMoc3RydWN0SGFzaGVzKV07XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwibWVya2xldHJlZVwiKSB7XG4gICAgY29uc3QgbWVya2xlVHJlZVR5cGUgPSBnZXRNZXJrbGVUcmVlVHlwZSh0eXBlcywgY3R4KTtcbiAgICBjb25zdCBzdHJ1Y3RIYXNoZXMgPSBkYXRhLm1hcCgoc3RydWN0KSA9PiB7XG4gICAgICByZXR1cm4gZW5jb2RlVmFsdWUodHlwZXMsIG1lcmtsZVRyZWVUeXBlLCBzdHJ1Y3QpWzFdO1xuICAgIH0pO1xuICAgIGNvbnN0IHsgcm9vdCB9ID0gbmV3IE1lcmtsZVRyZWUoc3RydWN0SGFzaGVzKTtcbiAgICByZXR1cm4gW1wiZmVsdFwiLCByb290XTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJmZWx0KlwiKSB7XG4gICAgcmV0dXJuIFtcImZlbHQqXCIsIGNvbXB1dGVIYXNoT25FbGVtZW50cyhkYXRhKV07XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwic2VsZWN0b3JcIikge1xuICAgIHJldHVybiBbXCJmZWx0XCIsIHByZXBhcmVTZWxlY3RvcihkYXRhKV07XG4gIH1cbiAgcmV0dXJuIFt0eXBlLCBnZXRIZXgoZGF0YSldO1xufTtcbnZhciBlbmNvZGVEYXRhID0gKHR5cGVzLCB0eXBlLCBkYXRhKSA9PiB7XG4gIGNvbnN0IFtyZXR1cm5UeXBlcywgdmFsdWVzXSA9IHR5cGVzW3R5cGVdLnJlZHVjZShcbiAgICAoW3RzLCB2c10sIGZpZWxkKSA9PiB7XG4gICAgICBpZiAoZGF0YVtmaWVsZC5uYW1lXSA9PT0gdm9pZCAwIHx8IGRhdGFbZmllbGQubmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZW5jb2RlIGRhdGE6IG1pc3NpbmcgZGF0YSBmb3IgJyR7ZmllbGQubmFtZX0nYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IGRhdGFbZmllbGQubmFtZV07XG4gICAgICBjb25zdCBbdCwgZW5jb2RlZFZhbHVlXSA9IGVuY29kZVZhbHVlKHR5cGVzLCBmaWVsZC50eXBlLCB2YWx1ZSwge1xuICAgICAgICBwYXJlbnQ6IHR5cGUsXG4gICAgICAgIGtleTogZmllbGQubmFtZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbLi4udHMsIHRdLFxuICAgICAgICBbLi4udnMsIGVuY29kZWRWYWx1ZV1cbiAgICAgIF07XG4gICAgfSxcbiAgICBbW1wiZmVsdFwiXSwgW2dldFR5cGVIYXNoKHR5cGVzLCB0eXBlKV1dXG4gICk7XG4gIHJldHVybiBbcmV0dXJuVHlwZXMsIHZhbHVlc107XG59O1xudmFyIGdldFN0cnVjdEhhc2ggPSAodHlwZXMsIHR5cGUsIGRhdGEpID0+IHtcbiAgcmV0dXJuIGNvbXB1dGVIYXNoT25FbGVtZW50cyhlbmNvZGVEYXRhKHR5cGVzLCB0eXBlLCBkYXRhKVsxXSk7XG59O1xudmFyIGdldE1lc3NhZ2VIYXNoID0gKHR5cGVkRGF0YSwgYWNjb3VudCkgPT4ge1xuICBpZiAoIXZhbGlkYXRlVHlwZWREYXRhKHR5cGVkRGF0YSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlZCBkYXRhIGRvZXMgbm90IG1hdGNoIEpTT04gc2NoZW1hXCIpO1xuICB9XG4gIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgZW5jb2RlU2hvcnRTdHJpbmcoXCJTdGFya05ldCBNZXNzYWdlXCIpLFxuICAgIGdldFN0cnVjdEhhc2godHlwZWREYXRhLnR5cGVzLCBcIlN0YXJrTmV0RG9tYWluXCIsIHR5cGVkRGF0YS5kb21haW4pLFxuICAgIGFjY291bnQsXG4gICAgZ2V0U3RydWN0SGFzaCh0eXBlZERhdGEudHlwZXMsIHR5cGVkRGF0YS5wcmltYXJ5VHlwZSwgdHlwZWREYXRhLm1lc3NhZ2UpXG4gIF07XG4gIHJldHVybiBjb21wdXRlSGFzaE9uRWxlbWVudHMobWVzc2FnZSk7XG59O1xuXG4vLyBzcmMvc2lnbmVyL2RlZmF1bHQudHNcbnZhciBTaWduZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBrID0gc3RhcmtDdXJ2ZS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCkpIHtcbiAgICB0aGlzLnBrID0gcGsgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gYnVmMmhleChwaykgOiB0b0hleChwayk7XG4gIH1cbiAgYXN5bmMgZ2V0UHViS2V5KCkge1xuICAgIHJldHVybiBzdGFya0N1cnZlLmdldFN0YXJrS2V5KHRoaXMucGspO1xuICB9XG4gIGFzeW5jIHNpZ25NZXNzYWdlKHR5cGVkRGF0YSwgYWNjb3VudEFkZHJlc3MpIHtcbiAgICBjb25zdCBtc2dIYXNoID0gZ2V0TWVzc2FnZUhhc2godHlwZWREYXRhLCBhY2NvdW50QWRkcmVzcyk7XG4gICAgcmV0dXJuIHN0YXJrQ3VydmUuc2lnbihtc2dIYXNoLCB0aGlzLnBrKTtcbiAgfVxuICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25zLCB0cmFuc2FjdGlvbnNEZXRhaWwsIGFiaXMpIHtcbiAgICBpZiAoYWJpcyAmJiBhYmlzLmxlbmd0aCAhPT0gdHJhbnNhY3Rpb25zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUJJIG11c3QgYmUgcHJvdmlkZWQgZm9yIGVhY2ggdHJhbnNhY3Rpb24gb3Igbm8gdHJhbnNhY3Rpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKHRyYW5zYWN0aW9ucywgdHJhbnNhY3Rpb25zRGV0YWlsLmNhaXJvVmVyc2lvbik7XG4gICAgY29uc3QgbXNnSGFzaCA9IGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaChcbiAgICAgIHRyYW5zYWN0aW9uc0RldGFpbC53YWxsZXRBZGRyZXNzLFxuICAgICAgdHJhbnNhY3Rpb25zRGV0YWlsLnZlcnNpb24sXG4gICAgICBjYWxsZGF0YSxcbiAgICAgIHRyYW5zYWN0aW9uc0RldGFpbC5tYXhGZWUsXG4gICAgICB0cmFuc2FjdGlvbnNEZXRhaWwuY2hhaW5JZCxcbiAgICAgIHRyYW5zYWN0aW9uc0RldGFpbC5ub25jZVxuICAgICk7XG4gICAgcmV0dXJuIHN0YXJrQ3VydmUuc2lnbihtc2dIYXNoLCB0aGlzLnBrKTtcbiAgfVxuICBhc3luYyBzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKHtcbiAgICBjbGFzc0hhc2gsXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgYWRkcmVzc1NhbHQsXG4gICAgbWF4RmVlLFxuICAgIHZlcnNpb24sXG4gICAgY2hhaW5JZCxcbiAgICBub25jZVxuICB9KSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2goXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBjbGFzc0hhc2gsXG4gICAgICBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpLFxuICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgbWF4RmVlLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIG5vbmNlXG4gICAgKTtcbiAgICByZXR1cm4gc3RhcmtDdXJ2ZS5zaWduKG1zZ0hhc2gsIHRoaXMucGspO1xuICB9XG4gIGFzeW5jIHNpZ25EZWNsYXJlVHJhbnNhY3Rpb24oe1xuICAgIGNsYXNzSGFzaCxcbiAgICBzZW5kZXJBZGRyZXNzLFxuICAgIGNoYWluSWQsXG4gICAgbWF4RmVlLFxuICAgIHZlcnNpb24sXG4gICAgbm9uY2UsXG4gICAgY29tcGlsZWRDbGFzc0hhc2hcbiAgfSkge1xuICAgIGNvbnN0IG1zZ0hhc2ggPSBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoKFxuICAgICAgY2xhc3NIYXNoLFxuICAgICAgc2VuZGVyQWRkcmVzcyxcbiAgICAgIHZlcnNpb24sXG4gICAgICBtYXhGZWUsXG4gICAgICBjaGFpbklkLFxuICAgICAgbm9uY2UsXG4gICAgICBjb21waWxlZENsYXNzSGFzaFxuICAgICk7XG4gICAgcmV0dXJuIHN0YXJrQ3VydmUuc2lnbihtc2dIYXNoLCB0aGlzLnBrKTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2V2ZW50cy50c1xuZnVuY3Rpb24gcGFyc2VVRENFdmVudCh0eFJlY2VpcHQpIHtcbiAgaWYgKCF0eFJlY2VpcHQuZXZlbnRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVURDIGVtaXR0ZWQgZXZlbnQgaXMgZW1wdHlcIik7XG4gIH1cbiAgY29uc3QgZXZlbnQgPSB0eFJlY2VpcHQuZXZlbnRzLmZpbmQoXG4gICAgKGl0KSA9PiBjbGVhbkhleChpdC5mcm9tX2FkZHJlc3MpID09PSBjbGVhbkhleChVREMuQUREUkVTUylcbiAgKSB8fCB7XG4gICAgZGF0YTogW11cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2FjdGlvbl9oYXNoOiB0eFJlY2VpcHQudHJhbnNhY3Rpb25faGFzaCxcbiAgICBjb250cmFjdF9hZGRyZXNzOiBldmVudC5kYXRhWzBdLFxuICAgIGFkZHJlc3M6IGV2ZW50LmRhdGFbMF0sXG4gICAgZGVwbG95ZXI6IGV2ZW50LmRhdGFbMV0sXG4gICAgdW5pcXVlOiBldmVudC5kYXRhWzJdLFxuICAgIGNsYXNzSGFzaDogZXZlbnQuZGF0YVszXSxcbiAgICBjYWxsZGF0YV9sZW46IGV2ZW50LmRhdGFbNF0sXG4gICAgY2FsbGRhdGE6IGV2ZW50LmRhdGEuc2xpY2UoNSwgNSArIHBhcnNlSW50KGV2ZW50LmRhdGFbNF0sIDE2KSksXG4gICAgc2FsdDogZXZlbnQuZGF0YVtldmVudC5kYXRhLmxlbmd0aCAtIDFdXG4gIH07XG59XG5cbi8vIHNyYy9hY2NvdW50L2RlZmF1bHQudHNcbnZhciBBY2NvdW50ID0gY2xhc3MgZXh0ZW5kcyBQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKHByb3ZpZGVyT3JPcHRpb25zLCBhZGRyZXNzLCBwa09yU2lnbmVyLCBjYWlyb1ZlcnNpb24pIHtcbiAgICBzdXBlcihwcm92aWRlck9yT3B0aW9ucyk7XG4gICAgdGhpcy5kZXBsb3lTZWxmID0gdGhpcy5kZXBsb3lBY2NvdW50O1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnNpZ25lciA9IHR5cGVvZiBwa09yU2lnbmVyID09PSBcInN0cmluZ1wiIHx8IHBrT3JTaWduZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gbmV3IFNpZ25lcihwa09yU2lnbmVyKSA6IHBrT3JTaWduZXI7XG4gICAgaWYgKGNhaXJvVmVyc2lvbikge1xuICAgICAgdGhpcy5jYWlyb1ZlcnNpb24gPSBjYWlyb1ZlcnNpb24udG9TdHJpbmcoKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2UoYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldE5vbmNlRm9yQWRkcmVzcyh0aGlzLmFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2VTYWZlKG5vbmNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0b0JpZ0ludChub25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gMG47XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIENhaXJvIHZlcnNpb24gZnJvbSB0aGUgbmV0d29yayBhbmQgc2V0cyBgY2Fpcm9WZXJzaW9uYCBpZiBub3QgYWxyZWFkeSBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSBjbGFzc0hhc2ggaWYgcHJvdmlkZWQgZGV0ZWN0cyBDYWlybyB2ZXJzaW9uIGZyb20gY2xhc3NIYXNoLCBvdGhlcndpc2UgZnJvbSB0aGUgYWNjb3VudCBhZGRyZXNzXG4gICAqL1xuICBhc3luYyBnZXRDYWlyb1ZlcnNpb24oY2xhc3NIYXNoKSB7XG4gICAgaWYgKCF0aGlzLmNhaXJvVmVyc2lvbikge1xuICAgICAgY29uc3QgeyBjYWlybyB9ID0gY2xhc3NIYXNoID8gYXdhaXQgc3VwZXIuZ2V0Q29udHJhY3RWZXJzaW9uKHZvaWQgMCwgY2xhc3NIYXNoKSA6IGF3YWl0IHN1cGVyLmdldENvbnRyYWN0VmVyc2lvbih0aGlzLmFkZHJlc3MpO1xuICAgICAgdGhpcy5jYWlyb1ZlcnNpb24gPSBjYWlybztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2Fpcm9WZXJzaW9uO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlRmVlKGNhbGxzLCBlc3RpbWF0ZUZlZURldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZUludm9rZUZlZShjYWxscywgZXN0aW1hdGVGZWVEZXRhaWxzKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZUludm9rZUZlZShjYWxscywgeyBub25jZTogcHJvdmlkZWROb25jZSwgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgfSA9IHt9KSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25zID0gQXJyYXkuaXNBcnJheShjYWxscykgPyBjYWxscyA6IFtjYWxsc107XG4gICAgY29uc3Qgbm9uY2UgPSB0b0JpZ0ludChwcm92aWRlZE5vbmNlID8/IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKSk7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvQmlnSW50KGZlZVRyYW5zYWN0aW9uVmVyc2lvbik7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHNpZ25lckRldGFpbHMgPSB7XG4gICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBub25jZSxcbiAgICAgIG1heEZlZTogWkVSTyxcbiAgICAgIHZlcnNpb24sXG4gICAgICBjaGFpbklkLFxuICAgICAgY2Fpcm9WZXJzaW9uOiBhd2FpdCB0aGlzLmdldENhaXJvVmVyc2lvbigpXG4gICAgfTtcbiAgICBjb25zdCBpbnZvY2F0aW9uID0gYXdhaXQgdGhpcy5idWlsZEludm9jYXRpb24odHJhbnNhY3Rpb25zLCBzaWduZXJEZXRhaWxzKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHN1cGVyLmdldEludm9rZUVzdGltYXRlRmVlKFxuICAgICAgeyAuLi5pbnZvY2F0aW9uIH0sXG4gICAgICB7IHZlcnNpb24sIG5vbmNlIH0sXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGVcbiAgICApO1xuICAgIGNvbnN0IHN1Z2dlc3RlZE1heEZlZSA9IGVzdGltYXRlZEZlZVRvTWF4RmVlKHJlc3BvbnNlLm92ZXJhbGxfZmVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICBzdWdnZXN0ZWRNYXhGZWVcbiAgICB9O1xuICB9XG4gIGFzeW5jIGVzdGltYXRlRGVjbGFyZUZlZSh7IGNvbnRyYWN0LCBjbGFzc0hhc2g6IHByb3ZpZGVkQ2xhc3NIYXNoLCBjYXNtLCBjb21waWxlZENsYXNzSGFzaCB9LCB7IGJsb2NrSWRlbnRpZmllciwgbm9uY2U6IHByb3ZpZGVkTm9uY2UsIHNraXBWYWxpZGF0ZSB9ID0ge30pIHtcbiAgICBjb25zdCBub25jZSA9IHRvQmlnSW50KHByb3ZpZGVkTm9uY2UgPz8gYXdhaXQgdGhpcy5nZXROb25jZSgpKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gIWlzU2llcnJhKGNvbnRyYWN0KSA/IGZlZVRyYW5zYWN0aW9uVmVyc2lvbiA6IGZlZVRyYW5zYWN0aW9uVmVyc2lvbl8yO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuYnVpbGREZWNsYXJlUGF5bG9hZChcbiAgICAgIHsgY2xhc3NIYXNoOiBwcm92aWRlZENsYXNzSGFzaCwgY29udHJhY3QsIGNhc20sIGNvbXBpbGVkQ2xhc3NIYXNoIH0sXG4gICAgICB7XG4gICAgICAgIG5vbmNlLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgIG1heEZlZTogWkVSTyxcbiAgICAgICAgY2Fpcm9WZXJzaW9uOiB2b2lkIDBcbiAgICAgICAgLy8gdW51c2VkIHBhcmFtZXRlclxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzdXBlci5nZXREZWNsYXJlRXN0aW1hdGVGZWUoXG4gICAgICBkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbixcbiAgICAgIHsgdmVyc2lvbiwgbm9uY2UgfSxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZVxuICAgICk7XG4gICAgY29uc3Qgc3VnZ2VzdGVkTWF4RmVlID0gZXN0aW1hdGVkRmVlVG9NYXhGZWUocmVzcG9uc2Uub3ZlcmFsbF9mZWUpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNwb25zZSxcbiAgICAgIHN1Z2dlc3RlZE1heEZlZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVBY2NvdW50RGVwbG95RmVlKHtcbiAgICBjbGFzc0hhc2gsXG4gICAgYWRkcmVzc1NhbHQgPSAwLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBbXSxcbiAgICBjb250cmFjdEFkZHJlc3M6IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzXG4gIH0sIHsgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgfSA9IHt9KSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvQmlnSW50KGZlZVRyYW5zYWN0aW9uVmVyc2lvbik7XG4gICAgY29uc3Qgbm9uY2UgPSBaRVJPO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZEFjY291bnREZXBsb3lQYXlsb2FkKFxuICAgICAgeyBjbGFzc0hhc2gsIGFkZHJlc3NTYWx0LCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBjb250cmFjdEFkZHJlc3M6IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzIH0sXG4gICAgICB7XG4gICAgICAgIG5vbmNlLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgIC8vIHVudXNlZCBwYXJhbWV0ZXJcbiAgICAgICAgbWF4RmVlOiBaRVJPLFxuICAgICAgICBjYWlyb1ZlcnNpb246IHZvaWQgMFxuICAgICAgICAvLyB1bnVzZWQgcGFyYW1ldGVyXG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHN1cGVyLmdldERlcGxveUFjY291bnRFc3RpbWF0ZUZlZShcbiAgICAgIHsgLi4ucGF5bG9hZCB9LFxuICAgICAgeyB2ZXJzaW9uLCBub25jZSB9LFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgKTtcbiAgICBjb25zdCBzdWdnZXN0ZWRNYXhGZWUgPSBlc3RpbWF0ZWRGZWVUb01heEZlZShyZXNwb25zZS5vdmVyYWxsX2ZlZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgc3VnZ2VzdGVkTWF4RmVlXG4gICAgfTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZURlcGxveUZlZShwYXlsb2FkLCB0cmFuc2FjdGlvbnNEZXRhaWwpIHtcbiAgICBjb25zdCBjYWxscyA9IHRoaXMuYnVpbGRVRENDb250cmFjdFBheWxvYWQocGF5bG9hZCk7XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVJbnZva2VGZWUoY2FsbHMsIHRyYW5zYWN0aW9uc0RldGFpbCk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVGZWVCdWxrKGludm9jYXRpb25zLCB7IG5vbmNlLCBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSB9ID0ge30pIHtcbiAgICBjb25zdCBhY2NvdW50SW52b2NhdGlvbnMgPSBhd2FpdCB0aGlzLmFjY291bnRJbnZvY2F0aW9uc0ZhY3RvcnkoaW52b2NhdGlvbnMsIHtcbiAgICAgIHZlcnNpb25zOiBbZmVlVHJhbnNhY3Rpb25WZXJzaW9uLCBmZWVUcmFuc2FjdGlvblZlcnNpb25fMl0sXG4gICAgICBub25jZSxcbiAgICAgIGJsb2NrSWRlbnRpZmllclxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc3VwZXIuZ2V0RXN0aW1hdGVGZWVCdWxrKGFjY291bnRJbnZvY2F0aW9ucywge1xuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgfSk7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChyZXNwb25zZSkubWFwKChlbGVtKSA9PiB7XG4gICAgICBjb25zdCBzdWdnZXN0ZWRNYXhGZWUgPSBlc3RpbWF0ZWRGZWVUb01heEZlZShlbGVtLm92ZXJhbGxfZmVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmVsZW0sXG4gICAgICAgIHN1Z2dlc3RlZE1heEZlZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBidWlsZEludm9jYXRpb24oY2FsbCwgc2lnbmVyRGV0YWlscykge1xuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKGNhbGwsIGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKCkpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25UcmFuc2FjdGlvbihjYWxsLCBzaWduZXJEZXRhaWxzKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBjYWxsZGF0YSxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZXhlY3V0ZShjYWxscywgYWJpcyA9IHZvaWQgMCwgdHJhbnNhY3Rpb25zRGV0YWlsID0ge30pIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBBcnJheS5pc0FycmF5KGNhbGxzKSA/IGNhbGxzIDogW2NhbGxzXTtcbiAgICBjb25zdCBub25jZSA9IHRvQmlnSW50KHRyYW5zYWN0aW9uc0RldGFpbC5ub25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpO1xuICAgIGNvbnN0IG1heEZlZSA9IHRyYW5zYWN0aW9uc0RldGFpbC5tYXhGZWUgPz8gYXdhaXQgdGhpcy5nZXRTdWdnZXN0ZWRNYXhGZWUoXG4gICAgICB7IHR5cGU6IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovLCBwYXlsb2FkOiBjYWxscyB9LFxuICAgICAgdHJhbnNhY3Rpb25zRGV0YWlsXG4gICAgKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9CaWdJbnQodHJhbnNhY3Rpb25WZXJzaW9uKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3Qgc2lnbmVyRGV0YWlscyA9IHtcbiAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIG5vbmNlLFxuICAgICAgbWF4RmVlLFxuICAgICAgdmVyc2lvbixcbiAgICAgIGNoYWluSWQsXG4gICAgICBjYWlyb1ZlcnNpb246IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKClcbiAgICB9O1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbnMsIHNpZ25lckRldGFpbHMsIGFiaXMpO1xuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKHRyYW5zYWN0aW9ucywgYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKSk7XG4gICAgcmV0dXJuIHRoaXMuaW52b2tlRnVuY3Rpb24oXG4gICAgICB7IGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLCBjYWxsZGF0YSwgc2lnbmF0dXJlIH0sXG4gICAgICB7XG4gICAgICAgIG5vbmNlLFxuICAgICAgICBtYXhGZWUsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBGaXJzdCBjaGVjayBpZiBjb250cmFjdCBpcyBhbHJlYWR5IGRlY2xhcmVkLCBpZiBub3QgZGVjbGFyZSBpdFxuICAgKiBJZiBjb250cmFjdCBhbHJlYWR5IGRlY2xhcmVkIHJldHVybmVkIHRyYW5zYWN0aW9uX2hhc2ggaXMgJycuXG4gICAqIE1ldGhvZCB3aWxsIHBhc3MgZXZlbiBpZiBjb250cmFjdCBpcyBhbHJlYWR5IGRlY2xhcmVkXG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvbnNEZXRhaWwgKG9wdGlvbmFsKVxuICAgKi9cbiAgYXN5bmMgZGVjbGFyZUlmTm90KHBheWxvYWQsIHRyYW5zYWN0aW9uc0RldGFpbCA9IHt9KSB7XG4gICAgY29uc3QgZGVjbGFyZUNvbnRyYWN0UGF5bG9hZCA9IGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5nZXRDbGFzc0J5SGFzaChkZWNsYXJlQ29udHJhY3RQYXlsb2FkLmNsYXNzSGFzaCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY2xhcmUocGF5bG9hZCwgdHJhbnNhY3Rpb25zRGV0YWlsKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zYWN0aW9uX2hhc2g6IFwiXCIsXG4gICAgICBjbGFzc19oYXNoOiBkZWNsYXJlQ29udHJhY3RQYXlsb2FkLmNsYXNzSGFzaFxuICAgIH07XG4gIH1cbiAgYXN5bmMgZGVjbGFyZShwYXlsb2FkLCB0cmFuc2FjdGlvbnNEZXRhaWwgPSB7fSkge1xuICAgIGNvbnN0IGRlY2xhcmVDb250cmFjdFBheWxvYWQgPSBleHRyYWN0Q29udHJhY3RIYXNoZXMocGF5bG9hZCk7XG4gICAgY29uc3QgZGV0YWlscyA9IHt9O1xuICAgIGRldGFpbHMubm9uY2UgPSB0b0JpZ0ludCh0cmFuc2FjdGlvbnNEZXRhaWwubm9uY2UgPz8gYXdhaXQgdGhpcy5nZXROb25jZSgpKTtcbiAgICBkZXRhaWxzLm1heEZlZSA9IHRyYW5zYWN0aW9uc0RldGFpbC5tYXhGZWUgPz8gYXdhaXQgdGhpcy5nZXRTdWdnZXN0ZWRNYXhGZWUoXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgICAgIHBheWxvYWQ6IGRlY2xhcmVDb250cmFjdFBheWxvYWRcbiAgICAgIH0sXG4gICAgICB0cmFuc2FjdGlvbnNEZXRhaWxcbiAgICApO1xuICAgIGRldGFpbHMudmVyc2lvbiA9ICFpc1NpZXJyYShwYXlsb2FkLmNvbnRyYWN0KSA/IHRyYW5zYWN0aW9uVmVyc2lvbiA6IHRyYW5zYWN0aW9uVmVyc2lvbl8yO1xuICAgIGRldGFpbHMuY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IGRlY2xhcmVDb250cmFjdFRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5idWlsZERlY2xhcmVQYXlsb2FkKGRlY2xhcmVDb250cmFjdFBheWxvYWQsIHtcbiAgICAgIC4uLmRldGFpbHMsXG4gICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBjYWlyb1ZlcnNpb246IHZvaWQgMFxuICAgICAgLy8gdW51c2VkIHBhcmFtZXRlclxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmRlY2xhcmVDb250cmFjdChkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbiwgZGV0YWlscyk7XG4gIH1cbiAgYXN5bmMgZGVwbG95KHBheWxvYWQsIGRldGFpbHMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBbXS5jb25jYXQocGF5bG9hZCkubWFwKChpdCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgIHNhbHQsXG4gICAgICAgIHVuaXF1ZSA9IHRydWUsXG4gICAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBbXVxuICAgICAgfSA9IGl0O1xuICAgICAgY29uc3QgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICAgIGNvbnN0IGRlcGxveVNhbHQgPSBzYWx0ID8/IHJhbmRvbUFkZHJlc3MoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbGw6IHtcbiAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IFVEQy5BRERSRVNTLFxuICAgICAgICAgIGVudHJ5cG9pbnQ6IFVEQy5FTlRSWVBPSU5ULFxuICAgICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgICAgICBkZXBsb3lTYWx0LFxuICAgICAgICAgICAgdG9DYWlyb0Jvb2wodW5pcXVlKSxcbiAgICAgICAgICAgIGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAuLi5jb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGFcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIGFkZHJlc3M6IGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoKFxuICAgICAgICAgIHVuaXF1ZSA/IHN0YXJrQ3VydmUucGVkZXJzZW4odGhpcy5hZGRyZXNzLCBkZXBsb3lTYWx0KSA6IGRlcGxveVNhbHQsXG4gICAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICAgIGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YSxcbiAgICAgICAgICB1bmlxdWUgPyBVREMuQUREUkVTUyA6IDBcbiAgICAgICAgKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjYWxscyA9IHBhcmFtcy5tYXAoKGl0KSA9PiBpdC5jYWxsKTtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSBwYXJhbXMubWFwKChpdCkgPT4gaXQuYWRkcmVzcyk7XG4gICAgY29uc3QgaW52b2tlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmV4ZWN1dGUoY2FsbHMsIHZvaWQgMCwgZGV0YWlscyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmludm9rZVJlc3BvbnNlLFxuICAgICAgY29udHJhY3RfYWRkcmVzczogYWRkcmVzc2VzXG4gICAgfTtcbiAgfVxuICBhc3luYyBkZXBsb3lDb250cmFjdChwYXlsb2FkLCBkZXRhaWxzKSB7XG4gICAgY29uc3QgZGVwbG95VHggPSBhd2FpdCB0aGlzLmRlcGxveShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICBjb25zdCB0eFJlY2VpcHQgPSBhd2FpdCB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbihkZXBsb3lUeC50cmFuc2FjdGlvbl9oYXNoKTtcbiAgICByZXR1cm4gcGFyc2VVRENFdmVudCh0eFJlY2VpcHQpO1xuICB9XG4gIGFzeW5jIGRlY2xhcmVBbmREZXBsb3kocGF5bG9hZCwgZGV0YWlscykge1xuICAgIGNvbnN0IHsgY29uc3RydWN0b3JDYWxsZGF0YSwgc2FsdCwgdW5pcXVlIH0gPSBwYXlsb2FkO1xuICAgIGxldCBkZWNsYXJlID0gYXdhaXQgdGhpcy5kZWNsYXJlSWZOb3QocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgaWYgKGRlY2xhcmUudHJhbnNhY3Rpb25faGFzaCAhPT0gXCJcIikge1xuICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbihkZWNsYXJlLnRyYW5zYWN0aW9uX2hhc2gpO1xuICAgICAgZGVjbGFyZSA9IHsgLi4uZGVjbGFyZSwgLi4udHggfTtcbiAgICB9XG4gICAgY29uc3QgZGVwbG95ID0gYXdhaXQgdGhpcy5kZXBsb3lDb250cmFjdChcbiAgICAgIHsgY2xhc3NIYXNoOiBkZWNsYXJlLmNsYXNzX2hhc2gsIHNhbHQsIHVuaXF1ZSwgY29uc3RydWN0b3JDYWxsZGF0YSB9LFxuICAgICAgZGV0YWlsc1xuICAgICk7XG4gICAgcmV0dXJuIHsgZGVjbGFyZTogeyAuLi5kZWNsYXJlIH0sIGRlcGxveSB9O1xuICB9XG4gIGFzeW5jIGRlcGxveUFjY291bnQoe1xuICAgIGNsYXNzSGFzaCxcbiAgICBjb25zdHJ1Y3RvckNhbGxkYXRhID0gW10sXG4gICAgYWRkcmVzc1NhbHQgPSAwLFxuICAgIGNvbnRyYWN0QWRkcmVzczogcHJvdmlkZWRDb250cmFjdEFkZHJlc3NcbiAgfSwgdHJhbnNhY3Rpb25zRGV0YWlsID0ge30pIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9CaWdJbnQodHJhbnNhY3Rpb25WZXJzaW9uKTtcbiAgICBjb25zdCBub25jZSA9IFpFUk87XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IGNvbXBpbGVkQ2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICAgIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzID8/IGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoKGFkZHJlc3NTYWx0LCBjbGFzc0hhc2gsIGNvbXBpbGVkQ2FsbGRhdGEsIDApO1xuICAgIGNvbnN0IG1heEZlZSA9IHRyYW5zYWN0aW9uc0RldGFpbC5tYXhGZWUgPz8gYXdhaXQgdGhpcy5nZXRTdWdnZXN0ZWRNYXhGZWUoXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIGNsYXNzSGFzaCxcbiAgICAgICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhLFxuICAgICAgICAgIGFkZHJlc3NTYWx0LFxuICAgICAgICAgIGNvbnRyYWN0QWRkcmVzc1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHJhbnNhY3Rpb25zRGV0YWlsXG4gICAgKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25lci5zaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKHtcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGE6IGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBhZGRyZXNzU2FsdCxcbiAgICAgIGNoYWluSWQsXG4gICAgICBtYXhGZWUsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgbm9uY2VcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5kZXBsb3lBY2NvdW50Q29udHJhY3QoXG4gICAgICB7IGNsYXNzSGFzaCwgYWRkcmVzc1NhbHQsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIHNpZ25hdHVyZSB9LFxuICAgICAge1xuICAgICAgICBub25jZSxcbiAgICAgICAgbWF4RmVlLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBzaWduTWVzc2FnZSh0eXBlZERhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduZXIuc2lnbk1lc3NhZ2UodHlwZWREYXRhLCB0aGlzLmFkZHJlc3MpO1xuICB9XG4gIGFzeW5jIGhhc2hNZXNzYWdlKHR5cGVkRGF0YSkge1xuICAgIHJldHVybiBnZXRNZXNzYWdlSGFzaCh0eXBlZERhdGEsIHRoaXMuYWRkcmVzcyk7XG4gIH1cbiAgYXN5bmMgdmVyaWZ5TWVzc2FnZUhhc2goaGFzaCwgc2lnbmF0dXJlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuY2FsbENvbnRyYWN0KHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgIGVudHJ5cG9pbnQ6IFwiaXNWYWxpZFNpZ25hdHVyZVwiLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZSh7XG4gICAgICAgICAgaGFzaDogdG9CaWdJbnQoaGFzaCkudG9TdHJpbmcoKSxcbiAgICAgICAgICBzaWduYXR1cmU6IGZvcm1hdFNpZ25hdHVyZShzaWduYXR1cmUpXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyB2ZXJpZnlNZXNzYWdlKHR5cGVkRGF0YSwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuaGFzaE1lc3NhZ2UodHlwZWREYXRhKTtcbiAgICByZXR1cm4gdGhpcy52ZXJpZnlNZXNzYWdlSGFzaChoYXNoLCBzaWduYXR1cmUpO1xuICB9XG4gIGFzeW5jIGdldFN1Z2dlc3RlZE1heEZlZSh7IHR5cGUsIHBheWxvYWQgfSwgZGV0YWlscykge1xuICAgIGxldCBmZWVFc3RpbWF0ZTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi86XG4gICAgICAgIGZlZUVzdGltYXRlID0gYXdhaXQgdGhpcy5lc3RpbWF0ZUludm9rZUZlZShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi86XG4gICAgICAgIGZlZUVzdGltYXRlID0gYXdhaXQgdGhpcy5lc3RpbWF0ZURlY2xhcmVGZWUocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi86XG4gICAgICAgIGZlZUVzdGltYXRlID0gYXdhaXQgdGhpcy5lc3RpbWF0ZUFjY291bnREZXBsb3lGZWUocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkRFUExPWVwiIC8qIERFUExPWSAqLzpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSBhd2FpdCB0aGlzLmVzdGltYXRlRGVwbG95RmVlKHBheWxvYWQsIGRldGFpbHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGZlZUVzdGltYXRlID0geyBzdWdnZXN0ZWRNYXhGZWU6IFpFUk8sIG92ZXJhbGxfZmVlOiBaRVJPIH07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZmVlRXN0aW1hdGUuc3VnZ2VzdGVkTWF4RmVlO1xuICB9XG4gIC8qKlxuICAgKiB3aWxsIGJlIHJlbmFtZWQgdG8gYnVpbGREZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgYnVpbGREZWNsYXJlUGF5bG9hZChwYXlsb2FkLCB7IG5vbmNlLCBjaGFpbklkLCB2ZXJzaW9uLCB3YWxsZXRBZGRyZXNzLCBtYXhGZWUgfSkge1xuICAgIGNvbnN0IHsgY2xhc3NIYXNoLCBjb250cmFjdCwgY29tcGlsZWRDbGFzc0hhc2ggfSA9IGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKTtcbiAgICBjb25zdCBjb21wcmVzc2VkQ29tcGlsZWRDb250cmFjdCA9IHBhcnNlQ29udHJhY3QoY29udHJhY3QpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25EZWNsYXJlVHJhbnNhY3Rpb24oe1xuICAgICAgY2xhc3NIYXNoLFxuICAgICAgY29tcGlsZWRDbGFzc0hhc2gsXG4gICAgICBzZW5kZXJBZGRyZXNzOiB3YWxsZXRBZGRyZXNzLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIG1heEZlZSxcbiAgICAgIHZlcnNpb24sXG4gICAgICBub25jZVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBzZW5kZXJBZGRyZXNzOiB3YWxsZXRBZGRyZXNzLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgY29udHJhY3Q6IGNvbXByZXNzZWRDb21waWxlZENvbnRyYWN0LFxuICAgICAgY29tcGlsZWRDbGFzc0hhc2hcbiAgICB9O1xuICB9XG4gIGFzeW5jIGJ1aWxkQWNjb3VudERlcGxveVBheWxvYWQoe1xuICAgIGNsYXNzSGFzaCxcbiAgICBhZGRyZXNzU2FsdCA9IDAsXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdLFxuICAgIGNvbnRyYWN0QWRkcmVzczogcHJvdmlkZWRDb250cmFjdEFkZHJlc3NcbiAgfSwgeyBub25jZSwgY2hhaW5JZCwgdmVyc2lvbiwgbWF4RmVlIH0pIHtcbiAgICBjb25zdCBjb21waWxlZENhbGxkYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBwcm92aWRlZENvbnRyYWN0QWRkcmVzcyA/PyBjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaChhZGRyZXNzU2FsdCwgY2xhc3NIYXNoLCBjb21waWxlZENhbGxkYXRhLCAwKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25lci5zaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKHtcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGNoYWluSWQsXG4gICAgICBtYXhGZWUsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgbm9uY2UsXG4gICAgICBhZGRyZXNzU2FsdCxcbiAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGE6IGNvbXBpbGVkQ2FsbGRhdGFcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3NIYXNoLFxuICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfTtcbiAgfVxuICBidWlsZFVEQ0NvbnRyYWN0UGF5bG9hZChwYXlsb2FkKSB7XG4gICAgY29uc3QgY2FsbHMgPSBbXS5jb25jYXQocGF5bG9hZCkubWFwKChpdCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgIHNhbHQgPSBcIjBcIixcbiAgICAgICAgdW5pcXVlID0gdHJ1ZSxcbiAgICAgICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdXG4gICAgICB9ID0gaXQ7XG4gICAgICBjb25zdCBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBVREMuQUREUkVTUyxcbiAgICAgICAgZW50cnlwb2ludDogVURDLkVOVFJZUE9JTlQsXG4gICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICAgIHNhbHQsXG4gICAgICAgICAgdG9DYWlyb0Jvb2wodW5pcXVlKSxcbiAgICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEubGVuZ3RoLFxuICAgICAgICAgIC4uLmNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YVxuICAgICAgICBdXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBjYWxscztcbiAgfVxuICBhc3luYyBzaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCB7IG5vbmNlLCBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSwgc2tpcEV4ZWN1dGUgfSA9IHt9KSB7XG4gICAgY29uc3QgYWNjb3VudEludm9jYXRpb25zID0gYXdhaXQgdGhpcy5hY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5KGludm9jYXRpb25zLCB7XG4gICAgICB2ZXJzaW9uczogW3RyYW5zYWN0aW9uVmVyc2lvbiwgdHJhbnNhY3Rpb25WZXJzaW9uXzJdLFxuICAgICAgbm9uY2UsXG4gICAgICBibG9ja0lkZW50aWZpZXJcbiAgICB9KTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0U2ltdWxhdGVUcmFuc2FjdGlvbihhY2NvdW50SW52b2NhdGlvbnMsIHtcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZSxcbiAgICAgIHNraXBFeGVjdXRlXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgYWNjb3VudEludm9jYXRpb25zRmFjdG9yeShpbnZvY2F0aW9ucywgeyB2ZXJzaW9ucywgbm9uY2UsIGJsb2NrSWRlbnRpZmllciB9KSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IHZlcnNpb25zWzBdO1xuICAgIGNvbnN0IHNhZmVOb25jZSA9IGF3YWl0IHRoaXMuZ2V0Tm9uY2VTYWZlKG5vbmNlKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgdHgwUGF5bG9hZCA9IFwicGF5bG9hZFwiIGluIGludm9jYXRpb25zWzBdID8gaW52b2NhdGlvbnNbMF0ucGF5bG9hZCA6IGludm9jYXRpb25zWzBdO1xuICAgIGNvbnN0IGNhaXJvVmVyc2lvbiA9IGludm9jYXRpb25zWzBdLnR5cGUgPT09IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyA/IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKHR4MFBheWxvYWQuY2xhc3NIYXNoKSA6IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKCk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgW10uY29uY2F0KGludm9jYXRpb25zKS5tYXAoYXN5bmMgKHRyYW5zYWN0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB0eFBheWxvYWQgPSBcInBheWxvYWRcIiBpbiB0cmFuc2FjdGlvbiA/IHRyYW5zYWN0aW9uLnBheWxvYWQgOiB0cmFuc2FjdGlvbjtcbiAgICAgICAgY29uc3Qgc2lnbmVyRGV0YWlscyA9IHtcbiAgICAgICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgbm9uY2U6IHRvQmlnSW50KE51bWJlcihzYWZlTm9uY2UpICsgaW5kZXgpLFxuICAgICAgICAgIG1heEZlZTogWkVSTyxcbiAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgY2Fpcm9WZXJzaW9uXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbW1vbiA9IHtcbiAgICAgICAgICB0eXBlOiB0cmFuc2FjdGlvbi50eXBlLFxuICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgbm9uY2U6IHRvQmlnSW50KE51bWJlcihzYWZlTm9uY2UpICsgaW5kZXgpLFxuICAgICAgICAgIGJsb2NrSWRlbnRpZmllclxuICAgICAgICB9O1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi8pIHtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZEludm9jYXRpb24oXG4gICAgICAgICAgICBbXS5jb25jYXQodHhQYXlsb2FkKSxcbiAgICAgICAgICAgIHNpZ25lckRldGFpbHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICAuLi5wYXlsb2FkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLykge1xuICAgICAgICAgIHNpZ25lckRldGFpbHMudmVyc2lvbiA9ICFpc1NpZXJyYSh0eFBheWxvYWQuY29udHJhY3QpID8gdG9CaWdJbnQodmVyc2lvbnNbMF0pIDogdG9CaWdJbnQodmVyc2lvbnNbMV0pO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzLmJ1aWxkRGVjbGFyZVBheWxvYWQodHhQYXlsb2FkLCBzaWduZXJEZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgIHZlcnNpb246IHNpZ25lckRldGFpbHMudmVyc2lvblxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT09IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLykge1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzLmJ1aWxkQWNjb3VudERlcGxveVBheWxvYWQodHhQYXlsb2FkLCBzaWduZXJEZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgLi4ucGF5bG9hZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT09IFwiREVQTE9ZXCIgLyogREVQTE9ZICovKSB7XG4gICAgICAgICAgY29uc3QgY2FsbHMgPSB0aGlzLmJ1aWxkVURDQ29udHJhY3RQYXlsb2FkKHR4UGF5bG9hZCk7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXMuYnVpbGRJbnZvY2F0aW9uKGNhbGxzLCBzaWduZXJEZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgIHR5cGU6IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBFcnJvcihgYWNjb3VudEludm9jYXRpb25zRmFjdG9yeTogdW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZTogJHt0cmFuc2FjdGlvbn1gKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRTdGFya05hbWUoYWRkcmVzcyA9IHRoaXMuYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBzdXBlci5nZXRTdGFya05hbWUoYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mik7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9pbnRlcmZhY2UudHNcbnZhciBQcm92aWRlckludGVyZmFjZSA9IGNsYXNzIHtcbn07XG5cbi8vIHNyYy9wcm92aWRlci9pbmRleC50c1xudmFyIGRlZmF1bHRQcm92aWRlciA9IG5ldyBQcm92aWRlcih7IHJwYzogeyBkZWZhdWx0OiB0cnVlIH0gfSk7XG5cbi8vIHNyYy9hY2NvdW50L2ludGVyZmFjZS50c1xudmFyIEFjY291bnRJbnRlcmZhY2UgPSBjbGFzcyBleHRlbmRzIFByb3ZpZGVySW50ZXJmYWNlIHtcbn07XG5cbi8vIHNyYy91dGlscy9ldmVudHMvaW5kZXgudHNcbnZhciBldmVudHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZXZlbnRzX2V4cG9ydHMsIHtcbiAgZ2V0QWJpRXZlbnRzOiAoKSA9PiBnZXRBYmlFdmVudHMsXG4gIHBhcnNlRXZlbnRzOiAoKSA9PiBwYXJzZUV2ZW50c1xufSk7XG5mdW5jdGlvbiBnZXRBYmlFdmVudHMoYWJpKSB7XG4gIHJldHVybiBhYmkuZmlsdGVyKChhYmlFbnRyeSkgPT4gYWJpRW50cnkudHlwZSA9PT0gXCJldmVudFwiICYmIChhYmlFbnRyeS5zaXplIHx8IGFiaUVudHJ5LmtpbmQgIT09IFwiZW51bVwiKSkucmVkdWNlKChhY2MsIGFiaUVudHJ5KSA9PiB7XG4gICAgY29uc3QgZW50cnlOYW1lID0gYWJpRW50cnkubmFtZS5zbGljZShhYmlFbnRyeS5uYW1lLmxhc3RJbmRleE9mKFwiOlwiKSArIDEpO1xuICAgIGNvbnN0IGFiaUVudHJ5TW9kID0geyAuLi5hYmlFbnRyeSB9O1xuICAgIGFiaUVudHJ5TW9kLm5hbWUgPSBlbnRyeU5hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmFjYyxcbiAgICAgIFthZGRIZXhQcmVmaXgoc3RhcmtDdXJ2ZS5rZWNjYWsodXRmOFRvQXJyYXkoZW50cnlOYW1lKSkudG9TdHJpbmcoMTYpKV06IGFiaUVudHJ5TW9kXG4gICAgfTtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gcGFyc2VFdmVudHMocHJvdmlkZXJSZWNlaXZlZEV2ZW50cywgYWJpRXZlbnRzLCBhYmlTdHJ1Y3RzLCBhYmlFbnVtcykge1xuICBjb25zdCByZXQgPSBwcm92aWRlclJlY2VpdmVkRXZlbnRzLmZsYXQoKS5yZWR1Y2UoKGFjYywgcmVjRXZlbnQpID0+IHtcbiAgICBjb25zdCBhYmlFdmVudCA9IGFiaUV2ZW50c1tyZWNFdmVudC5rZXlzWzBdXTtcbiAgICBpZiAoIWFiaUV2ZW50KSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRFdmVudCA9IHt9O1xuICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdID0ge307XG4gICAgcmVjRXZlbnQua2V5cy5zaGlmdCgpO1xuICAgIGNvbnN0IGtleXNJdGVyID0gcmVjRXZlbnQua2V5c1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgZGF0YUl0ZXIgPSByZWNFdmVudC5kYXRhW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBjb25zdCBhYmlFdmVudEtleXMgPSBhYmlFdmVudC5tZW1iZXJzPy5maWx0ZXIoKGl0KSA9PiBpdC5raW5kID09PSBcImtleVwiKSB8fCBhYmlFdmVudC5rZXlzO1xuICAgIGNvbnN0IGFiaUV2ZW50RGF0YSA9IGFiaUV2ZW50Lm1lbWJlcnM/LmZpbHRlcigoaXQpID0+IGl0LmtpbmQgPT09IFwiZGF0YVwiKSB8fCBhYmlFdmVudC5kYXRhO1xuICAgIGFiaUV2ZW50S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdW2tleS5uYW1lXSA9IHJlc3BvbnNlUGFyc2VyKFxuICAgICAgICBrZXlzSXRlcixcbiAgICAgICAga2V5LFxuICAgICAgICBhYmlTdHJ1Y3RzLFxuICAgICAgICBhYmlFbnVtcyxcbiAgICAgICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV1cbiAgICAgICk7XG4gICAgfSk7XG4gICAgYWJpRXZlbnREYXRhLmZvckVhY2goKGRhdGEpID0+IHtcbiAgICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdW2RhdGEubmFtZV0gPSByZXNwb25zZVBhcnNlcihcbiAgICAgICAgZGF0YUl0ZXIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGFiaVN0cnVjdHMsXG4gICAgICAgIGFiaUVudW1zLFxuICAgICAgICBwYXJzZWRFdmVudFthYmlFdmVudC5uYW1lXVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBhY2MucHVzaChwYXJzZWRFdmVudCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10pO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBzcmMvY29udHJhY3QvZGVmYXVsdC50c1xudmFyIHNwbGl0QXJnc0FuZE9wdGlvbnMgPSAoYXJncykgPT4ge1xuICBjb25zdCBvcHRpb25zID0gW1xuICAgIFwiYmxvY2tJZGVudGlmaWVyXCIsXG4gICAgXCJwYXJzZVJlcXVlc3RcIixcbiAgICBcInBhcnNlUmVzcG9uc2VcIixcbiAgICBcImZvcm1hdFJlc3BvbnNlXCIsXG4gICAgXCJtYXhGZWVcIixcbiAgICBcIm5vbmNlXCIsXG4gICAgXCJzaWduYXR1cmVcIixcbiAgICBcImFkZHJlc3NTYWx0XCJcbiAgXTtcbiAgY29uc3QgbGFzdEFyZyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgaWYgKHR5cGVvZiBsYXN0QXJnID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuc29tZSgoeCkgPT4geCBpbiBsYXN0QXJnKSkge1xuICAgIHJldHVybiB7IGFyZ3MsIG9wdGlvbnM6IGFyZ3MucG9wKCkgfTtcbiAgfVxuICByZXR1cm4geyBhcmdzIH07XG59O1xuZnVuY3Rpb24gYnVpbGRDYWxsKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHNwbGl0QXJnc0FuZE9wdGlvbnMoYXJncyk7XG4gICAgcmV0dXJuIGNvbnRyYWN0LmNhbGwoZnVuY3Rpb25BYmkubmFtZSwgcGFyYW1zLmFyZ3MsIHtcbiAgICAgIHBhcnNlUmVxdWVzdDogdHJ1ZSxcbiAgICAgIHBhcnNlUmVzcG9uc2U6IHRydWUsXG4gICAgICAuLi5wYXJhbXMub3B0aW9uc1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRJbnZva2UoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3BsaXRBcmdzQW5kT3B0aW9ucyhhcmdzKTtcbiAgICByZXR1cm4gY29udHJhY3QuaW52b2tlKGZ1bmN0aW9uQWJpLm5hbWUsIHBhcmFtcy5hcmdzLCB7XG4gICAgICBwYXJzZVJlcXVlc3Q6IHRydWUsXG4gICAgICAuLi5wYXJhbXMub3B0aW9uc1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGREZWZhdWx0KGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICBpZiAoZnVuY3Rpb25BYmkuc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBmdW5jdGlvbkFiaS5zdGF0ZV9tdXRhYmlsaXR5ID09PSBcInZpZXdcIikge1xuICAgIHJldHVybiBidWlsZENhbGwoY29udHJhY3QsIGZ1bmN0aW9uQWJpKTtcbiAgfVxuICByZXR1cm4gYnVpbGRJbnZva2UoY29udHJhY3QsIGZ1bmN0aW9uQWJpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUG9wdWxhdGUoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGNvbnRyYWN0LnBvcHVsYXRlKGZ1bmN0aW9uQWJpLm5hbWUsIGFyZ3MpO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRFc3RpbWF0ZShjb250cmFjdCwgZnVuY3Rpb25BYmkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gY29udHJhY3QuZXN0aW1hdGUoZnVuY3Rpb25BYmkubmFtZSwgYXJncyk7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDYWxsZGF0YShhcmdzLCBjYWxsYmFjaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBcIl9fY29tcGlsZWRfX1wiIGluIGFyZ3MpXG4gICAgcmV0dXJuIGFyZ3M7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIEFycmF5LmlzQXJyYXkoYXJnc1swXSkgJiYgXCJfX2NvbXBpbGVkX19cIiBpbiBhcmdzWzBdKVxuICAgIHJldHVybiBhcmdzWzBdO1xuICByZXR1cm4gY2FsbGJhY2soKTtcbn1cbnZhciBDb250cmFjdCA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENvbnRyYWN0IGNsYXNzIHRvIGhhbmRsZSBjb250cmFjdCBtZXRob2RzXG4gICAqXG4gICAqIEBwYXJhbSBhYmkgLSBBYmkgb2YgdGhlIGNvbnRyYWN0IG9iamVjdFxuICAgKiBAcGFyYW0gYWRkcmVzcyAob3B0aW9uYWwpIC0gYWRkcmVzcyB0byBjb25uZWN0IHRvXG4gICAqIEBwYXJhbSBwcm92aWRlck9yQWNjb3VudCAob3B0aW9uYWwpIC0gUHJvdmlkZXIgb3IgQWNjb3VudCB0byBhdHRhY2ggdG9cbiAgICovXG4gIGNvbnN0cnVjdG9yKGFiaSwgYWRkcmVzcywgcHJvdmlkZXJPckFjY291bnQgPSBkZWZhdWx0UHJvdmlkZXIpIHtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzICYmIGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3ZpZGVyT3JBY2NvdW50ID0gcHJvdmlkZXJPckFjY291bnQ7XG4gICAgdGhpcy5jYWxsRGF0YSA9IG5ldyBDYWxsRGF0YShhYmkpO1xuICAgIHRoaXMuc3RydWN0cyA9IENhbGxEYXRhLmdldEFiaVN0cnVjdChhYmkpO1xuICAgIHRoaXMuZXZlbnRzID0gZ2V0QWJpRXZlbnRzKGFiaSk7XG4gICAgY29uc3QgcGFyc2VyID0gY3JlYXRlQWJpUGFyc2VyKGFiaSk7XG4gICAgdGhpcy5hYmkgPSBwYXJzZXIuZ2V0TGVnYWN5Rm9ybWF0KCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBmdW5jdGlvbnM6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfSxcbiAgICAgIGNhbGxTdGF0aWM6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfSxcbiAgICAgIHBvcHVsYXRlVHJhbnNhY3Rpb246IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfSxcbiAgICAgIGVzdGltYXRlRmVlOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH1cbiAgICB9KTtcbiAgICB0aGlzLmFiaS5mb3JFYWNoKChhYmlFbGVtZW50KSA9PiB7XG4gICAgICBpZiAoYWJpRWxlbWVudC50eXBlICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGFiaUVsZW1lbnQubmFtZTtcbiAgICAgIGlmICghdGhpc1tzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZERlZmF1bHQodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZnVuY3Rpb25zW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZnVuY3Rpb25zLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZERlZmF1bHQodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY2FsbFN0YXRpY1tzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmNhbGxTdGF0aWMsIHNpZ25hdHVyZSwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdmFsdWU6IGJ1aWxkQ2FsbCh0aGlzLCBhYmlFbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbiwgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGRQb3B1bGF0ZSh0aGlzLCBhYmlFbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5lc3RpbWF0ZUZlZVtzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVzdGltYXRlRmVlLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZEVzdGltYXRlKHRoaXMsIGFiaUVsZW1lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGF0dGFjaChhZGRyZXNzKSB7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgfVxuICBjb25uZWN0KHByb3ZpZGVyT3JBY2NvdW50KSB7XG4gICAgdGhpcy5wcm92aWRlck9yQWNjb3VudCA9IHByb3ZpZGVyT3JBY2NvdW50O1xuICB9XG4gIGFzeW5jIGRlcGxveWVkKCkge1xuICAgIGlmICh0aGlzLmRlcGxveVRyYW5zYWN0aW9uSGFzaCkge1xuICAgICAgYXdhaXQgdGhpcy5wcm92aWRlck9yQWNjb3VudC53YWl0Rm9yVHJhbnNhY3Rpb24odGhpcy5kZXBsb3lUcmFuc2FjdGlvbkhhc2gpO1xuICAgICAgdGhpcy5kZXBsb3lUcmFuc2FjdGlvbkhhc2ggPSB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFzeW5jIGNhbGwobWV0aG9kLCBhcmdzID0gW10sIHtcbiAgICBwYXJzZVJlcXVlc3QgPSB0cnVlLFxuICAgIHBhcnNlUmVzcG9uc2UgPSB0cnVlLFxuICAgIGZvcm1hdFJlc3BvbnNlID0gdm9pZCAwLFxuICAgIGJsb2NrSWRlbnRpZmllciA9IHZvaWQgMFxuICB9ID0ge30pIHtcbiAgICBhc3NlcnQodGhpcy5hZGRyZXNzICE9PSBudWxsLCBcImNvbnRyYWN0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYW4gYWRkcmVzc1wiKTtcbiAgICBjb25zdCBjYWxsZGF0YSA9IGdldENhbGxkYXRhKGFyZ3MsICgpID0+IHtcbiAgICAgIGlmIChwYXJzZVJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5jYWxsRGF0YS52YWxpZGF0ZShcIkNBTExcIiAvKiBDQUxMICovLCBtZXRob2QsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsRGF0YS5jb21waWxlKG1ldGhvZCwgYXJncyk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLndhcm4oXCJDYWxsIHNraXBwZWQgcGFyc2luZyBidXQgcHJvdmlkZWQgcmF3QXJncywgcG9zc2libGUgbWFsZnVuY3Rpb24gcmVxdWVzdFwiKTtcbiAgICAgIHJldHVybiBhcmdzO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmNhbGxDb250cmFjdChcbiAgICAgIHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgIGNhbGxkYXRhLFxuICAgICAgICBlbnRyeXBvaW50OiBtZXRob2RcbiAgICAgIH0sXG4gICAgICBibG9ja0lkZW50aWZpZXJcbiAgICApLnRoZW4oKHgpID0+IHtcbiAgICAgIGlmICghcGFyc2VSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4geC5yZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0UmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbERhdGEuZm9ybWF0KG1ldGhvZCwgeC5yZXN1bHQsIGZvcm1hdFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLnBhcnNlKG1ldGhvZCwgeC5yZXN1bHQpO1xuICAgIH0pO1xuICB9XG4gIGludm9rZShtZXRob2QsIGFyZ3MgPSBbXSwgeyBwYXJzZVJlcXVlc3QgPSB0cnVlLCBtYXhGZWUsIG5vbmNlLCBzaWduYXR1cmUgfSA9IHt9KSB7XG4gICAgYXNzZXJ0KHRoaXMuYWRkcmVzcyAhPT0gbnVsbCwgXCJjb250cmFjdCBpcyBub3QgY29ubmVjdGVkIHRvIGFuIGFkZHJlc3NcIik7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB7XG4gICAgICBpZiAocGFyc2VSZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuY2FsbERhdGEudmFsaWRhdGUoXCJJTlZPS0VcIiAvKiBJTlZPS0UgKi8sIG1ldGhvZCwgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIkludm9rZSBza2lwcGVkIHBhcnNpbmcgYnV0IHByb3ZpZGVkIHJhd0FyZ3MsIHBvc3NpYmxlIG1hbGZ1bmN0aW9uIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9KTtcbiAgICBjb25zdCBpbnZvY2F0aW9uID0ge1xuICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBjYWxsZGF0YSxcbiAgICAgIGVudHJ5cG9pbnQ6IG1ldGhvZFxuICAgIH07XG4gICAgaWYgKFwiZXhlY3V0ZVwiIGluIHRoaXMucHJvdmlkZXJPckFjY291bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmV4ZWN1dGUoaW52b2NhdGlvbiwgdm9pZCAwLCB7XG4gICAgICAgIG1heEZlZSxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIW5vbmNlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb25jZSBpcyByZXF1aXJlZCB3aGVuIGludm9raW5nIGEgZnVuY3Rpb24gd2l0aG91dCBhbiBhY2NvdW50YCk7XG4gICAgY29uc29sZS53YXJuKGBJbnZva2luZyAke21ldGhvZH0gd2l0aG91dCBhbiBhY2NvdW50LiBUaGlzIHdpbGwgbm90IHdvcmsgb24gYSBwdWJsaWMgbm9kZS5gKTtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlck9yQWNjb3VudC5pbnZva2VGdW5jdGlvbihcbiAgICAgIHtcbiAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgc2lnbmF0dXJlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBub25jZVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGUobWV0aG9kLCBhcmdzID0gW10pIHtcbiAgICBhc3NlcnQodGhpcy5hZGRyZXNzICE9PSBudWxsLCBcImNvbnRyYWN0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYW4gYWRkcmVzc1wiKTtcbiAgICBpZiAoIWdldENhbGxkYXRhKGFyZ3MsICgpID0+IGZhbHNlKSkge1xuICAgICAgdGhpcy5jYWxsRGF0YS52YWxpZGF0ZShcIklOVk9LRVwiIC8qIElOVk9LRSAqLywgbWV0aG9kLCBhcmdzKTtcbiAgICB9XG4gICAgY29uc3QgaW52b2NhdGlvbiA9IHRoaXMucG9wdWxhdGUobWV0aG9kLCBhcmdzKTtcbiAgICBpZiAoXCJlc3RpbWF0ZUludm9rZUZlZVwiIGluIHRoaXMucHJvdmlkZXJPckFjY291bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmVzdGltYXRlSW52b2tlRmVlKGludm9jYXRpb24pO1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIkNvbnRyYWN0IG11c3QgYmUgY29ubmVjdGVkIHRvIHRoZSBhY2NvdW50IGNvbnRyYWN0IHRvIGVzdGltYXRlXCIpO1xuICB9XG4gIHBvcHVsYXRlKG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgZW50cnlwb2ludDogbWV0aG9kLFxuICAgICAgY2FsbGRhdGFcbiAgICB9O1xuICB9XG4gIHBhcnNlRXZlbnRzKHJlY2VpcHQpIHtcbiAgICByZXR1cm4gcGFyc2VFdmVudHMoXG4gICAgICByZWNlaXB0LmV2ZW50cz8uZmlsdGVyKFxuICAgICAgICAoZXZlbnQpID0+IGNsZWFuSGV4KGV2ZW50LmZyb21fYWRkcmVzcykgPT09IGNsZWFuSGV4KHRoaXMuYWRkcmVzcyksXG4gICAgICAgIFtdXG4gICAgICApIHx8IFtdLFxuICAgICAgdGhpcy5ldmVudHMsXG4gICAgICB0aGlzLnN0cnVjdHMsXG4gICAgICBDYWxsRGF0YS5nZXRBYmlFbnVtKHRoaXMuYWJpKVxuICAgICk7XG4gIH1cbiAgaXNDYWlybzEoKSB7XG4gICAgcmV0dXJuIGNhaXJvX2V4cG9ydHMuaXNDYWlybzFBYmkodGhpcy5hYmkpO1xuICB9XG4gIGFzeW5jIGdldFZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXJPckFjY291bnQuZ2V0Q29udHJhY3RWZXJzaW9uKHRoaXMuYWRkcmVzcyk7XG4gIH1cbiAgdHlwZWQodEFiaSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG4vLyBzcmMvY29udHJhY3QvaW50ZXJmYWNlLnRzXG52YXIgQ29udHJhY3RJbnRlcmZhY2UgPSBjbGFzcyB7XG59O1xuXG4vLyBzcmMvY29udHJhY3QvY29udHJhY3RGYWN0b3J5LnRzXG52YXIgQ29udHJhY3RGYWN0b3J5ID0gY2xhc3Mge1xuICAvKipcbiAgICogQHBhcmFtIHBhcmFtcyBDRlBhcmFtc1xuICAgKiAgLSBjb21waWxlZENvbnRyYWN0OiBDb21waWxlZENvbnRyYWN0O1xuICAgKiAgLSBhY2NvdW50OiBBY2NvdW50SW50ZXJmYWNlO1xuICAgKiAgLSBjYXNtPzogQ2Fpcm9Bc3NlbWJseTtcbiAgICogIC0gY2xhc3NIYXNoPzogc3RyaW5nO1xuICAgKiAgLSBjb21waWxlZENsYXNzSGFzaD86IHN0cmluZztcbiAgICogIC0gYWJpPzogQWJpO1xuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgdGhpcy5jb21waWxlZENvbnRyYWN0ID0gcGFyYW1zLmNvbXBpbGVkQ29udHJhY3Q7XG4gICAgdGhpcy5hY2NvdW50ID0gcGFyYW1zLmFjY291bnQ7XG4gICAgdGhpcy5jYXNtID0gcGFyYW1zLmNhc207XG4gICAgdGhpcy5hYmkgPSBwYXJhbXMuYWJpID8/IHBhcmFtcy5jb21waWxlZENvbnRyYWN0LmFiaTtcbiAgICB0aGlzLmNsYXNzSGFzaCA9IHBhcmFtcy5jbGFzc0hhc2g7XG4gICAgdGhpcy5jb21waWxlZENsYXNzSGFzaCA9IHBhcmFtcy5jb21waWxlZENsYXNzSGFzaDtcbiAgICB0aGlzLkNhbGxEYXRhID0gbmV3IENhbGxEYXRhKHRoaXMuYWJpKTtcbiAgfVxuICAvKipcbiAgICogRGVwbG95cyBjb250cmFjdCBhbmQgcmV0dXJucyBuZXcgaW5zdGFuY2Ugb2YgdGhlIENvbnRyYWN0XG4gICAqXG4gICAqIElmIGNvbnRyYWN0IGlzIG5vdCBkZWNsYXJlZCBpdCB3aWxsIGZpcnN0IGRlY2xhcmUgaXQsIGFuZCB0aGVuIGRlcGxveVxuICAgKi9cbiAgYXN5bmMgZGVwbG95KC4uLmFyZ3MpIHtcbiAgICBjb25zdCB7IGFyZ3M6IHBhcmFtLCBvcHRpb25zID0geyBwYXJzZVJlcXVlc3Q6IHRydWUgfSB9ID0gc3BsaXRBcmdzQW5kT3B0aW9ucyhhcmdzKTtcbiAgICBjb25zdCBjb25zdHJ1Y3RvckNhbGxkYXRhID0gZ2V0Q2FsbGRhdGEocGFyYW0sICgpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnBhcnNlUmVxdWVzdCkge1xuICAgICAgICB0aGlzLkNhbGxEYXRhLnZhbGlkYXRlKFwiREVQTE9ZXCIgLyogREVQTE9ZICovLCBcImNvbnN0cnVjdG9yXCIsIHBhcmFtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbERhdGEuY29tcGlsZShcImNvbnN0cnVjdG9yXCIsIHBhcmFtKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIkNhbGwgc2tpcHBlZCBwYXJzaW5nIGJ1dCBwcm92aWRlZCByYXdBcmdzLCBwb3NzaWJsZSBtYWxmdW5jdGlvbiByZXF1ZXN0XCIpO1xuICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGRlcGxveTogeyBjb250cmFjdF9hZGRyZXNzLCB0cmFuc2FjdGlvbl9oYXNoIH1cbiAgICB9ID0gYXdhaXQgdGhpcy5hY2NvdW50LmRlY2xhcmVBbmREZXBsb3koe1xuICAgICAgY29udHJhY3Q6IHRoaXMuY29tcGlsZWRDb250cmFjdCxcbiAgICAgIGNhc206IHRoaXMuY2FzbSxcbiAgICAgIGNsYXNzSGFzaDogdGhpcy5jbGFzc0hhc2gsXG4gICAgICBjb21waWxlZENsYXNzSGFzaDogdGhpcy5jb21waWxlZENsYXNzSGFzaCxcbiAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICBzYWx0OiBvcHRpb25zLmFkZHJlc3NTYWx0XG4gICAgfSk7XG4gICAgYXNzZXJ0KEJvb2xlYW4oY29udHJhY3RfYWRkcmVzcyksIFwiRGVwbG95bWVudCBvZiB0aGUgY29udHJhY3QgZmFpbGVkXCIpO1xuICAgIGNvbnN0IGNvbnRyYWN0SW5zdGFuY2UgPSBuZXcgQ29udHJhY3QoXG4gICAgICB0aGlzLmNvbXBpbGVkQ29udHJhY3QuYWJpLFxuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIHRoaXMuYWNjb3VudFxuICAgICk7XG4gICAgY29udHJhY3RJbnN0YW5jZS5kZXBsb3lUcmFuc2FjdGlvbkhhc2ggPSB0cmFuc2FjdGlvbl9oYXNoO1xuICAgIHJldHVybiBjb250cmFjdEluc3RhbmNlO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2hlcyB0byBuZXcgQWNjb3VudFxuICAgKlxuICAgKiBAcGFyYW0gYWNjb3VudCAtIG5ldyBBY2NvdW50IHRvIGF0dGFjaCB0b1xuICAgKi9cbiAgY29ubmVjdChhY2NvdW50KSB7XG4gICAgdGhpcy5hY2NvdW50ID0gYWNjb3VudDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXR0YWNoZXMgY3VycmVudCBhYmkgYW5kIGFjY291bnQgdG8gdGhlIG5ldyBhZGRyZXNzXG4gICAqL1xuICBhdHRhY2goYWRkcmVzcykge1xuICAgIHJldHVybiBuZXcgQ29udHJhY3QodGhpcy5hYmksIGFkZHJlc3MsIHRoaXMuYWNjb3VudCk7XG4gIH1cbiAgLy8gZXRoZXJzLmpzJyBnZXREZXBsb3lUcmFuc2FjdGlvbiBjYW50IGJlIHN1cHBvcnRlZCBhcyBpdCByZXF1aXJlcyB0aGUgYWNjb3VudCBvciBzaWduZXIgdG8gcmV0dXJuIGEgc2lnbmVkIHRyYW5zYWN0aW9uIHdoaWNoIGlzIG5vdCBwb3NzaWJsZSB3aXRoIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uXG59O1xuXG4vLyBzcmMvdXRpbHMvYWRkcmVzcy50c1xudmFyIGltcG9ydF91dGlsczQgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiKTtcbmZ1bmN0aW9uIGFkZEFkZHJlc3NQYWRkaW5nKGFkZHJlc3MpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChyZW1vdmVIZXhQcmVmaXgodG9IZXgoYWRkcmVzcykpLnBhZFN0YXJ0KDY0LCBcIjBcIikpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBbmRQYXJzZUFkZHJlc3MoYWRkcmVzcykge1xuICBhc3NlcnRJblJhbmdlKGFkZHJlc3MsIFpFUk8sIE1BU0tfMjUxLCBcIlN0YXJrbmV0IEFkZHJlc3NcIik7XG4gIGNvbnN0IHJlc3VsdCA9IGFkZEFkZHJlc3NQYWRkaW5nKGFkZHJlc3MpO1xuICBpZiAoIXJlc3VsdC5tYXRjaCgvXigweCk/WzAtOWEtZkEtRl17NjR9JC8pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBBZGRyZXNzIEZvcm1hdFwiKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgY29uc3QgY2hhcnMgPSByZW1vdmVIZXhQcmVmaXgodmFsaWRhdGVBbmRQYXJzZUFkZHJlc3MoYWRkcmVzcykpLnRvTG93ZXJDYXNlKCkuc3BsaXQoXCJcIik7XG4gIGNvbnN0IGhleCA9IHJlbW92ZUhleFByZWZpeChrZWNjYWtCbihhZGRyZXNzKSk7XG4gIGNvbnN0IGhhc2hlZCA9ICgwLCBpbXBvcnRfdXRpbHM0LmhleFRvQnl0ZXMpKGhleC5wYWRTdGFydCg2NCwgXCIwXCIpKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGlmIChoYXNoZWRbaSA+PiAxXSA+PiA0ID49IDgpIHtcbiAgICAgIGNoYXJzW2ldID0gY2hhcnNbaV0udG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKChoYXNoZWRbaSA+PiAxXSAmIDE1KSA+PSA4KSB7XG4gICAgICBjaGFyc1tpICsgMV0gPSBjaGFyc1tpICsgMV0udG9VcHBlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFkZEhleFByZWZpeChjaGFycy5qb2luKFwiXCIpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgcmV0dXJuIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSA9PT0gYWRkcmVzcztcbn1cblxuLy8gc3JjL2luZGV4LnRzXG52YXIgbnVtYmVyID0gbnVtX2V4cG9ydHM7XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQWNjb3VudCxcbiAgQWNjb3VudEludGVyZmFjZSxcbiAgQmxvY2tTdGF0dXMsXG4gIEJsb2NrVGFnLFxuICBDYWlyb0N1c3RvbUVudW0sXG4gIENhaXJvT3B0aW9uLFxuICBDYWlyb09wdGlvblZhcmlhbnQsXG4gIENhaXJvUmVzdWx0LFxuICBDYWlyb1Jlc3VsdFZhcmlhbnQsXG4gIENhbGxEYXRhLFxuICBDb250cmFjdCxcbiAgQ29udHJhY3RGYWN0b3J5LFxuICBDb250cmFjdEludGVyZmFjZSxcbiAgQ3VzdG9tRXJyb3IsXG4gIEVudHJ5UG9pbnRUeXBlLFxuICBHYXRld2F5RXJyb3IsXG4gIEh0dHBFcnJvcixcbiAgTGlicmFyeUVycm9yLFxuICBMaXR0ZXJhbCxcbiAgUHJvdmlkZXIsXG4gIFByb3ZpZGVySW50ZXJmYWNlLFxuICBSUEMsXG4gIFJwY1Byb3ZpZGVyLFxuICBTSU1VTEFUSU9OX0ZMQUcsXG4gIFNlcXVlbmNlcixcbiAgU2VxdWVuY2VyUHJvdmlkZXIsXG4gIFNpZ25lcixcbiAgU2lnbmVySW50ZXJmYWNlLFxuICBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyxcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyxcbiAgVHJhbnNhY3Rpb25TdGF0dXMsXG4gIFRyYW5zYWN0aW9uVHlwZSxcbiAgVWludCxcbiAgVmFsaWRhdGVUeXBlLFxuICBhZGRBZGRyZXNzUGFkZGluZyxcbiAgYnVpbGRVcmwsXG4gIGNhaXJvLFxuICBjb25zdGFudHMsXG4gIGNvbnRyYWN0Q2xhc3NSZXNwb25zZVRvTGVnYWN5Q29tcGlsZWRDb250cmFjdCxcbiAgZGVmYXVsdFByb3ZpZGVyLFxuICBlYyxcbiAgZW5jb2RlLFxuICBldmVudHMsXG4gIGV4dHJhY3RDb250cmFjdEhhc2hlcyxcbiAgZml4UHJvdG8sXG4gIGZpeFN0YWNrLFxuICBnZXRDYWxsZGF0YSxcbiAgZ2V0Q2hlY2tzdW1BZGRyZXNzLFxuICBnZXREZWZhdWx0Tm9kZVVybCxcbiAgaGFzaCxcbiAgaXNTaWVycmEsXG4gIGlzVXJsLFxuICBqc29uLFxuICBtZXJrbGUsXG4gIG51bSxcbiAgbnVtYmVyLFxuICBwYXJzZVVEQ0V2ZW50LFxuICBwcm92aWRlcixcbiAgc2VsZWN0b3IsXG4gIHNob3J0U3RyaW5nLFxuICBzcGxpdEFyZ3NBbmRPcHRpb25zLFxuICBzdGFyayxcbiAgc3RhcmtuZXRJZCxcbiAgdHJhbnNhY3Rpb24sXG4gIHR5cGVkRGF0YSxcbiAgdHlwZXMsXG4gIHVpbnQyNTYsXG4gIHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzLFxuICB2YWxpZGF0ZUNoZWNrc3VtQWRkcmVzc1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiX19jcmVhdGUiLCJPYmplY3QiLCJjcmVhdGUiLCJfX2RlZlByb3AiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZ2V0T3duUHJvcERlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2dldE93blByb3BOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJfX2dldFByb3RvT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9faGFzT3duUHJvcCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiX19leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZ2V0IiwiZW51bWVyYWJsZSIsIl9fY29weVByb3BzIiwidG8iLCJmcm9tIiwiZXhjZXB0IiwiZGVzYyIsImtleSIsImNhbGwiLCJfX3RvRVNNIiwibW9kIiwiaXNOb2RlTW9kZSIsIl9fZXNNb2R1bGUiLCJ2YWx1ZSIsIl9fdG9Db21tb25KUyIsInNyY19leHBvcnRzIiwiQWNjb3VudCIsIkFjY291bnRJbnRlcmZhY2UiLCJCbG9ja1N0YXR1cyIsIkJsb2NrVGFnIiwiQ2Fpcm9DdXN0b21FbnVtIiwiQ2Fpcm9PcHRpb24iLCJDYWlyb09wdGlvblZhcmlhbnQiLCJDYWlyb1Jlc3VsdCIsIkNhaXJvUmVzdWx0VmFyaWFudCIsIkNhbGxEYXRhIiwiQ29udHJhY3QiLCJDb250cmFjdEZhY3RvcnkiLCJDb250cmFjdEludGVyZmFjZSIsIkN1c3RvbUVycm9yIiwiRW50cnlQb2ludFR5cGUiLCJHYXRld2F5RXJyb3IiLCJIdHRwRXJyb3IiLCJMaWJyYXJ5RXJyb3IiLCJMaXR0ZXJhbCIsIlByb3ZpZGVyIiwiUHJvdmlkZXJJbnRlcmZhY2UiLCJSUEMiLCJycGNfZXhwb3J0cyIsIlJwY1Byb3ZpZGVyIiwiU0lNVUxBVElPTl9GTEFHIiwiU2VxdWVuY2VyIiwic2VxdWVuY2VyX2V4cG9ydHMiLCJTZXF1ZW5jZXJQcm92aWRlciIsIlNpZ25lciIsIlNpZ25lckludGVyZmFjZSIsIlRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzIiwiVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyIsIlRyYW5zYWN0aW9uU3RhdHVzIiwiVHJhbnNhY3Rpb25UeXBlIiwiVWludCIsIlZhbGlkYXRlVHlwZSIsImFkZEFkZHJlc3NQYWRkaW5nIiwiYnVpbGRVcmwiLCJjYWlybyIsImNhaXJvX2V4cG9ydHMiLCJjb25zdGFudHMiLCJjb25zdGFudHNfZXhwb3J0cyIsImNvbnRyYWN0Q2xhc3NSZXNwb25zZVRvTGVnYWN5Q29tcGlsZWRDb250cmFjdCIsImRlZmF1bHRQcm92aWRlciIsImVjIiwiZWNfZXhwb3J0cyIsImVuY29kZSIsImVuY29kZV9leHBvcnRzIiwiZXZlbnRzIiwiZXZlbnRzX2V4cG9ydHMiLCJleHRyYWN0Q29udHJhY3RIYXNoZXMiLCJmaXhQcm90byIsImZpeFN0YWNrIiwiZ2V0Q2FsbGRhdGEiLCJnZXRDaGVja3N1bUFkZHJlc3MiLCJnZXREZWZhdWx0Tm9kZVVybCIsImhhc2giLCJoYXNoX2V4cG9ydHMiLCJpc1NpZXJyYSIsImlzVXJsIiwianNvbiIsImpzb25fZXhwb3J0cyIsIm1lcmtsZSIsIm1lcmtsZV9leHBvcnRzIiwibnVtIiwibnVtX2V4cG9ydHMiLCJudW1iZXIiLCJwYXJzZVVEQ0V2ZW50IiwicHJvdmlkZXIiLCJwcm92aWRlcl9leHBvcnRzIiwic2VsZWN0b3IiLCJzZWxlY3Rvcl9leHBvcnRzIiwic2hvcnRTdHJpbmciLCJzaG9ydFN0cmluZ19leHBvcnRzIiwic3BsaXRBcmdzQW5kT3B0aW9ucyIsInN0YXJrIiwic3RhcmtfZXhwb3J0cyIsInN0YXJrbmV0SWQiLCJzdGFya25ldElkX2V4cG9ydHMiLCJ0cmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uX2V4cG9ydHMiLCJ0eXBlZERhdGEiLCJ0eXBlZERhdGFfZXhwb3J0cyIsInR5cGVzIiwidHlwZXNfZXhwb3J0cyIsInVpbnQyNTYiLCJ1aW50MjU2X2V4cG9ydHMiLCJ2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyIsInZhbGlkYXRlQ2hlY2tzdW1BZGRyZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsIkFQSV9WRVJTSU9OIiwiQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMSIsIkJOX0ZFRV9UUkFOU0FDVElPTl9WRVJTSU9OXzIiLCJCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzEiLCJCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzIiLCJCYXNlVXJsIiwiSEVYX1NUUl9UUkFOU0FDVElPTl9WRVJTSU9OXzEiLCJIRVhfU1RSX1RSQU5TQUNUSU9OX1ZFUlNJT05fMiIsIklTX0JST1dTRVIiLCJNQVNLXzI1MCIsIk1BU0tfMjUxIiwiTmV0d29ya05hbWUiLCJSUENfR09FUkxJX05PREVTIiwiUlBDX01BSU5ORVRfTk9ERVMiLCJTdGFya25ldENoYWluSWQiLCJURVhUX1RPX0ZFTFRfTUFYX0xFTiIsIlRyYW5zYWN0aW9uSGFzaFByZWZpeCIsIlVEQyIsIlpFUk8iLCJhZGRIZXhQcmVmaXgiLCJhcnJheUJ1ZmZlclRvU3RyaW5nIiwiYXRvYlVuaXZlcnNhbCIsImJ0b2FVbml2ZXJzYWwiLCJidWYyaGV4IiwiY2FsY0J5dGVMZW5ndGgiLCJwYWRMZWZ0IiwicGFzY2FsVG9TbmFrZSIsInJlbW92ZUhleFByZWZpeCIsInNhbml0aXplQnl0ZXMiLCJzYW5pdGl6ZUhleCIsInN0cmluZ1RvQXJyYXlCdWZmZXIiLCJ1dGY4VG9BcnJheSIsImltcG9ydF9iYXNlIiwicmVxdWlyZSIsIlNUUklOR19aRVJPIiwiYXJyYXkiLCJVaW50OEFycmF5IiwicmVkdWNlIiwiZGF0YSIsImJ5dGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzdHIiLCJUZXh0RW5jb2RlciIsImEiLCJiYXNlNjQiLCJkZWNvZGUiLCJiIiwiYnVmZmVyIiwiciIsIngiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiaGV4IiwicmVwbGFjZSIsInBhZFN0cmluZyIsImxlbmd0aCIsImxlZnQiLCJwYWRkaW5nIiwiZGlmZiIsInJlc3VsdCIsInBhZCIsInJlcGVhdCIsImJ5dGVTaXplIiwicmVtYWluZGVyIiwidGV4dCIsInRlc3QiLCJzcGxpdCIsImpvaW4iLCJ0b1VwcGVyQ2FzZSIsIkJhc2VVcmwyIiwiTmV0d29ya05hbWUyIiwiU3RhcmtuZXRDaGFpbklkNCIsIlRyYW5zYWN0aW9uSGFzaFByZWZpeDIiLCJBRERSRVNTIiwiRU5UUllQT0lOVCIsIlNJTVVMQVRJT05fRkxBRzIiLCJWYWxpZGF0ZVR5cGUyIiwiVWludDIiLCJMaXR0ZXJhbDIiLCJFbnRyeVBvaW50VHlwZTIiLCJUcmFuc2FjdGlvblR5cGUyIiwiVHJhbnNhY3Rpb25TdGF0dXMyIiwiVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czIiLCJUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czIiLCJCbG9ja1N0YXR1czIiLCJCbG9ja1RhZzIiLCJFQmxvY2tUYWciLCJFRGF0YUF2YWlsYWJpbGl0eU1vZGUiLCJFU2ltdWxhdGlvbkZsYWciLCJFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMiLCJFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyIsIkVUcmFuc2FjdGlvblN0YXR1cyIsIkVUcmFuc2FjdGlvblR5cGUiLCJFcnJvcnMiLCJlcnJvcnNfZXhwb3J0cyIsIkpSUEMiLCJqc29ucnBjX2V4cG9ydHMiLCJTUEVDIiwiY29tcG9uZW50c19leHBvcnRzIiwiRVRyYW5zYWN0aW9uVHlwZTIiLCJFU2ltdWxhdGlvbkZsYWcyIiwiRVRyYW5zYWN0aW9uU3RhdHVzMiIsIkVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMiIsIkVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czIiLCJFQmxvY2tUYWcyIiwiRURhdGFBdmFpbGFiaWxpdHlNb2RlMiIsImFzc2VydCIsImNvbmRpdGlvbiIsIm1lc3NhZ2UiLCJFcnJvciIsImFzc2VydEluUmFuZ2UiLCJiaWdOdW1iZXJpc2hBcnJheVRvRGVjaW1hbFN0cmluZ0FycmF5IiwiYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXkiLCJjbGVhbkhleCIsImdldERlY2ltYWxTdHJpbmciLCJnZXRIZXhTdHJpbmciLCJnZXRIZXhTdHJpbmdBcnJheSIsImhleFRvQnl0ZXMiLCJoZXhUb0RlY2ltYWxTdHJpbmciLCJpc0JpZ0ludCIsImlzSGV4IiwiaXNTdHJpbmdXaG9sZU51bWJlciIsInRvQmlnSW50IiwidG9DYWlyb0Jvb2wiLCJ0b0hleCIsInRvSGV4U3RyaW5nIiwidG9TdG9yYWdlS2V5IiwiaW1wb3J0X3V0aWxzIiwiQmlnSW50IiwibnVtYmVyMiIsInJlcyIsInRvTG93ZXJDYXNlIiwiaW5wdXQiLCJsb3dlckJvdW5kIiwidXBwZXJCb3VuZCIsImlucHV0TmFtZSIsIm1lc3NhZ2VTdWZmaXgiLCJpbnB1dEJpZ0ludCIsImxvd2VyQm91bmRCaWdJbnQiLCJ1cHBlckJvdW5kQmlnSW50IiwicmF3Q2FsbGRhdGEiLCJtYXAiLCJlbCIsImFkYXB0ZWRWYWx1ZSIsImdldFNlbGVjdG9yIiwiZ2V0U2VsZWN0b3JGcm9tTmFtZSIsImtlY2Nha0JuIiwic3RhcmtuZXRLZWNjYWsiLCJpbXBvcnRfc3RhcmtuZXQiLCJoZXhXaXRob3V0UHJlZml4IiwiZXZlbkhleCIsImtlY2NhayIsImtlY2Nha0hleCIsImZ1bmNOYW1lIiwiZGVjb2RlU2hvcnRTdHJpbmciLCJlbmNvZGVTaG9ydFN0cmluZyIsImlzQVNDSUkiLCJpc0RlY2ltYWxTdHJpbmciLCJpc0xvbmdUZXh0IiwiaXNTaG9ydFN0cmluZyIsImlzU2hvcnRUZXh0IiwiaXNUZXh0Iiwic3BsaXRMb25nU3RyaW5nIiwidmFsIiwibG9uZ1N0ciIsInJlZ2V4IiwiUmVnRXhwIiwibWF0Y2giLCJjaGFyIiwiY2hhckNvZGVBdCIsInBhcnNlSW50IiwiY29uY2F0IiwiZmVsdCIsImdldEFiaUNvbnRyYWN0VmVyc2lvbiIsImdldEFycmF5VHlwZSIsImlzQ2Fpcm8xQWJpIiwiaXNDYWlybzFUeXBlIiwiaXNMZW4iLCJpc1R5cGVBcnJheSIsImlzVHlwZUJvb2wiLCJpc1R5cGVDb250cmFjdEFkZHJlc3MiLCJpc1R5cGVFbnVtIiwiaXNUeXBlRXRoQWRkcmVzcyIsImlzVHlwZUZlbHQiLCJpc1R5cGVMaXR0ZXJhbCIsImlzVHlwZU5hbWVkVHVwbGUiLCJpc1R5cGVPcHRpb24iLCJpc1R5cGVSZXN1bHQiLCJpc1R5cGVTdHJ1Y3QiLCJpc1R5cGVUdXBsZSIsImlzVHlwZVVpbnQiLCJpc1R5cGVVaW50MjU2IiwidHVwbGUiLCJVSU5UXzEyOF9NQVgiLCJVSU5UXzI1Nl9NQVgiLCJiblRvVWludDI1NiIsImlzVWludDI1NiIsInVpbnQyNTZUb0JOIiwidWludDI1NjIiLCJoaWdoIiwibG93IiwiYm4iLCJiaSIsInR5cGUiLCJzdGFydHNXaXRoIiwiaW5jbHVkZXMiLCJzdHJ1Y3RzIiwiZW51bXMiLCJ2YWx1ZXMiLCJzdWJzdHJpbmciLCJpbmRleE9mIiwibGFzdEluZGV4T2YiLCJhYmkiLCJmaW5kIiwiaXQiLCJjb21waWxlciIsInRlc3RGdW5jdGlvbiIsImlucHV0cyIsIm91dHB1dHMiLCJpbyIsImFyZ3MiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJlbmNvZGVkIiwiY29uc3RydWN0b3IiLCJlbnVtQ29udGVudCIsInZhcmlhbnRzTGlzdCIsIm5iQWN0aXZlVmFyaWFudHMiLCJmaWx0ZXIiLCJjb250ZW50IiwidmFyaWFudCIsInVud3JhcCIsInZhcmlhbnRzIiwiZW50cmllcyIsImFjdGl2ZVZhcmlhbnQiLCJpdGVtIiwiQ2Fpcm9PcHRpb25WYXJpYW50MiIsInNvbWVDb250ZW50IiwiU29tZSIsIk5vbmUiLCJpc1NvbWUiLCJpc05vbmUiLCJDYWlyb1Jlc3VsdFZhcmlhbnQyIiwicmVzdWx0Q29udGVudCIsIk9rIiwiRXJyIiwiaXNPayIsImlzRXJyIiwiZ3VhcmQiLCJpc0JOIiwidW5rbm93biIsImZvcm1hdHRlciIsInNhbWVUeXBlIiwiYWNjIiwiZWxUeXBlIiwiQXJyYXkiLCJpc0FycmF5IiwiYXJyYXlTdHIiLCJfIiwiYXJyYXlPYmoiLCJBYmlQYXJzZXIxIiwibWV0aG9kSW5wdXRzTGVuZ3RoIiwiYWJpTWV0aG9kIiwiZ2V0TWV0aG9kIiwiZ2V0TGVnYWN5Rm9ybWF0IiwiQWJpUGFyc2VyMiIsImludGYiLCJpdGVtcyIsImZsYXRNYXAiLCJlIiwiY3JlYXRlQWJpUGFyc2VyIiwidmVyc2lvbiIsImdldEFiaVZlcnNpb24iLCJpc05vQ29uc3RydWN0b3JWYWxpZCIsIm1ldGhvZCIsImFyZ3NDYWxsZGF0YSIsInBhcnNlTmFtZWRUdXBsZSIsIm5hbWVkVHVwbGUiLCJwYXJzZVN1YlR1cGxlIiwicyIsInN1YlR1cGxlIiwiaSIsImNvdW50ZXIiLCJsQnJhY2tldCIsInB1c2giLCJleHRyYWN0Q2Fpcm8wVHVwbGUiLCJjbGVhblR5cGUiLCJzbGljZSIsInJlY29tcG9zZWQiLCJzaGlmdCIsImV4dHJhY3RDYWlybzFUdXBsZSIsImV4dHJhY3RUdXBsZU1lbWJlclR5cGVzIiwiZXJyb3JVMjU2Iiwib3JkZXJQcm9wc0J5QWJpIiwidW5vcmRlcmVkT2JqZWN0IiwiYWJpT2ZPYmplY3QiLCJvcmRlcklucHV0IiwidW5vcmRlcmVkSXRlbSIsImFiaVR5cGUiLCJvcmRlckFycmF5IiwiYWJpT2JqIiwib3JkZXJFbnVtIiwib3JkZXJUdXBsZSIsInUyNTYiLCJhYmlPZlN0cnVjdCIsIm1lbWJlcnMiLCJvcmRlclN0cnVjdCIsInVub3JkZXJlZE9iamVjdDIiLCJhYmlPYmplY3QiLCJvcmRlcmVkT2JqZWN0MiIsIm9yZGVyZWRPYmplY3QiLCJhYmlQYXJhbSIsInNldFByb3BlcnR5IiwibXlBcnJheSIsInR5cGVJbkFycmF5IiwibXlFbGVtIiwidHlwZUxpc3QiLCJhYmlUeXBlQ2Fpcm9YIiwiaW5kZXgiLCJteU9iaktleXMiLCJrZXlzIiwidW5vcmRlcmVkUmVzdWx0IiwicmVzdWx0T2tUeXBlIiwicmVzdWx0RXJyVHlwZSIsInVub3JkZXJlZE9wdGlvbiIsInJlc3VsdFNvbWVUeXBlIiwidW5vcmRlcmVkQ3VzdG9tRW51bSIsIm5ld0VudHJpZXMiLCJ2YXJpYW50VHlwZSIsImZyb21FbnRyaWVzIiwiZmluYWxPcmRlcmVkT2JqZWN0IiwicGFyc2VCYXNlVHlwZXMiLCJlbF91aW50MjU2IiwicGFyc2VUdXBsZSIsImVsZW1lbnQiLCJ0eXBlU3RyIiwibWVtYmVyVHlwZXMiLCJlbGVtZW50cyIsImR4IiwicGFyc2VVaW50MjU2IiwicGFyc2VDYWxsZGF0YVZhbHVlIiwiYXJyYXlUeXBlIiwic3ViRWxlbWVudCIsInR1cGxlZCIsInBhcnNlZERhdGEiLCJteU9wdGlvbiIsImxpc3RUeXBlVmFyaWFudDIiLCJ0eXBlVmFyaWFudFNvbWUiLCJwYXJzZWRQYXJhbWV0ZXIyIiwibXlSZXN1bHQiLCJsaXN0VHlwZVZhcmlhbnQzIiwidHlwZVZhcmlhbnRPayIsInBhcnNlZFBhcmFtZXRlcjMiLCJ0eXBlVmFyaWFudEVyciIsIm15RW51bSIsImxpc3RUeXBlVmFyaWFudCIsInR5cGVBY3RpdmVWYXJpYW50IiwibnVtQWN0aXZlVmFyaWFudCIsImZpbmRJbmRleCIsInBhcnNlZFBhcmFtZXRlciIsInBhcnNlQ2FsbGRhdGFGaWVsZCIsImFyZ3NJdGVyYXRvciIsIm5leHQiLCJwYXJzZUJhc2VUeXBlczIiLCJ0ZW1wIiwiQm9vbGVhbiIsInBhcnNlUmVzcG9uc2VWYWx1ZSIsInJlc3BvbnNlSXRlcmF0b3IiLCJwYXJzZWREYXRhQXJyIiwibGVuIiwidmFyaWFudE51bSIsInJhd0VudW0iLCJjdXN0b21FbnVtIiwiaWR4IiwicmVzcG9uc2VQYXJzZXIiLCJvdXRwdXQiLCJwYXJzZWRSZXN1bHQiLCJhcnJMZW4iLCJ2YWxpZGF0ZUZlbHQiLCJwYXJhbWV0ZXIiLCJwYXJhbSIsInZhbGlkYXRlVWludCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJ2YWxpZGF0ZUJvb2wiLCJ2YWxpZGF0ZVN0cnVjdCIsImZvckVhY2giLCJ2YWxpZGF0ZUVudW0iLCJtZXRob2RzS2V5cyIsInZhbGlkYXRlVHVwbGUiLCJ2YWxpZGF0ZUFycmF5IiwiYmFzZVR5cGUiLCJ2YWxpZGF0ZUZpZWxkcyIsImdldEFiaVN0cnVjdCIsImdldEFiaUVudW0iLCJwYXJzZXIiLCJ2YWxpZGF0ZSIsImludm9jYWJsZUZ1bmN0aW9uTmFtZXMiLCJpc1ZpZXciLCJzdGF0ZU11dGFiaWxpdHkiLCJzdGF0ZV9tdXRhYmlsaXR5IiwiaW5wdXRzTGVuZ3RoIiwiY29tcGlsZSIsImFiaUZ1bmN0aW9uIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjYWxsQXJyYXkiLCJ3cml0YWJsZSIsInJhd0FyZ3MiLCJjcmVhdGVUcmVlIiwib2JqIiwiZ2V0RW50cmllcyIsIm8iLCJwcmVmaXgiLCJvZSIsImsiLCJ2Iiwia2siLCJ2YXJpYW50TmIiLCJsaXN0VmFyaWFudHMiLCJhY3RpdmVWYXJpYW50TmIiLCJjYWxsVHJlZUFycmF5IiwiY2FsbFRyZWUiLCJjYWxsT2JqIiwicGFyc2UiLCJyZXNwb25zZSIsImZsYXQiLCJwYXJzZWQiLCJwcm9wTmFtZSIsImZvcm1hdCIsImFiaUVudHJ5IiwiZnVsbEVudW1MaXN0IiwidG9DYWxsZGF0YSIsInJhdyIsImNhbGxkYXRhIiwiY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2giLCJjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoIiwiY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaCIsImNhbGN1bGF0ZURlcGxveVRyYW5zYWN0aW9uSGFzaCIsImNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaCIsImNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbiIsImNvbXB1dGVDb21waWxlZENsYXNzSGFzaCIsImNvbXB1dGVDb250cmFjdENsYXNzSGFzaCIsImNvbXB1dGVIYXNoT25FbGVtZW50cyIsImNvbXB1dGVMZWdhY3lDb250cmFjdENsYXNzSGFzaCIsImNvbXB1dGVTaWVycmFDb250cmFjdENsYXNzSGFzaCIsImRlZmF1bHQiLCJjb21wdXRlSGludGVkQ2xhc3NIYXNoIiwiZmVlVHJhbnNhY3Rpb25WZXJzaW9uIiwiZmVlVHJhbnNhY3Rpb25WZXJzaW9uXzIiLCJmb3JtYXRTcGFjZXMiLCJnZXRWZXJzaW9uc0J5VHlwZSIsInBvc2VpZG9uIiwidHJhbnNhY3Rpb25WZXJzaW9uIiwidHJhbnNhY3Rpb25WZXJzaW9uXzIiLCJpbXBvcnRfc3RhcmtuZXQyIiwic3RhcmtDdXJ2ZSIsIndlaWVyc3RyYXNzIiwicGFyc2UyIiwicGFyc2VBbHdheXNBc0JpZyIsInN0cmluZ2lmeSIsInN0cmluZ2lmeTIiLCJzdHJpbmdpZnlBbHdheXNBc0JpZyIsInBhcnNlSW50QXNOdW1iZXJPckJpZ0ludCIsInBhcnNlRmxvYXQiLCJpc1NhZmVJbnRlZ2VyIiwicGFyc2VOdW1iZXJBbmRCaWdJbnQiLCJyZXBsYWNlciIsInNwYWNlIiwibnVtYmVyU3RyaW5naWZpZXJzIiwidmVyc2lvblR5cGUiLCJ2MSIsInYyIiwieSIsInBlZGVyc2VuIiwidHhIYXNoUHJlZml4IiwiY29udHJhY3RBZGRyZXNzIiwiZW50cnlQb2ludFNlbGVjdG9yIiwibWF4RmVlIiwiY2hhaW5JZCIsImFkZGl0aW9uYWxEYXRhIiwiY2FsbGRhdGFIYXNoIiwiZGF0YVRvSGFzaCIsImNvbnN0cnVjdG9yQ2FsbGRhdGEiLCJjb25zdHJ1Y3Rvck5hbWUiLCJjbGFzc0hhc2giLCJzZW5kZXJBZGRyZXNzIiwibm9uY2UiLCJjb21waWxlZENsYXNzSGFzaCIsInNhbHQiLCJkZXBsb3llckFkZHJlc3MiLCJjb21waWxlZENhbGxkYXRhIiwiY29uc3RydWN0b3JDYWxsZGF0YUhhc2giLCJDT05UUkFDVF9BRERSRVNTX1BSRUZJWCIsIm51bGxTa2lwUmVwbGFjZXIiLCJqc29uMiIsImluc2lkZVF1b3RlcyIsIm5ld1N0cmluZyIsImNvbXBpbGVkQ29udHJhY3QiLCJwcm9ncmFtIiwiY29udHJhY3RDbGFzcyIsInNlcmlhbGl6ZWRKc29uIiwiY29udHJhY3QiLCJhcGlWZXJzaW9uIiwiZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2giLCJlbnRyeV9wb2ludHNfYnlfdHlwZSIsIkVYVEVSTkFMIiwib2Zmc2V0IiwibDFIYW5kbGVyRW50cnlQb2ludHNIYXNoIiwiTDFfSEFORExFUiIsImNvbnN0cnVjdG9yRW50cnlQb2ludEhhc2giLCJDT05TVFJVQ1RPUiIsImJ1aWx0aW5zSGFzaCIsImJ1aWx0aW5zIiwiaGludGVkQ2xhc3NIYXNoIiwiZGF0YUhhc2giLCJoYXNoQnVpbHRpbnMiLCJwb3NlaWRvbkhhc2hNYW55IiwiaGFzaEVudHJ5UG9pbnQiLCJiYXNlIiwiY2FzbSIsIkNPTVBJTEVEX0NMQVNTX1ZFUlNJT04iLCJjb21waWxlZENsYXNzVmVyc2lvbiIsImwxSGFuZGxlcnMiLCJieXRlY29kZSIsImhhc2hFbnRyeVBvaW50U2llcnJhIiwiZnVuY3Rpb25faWR4IiwiaGFzaEFiaSIsInNpZXJyYSIsImluZGVudFN0cmluZyIsIkNPTlRSQUNUX0NMQVNTX1ZFUlNJT04iLCJhYmlIYXNoIiwic2llcnJhUHJvZ3JhbSIsInNpZXJyYV9wcm9ncmFtIiwiY29tcHJlc3NQcm9ncmFtIiwiZGVjb21wcmVzc1Byb2dyYW0iLCJlc3RpbWF0ZWRGZWVUb01heEZlZSIsImZvcm1hdFNpZ25hdHVyZSIsIm1ha2VBZGRyZXNzIiwicmFuZG9tQWRkcmVzcyIsInNpZ25hdHVyZVRvRGVjaW1hbEFycmF5Iiwic2lnbmF0dXJlVG9IZXhBcnJheSIsImltcG9ydF9zdGFya25ldDMiLCJpbXBvcnRfcGFrbyIsImpzb25Qcm9ncmFtIiwic3RyaW5naWZpZWQiLCJjb21wcmVzc2VkUHJvZ3JhbSIsImd6aXAiLCJiYXNlNjQyIiwiZGVjb21wcmVzc2VkIiwidW5nemlwIiwicmFuZG9tS2V5UGFpciIsInV0aWxzIiwicmFuZG9tUHJpdmF0ZUtleSIsImdldFN0YXJrS2V5Iiwic2lnIiwiZXN0aW1hdGVkRmVlIiwib3ZlcmhlYWQiLCJvdmVySGVhZFBlcmNlbnQiLCJNYXRoIiwicm91bmQiLCJwYXlsb2FkIiwiY2NyIiwiaW1wb3J0X2lzb21vcnBoaWNfZmV0Y2giLCJmZXRjaFBvbnlmaWxsX2RlZmF1bHQiLCJ3aW5kb3ciLCJmZXRjaCIsImdsb2JhbCIsImNyZWF0ZVNpZXJyYUNvbnRyYWN0Q2xhc3MiLCJwYXJzZUNvbnRyYWN0Iiwid2FpdCIsImRlbGF5IiwiUHJvbWlzZSIsInNldFRpbWVvdXQiLCJzaWVycmFfcHJvZ3JhbV9kZWJ1Z19pbmZvIiwicGFyc2VkQ29udHJhY3QiLCJSUENSZXNwb25zZVBhcnNlciIsInBhcnNlR2V0QmxvY2tSZXNwb25zZSIsInRpbWVzdGFtcCIsImJsb2NrX2hhc2giLCJibG9ja19udW1iZXIiLCJuZXdfcm9vdCIsInBhcmVudF9oYXNoIiwic3RhdHVzIiwidHJhbnNhY3Rpb25zIiwicGFyc2VHZXRUcmFuc2FjdGlvblJlc3BvbnNlIiwiY29udHJhY3RfYWRkcmVzcyIsInNlbmRlcl9hZGRyZXNzIiwibWF4X2ZlZSIsInNpZ25hdHVyZSIsInRyYW5zYWN0aW9uX2hhc2giLCJwYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UiLCJvdmVyYWxsX2ZlZSIsImdhc19jb25zdW1lZCIsImdhc19wcmljZSIsInBhcnNlRmVlRXN0aW1hdGVCdWxrUmVzcG9uc2UiLCJwYXJzZUNhbGxDb250cmFjdFJlc3BvbnNlIiwicGFyc2VTaW11bGF0ZVRyYW5zYWN0aW9uUmVzcG9uc2UiLCJzdWdnZXN0ZWRNYXhGZWUiLCJmZWVfZXN0aW1hdGlvbiIsInBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlIiwiSlNPTiIsImZuIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsImNvbmZpZ3VyYWJsZSIsImVycm9yQ29kZSIsIlN0YXJrbmV0SWRDb250cmFjdCIsImdldFN0YXJrbmV0SWRDb250cmFjdCIsInVzZURlY29kZWQiLCJ1c2VFbmNvZGVkIiwiYmFzaWNBbHBoYWJldCIsImJhc2ljU2l6ZVBsdXNPbmUiLCJiaWdBbHBoYWJldCIsImJhc2ljQWxwaGFiZXRTaXplIiwiYmlnQWxwaGFiZXRTaXplIiwiYmlnQWxwaGFiZXRTaXplUGx1c09uZSIsImV4dHJhY3RTdGFycyIsImVuZHNXaXRoIiwiZGVjb2RlZCIsInN1YmRvbWFpbiIsImNvZGUiLCJuZXh0U3ViZG9tYWluIiwiY29kZTIiLCJtdWx0aXBsaWVyIiwiYm5JbmRleCIsIm5ld2lkIiwiU3RhcmtuZXRJZENvbnRyYWN0MiIsImdldFN0YXJrTmFtZSIsImFkZHJlc3MiLCJnZXRDaGFpbklkIiwiaGV4RG9tYWluIiwiY2FsbENvbnRyYWN0IiwiZW50cnlwb2ludCIsImRlY2ltYWxEb21haW4iLCJzdHJpbmdEb21haW4iLCJnZXRBZGRyZXNzRnJvbVN0YXJrTmFtZSIsImFkZHJlc3NEYXRhIiwiZG9tYWluIiwidmFsaWRCbG9ja1RhZ3MiLCJCbG9jayIsIl9pZGVudGlmaWVyIiwidGFnIiwidmFsdWVPZiIsInNldElkZW50aWZpZXIiLCJfX2lkZW50aWZpZXIiLCJxdWVyeUlkZW50aWZpZXIiLCJpZGVudGlmaWVyIiwic2VxdWVuY2VySWRlbnRpZmllciIsImJsb2NrSGFzaCIsImJsb2NrTnVtYmVyIiwibmV0d29ya05hbWUiLCJtdXRlIiwiY29uc29sZSIsIndhcm4iLCJub2RlcyIsInJhbmRJZHgiLCJmbG9vciIsInJhbmRvbSIsImRlZmF1bHRPcHRpb25zIiwiaGVhZGVycyIsImJsb2NrSWRlbnRpZmllciIsInJldHJpZXMiLCJvcHRpb25zT3JQcm92aWRlciIsImdldEJsb2NrSGFzaEFuZE51bWJlciIsImdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQiLCJnZXRTdGF0ZVVwZGF0ZSIsImdldEJsb2NrU3RhdGVVcGRhdGUiLCJ0cmFjZUJsb2NrVHJhbnNhY3Rpb25zIiwiZ2V0QmxvY2tUcmFuc2FjdGlvbnNUcmFjZXMiLCJnZXRUcmFuc2FjdGlvbkNvdW50IiwiZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50IiwidHJhY2VUcmFuc2FjdGlvbiIsImdldFRyYW5zYWN0aW9uVHJhY2UiLCJnZXRTaW11bGF0ZVRyYW5zYWN0aW9uIiwic2ltdWxhdGVUcmFuc2FjdGlvbiIsIm5vZGVVcmwiLCJwYXJhbXMiLCJpZCIsInJwY1JlcXVlc3RCb2R5IiwianNvbnJwYyIsImJvZHkiLCJlcnJvckhhbmRsZXIiLCJycGNFcnJvciIsIm90aGVyRXJyb3IiLCJmZXRjaEVuZHBvaW50IiwicmF3UmVzdWx0IiwiZXJyb3IiLCJnZXRTcGVjVmVyc2lvbiIsImdldE5vbmNlRm9yQWRkcmVzcyIsImJsb2NrX2lkIiwiZ2V0QmxvY2siLCJnZXRCbG9ja1dpdGhUeEhhc2hlcyIsInRoZW4iLCJnZXRCbG9ja051bWJlciIsImdldEJsb2NrV2l0aFR4cyIsImdldFBlbmRpbmdUcmFuc2FjdGlvbnMiLCJnZXRUcmFuc2FjdGlvbkJ5SGFzaCIsImdldFRyYW5zYWN0aW9uIiwidHhIYXNoIiwiZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSWRBbmRJbmRleCIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsImdldFRyYW5zYWN0aW9uU3RhdHVzIiwidHJhbnNhY3Rpb25IYXNoIiwiaW52b2NhdGlvbnMiLCJza2lwVmFsaWRhdGUiLCJza2lwRmVlQ2hhcmdlIiwic2ltdWxhdGlvbkZsYWdzIiwiU0tJUF9WQUxJREFURSIsIlNLSVBfRkVFX0NIQVJHRSIsImJ1aWxkVHJhbnNhY3Rpb24iLCJzaW11bGF0aW9uX2ZsYWdzIiwid2FpdEZvclRyYW5zYWN0aW9uIiwib3B0aW9ucyIsIm9uY2hhaW4iLCJpc0Vycm9yU3RhdGUiLCJyZXRyeUludGVydmFsIiwiZXJyb3JTdGF0ZXMiLCJSRUpFQ1RFRCIsIlJFVkVSVEVEIiwic3VjY2Vzc1N0YXRlcyIsIlNVQ0NFRURFRCIsIkFDQ0VQVEVEX09OX0wyIiwiQUNDRVBURURfT05fTDEiLCJ0eFN0YXR1cyIsImV4ZWN1dGlvblN0YXR1cyIsImV4ZWN1dGlvbl9zdGF0dXMiLCJmaW5hbGl0eVN0YXR1cyIsImZpbmFsaXR5X3N0YXR1cyIsInR4UmVjZWlwdCIsImdldFN0b3JhZ2VBdCIsInBhcnNlZEtleSIsImdldENsYXNzSGFzaEF0IiwiZ2V0Q2xhc3NCeUhhc2giLCJnZXRDbGFzcyIsImNsYXNzX2hhc2giLCJnZXRDbGFzc0F0IiwiZ2V0Q29kZSIsIl9jb250cmFjdEFkZHJlc3MiLCJfYmxvY2tJZGVudGlmaWVyIiwiZ2V0Q29udHJhY3RWZXJzaW9uIiwiYWJpVGVzdCIsImdldEVzdGltYXRlRmVlIiwiaW52b2NhdGlvbiIsImludm9jYXRpb25EZXRhaWxzIiwiZ2V0SW52b2tlRXN0aW1hdGVGZWUiLCJyZXF1ZXN0IiwiZ2V0RGVjbGFyZUVzdGltYXRlRmVlIiwiZGV0YWlscyIsImdldERlcGxveUFjY291bnRFc3RpbWF0ZUZlZSIsImdldEVzdGltYXRlRmVlQnVsayIsImludm9rZUZ1bmN0aW9uIiwiZnVuY3Rpb25JbnZvY2F0aW9uIiwiaW52b2tlX3RyYW5zYWN0aW9uIiwiSU5WT0tFIiwiZGVjbGFyZUNvbnRyYWN0IiwiZGVjbGFyZV90cmFuc2FjdGlvbiIsIkRFQ0xBUkUiLCJjb250cmFjdF9jbGFzcyIsImNvbnRyYWN0X2NsYXNzX3ZlcnNpb24iLCJjb21waWxlZF9jbGFzc19oYXNoIiwiZGVwbG95QWNjb3VudENvbnRyYWN0IiwiYWRkcmVzc1NhbHQiLCJkZXBsb3lfYWNjb3VudF90cmFuc2FjdGlvbiIsImNvbnN0cnVjdG9yX2NhbGxkYXRhIiwiY29udHJhY3RfYWRkcmVzc19zYWx0IiwiREVQTE9ZX0FDQ09VTlQiLCJlbnRyeV9wb2ludF9zZWxlY3RvciIsImVzdGltYXRlTWVzc2FnZUZlZSIsImZyb21fYWRkcmVzcyIsInRvX2FkZHJlc3MiLCJmb3JtYXR0ZWRNZXNzYWdlIiwiZ2V0U3luY2luZ1N0YXRzIiwiZ2V0RXZlbnRzIiwiZXZlbnRGaWx0ZXIiLCJkZWZhdWx0VmVyc2lvbnMiLCJpbXBvcnRfdXJsX2pvaW4yIiwiUmVzcG9uc2VQYXJzZXIiLCJTZXF1ZW5jZXJBUElSZXNwb25zZVBhcnNlciIsInN0YXRlX3Jvb3QiLCJwYXJlbnRfYmxvY2tfaGFzaCIsInBhcnNlR2V0VHJhbnNhY3Rpb25SZWNlaXB0UmVzcG9uc2UiLCJtZXNzYWdlc19zZW50IiwibDJfdG9fbDFfbWVzc2FnZXMiLCJyZXZlcnRfcmVhc29uIiwicmV2ZXJ0X2Vycm9yIiwiZ2FzSW5mbyIsImdhc191c2FnZSIsImFtb3VudCIsInRyYW5zYWN0aW9uX3RyYWNlIiwidHJhY2UiLCJwYXJzZUludm9rZUZ1bmN0aW9uUmVzcG9uc2UiLCJwYXJzZURlcGxveUNvbnRyYWN0UmVzcG9uc2UiLCJwYXJzZURlY2xhcmVDb250cmFjdFJlc3BvbnNlIiwicGFyc2VHZXRTdGF0ZVVwZGF0ZVJlc3BvbnNlIiwibm9uY2VzIiwic3RhdGVfZGlmZiIsInN0b3JhZ2VfZGlmZnMiLCJzdG9yYWdlX2VudHJpZXMiLCJpbXBvcnRfdXJsX2pvaW4iLCJwcm90b2NvbEFuZERvbWFpblJFIiwibG9jYWxob3N0RG9tYWluUkUiLCJub25Mb2NhbGhvc3REb21haW5SRSIsImV2ZXJ5dGhpbmdBZnRlclByb3RvY29sIiwiYmFzZVVybCIsImRlZmF1bHRQYXRoIiwidXJsT3JQYXRoIiwiaXNFbXB0eVF1ZXJ5T2JqZWN0IiwiZXZlcnkiLCJkZWZhdWx0T3B0aW9uczIiLCJuZXR3b3JrIiwiZ2V0TmV0d29ya0Zyb21OYW1lIiwiZmVlZGVyR2F0ZXdheVVybCIsImdhdGV3YXlVcmwiLCJnZXRDaGFpbklkRnJvbUJhc2VVcmwiLCJ1cmwiLCJVUkwiLCJob3N0IiwiZ2V0RmV0Y2hVcmwiLCJlbmRwb2ludCIsImdhdGV3YXlVcmxFbmRwb2ludHMiLCJnZXRGZXRjaE1ldGhvZCIsInBvc3RNZXRob2RFbmRwb2ludHMiLCJnZXRRdWVyeVN0cmluZyIsInF1ZXJ5IiwicXVlcnlTdHJpbmciLCJibG9jayIsImdldEhlYWRlcnMiLCJ0ZXh0UmVzcG9uc2UiLCJvayIsInJlc3BvbnNlQm9keSIsInN0YXR1c1RleHQiLCJwYXJzZUNob2ljZSIsInBhcnNlQWx3YXlzQXNCaWdJbnQiLCJyZXNvbHZlIiwidHhIYXNoSGV4IiwiZ2V0Q29tcGlsZWRDbGFzc0J5Q2xhc3NIYXNoIiwiY29tcGxldGVkIiwidHhfZmFpbHVyZV9yZWFzb24iLCJ0eF9zdGF0dXMiLCJlcnJvcl9tZXNzYWdlIiwidHhfcmV2ZXJ0X3JlYXNvbiIsImdldENvbnRyYWN0QWRkcmVzc2VzIiwidmFsaWRDYWxsTDFIYW5kbGVyIiwic2tpcEV4ZWN1dGUiLCJnZXRCbG9ja1RyYWNlcyIsInByb3ZpZGVyT3JPcHRpb25zIiwicnBjIiwic2VxdWVuY2VyIiwiaW52b2NhdGlvbldpdGhUeFR5cGUiLCJmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YSIsImZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhV2l0aE5vbmNlIiwiZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xIiwiZ2V0RXhlY3V0ZUNhbGxkYXRhIiwidHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5cyIsInRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXNfY2Fpcm8xIiwiY2FsbHMiLCJkYXRhX29mZnNldCIsImRhdGFfbGVuIiwiY29tcGlsZWRDYWxscyIsIm9yZGVyQ2FsbHMiLCJjYWlyb1ZlcnNpb24iLCJlbmNvZGVEYXRhIiwiZW5jb2RlVHlwZSIsImVuY29kZVZhbHVlIiwiZ2V0RGVwZW5kZW5jaWVzIiwiZ2V0TWVzc2FnZUhhc2giLCJnZXRTdHJ1Y3RIYXNoIiwiZ2V0VHlwZUhhc2giLCJpc01lcmtsZVRyZWVUeXBlIiwicHJlcGFyZVNlbGVjdG9yIiwiTWVya2xlVHJlZSIsInByb29mTWVya2xlUGF0aCIsImxlYWZIYXNoZXMiLCJicmFuY2hlcyIsImxlYXZlcyIsInJvb3QiLCJidWlsZCIsIm5ld0xlYXZlcyIsImFTb3J0ZWQiLCJiU29ydGVkIiwic29ydCIsImdldFByb29mIiwibGVhZiIsImJyYW5jaCIsImhhc2hQYXRoIiwiaXNMZWZ0IiwibmVlZGVkQnJhbmNoIiwibmV3SGFzaFBhdGgiLCJjdXJyZW50QnJhbmNoTGV2ZWxJbmRleCIsIm5leHRCcmFuY2giLCJwYXRoIiwicmVzdCIsImdldEhleCIsInZhbGlkYXRlVHlwZWREYXRhIiwidmFsaWQiLCJwcmltYXJ5VHlwZSIsImRlcGVuZGVuY2llcyIsInByZXZpb3VzIiwidCIsImRlcGVuZGVuY3kiLCJnZXRNZXJrbGVUcmVlVHlwZSIsImN0eCIsInBhcmVudCIsInBhcmVudFR5cGUiLCJtZXJrbGVUeXBlIiwiaXNNZXJrbGVUcmVlIiwiY29udGFpbnMiLCJwcmltYXJ5IiwibmV3VHlwZXMiLCJzdHJ1Y3RIYXNoZXMiLCJzdHJ1Y3QiLCJtZXJrbGVUcmVlVHlwZSIsInJldHVyblR5cGVzIiwidHMiLCJ2cyIsImZpZWxkIiwiZW5jb2RlZFZhbHVlIiwiYWNjb3VudCIsInBrIiwiZ2V0UHViS2V5Iiwic2lnbk1lc3NhZ2UiLCJhY2NvdW50QWRkcmVzcyIsIm1zZ0hhc2giLCJzaWduIiwic2lnblRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25zRGV0YWlsIiwiYWJpcyIsIndhbGxldEFkZHJlc3MiLCJzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uIiwic2lnbkRlY2xhcmVUcmFuc2FjdGlvbiIsImV2ZW50IiwiZGVwbG95ZXIiLCJ1bmlxdWUiLCJjYWxsZGF0YV9sZW4iLCJwa09yU2lnbmVyIiwiZGVwbG95U2VsZiIsImRlcGxveUFjY291bnQiLCJzaWduZXIiLCJnZXROb25jZSIsImdldE5vbmNlU2FmZSIsImdldENhaXJvVmVyc2lvbiIsImVzdGltYXRlRmVlIiwiZXN0aW1hdGVGZWVEZXRhaWxzIiwiZXN0aW1hdGVJbnZva2VGZWUiLCJwcm92aWRlZE5vbmNlIiwic2lnbmVyRGV0YWlscyIsImJ1aWxkSW52b2NhdGlvbiIsImVzdGltYXRlRGVjbGFyZUZlZSIsInByb3ZpZGVkQ2xhc3NIYXNoIiwiZGVjbGFyZUNvbnRyYWN0VHJhbnNhY3Rpb24iLCJidWlsZERlY2xhcmVQYXlsb2FkIiwiZXN0aW1hdGVBY2NvdW50RGVwbG95RmVlIiwicHJvdmlkZWRDb250cmFjdEFkZHJlc3MiLCJidWlsZEFjY291bnREZXBsb3lQYXlsb2FkIiwiZXN0aW1hdGVEZXBsb3lGZWUiLCJidWlsZFVEQ0NvbnRyYWN0UGF5bG9hZCIsImVzdGltYXRlRmVlQnVsayIsImFjY291bnRJbnZvY2F0aW9ucyIsImFjY291bnRJbnZvY2F0aW9uc0ZhY3RvcnkiLCJ2ZXJzaW9ucyIsImVsZW0iLCJleGVjdXRlIiwiZ2V0U3VnZ2VzdGVkTWF4RmVlIiwiZGVjbGFyZUlmTm90IiwiZGVjbGFyZUNvbnRyYWN0UGF5bG9hZCIsImRlY2xhcmUiLCJkZXBsb3kiLCJjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEiLCJkZXBsb3lTYWx0IiwiYWRkcmVzc2VzIiwiaW52b2tlUmVzcG9uc2UiLCJkZXBsb3lDb250cmFjdCIsImRlcGxveVR4IiwiZGVjbGFyZUFuZERlcGxveSIsInR4IiwiaGFzaE1lc3NhZ2UiLCJ2ZXJpZnlNZXNzYWdlSGFzaCIsInZlcmlmeU1lc3NhZ2UiLCJmZWVFc3RpbWF0ZSIsImNvbXByZXNzZWRDb21waWxlZENvbnRyYWN0Iiwic2FmZU5vbmNlIiwidHgwUGF5bG9hZCIsInR4UGF5bG9hZCIsImNvbW1vbiIsImdldEFiaUV2ZW50cyIsInBhcnNlRXZlbnRzIiwic2l6ZSIsImtpbmQiLCJlbnRyeU5hbWUiLCJhYmlFbnRyeU1vZCIsInByb3ZpZGVyUmVjZWl2ZWRFdmVudHMiLCJhYmlFdmVudHMiLCJhYmlTdHJ1Y3RzIiwiYWJpRW51bXMiLCJyZXQiLCJyZWNFdmVudCIsImFiaUV2ZW50IiwicGFyc2VkRXZlbnQiLCJrZXlzSXRlciIsImRhdGFJdGVyIiwiYWJpRXZlbnRLZXlzIiwiYWJpRXZlbnREYXRhIiwibGFzdEFyZyIsInNvbWUiLCJwb3AiLCJidWlsZENhbGwiLCJmdW5jdGlvbkFiaSIsInBhcnNlUmVxdWVzdCIsInBhcnNlUmVzcG9uc2UiLCJidWlsZEludm9rZSIsImludm9rZSIsImJ1aWxkRGVmYXVsdCIsImJ1aWxkUG9wdWxhdGUiLCJwb3B1bGF0ZSIsImJ1aWxkRXN0aW1hdGUiLCJlc3RpbWF0ZSIsImNhbGxiYWNrIiwicHJvdmlkZXJPckFjY291bnQiLCJjYWxsRGF0YSIsImRlZmluZVByb3BlcnRpZXMiLCJmdW5jdGlvbnMiLCJjYWxsU3RhdGljIiwicG9wdWxhdGVUcmFuc2FjdGlvbiIsImFiaUVsZW1lbnQiLCJhdHRhY2giLCJjb25uZWN0IiwiZGVwbG95ZWQiLCJkZXBsb3lUcmFuc2FjdGlvbkhhc2giLCJmb3JtYXRSZXNwb25zZSIsInJlY2VpcHQiLCJpc0NhaXJvMSIsImdldFZlcnNpb24iLCJ0eXBlZCIsInRBYmkiLCJjb250cmFjdEluc3RhbmNlIiwiaW1wb3J0X3V0aWxzNCIsImNoYXJzIiwiaGFzaGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/starknet/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AccountInterface: () => (/* binding */ AccountInterface),\n/* harmony export */   BlockStatus: () => (/* binding */ BlockStatus),\n/* harmony export */   BlockTag: () => (/* binding */ BlockTag),\n/* harmony export */   CairoCustomEnum: () => (/* binding */ CairoCustomEnum),\n/* harmony export */   CairoOption: () => (/* binding */ CairoOption),\n/* harmony export */   CairoOptionVariant: () => (/* binding */ CairoOptionVariant),\n/* harmony export */   CairoResult: () => (/* binding */ CairoResult),\n/* harmony export */   CairoResultVariant: () => (/* binding */ CairoResultVariant),\n/* harmony export */   CallData: () => (/* binding */ CallData),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   ContractFactory: () => (/* binding */ ContractFactory),\n/* harmony export */   ContractInterface: () => (/* binding */ ContractInterface),\n/* harmony export */   CustomError: () => (/* binding */ CustomError),\n/* harmony export */   EntryPointType: () => (/* binding */ EntryPointType),\n/* harmony export */   GatewayError: () => (/* binding */ GatewayError),\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   LibraryError: () => (/* binding */ LibraryError),\n/* harmony export */   Litteral: () => (/* binding */ Litteral),\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   ProviderInterface: () => (/* binding */ ProviderInterface),\n/* harmony export */   RPC: () => (/* binding */ rpc_exports),\n/* harmony export */   RpcProvider: () => (/* binding */ RpcProvider),\n/* harmony export */   SIMULATION_FLAG: () => (/* binding */ SIMULATION_FLAG),\n/* harmony export */   Sequencer: () => (/* binding */ sequencer_exports),\n/* harmony export */   SequencerProvider: () => (/* binding */ SequencerProvider),\n/* harmony export */   Signer: () => (/* binding */ Signer),\n/* harmony export */   SignerInterface: () => (/* binding */ SignerInterface),\n/* harmony export */   TransactionExecutionStatus: () => (/* binding */ TransactionExecutionStatus),\n/* harmony export */   TransactionFinalityStatus: () => (/* binding */ TransactionFinalityStatus),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   TransactionType: () => (/* binding */ TransactionType),\n/* harmony export */   Uint: () => (/* binding */ Uint),\n/* harmony export */   ValidateType: () => (/* binding */ ValidateType),\n/* harmony export */   addAddressPadding: () => (/* binding */ addAddressPadding),\n/* harmony export */   buildUrl: () => (/* binding */ buildUrl),\n/* harmony export */   cairo: () => (/* binding */ cairo_exports),\n/* harmony export */   constants: () => (/* binding */ constants_exports),\n/* harmony export */   contractClassResponseToLegacyCompiledContract: () => (/* binding */ contractClassResponseToLegacyCompiledContract),\n/* harmony export */   defaultProvider: () => (/* binding */ defaultProvider),\n/* harmony export */   ec: () => (/* binding */ ec_exports),\n/* harmony export */   encode: () => (/* binding */ encode_exports),\n/* harmony export */   events: () => (/* binding */ events_exports),\n/* harmony export */   extractContractHashes: () => (/* binding */ extractContractHashes),\n/* harmony export */   fixProto: () => (/* binding */ fixProto),\n/* harmony export */   fixStack: () => (/* binding */ fixStack),\n/* harmony export */   getCalldata: () => (/* binding */ getCalldata),\n/* harmony export */   getChecksumAddress: () => (/* binding */ getChecksumAddress),\n/* harmony export */   getDefaultNodeUrl: () => (/* binding */ getDefaultNodeUrl),\n/* harmony export */   hash: () => (/* binding */ hash_exports),\n/* harmony export */   isSierra: () => (/* binding */ isSierra),\n/* harmony export */   isUrl: () => (/* binding */ isUrl),\n/* harmony export */   json: () => (/* binding */ json_exports),\n/* harmony export */   merkle: () => (/* binding */ merkle_exports),\n/* harmony export */   num: () => (/* binding */ num_exports),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   parseUDCEvent: () => (/* binding */ parseUDCEvent),\n/* harmony export */   provider: () => (/* binding */ provider_exports),\n/* harmony export */   selector: () => (/* binding */ selector_exports),\n/* harmony export */   shortString: () => (/* binding */ shortString_exports),\n/* harmony export */   splitArgsAndOptions: () => (/* binding */ splitArgsAndOptions),\n/* harmony export */   stark: () => (/* binding */ stark_exports),\n/* harmony export */   starknetId: () => (/* binding */ starknetId_exports),\n/* harmony export */   transaction: () => (/* binding */ transaction_exports),\n/* harmony export */   typedData: () => (/* binding */ typedData_exports),\n/* harmony export */   types: () => (/* binding */ types_exports),\n/* harmony export */   uint256: () => (/* binding */ uint256_exports),\n/* harmony export */   validateAndParseAddress: () => (/* binding */ validateAndParseAddress),\n/* harmony export */   validateChecksumAddress: () => (/* binding */ validateChecksumAddress)\n/* harmony export */ });\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _scure_starknet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @scure/starknet */ \"(ssr)/./node_modules/@scure/starknet/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/abstract/weierstrass */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var lossless_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lossless-json */ \"(ssr)/./node_modules/lossless-json/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/abstract/poseidon */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/poseidon.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/dist/pako.esm.mjs\");\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! isomorphic-fetch */ \"(ssr)/./node_modules/isomorphic-fetch/fetch-npm-node.js\");\n/* harmony import */ var url_join__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! url-join */ \"(ssr)/./node_modules/url-join/lib/url-join.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\n// src/constants.ts\nvar constants_exports = {};\n__export(constants_exports, {\n    API_VERSION: ()=>API_VERSION,\n    BN_FEE_TRANSACTION_VERSION_1: ()=>BN_FEE_TRANSACTION_VERSION_1,\n    BN_FEE_TRANSACTION_VERSION_2: ()=>BN_FEE_TRANSACTION_VERSION_2,\n    BN_TRANSACTION_VERSION_1: ()=>BN_TRANSACTION_VERSION_1,\n    BN_TRANSACTION_VERSION_2: ()=>BN_TRANSACTION_VERSION_2,\n    BaseUrl: ()=>BaseUrl,\n    HEX_STR_TRANSACTION_VERSION_1: ()=>HEX_STR_TRANSACTION_VERSION_1,\n    HEX_STR_TRANSACTION_VERSION_2: ()=>HEX_STR_TRANSACTION_VERSION_2,\n    IS_BROWSER: ()=>IS_BROWSER,\n    MASK_250: ()=>MASK_250,\n    MASK_251: ()=>MASK_251,\n    NetworkName: ()=>NetworkName,\n    RPC_GOERLI_NODES: ()=>RPC_GOERLI_NODES,\n    RPC_MAINNET_NODES: ()=>RPC_MAINNET_NODES,\n    StarknetChainId: ()=>StarknetChainId,\n    TEXT_TO_FELT_MAX_LEN: ()=>TEXT_TO_FELT_MAX_LEN,\n    TransactionHashPrefix: ()=>TransactionHashPrefix,\n    UDC: ()=>UDC,\n    ZERO: ()=>ZERO\n});\n// src/utils/encode.ts\nvar encode_exports = {};\n__export(encode_exports, {\n    IS_BROWSER: ()=>IS_BROWSER,\n    addHexPrefix: ()=>addHexPrefix,\n    arrayBufferToString: ()=>arrayBufferToString,\n    atobUniversal: ()=>atobUniversal,\n    btoaUniversal: ()=>btoaUniversal,\n    buf2hex: ()=>buf2hex,\n    calcByteLength: ()=>calcByteLength,\n    padLeft: ()=>padLeft,\n    pascalToSnake: ()=>pascalToSnake,\n    removeHexPrefix: ()=>removeHexPrefix,\n    sanitizeBytes: ()=>sanitizeBytes,\n    sanitizeHex: ()=>sanitizeHex,\n    stringToArrayBuffer: ()=>stringToArrayBuffer,\n    utf8ToArray: ()=>utf8ToArray\n});\n\nvar IS_BROWSER = \"undefined\" !== \"undefined\";\nvar STRING_ZERO = \"0\";\nfunction arrayBufferToString(array) {\n    return new Uint8Array(array).reduce((data, byte)=>data + String.fromCharCode(byte), \"\");\n}\nfunction utf8ToArray(str) {\n    return new TextEncoder().encode(str);\n}\nfunction stringToArrayBuffer(str) {\n    return utf8ToArray(str);\n}\nfunction atobUniversal(a) {\n    return _scure_base__WEBPACK_IMPORTED_MODULE_0__.base64.decode(a);\n}\nfunction btoaUniversal(b) {\n    return _scure_base__WEBPACK_IMPORTED_MODULE_0__.base64.encode(new Uint8Array(b));\n}\nfunction buf2hex(buffer) {\n    return buffer.reduce((r, x)=>r + x.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction removeHexPrefix(hex) {\n    return hex.replace(/^0x/i, \"\");\n}\nfunction addHexPrefix(hex) {\n    return `0x${removeHexPrefix(hex)}`;\n}\nfunction padString(str, length, left, padding = STRING_ZERO) {\n    const diff = length - str.length;\n    let result = str;\n    if (diff > 0) {\n        const pad = padding.repeat(diff);\n        result = left ? pad + str : str + pad;\n    }\n    return result;\n}\nfunction padLeft(str, length, padding = STRING_ZERO) {\n    return padString(str, length, true, padding);\n}\nfunction calcByteLength(str, byteSize = 8) {\n    const { length } = str;\n    const remainder = length % byteSize;\n    return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;\n}\nfunction sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {\n    return padLeft(str, calcByteLength(str, byteSize), padding);\n}\nfunction sanitizeHex(hex) {\n    hex = removeHexPrefix(hex);\n    hex = sanitizeBytes(hex, 2);\n    if (hex) {\n        hex = addHexPrefix(hex);\n    }\n    return hex;\n}\nvar pascalToSnake = (text)=>/[a-z]/.test(text) ? text.split(/(?=[A-Z])/).join(\"_\").toUpperCase() : text;\n// src/constants.ts\nvar TEXT_TO_FELT_MAX_LEN = 31;\nvar HEX_STR_TRANSACTION_VERSION_1 = \"0x1\";\nvar HEX_STR_TRANSACTION_VERSION_2 = \"0x2\";\nvar BN_TRANSACTION_VERSION_1 = 1n;\nvar BN_TRANSACTION_VERSION_2 = 2n;\nvar BN_FEE_TRANSACTION_VERSION_1 = 2n ** 128n + BN_TRANSACTION_VERSION_1;\nvar BN_FEE_TRANSACTION_VERSION_2 = 2n ** 128n + BN_TRANSACTION_VERSION_2;\nvar ZERO = 0n;\nvar MASK_250 = 2n ** 250n - 1n;\nvar MASK_251 = 2n ** 251n;\nvar API_VERSION = ZERO;\nvar BaseUrl = /* @__PURE__ */ ((BaseUrl2)=>{\n    BaseUrl2[\"SN_MAIN\"] = \"https://alpha-mainnet.starknet.io\";\n    BaseUrl2[\"SN_GOERLI\"] = \"https://alpha4.starknet.io\";\n    return BaseUrl2;\n})(BaseUrl || {});\nvar NetworkName = /* @__PURE__ */ ((NetworkName2)=>{\n    NetworkName2[\"SN_MAIN\"] = \"SN_MAIN\";\n    NetworkName2[\"SN_GOERLI\"] = \"SN_GOERLI\";\n    return NetworkName2;\n})(NetworkName || {});\nvar StarknetChainId = /* @__PURE__ */ ((StarknetChainId4)=>{\n    StarknetChainId4[\"SN_MAIN\"] = \"0x534e5f4d41494e\";\n    StarknetChainId4[\"SN_GOERLI\"] = \"0x534e5f474f45524c49\";\n    return StarknetChainId4;\n})(StarknetChainId || {});\nvar TransactionHashPrefix = /* @__PURE__ */ ((TransactionHashPrefix2)=>{\n    TransactionHashPrefix2[\"DECLARE\"] = \"0x6465636c617265\";\n    TransactionHashPrefix2[\"DEPLOY\"] = \"0x6465706c6f79\";\n    TransactionHashPrefix2[\"DEPLOY_ACCOUNT\"] = \"0x6465706c6f795f6163636f756e74\";\n    TransactionHashPrefix2[\"INVOKE\"] = \"0x696e766f6b65\";\n    TransactionHashPrefix2[\"L1_HANDLER\"] = \"0x6c315f68616e646c6572\";\n    return TransactionHashPrefix2;\n})(TransactionHashPrefix || {});\nvar UDC = {\n    ADDRESS: \"0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf\",\n    ENTRYPOINT: \"deployContract\"\n};\nvar RPC_GOERLI_NODES = [\n    \"https://starknet-testnet.public.blastapi.io/rpc/v0.5\",\n    \"https://limited-rpc.nethermind.io/goerli-juno/v0_5\"\n];\nvar RPC_MAINNET_NODES = [\n    \"https://starknet-mainnet.public.blastapi.io/rpc/v0.5\",\n    \"https://limited-rpc.nethermind.io/mainnet-juno/v0_5\"\n];\n// src/types/index.ts\nvar types_exports = {};\n__export(types_exports, {\n    BlockStatus: ()=>BlockStatus,\n    BlockTag: ()=>BlockTag,\n    EntryPointType: ()=>EntryPointType,\n    Litteral: ()=>Litteral,\n    RPC: ()=>rpc_exports,\n    SIMULATION_FLAG: ()=>SIMULATION_FLAG,\n    Sequencer: ()=>sequencer_exports,\n    TransactionExecutionStatus: ()=>TransactionExecutionStatus,\n    TransactionFinalityStatus: ()=>TransactionFinalityStatus,\n    TransactionStatus: ()=>TransactionStatus,\n    TransactionType: ()=>TransactionType,\n    Uint: ()=>Uint,\n    ValidateType: ()=>ValidateType\n});\n// src/types/account.ts\nvar SIMULATION_FLAG = /* @__PURE__ */ ((SIMULATION_FLAG2)=>{\n    SIMULATION_FLAG2[\"SKIP_VALIDATE\"] = \"SKIP_VALIDATE\";\n    SIMULATION_FLAG2[\"SKIP_EXECUTE\"] = \"SKIP_EXECUTE\";\n    return SIMULATION_FLAG2;\n})(SIMULATION_FLAG || {});\n// src/types/calldata.ts\nvar ValidateType = /* @__PURE__ */ ((ValidateType2)=>{\n    ValidateType2[\"DEPLOY\"] = \"DEPLOY\";\n    ValidateType2[\"CALL\"] = \"CALL\";\n    ValidateType2[\"INVOKE\"] = \"INVOKE\";\n    return ValidateType2;\n})(ValidateType || {});\nvar Uint = /* @__PURE__ */ ((Uint2)=>{\n    Uint2[\"u8\"] = \"core::integer::u8\";\n    Uint2[\"u16\"] = \"core::integer::u16\";\n    Uint2[\"u32\"] = \"core::integer::u32\";\n    Uint2[\"u64\"] = \"core::integer::u64\";\n    Uint2[\"u128\"] = \"core::integer::u128\";\n    Uint2[\"u256\"] = \"core::integer::u256\";\n    return Uint2;\n})(Uint || {});\nvar Litteral = /* @__PURE__ */ ((Litteral2)=>{\n    Litteral2[\"ClassHash\"] = \"core::starknet::class_hash::ClassHash\";\n    Litteral2[\"ContractAddress\"] = \"core::starknet::contract_address::ContractAddress\";\n    return Litteral2;\n})(Litteral || {});\n// src/types/lib/contract/index.ts\nvar EntryPointType = /* @__PURE__ */ ((EntryPointType2)=>{\n    EntryPointType2[\"EXTERNAL\"] = \"EXTERNAL\";\n    EntryPointType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n    EntryPointType2[\"CONSTRUCTOR\"] = \"CONSTRUCTOR\";\n    return EntryPointType2;\n})(EntryPointType || {});\n// src/types/lib/index.ts\nvar TransactionType = /* @__PURE__ */ ((TransactionType2)=>{\n    TransactionType2[\"DECLARE\"] = \"DECLARE\";\n    TransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n    TransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n    TransactionType2[\"INVOKE\"] = \"INVOKE_FUNCTION\";\n    return TransactionType2;\n})(TransactionType || {});\nvar TransactionStatus = /* @__PURE__ */ ((TransactionStatus2)=>{\n    TransactionStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n    TransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n    TransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    TransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    TransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n    TransactionStatus2[\"REVERTED\"] = \"REVERTED\";\n    return TransactionStatus2;\n})(TransactionStatus || {});\nvar TransactionFinalityStatus = /* @__PURE__ */ ((TransactionFinalityStatus2)=>{\n    TransactionFinalityStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n    TransactionFinalityStatus2[\"RECEIVED\"] = \"RECEIVED\";\n    TransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    TransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    return TransactionFinalityStatus2;\n})(TransactionFinalityStatus || {});\nvar TransactionExecutionStatus = /* @__PURE__ */ ((TransactionExecutionStatus2)=>{\n    TransactionExecutionStatus2[\"REJECTED\"] = \"REJECTED\";\n    TransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n    TransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n    return TransactionExecutionStatus2;\n})(TransactionExecutionStatus || {});\nvar BlockStatus = /* @__PURE__ */ ((BlockStatus2)=>{\n    BlockStatus2[\"PENDING\"] = \"PENDING\";\n    BlockStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    BlockStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    BlockStatus2[\"REJECTED\"] = \"REJECTED\";\n    return BlockStatus2;\n})(BlockStatus || {});\nvar BlockTag = /* @__PURE__ */ ((BlockTag2)=>{\n    BlockTag2[\"pending\"] = \"pending\";\n    BlockTag2[\"latest\"] = \"latest\";\n    return BlockTag2;\n})(BlockTag || {});\n// src/types/api/rpc.ts\nvar rpc_exports = {};\n__export(rpc_exports, {\n    EBlockTag: ()=>EBlockTag,\n    EDataAvailabilityMode: ()=>EDataAvailabilityMode,\n    ESimulationFlag: ()=>ESimulationFlag,\n    ETransactionExecutionStatus: ()=>ETransactionExecutionStatus,\n    ETransactionFinalityStatus: ()=>ETransactionFinalityStatus,\n    ETransactionStatus: ()=>ETransactionStatus,\n    ETransactionType: ()=>ETransactionType,\n    Errors: ()=>errors_exports,\n    JRPC: ()=>jsonrpc_exports,\n    SPEC: ()=>components_exports\n});\n// src/types/api/jsonrpc/index.ts\nvar jsonrpc_exports = {};\n// src/types/api/rpcspec/errors.ts\nvar errors_exports = {};\n// src/types/api/rpcspec/components.ts\nvar components_exports = {};\n// src/types/api/rpcspec/nonspec.ts\nvar ETransactionType = /* @__PURE__ */ ((ETransactionType2)=>{\n    ETransactionType2[\"DECLARE\"] = \"DECLARE\";\n    ETransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n    ETransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n    ETransactionType2[\"INVOKE\"] = \"INVOKE\";\n    ETransactionType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n    return ETransactionType2;\n})(ETransactionType || {});\nvar ESimulationFlag = /* @__PURE__ */ ((ESimulationFlag2)=>{\n    ESimulationFlag2[\"SKIP_VALIDATE\"] = \"SKIP_VALIDATE\";\n    ESimulationFlag2[\"SKIP_FEE_CHARGE\"] = \"SKIP_FEE_CHARGE\";\n    return ESimulationFlag2;\n})(ESimulationFlag || {});\nvar ETransactionStatus = /* @__PURE__ */ ((ETransactionStatus2)=>{\n    ETransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n    ETransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n    ETransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    ETransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    return ETransactionStatus2;\n})(ETransactionStatus || {});\nvar ETransactionFinalityStatus = /* @__PURE__ */ ((ETransactionFinalityStatus2)=>{\n    ETransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    ETransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    return ETransactionFinalityStatus2;\n})(ETransactionFinalityStatus || {});\nvar ETransactionExecutionStatus = /* @__PURE__ */ ((ETransactionExecutionStatus2)=>{\n    ETransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n    ETransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n    return ETransactionExecutionStatus2;\n})(ETransactionExecutionStatus || {});\nvar EBlockTag = /* @__PURE__ */ ((EBlockTag2)=>{\n    EBlockTag2[\"LATEST\"] = \"latest\";\n    EBlockTag2[\"PENDING\"] = \"pending\";\n    return EBlockTag2;\n})(EBlockTag || {});\nvar EDataAvailabilityMode = /* @__PURE__ */ ((EDataAvailabilityMode2)=>{\n    EDataAvailabilityMode2[\"L1\"] = \"L1\";\n    EDataAvailabilityMode2[\"L2\"] = \"L2\";\n    return EDataAvailabilityMode2;\n})(EDataAvailabilityMode || {});\n// src/types/api/sequencer.ts\nvar sequencer_exports = {};\n// src/utils/assert.ts\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failure\");\n    }\n}\n// src/utils/num.ts\nvar num_exports = {};\n__export(num_exports, {\n    assertInRange: ()=>assertInRange,\n    bigNumberishArrayToDecimalStringArray: ()=>bigNumberishArrayToDecimalStringArray,\n    bigNumberishArrayToHexadecimalStringArray: ()=>bigNumberishArrayToHexadecimalStringArray,\n    cleanHex: ()=>cleanHex,\n    getDecimalString: ()=>getDecimalString,\n    getHexString: ()=>getHexString,\n    getHexStringArray: ()=>getHexStringArray,\n    hexToBytes: ()=>hexToBytes,\n    hexToDecimalString: ()=>hexToDecimalString,\n    isBigInt: ()=>isBigInt,\n    isHex: ()=>isHex,\n    isStringWholeNumber: ()=>isStringWholeNumber,\n    toBigInt: ()=>toBigInt,\n    toCairoBool: ()=>toCairoBool,\n    toHex: ()=>toHex,\n    toHexString: ()=>toHexString,\n    toStorageKey: ()=>toStorageKey\n});\n\nfunction isHex(hex) {\n    return /^0x[0-9a-f]*$/i.test(hex);\n}\nfunction toBigInt(value) {\n    return BigInt(value);\n}\nfunction isBigInt(value) {\n    return typeof value === \"bigint\";\n}\nfunction toHex(number2) {\n    return addHexPrefix(toBigInt(number2).toString(16));\n}\nvar toHexString = toHex;\nfunction toStorageKey(number2) {\n    const res = addHexPrefix(toBigInt(number2).toString(16).padStart(64, \"0\"));\n    return res;\n}\nfunction hexToDecimalString(hex) {\n    return BigInt(addHexPrefix(hex)).toString(10);\n}\nvar cleanHex = (hex)=>hex.toLowerCase().replace(/^(0x)0+/, \"$1\");\nfunction assertInRange(input, lowerBound, upperBound, inputName = \"\") {\n    const messageSuffix = inputName === \"\" ? \"invalid length\" : `invalid ${inputName} length`;\n    const inputBigInt = BigInt(input);\n    const lowerBoundBigInt = BigInt(lowerBound);\n    const upperBoundBigInt = BigInt(upperBound);\n    assert(inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt, `Message not signable, ${messageSuffix}.`);\n}\nfunction bigNumberishArrayToDecimalStringArray(rawCalldata) {\n    return rawCalldata.map((x)=>toBigInt(x).toString(10));\n}\nfunction bigNumberishArrayToHexadecimalStringArray(rawCalldata) {\n    return rawCalldata.map((x)=>toHex(x));\n}\nvar isStringWholeNumber = (value)=>/^\\d+$/.test(value);\nfunction getDecimalString(value) {\n    if (isHex(value)) {\n        return hexToDecimalString(value);\n    }\n    if (isStringWholeNumber(value)) {\n        return value;\n    }\n    throw new Error(`${value} need to be hex-string or whole-number-string`);\n}\nfunction getHexString(value) {\n    if (isHex(value)) {\n        return value;\n    }\n    if (isStringWholeNumber(value)) {\n        return toHexString(value);\n    }\n    throw new Error(`${value} need to be hex-string or whole-number-string`);\n}\nfunction getHexStringArray(value) {\n    return value.map((el)=>getHexString(el));\n}\nvar toCairoBool = (value)=>(+value).toString();\nfunction hexToBytes(value) {\n    if (!isHex(value)) throw new Error(`${value} need to be a hex-string`);\n    let adaptedValue = removeHexPrefix(value);\n    if (adaptedValue.length % 2 !== 0) {\n        adaptedValue = `0${adaptedValue}`;\n    }\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(adaptedValue);\n}\n// src/utils/selector.ts\nvar selector_exports = {};\n__export(selector_exports, {\n    getSelector: ()=>getSelector,\n    getSelectorFromName: ()=>getSelectorFromName,\n    keccakBn: ()=>keccakBn,\n    starknetKeccak: ()=>starknetKeccak\n});\n\nfunction keccakBn(value) {\n    const hexWithoutPrefix = removeHexPrefix(toHex(BigInt(value)));\n    const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;\n    return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak)(hexToBytes(addHexPrefix(evenHex))).toString(16));\n}\nfunction keccakHex(str) {\n    return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak)(utf8ToArray(str)).toString(16));\n}\nfunction starknetKeccak(str) {\n    const hash = BigInt(keccakHex(str));\n    return hash & MASK_250;\n}\nfunction getSelectorFromName(funcName) {\n    return toHex(starknetKeccak(funcName));\n}\nfunction getSelector(value) {\n    if (isHex(value)) {\n        return value;\n    }\n    if (isStringWholeNumber(value)) {\n        return toHexString(value);\n    }\n    return getSelectorFromName(value);\n}\n// src/utils/shortString.ts\nvar shortString_exports = {};\n__export(shortString_exports, {\n    decodeShortString: ()=>decodeShortString,\n    encodeShortString: ()=>encodeShortString,\n    isASCII: ()=>isASCII,\n    isDecimalString: ()=>isDecimalString,\n    isLongText: ()=>isLongText,\n    isShortString: ()=>isShortString,\n    isShortText: ()=>isShortText,\n    isText: ()=>isText,\n    splitLongString: ()=>splitLongString\n});\nfunction isASCII(str) {\n    return /^[\\x00-\\x7F]*$/.test(str);\n}\nfunction isShortString(str) {\n    return str.length <= TEXT_TO_FELT_MAX_LEN;\n}\nfunction isDecimalString(str) {\n    return /^[0-9]*$/i.test(str);\n}\nfunction isText(val) {\n    return typeof val === \"string\" && !isHex(val) && !isStringWholeNumber(val);\n}\nvar isShortText = (val)=>isText(val) && isShortString(val);\nvar isLongText = (val)=>isText(val) && !isShortString(val);\nfunction splitLongString(longStr) {\n    const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, \"g\");\n    return longStr.match(regex) || [];\n}\nfunction encodeShortString(str) {\n    if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n    if (!isShortString(str)) throw new Error(`${str} is too long`);\n    return addHexPrefix(str.replace(/./g, (char)=>char.charCodeAt(0).toString(16)));\n}\nfunction decodeShortString(str) {\n    if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n    if (isHex(str)) {\n        return removeHexPrefix(str).replace(/.{2}/g, (hex)=>String.fromCharCode(parseInt(hex, 16)));\n    }\n    if (isDecimalString(str)) {\n        return decodeShortString(\"0X\".concat(BigInt(str).toString(16)));\n    }\n    throw new Error(`${str} is not Hex or decimal`);\n}\n// src/utils/calldata/cairo.ts\nvar cairo_exports = {};\n__export(cairo_exports, {\n    felt: ()=>felt,\n    getAbiContractVersion: ()=>getAbiContractVersion,\n    getArrayType: ()=>getArrayType,\n    isCairo1Abi: ()=>isCairo1Abi,\n    isCairo1Type: ()=>isCairo1Type,\n    isLen: ()=>isLen,\n    isTypeArray: ()=>isTypeArray,\n    isTypeBool: ()=>isTypeBool,\n    isTypeContractAddress: ()=>isTypeContractAddress,\n    isTypeEnum: ()=>isTypeEnum,\n    isTypeEthAddress: ()=>isTypeEthAddress,\n    isTypeFelt: ()=>isTypeFelt,\n    isTypeLitteral: ()=>isTypeLitteral,\n    isTypeNamedTuple: ()=>isTypeNamedTuple,\n    isTypeOption: ()=>isTypeOption,\n    isTypeResult: ()=>isTypeResult,\n    isTypeStruct: ()=>isTypeStruct,\n    isTypeTuple: ()=>isTypeTuple,\n    isTypeUint: ()=>isTypeUint,\n    isTypeUint256: ()=>isTypeUint256,\n    tuple: ()=>tuple,\n    uint256: ()=>uint256\n});\n// src/utils/uint256.ts\nvar uint256_exports = {};\n__export(uint256_exports, {\n    UINT_128_MAX: ()=>UINT_128_MAX,\n    UINT_256_MAX: ()=>UINT_256_MAX,\n    bnToUint256: ()=>bnToUint256,\n    isUint256: ()=>isUint256,\n    uint256ToBN: ()=>uint256ToBN\n});\nvar UINT_128_MAX = (1n << 128n) - 1n;\nvar UINT_256_MAX = (1n << 256n) - 1n;\nfunction uint256ToBN(uint2562) {\n    return (toBigInt(uint2562.high) << 128n) + toBigInt(uint2562.low);\n}\nfunction isUint256(bn) {\n    return toBigInt(bn) <= UINT_256_MAX;\n}\nfunction bnToUint256(bn) {\n    const bi = toBigInt(bn);\n    if (!isUint256(bi)) throw new Error(\"Number is too large\");\n    return {\n        low: addHexPrefix((bi & UINT_128_MAX).toString(16)),\n        high: addHexPrefix((bi >> 128n).toString(16))\n    };\n}\n// src/utils/calldata/cairo.ts\nvar isLen = (name)=>/_len$/.test(name);\nvar isTypeFelt = (type)=>type === \"felt\" || type === \"core::felt252\";\nvar isTypeArray = (type)=>/\\*/.test(type) || type.startsWith(\"core::array::Array::\") || type.startsWith(\"core::array::Span::\");\nvar isTypeTuple = (type)=>/^\\(.*\\)$/i.test(type);\nvar isTypeNamedTuple = (type)=>/\\(.*\\)/i.test(type) && type.includes(\":\");\nvar isTypeStruct = (type, structs)=>type in structs;\nvar isTypeEnum = (type, enums)=>type in enums;\nvar isTypeOption = (type)=>type.startsWith(\"core::option::Option::\");\nvar isTypeResult = (type)=>type.startsWith(\"core::result::Result::\");\nvar isTypeUint = (type)=>Object.values(Uint).includes(type);\nvar isTypeLitteral = (type)=>Object.values(Litteral).includes(type);\nvar isTypeUint256 = (type)=>type === \"core::integer::u256\";\nvar isTypeBool = (type)=>type === \"core::bool\";\nvar isTypeContractAddress = (type)=>type === \"core::starknet::contract_address::ContractAddress\";\nvar isTypeEthAddress = (type)=>type === \"core::starknet::eth_address::EthAddress\";\nvar isCairo1Type = (type)=>type.includes(\"::\");\nvar getArrayType = (type)=>{\n    if (isCairo1Type(type)) {\n        return type.substring(type.indexOf(\"<\") + 1, type.lastIndexOf(\">\"));\n    }\n    return type.replace(\"*\", \"\");\n};\nfunction isCairo1Abi(abi) {\n    const { cairo } = getAbiContractVersion(abi);\n    if (cairo === void 0) {\n        throw Error(\"Unable to determine Cairo version\");\n    }\n    return cairo === \"1\";\n}\nfunction getAbiContractVersion(abi) {\n    if (abi.find((it)=>it.type === \"interface\")) {\n        return {\n            cairo: \"1\",\n            compiler: \"2\"\n        };\n    }\n    const testFunction = abi.find((it)=>it.type === \"function\" && (it.inputs.length || it.outputs.length));\n    if (!testFunction) {\n        return {\n            cairo: void 0,\n            compiler: void 0\n        };\n    }\n    const io = testFunction.inputs.length ? testFunction.inputs : testFunction.outputs;\n    if (isCairo1Type(io[0].type)) {\n        return {\n            cairo: \"1\",\n            compiler: \"1\"\n        };\n    }\n    return {\n        cairo: \"0\",\n        compiler: \"0\"\n    };\n}\nvar uint256 = (it)=>{\n    const bn = BigInt(it);\n    if (!isUint256(bn)) throw new Error(\"Number is too large\");\n    return {\n        // eslint-disable-next-line no-bitwise\n        low: (bn & UINT_128_MAX).toString(10),\n        // eslint-disable-next-line no-bitwise\n        high: (bn >> 128n).toString(10)\n    };\n};\nvar tuple = (...args)=>({\n        ...args\n    });\nfunction felt(it) {\n    if (isBigInt(it) || typeof it === \"number\" && Number.isInteger(it)) {\n        return it.toString();\n    }\n    if (isText(it)) {\n        if (!isShortString(it)) throw new Error(`${it} is a long string > 31 chars, felt can store short strings, split it to array of short strings`);\n        const encoded = encodeShortString(it);\n        return BigInt(encoded).toString();\n    }\n    if (typeof it === \"string\" && isHex(it)) {\n        return BigInt(it).toString();\n    }\n    if (typeof it === \"string\" && isStringWholeNumber(it)) {\n        return it;\n    }\n    if (typeof it === \"boolean\") {\n        return `${+it}`;\n    }\n    throw new Error(`${it} can't be computed by felt()`);\n}\n// src/utils/calldata/enum/CairoCustomEnum.ts\nvar CairoCustomEnum = class {\n    /**\n   * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.\n   */ constructor(enumContent){\n        const variantsList = Object.values(enumContent);\n        if (variantsList.length === 0) {\n            throw new Error(\"This Enum must have a least 1 variant\");\n        }\n        const nbActiveVariants = variantsList.filter((content)=>typeof content !== \"undefined\").length;\n        if (nbActiveVariants !== 1) {\n            throw new Error(\"This Enum must have exactly one active variant\");\n        }\n        this.variant = enumContent;\n    }\n    /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   */ unwrap() {\n        const variants = Object.entries(this.variant);\n        const activeVariant = variants.find((item)=>typeof item[1] !== \"undefined\");\n        if (typeof activeVariant === \"undefined\") {\n            return void 0;\n        }\n        return activeVariant[1];\n    }\n    /**\n   *\n   * @returns the name of the valid variant of a Cairo custom Enum.\n   */ activeVariant() {\n        const variants = Object.entries(this.variant);\n        const activeVariant = variants.find((item)=>typeof item[1] !== \"undefined\");\n        if (typeof activeVariant === \"undefined\") {\n            return \"\";\n        }\n        return activeVariant[0];\n    }\n};\n// src/utils/calldata/enum/CairoOption.ts\nvar CairoOptionVariant = /* @__PURE__ */ ((CairoOptionVariant2)=>{\n    CairoOptionVariant2[CairoOptionVariant2[\"Some\"] = 0] = \"Some\";\n    CairoOptionVariant2[CairoOptionVariant2[\"None\"] = 1] = \"None\";\n    return CairoOptionVariant2;\n})(CairoOptionVariant || {});\nvar CairoOption = class {\n    constructor(variant, someContent){\n        if (!(variant in CairoOptionVariant)) {\n            throw new Error(\"Wrong variant : should be CairoOptionVariant.Some or .None.\");\n        }\n        if (variant === 0 /* Some */ ) {\n            if (typeof someContent === \"undefined\") {\n                throw new Error('The creation of a Cairo Option with \"Some\" variant needs a content as input.');\n            }\n            this.Some = someContent;\n            this.None = void 0;\n        } else {\n            this.Some = void 0;\n            this.None = true;\n        }\n    }\n    /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   *  If None, returns 'undefined'.\n   */ unwrap() {\n        if (this.None) {\n            return void 0;\n        }\n        return this.Some;\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'isSome'.\n   */ isSome() {\n        return !(typeof this.Some === \"undefined\");\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'isNone'.\n   */ isNone() {\n        return this.None === true;\n    }\n};\n// src/utils/calldata/enum/CairoResult.ts\nvar CairoResultVariant = /* @__PURE__ */ ((CairoResultVariant2)=>{\n    CairoResultVariant2[CairoResultVariant2[\"Ok\"] = 0] = \"Ok\";\n    CairoResultVariant2[CairoResultVariant2[\"Err\"] = 1] = \"Err\";\n    return CairoResultVariant2;\n})(CairoResultVariant || {});\nvar CairoResult = class {\n    constructor(variant, resultContent){\n        if (!(variant in CairoResultVariant)) {\n            throw new Error(\"Wrong variant : should be CairoResultVariant.Ok or .Err.\");\n        }\n        if (variant === 0 /* Ok */ ) {\n            this.Ok = resultContent;\n            this.Err = void 0;\n        } else {\n            this.Ok = void 0;\n            this.Err = resultContent;\n        }\n    }\n    /**\n   *\n   * @returns the content of the valid variant of a Cairo Result.\n   */ unwrap() {\n        if (typeof this.Ok !== \"undefined\") {\n            return this.Ok;\n        }\n        if (typeof this.Err !== \"undefined\") {\n            return this.Err;\n        }\n        throw new Error(\"Both Result.Ok and .Err are undefined. Not authorized.\");\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'Ok'.\n   */ isOk() {\n        return !(typeof this.Ok === \"undefined\");\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'isErr'.\n   */ isErr() {\n        return !(typeof this.Err === \"undefined\");\n    }\n};\n// src/utils/calldata/formatter.ts\nvar guard = {\n    isBN: (data, type, key)=>{\n        if (!isBigInt(data[key])) throw new Error(`Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${data[key]} to be BN instead it is ${typeof data[key]}`);\n    },\n    unknown: (data, type, key)=>{\n        throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);\n    }\n};\nfunction formatter(data, type, sameType) {\n    return Object.entries(data).reduce((acc, [key, value])=>{\n        const elType = sameType ?? type[key];\n        if (!(key in type) && !sameType) {\n            acc[key] = value;\n            return acc;\n        }\n        if (elType === \"string\") {\n            if (Array.isArray(data[key])) {\n                const arrayStr = formatter(data[key], data[key].map((_)=>elType));\n                acc[key] = Object.values(arrayStr).join(\"\");\n                return acc;\n            }\n            guard.isBN(data, type, key);\n            acc[key] = decodeShortString(value);\n            return acc;\n        }\n        if (elType === \"number\") {\n            guard.isBN(data, type, key);\n            acc[key] = Number(value);\n            return acc;\n        }\n        if (typeof elType === \"function\") {\n            acc[key] = elType(value);\n            return acc;\n        }\n        if (Array.isArray(elType)) {\n            const arrayObj = formatter(data[key], elType, elType[0]);\n            acc[key] = Object.values(arrayObj);\n            return acc;\n        }\n        if (typeof elType === \"object\") {\n            acc[key] = formatter(data[key], elType);\n            return acc;\n        }\n        guard.unknown(data, type, key);\n        return acc;\n    }, {});\n}\n// src/utils/calldata/parser/parser-0-1.1.0.ts\nvar AbiParser1 = class {\n    constructor(abi){\n        this.abi = abi;\n    }\n    /**\n   * abi method inputs length without '_len' inputs\n   * cairo 0 reducer\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */ methodInputsLength(abiMethod) {\n        return abiMethod.inputs.reduce((acc, input)=>!isLen(input.name) ? acc + 1 : acc, 0);\n    }\n    /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */ getMethod(name) {\n        return this.abi.find((it)=>it.name === name);\n    }\n    /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */ getLegacyFormat() {\n        return this.abi;\n    }\n};\n// src/utils/calldata/parser/parser-2.0.0.ts\nvar AbiParser2 = class {\n    constructor(abi){\n        this.abi = abi;\n    }\n    /**\n   * abi method inputs length\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */ methodInputsLength(abiMethod) {\n        return abiMethod.inputs.length;\n    }\n    /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */ getMethod(name) {\n        const intf = this.abi.find((it)=>it.type === \"interface\");\n        return intf.items.find((it)=>it.name === name);\n    }\n    /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */ getLegacyFormat() {\n        return this.abi.flatMap((e)=>{\n            if (e.type === \"interface\") {\n                return e.items;\n            }\n            return e;\n        });\n    }\n};\n// src/utils/calldata/parser/index.ts\nfunction createAbiParser(abi) {\n    const version = getAbiVersion(abi);\n    if (version === 0 || version === 1) {\n        return new AbiParser1(abi);\n    }\n    if (version === 2) {\n        return new AbiParser2(abi);\n    }\n    throw Error(`Unsupported ABI version ${version}`);\n}\nfunction getAbiVersion(abi) {\n    if (abi.find((it)=>it.type === \"interface\")) return 2;\n    if (isCairo1Abi(abi)) return 1;\n    return 0;\n}\nfunction isNoConstructorValid(method, argsCalldata, abiMethod) {\n    return method === \"constructor\" && !abiMethod && !argsCalldata.length;\n}\n// src/utils/calldata/tuple.ts\nfunction parseNamedTuple(namedTuple) {\n    const name = namedTuple.substring(0, namedTuple.indexOf(\":\"));\n    const type = namedTuple.substring(name.length + \":\".length);\n    return {\n        name,\n        type\n    };\n}\nfunction parseSubTuple(s) {\n    if (!s.includes(\"(\")) return {\n        subTuple: [],\n        result: s\n    };\n    const subTuple = [];\n    let result = \"\";\n    let i = 0;\n    while(i < s.length){\n        if (s[i] === \"(\") {\n            let counter = 1;\n            const lBracket = i;\n            i++;\n            while(counter){\n                if (s[i] === \")\") counter--;\n                if (s[i] === \"(\") counter++;\n                i++;\n            }\n            subTuple.push(s.substring(lBracket, i));\n            result += \" \";\n            i--;\n        } else {\n            result += s[i];\n        }\n        i++;\n    }\n    return {\n        subTuple,\n        result\n    };\n}\nfunction extractCairo0Tuple(type) {\n    const cleanType = type.replace(/\\s/g, \"\").slice(1, -1);\n    const { subTuple, result } = parseSubTuple(cleanType);\n    let recomposed = result.split(\",\").map((it)=>{\n        return subTuple.length ? it.replace(\" \", subTuple.shift()) : it;\n    });\n    if (isTypeNamedTuple(type)) {\n        recomposed = recomposed.reduce((acc, it)=>{\n            return acc.concat(parseNamedTuple(it));\n        }, []);\n    }\n    return recomposed;\n}\nfunction extractCairo1Tuple(type) {\n    const cleanType = type.replace(/\\s/g, \"\").slice(1, -1);\n    const { subTuple, result } = parseSubTuple(cleanType);\n    const recomposed = result.split(\",\").map((it)=>{\n        return subTuple.length ? it.replace(\" \", subTuple.shift()) : it;\n    });\n    return recomposed;\n}\nfunction extractTupleMemberTypes(type) {\n    if (isCairo1Type(type)) {\n        return extractCairo1Tuple(type);\n    }\n    return extractCairo0Tuple(type);\n}\n// src/utils/calldata/propertyOrder.ts\nfunction errorU256(key) {\n    return Error(`Your object includes the property : ${key}, containing an Uint256 object without the 'low' and 'high' keys.`);\n}\nfunction orderPropsByAbi(unorderedObject, abiOfObject, structs, enums) {\n    const orderInput = (unorderedItem, abiType)=>{\n        if (isTypeArray(abiType)) {\n            return orderArray(unorderedItem, abiType);\n        }\n        if (isTypeEnum(abiType, enums)) {\n            const abiObj = enums[abiType];\n            return orderEnum(unorderedItem, abiObj);\n        }\n        if (isTypeTuple(abiType)) {\n            return orderTuple(unorderedItem, abiType);\n        }\n        if (isTypeEthAddress(abiType)) {\n            return unorderedItem;\n        }\n        if (isTypeUint256(abiType)) {\n            const u256 = unorderedItem;\n            if (typeof u256 !== \"object\") {\n                return u256;\n            }\n            if (!(\"low\" in u256 && \"high\" in u256)) {\n                throw errorU256(abiType);\n            }\n            return {\n                low: u256.low,\n                high: u256.high\n            };\n        }\n        if (isTypeStruct(abiType, structs)) {\n            const abiOfStruct = structs[abiType].members;\n            return orderStruct(unorderedItem, abiOfStruct);\n        }\n        return unorderedItem;\n    };\n    const orderStruct = (unorderedObject2, abiObject)=>{\n        const orderedObject2 = abiObject.reduce((orderedObject, abiParam)=>{\n            const setProperty = (value)=>Object.defineProperty(orderedObject, abiParam.name, {\n                    enumerable: true,\n                    value: value ?? unorderedObject2[abiParam.name]\n                });\n            if (unorderedObject2[abiParam.name] === \"undefined\") {\n                if (isCairo1Type(abiParam.type) || !isLen(abiParam.name)) {\n                    throw Error(`Your object needs a property with key : ${abiParam.name} .`);\n                }\n            }\n            setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));\n            return orderedObject;\n        }, {});\n        return orderedObject2;\n    };\n    function orderArray(myArray, abiParam) {\n        const typeInArray = getArrayType(abiParam);\n        if (typeof myArray === \"string\") {\n            return myArray;\n        }\n        return myArray.map((myElem)=>orderInput(myElem, typeInArray));\n    }\n    function orderTuple(unorderedObject2, abiParam) {\n        const typeList = extractTupleMemberTypes(abiParam);\n        const orderedObject2 = typeList.reduce((orderedObject, abiTypeCairoX, index)=>{\n            const myObjKeys = Object.keys(unorderedObject2);\n            const setProperty = (value)=>Object.defineProperty(orderedObject, index.toString(), {\n                    enumerable: true,\n                    value: value ?? unorderedObject2[myObjKeys[index]]\n                });\n            const abiType = abiTypeCairoX?.type ? abiTypeCairoX.type : abiTypeCairoX;\n            setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType));\n            return orderedObject;\n        }, {});\n        return orderedObject2;\n    }\n    const orderEnum = (unorderedObject2, abiObject)=>{\n        if (isTypeResult(abiObject.name)) {\n            const unorderedResult = unorderedObject2;\n            const resultOkType = abiObject.name.substring(abiObject.name.indexOf(\"<\") + 1, abiObject.name.lastIndexOf(\",\"));\n            const resultErrType = abiObject.name.substring(abiObject.name.indexOf(\",\") + 1, abiObject.name.lastIndexOf(\">\"));\n            if (unorderedResult.isOk()) {\n                return new CairoResult(0 /* Ok */ , orderInput(unorderedObject2.unwrap(), resultOkType));\n            }\n            return new CairoResult(1 /* Err */ , orderInput(unorderedObject2.unwrap(), resultErrType));\n        }\n        if (isTypeOption(abiObject.name)) {\n            const unorderedOption = unorderedObject2;\n            const resultSomeType = abiObject.name.substring(abiObject.name.indexOf(\"<\") + 1, abiObject.name.lastIndexOf(\">\"));\n            if (unorderedOption.isSome()) {\n                return new CairoOption(0 /* Some */ , orderInput(unorderedOption.unwrap(), resultSomeType));\n            }\n            return new CairoOption(1 /* None */ , {});\n        }\n        const unorderedCustomEnum = unorderedObject2;\n        const variants = Object.entries(unorderedCustomEnum.variant);\n        const newEntries = variants.map((variant)=>{\n            if (typeof variant[1] === \"undefined\") {\n                return variant;\n            }\n            const variantType = abiObject.type.substring(abiObject.type.lastIndexOf(\"<\") + 1, abiObject.type.lastIndexOf(\">\"));\n            if (variantType === \"()\") {\n                return variant;\n            }\n            return [\n                variant[0],\n                orderInput(unorderedCustomEnum.unwrap(), variantType)\n            ];\n        });\n        return new CairoCustomEnum(Object.fromEntries(newEntries));\n    };\n    const finalOrderedObject = abiOfObject.reduce((orderedObject, abiParam)=>{\n        const setProperty = (value)=>Object.defineProperty(orderedObject, abiParam.name, {\n                enumerable: true,\n                value\n            });\n        if (isLen(abiParam.name) && !isCairo1Type(abiParam.type)) {\n            return orderedObject;\n        }\n        setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));\n        return orderedObject;\n    }, {});\n    return finalOrderedObject;\n}\n// src/utils/calldata/requestParser.ts\nfunction parseBaseTypes(type, val) {\n    switch(true){\n        case isTypeUint256(type):\n            const el_uint256 = uint256(val);\n            return [\n                felt(el_uint256.low),\n                felt(el_uint256.high)\n            ];\n        default:\n            return felt(val);\n    }\n}\nfunction parseTuple(element, typeStr) {\n    const memberTypes = extractTupleMemberTypes(typeStr);\n    const elements = Object.values(element);\n    if (elements.length !== memberTypes.length) {\n        throw Error(`ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${elements} \n      expected: ${memberTypes}`);\n    }\n    return memberTypes.map((it, dx)=>{\n        return {\n            element: elements[dx],\n            type: it.type ?? it\n        };\n    });\n}\nfunction parseUint256(element) {\n    if (typeof element === \"object\") {\n        const { low, high } = element;\n        return [\n            felt(low),\n            felt(high)\n        ];\n    }\n    const el_uint256 = uint256(element);\n    return [\n        felt(el_uint256.low),\n        felt(el_uint256.high)\n    ];\n}\nfunction parseCalldataValue(element, type, structs, enums) {\n    if (element === void 0) {\n        throw Error(`Missing parameter for type ${type}`);\n    }\n    if (Array.isArray(element)) {\n        const result = [];\n        result.push(felt(element.length));\n        const arrayType = getArrayType(type);\n        return element.reduce((acc, it)=>{\n            return acc.concat(parseCalldataValue(it, arrayType, structs, enums));\n        }, result);\n    }\n    if (structs[type] && structs[type].members.length) {\n        if (isTypeUint256(type)) {\n            return parseUint256(element);\n        }\n        if (type === \"core::starknet::eth_address::EthAddress\") return parseBaseTypes(type, element);\n        const { members } = structs[type];\n        const subElement = element;\n        return members.reduce((acc, it)=>{\n            return acc.concat(parseCalldataValue(subElement[it.name], it.type, structs, enums));\n        }, []);\n    }\n    if (isTypeTuple(type)) {\n        const tupled = parseTuple(element, type);\n        return tupled.reduce((acc, it)=>{\n            const parsedData = parseCalldataValue(it.element, it.type, structs, enums);\n            return acc.concat(parsedData);\n        }, []);\n    }\n    if (isTypeUint256(type)) {\n        return parseUint256(element);\n    }\n    if (isTypeEnum(type, enums)) {\n        const { variants } = enums[type];\n        if (isTypeOption(type)) {\n            const myOption = element;\n            if (myOption.isSome()) {\n                const listTypeVariant2 = variants.find((variant)=>variant.name === \"Some\");\n                if (typeof listTypeVariant2 === \"undefined\") {\n                    throw Error(`Error in abi : Option has no 'Some' variant.`);\n                }\n                const typeVariantSome = listTypeVariant2.type;\n                if (typeVariantSome === \"()\") {\n                    return 0..toString();\n                }\n                const parsedParameter2 = parseCalldataValue(myOption.unwrap(), typeVariantSome, structs, enums);\n                if (Array.isArray(parsedParameter2)) {\n                    return [\n                        0..toString(),\n                        ...parsedParameter2\n                    ];\n                }\n                return [\n                    0..toString(),\n                    parsedParameter2\n                ];\n            }\n            return 1..toString();\n        }\n        if (isTypeResult(type)) {\n            const myResult = element;\n            if (myResult.isOk()) {\n                const listTypeVariant3 = variants.find((variant)=>variant.name === \"Ok\");\n                if (typeof listTypeVariant3 === \"undefined\") {\n                    throw Error(`Error in abi : Result has no 'Ok' variant.`);\n                }\n                const typeVariantOk = listTypeVariant3.type;\n                if (typeVariantOk === \"()\") {\n                    return 0..toString();\n                }\n                const parsedParameter3 = parseCalldataValue(myResult.unwrap(), typeVariantOk, structs, enums);\n                if (Array.isArray(parsedParameter3)) {\n                    return [\n                        0..toString(),\n                        ...parsedParameter3\n                    ];\n                }\n                return [\n                    0..toString(),\n                    parsedParameter3\n                ];\n            }\n            const listTypeVariant2 = variants.find((variant)=>variant.name === \"Err\");\n            if (typeof listTypeVariant2 === \"undefined\") {\n                throw Error(`Error in abi : Result has no 'Err' variant.`);\n            }\n            const typeVariantErr = listTypeVariant2.type;\n            if (typeVariantErr === \"()\") {\n                return 1..toString();\n            }\n            const parsedParameter2 = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);\n            if (Array.isArray(parsedParameter2)) {\n                return [\n                    1..toString(),\n                    ...parsedParameter2\n                ];\n            }\n            return [\n                1..toString(),\n                parsedParameter2\n            ];\n        }\n        const myEnum = element;\n        const activeVariant = myEnum.activeVariant();\n        const listTypeVariant = variants.find((variant)=>variant.name === activeVariant);\n        if (typeof listTypeVariant === \"undefined\") {\n            throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);\n        }\n        const typeActiveVariant = listTypeVariant.type;\n        const numActiveVariant = variants.findIndex((variant)=>variant.name === activeVariant);\n        if (typeActiveVariant === \"()\") {\n            return numActiveVariant.toString();\n        }\n        const parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);\n        if (Array.isArray(parsedParameter)) {\n            return [\n                numActiveVariant.toString(),\n                ...parsedParameter\n            ];\n        }\n        return [\n            numActiveVariant.toString(),\n            parsedParameter\n        ];\n    }\n    if (typeof element === \"object\") {\n        throw Error(`Parameter ${element} do not align with abi parameter ${type}`);\n    }\n    return parseBaseTypes(type, element);\n}\nfunction parseCalldataField(argsIterator, input, structs, enums) {\n    const { name, type } = input;\n    let { value } = argsIterator.next();\n    switch(true){\n        case isTypeArray(type):\n            if (!Array.isArray(value) && !isText(value)) {\n                throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);\n            }\n            if (typeof value === \"string\") {\n                value = splitLongString(value);\n            }\n            return parseCalldataValue(value, input.type, structs, enums);\n        case type === \"core::starknet::eth_address::EthAddress\":\n            return parseBaseTypes(type, value);\n        case isTypeStruct(type, structs) || isTypeTuple(type) || isTypeUint256(type):\n            return parseCalldataValue(value, type, structs, enums);\n        case isTypeEnum(type, enums):\n            return parseCalldataValue(value, type, structs, enums);\n        default:\n            return parseBaseTypes(type, value);\n    }\n}\n// src/utils/calldata/responseParser.ts\nfunction parseBaseTypes2(type, it) {\n    let temp;\n    switch(true){\n        case isTypeBool(type):\n            temp = it.next().value;\n            return Boolean(BigInt(temp));\n        case isTypeUint256(type):\n            const low = it.next().value;\n            const high = it.next().value;\n            return uint256ToBN({\n                low,\n                high\n            });\n        case type === \"core::starknet::eth_address::EthAddress\":\n            temp = it.next().value;\n            return BigInt(temp);\n        default:\n            temp = it.next().value;\n            return BigInt(temp);\n    }\n}\nfunction parseResponseValue(responseIterator, element, structs, enums) {\n    if (element.type === \"()\") {\n        return {};\n    }\n    if (isTypeUint256(element.type)) {\n        const low = responseIterator.next().value;\n        const high = responseIterator.next().value;\n        return uint256ToBN({\n            low,\n            high\n        });\n    }\n    if (isTypeArray(element.type)) {\n        const parsedDataArr = [];\n        const el = {\n            name: \"\",\n            type: getArrayType(element.type)\n        };\n        const len = BigInt(responseIterator.next().value);\n        while(parsedDataArr.length < len){\n            parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n        }\n        return parsedDataArr;\n    }\n    if (structs && element.type in structs && structs[element.type]) {\n        if (element.type === \"core::starknet::eth_address::EthAddress\") {\n            return parseBaseTypes2(element.type, responseIterator);\n        }\n        return structs[element.type].members.reduce((acc, el)=>{\n            acc[el.name] = parseResponseValue(responseIterator, el, structs, enums);\n            return acc;\n        }, {});\n    }\n    if (enums && element.type in enums && enums[element.type]) {\n        const variantNum = Number(responseIterator.next().value);\n        const rawEnum = enums[element.type].variants.reduce((acc, variant, num)=>{\n            if (num === variantNum) {\n                acc[variant.name] = parseResponseValue(responseIterator, {\n                    name: \"\",\n                    type: variant.type\n                }, structs, enums);\n                return acc;\n            }\n            acc[variant.name] = void 0;\n            return acc;\n        }, {});\n        if (element.type.startsWith(\"core::option::Option\")) {\n            const content = variantNum === 0 /* Some */  ? rawEnum.Some : void 0;\n            return new CairoOption(variantNum, content);\n        }\n        if (element.type.startsWith(\"core::result::Result\")) {\n            let content;\n            if (variantNum === 0 /* Ok */ ) {\n                content = rawEnum.Ok;\n            } else {\n                content = rawEnum.Err;\n            }\n            return new CairoResult(variantNum, content);\n        }\n        const customEnum = new CairoCustomEnum(rawEnum);\n        return customEnum;\n    }\n    if (isTypeTuple(element.type)) {\n        const memberTypes = extractTupleMemberTypes(element.type);\n        return memberTypes.reduce((acc, it, idx)=>{\n            const name = it?.name ? it.name : idx;\n            const type = it?.type ? it.type : it;\n            const el = {\n                name,\n                type\n            };\n            acc[name] = parseResponseValue(responseIterator, el, structs, enums);\n            return acc;\n        }, {});\n    }\n    if (isTypeArray(element.type)) {\n        const parsedDataArr = [];\n        const el = {\n            name: \"\",\n            type: getArrayType(element.type)\n        };\n        const len = BigInt(responseIterator.next().value);\n        while(parsedDataArr.length < len){\n            parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n        }\n        return parsedDataArr;\n    }\n    return parseBaseTypes2(element.type, responseIterator);\n}\nfunction responseParser(responseIterator, output, structs, enums, parsedResult) {\n    const { name, type } = output;\n    let temp;\n    switch(true){\n        case isLen(name):\n            temp = responseIterator.next().value;\n            return BigInt(temp);\n        case structs && type in structs || isTypeTuple(type):\n            return parseResponseValue(responseIterator, output, structs, enums);\n        case enums && isTypeEnum(type, enums):\n            return parseResponseValue(responseIterator, output, structs, enums);\n        case isTypeArray(type):\n            if (isCairo1Type(type)) {\n                return parseResponseValue(responseIterator, output, structs, enums);\n            }\n            const parsedDataArr = [];\n            if (parsedResult && parsedResult[`${name}_len`]) {\n                const arrLen = parsedResult[`${name}_len`];\n                while(parsedDataArr.length < arrLen){\n                    parsedDataArr.push(parseResponseValue(responseIterator, {\n                        name,\n                        type: output.type.replace(\"*\", \"\")\n                    }, structs, enums));\n                }\n            }\n            return parsedDataArr;\n        default:\n            return parseBaseTypes2(type, responseIterator);\n    }\n}\n// src/utils/calldata/validate.ts\nvar validateFelt = (parameter, input)=>{\n    assert(typeof parameter === \"string\" || typeof parameter === \"number\" || typeof parameter === \"bigint\", `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`);\n    if (typeof parameter === \"string\" && !isHex(parameter)) return;\n    const param = BigInt(parameter.toString(10));\n    assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1266\n    param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);\n};\nvar validateUint = (parameter, input)=>{\n    if (typeof parameter === \"number\") {\n        assert(parameter <= Number.MAX_SAFE_INTEGER, `Validation: Parameter is to large to be typed as Number use (BigInt or String)`);\n    }\n    assert(typeof parameter === \"string\" || typeof parameter === \"number\" || typeof parameter === \"bigint\" || typeof parameter === \"object\" && \"low\" in parameter && \"high\" in parameter, `Validate: arg ${input.name} of cairo type ${input.type} should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`);\n    const param = typeof parameter === \"object\" ? uint256ToBN(parameter) : toBigInt(parameter);\n    switch(input.type){\n        case \"core::integer::u8\" /* u8 */ :\n            assert(param >= 0n && param <= 255n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`);\n            break;\n        case \"core::integer::u16\" /* u16 */ :\n            assert(param >= 0n && param <= 65535n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`);\n            break;\n        case \"core::integer::u32\" /* u32 */ :\n            assert(param >= 0n && param <= 4294967295n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`);\n            break;\n        case \"core::integer::u64\" /* u64 */ :\n            assert(param >= 0n && param <= 2n ** 64n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`);\n            break;\n        case \"core::integer::u128\" /* u128 */ :\n            assert(param >= 0n && param <= 2n ** 128n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`);\n            break;\n        case \"core::integer::u256\" /* u256 */ :\n            assert(param >= 0n && param <= 2n ** 256n - 1n, `Validate: arg ${input.name} is ${input.type} 0 - 2^256-1`);\n            break;\n        case \"core::starknet::class_hash::ClassHash\" /* ClassHash */ :\n            assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1670\n            param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);\n            break;\n        case \"core::starknet::contract_address::ContractAddress\" /* ContractAddress */ :\n            assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1245\n            param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);\n            break;\n        default:\n            break;\n    }\n};\nvar validateBool = (parameter, input)=>{\n    assert(typeof parameter === \"boolean\", `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`);\n};\nvar validateStruct = (parameter, input, structs)=>{\n    if (input.type === \"core::integer::u256\" /* u256 */ ) {\n        validateUint(parameter, input);\n        return;\n    }\n    if (input.type === \"core::starknet::eth_address::EthAddress\") {\n        assert(typeof parameter !== \"object\", `EthAdress type is waiting a BigNumberish. Got ${parameter}`);\n        const param = BigInt(parameter.toString(10));\n        assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1259\n        param >= 0n && param <= 2n ** 160n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`);\n        return;\n    }\n    assert(typeof parameter === \"object\" && !Array.isArray(parameter), `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as js object (not array)`);\n    structs[input.type].members.forEach(({ name })=>{\n        assert(Object.keys(parameter).includes(name), `Validate: arg ${input.name} should have a property ${name}`);\n    });\n};\nvar validateEnum = (parameter, input)=>{\n    assert(typeof parameter === \"object\" && !Array.isArray(parameter), `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as js object (not array)`);\n    const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));\n    const keys = [\n        ...Object.getOwnPropertyNames(parameter),\n        ...methodsKeys\n    ];\n    if (isTypeOption(input.type) && keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n        return;\n    }\n    if (isTypeResult(input.type) && keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n        return;\n    }\n    if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n        return;\n    }\n    throw new Error(`Validate Enum: argument ${input.name}, type ${input.type}, value received ${parameter}, is not an Enum.`);\n};\nvar validateTuple = (parameter, input)=>{\n    assert(typeof parameter === \"object\" && !Array.isArray(parameter), `Validate: arg ${input.name} should be a tuple (defined as object)`);\n};\nvar validateArray = (parameter, input, structs, enums)=>{\n    const baseType = getArrayType(input.type);\n    if (isTypeFelt(baseType) && isLongText(parameter)) {\n        return;\n    }\n    assert(Array.isArray(parameter), `Validate: arg ${input.name} should be an Array`);\n    switch(true){\n        case isTypeFelt(baseType):\n            parameter.forEach((param)=>validateFelt(param, input));\n            break;\n        case isTypeTuple(baseType):\n            parameter.forEach((it)=>validateTuple(it, {\n                    name: input.name,\n                    type: baseType\n                }));\n            break;\n        case isTypeArray(baseType):\n            parameter.forEach((param)=>validateArray(param, {\n                    name: \"\",\n                    type: baseType\n                }, structs, enums));\n            break;\n        case isTypeStruct(baseType, structs):\n            parameter.forEach((it)=>validateStruct(it, {\n                    name: input.name,\n                    type: baseType\n                }, structs));\n            break;\n        case isTypeEnum(baseType, enums):\n            parameter.forEach((it)=>validateEnum(it, {\n                    name: input.name,\n                    type: baseType\n                }));\n            break;\n        case isTypeUint(baseType) || isTypeLitteral(baseType):\n            parameter.forEach((param)=>validateUint(param, input));\n            break;\n        case isTypeBool(baseType):\n            parameter.forEach((param)=>validateBool(param, input));\n            break;\n        default:\n            throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`);\n    }\n};\nfunction validateFields(abiMethod, args, structs, enums) {\n    abiMethod.inputs.reduce((acc, input)=>{\n        const parameter = args[acc];\n        switch(true){\n            case isLen(input.name):\n                return acc;\n            case isTypeFelt(input.type):\n                validateFelt(parameter, input);\n                break;\n            case isTypeUint(input.type) || isTypeLitteral(input.type):\n                validateUint(parameter, input);\n                break;\n            case isTypeBool(input.type):\n                validateBool(parameter, input);\n                break;\n            case isTypeArray(input.type):\n                validateArray(parameter, input, structs, enums);\n                break;\n            case isTypeStruct(input.type, structs):\n                validateStruct(parameter, input, structs);\n                break;\n            case isTypeEnum(input.type, enums):\n                validateEnum(parameter, input);\n                break;\n            case isTypeTuple(input.type):\n                validateTuple(parameter, input);\n                break;\n            default:\n                throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`);\n        }\n        return acc + 1;\n    }, 0);\n}\n// src/utils/calldata/index.ts\nvar CallData = class {\n    constructor(abi){\n        this.structs = CallData.getAbiStruct(abi);\n        this.enums = CallData.getAbiEnum(abi);\n        this.parser = createAbiParser(abi);\n        this.abi = this.parser.getLegacyFormat();\n    }\n    /**\n   * Validate arguments passed to the method as corresponding to the ones in the abi\n   * @param type ValidateType - type of the method\n   * @param method string - name of the method\n   * @param args ArgsOrCalldata - arguments that are passed to the method\n   */ validate(type, method, args = []) {\n        if (type !== \"DEPLOY\" /* DEPLOY */ ) {\n            const invocableFunctionNames = this.abi.filter((abi)=>{\n                if (abi.type !== \"function\") return false;\n                const isView = abi.stateMutability === \"view\" || abi.state_mutability === \"view\";\n                return type === \"INVOKE\" /* INVOKE */  ? !isView : isView;\n            }).map((abi)=>abi.name);\n            assert(invocableFunctionNames.includes(method), `${type === \"INVOKE\" /* INVOKE */  ? \"invocable\" : \"viewable\"} method not found in abi`);\n        }\n        const abiMethod = this.abi.find((abi)=>type === \"DEPLOY\" /* DEPLOY */  ? abi.name === method && abi.type === \"constructor\" : abi.name === method && abi.type === \"function\");\n        if (isNoConstructorValid(method, args, abiMethod)) {\n            return;\n        }\n        const inputsLength = this.parser.methodInputsLength(abiMethod);\n        if (args.length !== inputsLength) {\n            throw Error(`Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`);\n        }\n        validateFields(abiMethod, args, this.structs, this.enums);\n    }\n    /**\n   * Compile contract callData with abi\n   * Parse the calldata by using input fields from the abi for that method\n   * @param method string - method name\n   * @param args RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).\n   * @return Calldata - parsed arguments in format that contract is expecting\n   * @example\n   * ```typescript\n   * const calldata = myCallData.compile(\"constructor\", [\"0x34a\", [1, 3n]]);\n   * ```\n   * ```typescript\n   * const calldata2 = myCallData.compile(\"constructor\", {list:[1, 3n], balance:\"0x34\"}); // wrong order is valid\n   * ```\n   */ compile(method, argsCalldata) {\n        const abiMethod = this.abi.find((abiFunction)=>abiFunction.name === method);\n        if (isNoConstructorValid(method, argsCalldata, abiMethod)) {\n            return [];\n        }\n        let args;\n        if (Array.isArray(argsCalldata)) {\n            args = argsCalldata;\n        } else {\n            const orderedObject = orderPropsByAbi(argsCalldata, abiMethod.inputs, this.structs, this.enums);\n            args = Object.values(orderedObject);\n            validateFields(abiMethod, args, this.structs, this.enums);\n        }\n        const argsIterator = args[Symbol.iterator]();\n        const callArray = abiMethod.inputs.reduce((acc, input)=>isLen(input.name) && !isCairo1Type(input.type) ? acc : acc.concat(parseCalldataField(argsIterator, input, this.structs, this.enums)), []);\n        Object.defineProperty(callArray, \"__compiled__\", {\n            enumerable: false,\n            writable: false,\n            value: true\n        });\n        return callArray;\n    }\n    /**\n   * Compile contract callData without abi\n   * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data\n   * @returns Calldata\n   */ static compile(rawArgs) {\n        const createTree = (obj)=>{\n            const getEntries = (o, prefix = \".\")=>{\n                const oe = Array.isArray(o) ? [\n                    o.length.toString(),\n                    ...o\n                ] : o;\n                return Object.entries(oe).flatMap(([k, v])=>{\n                    let value = v;\n                    if (isLongText(value)) value = splitLongString(value);\n                    if (k === \"entrypoint\") value = getSelectorFromName(value);\n                    const kk = Array.isArray(oe) && k === \"0\" ? \"$$len\" : k;\n                    if (isBigInt(value)) return [\n                        [\n                            `${prefix}${kk}`,\n                            felt(value)\n                        ]\n                    ];\n                    if (Object(value) === value) {\n                        const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));\n                        const keys = [\n                            ...Object.getOwnPropertyNames(value),\n                            ...methodsKeys\n                        ];\n                        if (keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n                            const myOption = value;\n                            const variantNb = myOption.isSome() ? 0 /* Some */  : 1 /* None */ ;\n                            if (myOption.isSome()) return getEntries({\n                                0: variantNb,\n                                1: myOption.unwrap()\n                            }, `${prefix}${kk}.`);\n                            return [\n                                [\n                                    `${prefix}${kk}`,\n                                    felt(variantNb)\n                                ]\n                            ];\n                        }\n                        if (keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n                            const myResult = value;\n                            const variantNb = myResult.isOk() ? 0 /* Ok */  : 1 /* Err */ ;\n                            return getEntries({\n                                0: variantNb,\n                                1: myResult.unwrap()\n                            }, `${prefix}${kk}.`);\n                        }\n                        if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n                            const myEnum = value;\n                            const activeVariant = myEnum.activeVariant();\n                            const listVariants = Object.keys(myEnum.variant);\n                            const activeVariantNb = listVariants.findIndex((variant)=>variant === activeVariant);\n                            if (typeof myEnum.unwrap() === \"object\" && Object.keys(myEnum.unwrap()).length === 0) {\n                                return [\n                                    [\n                                        `${prefix}${kk}`,\n                                        felt(activeVariantNb)\n                                    ]\n                                ];\n                            }\n                            return getEntries({\n                                0: activeVariantNb,\n                                1: myEnum.unwrap()\n                            }, `${prefix}${kk}.`);\n                        }\n                        return getEntries(value, `${prefix}${kk}.`);\n                    }\n                    return [\n                        [\n                            `${prefix}${kk}`,\n                            felt(value)\n                        ]\n                    ];\n                });\n            };\n            const result = Object.fromEntries(getEntries(obj));\n            return result;\n        };\n        let callTreeArray;\n        if (!Array.isArray(rawArgs)) {\n            const callTree = createTree(rawArgs);\n            callTreeArray = Object.values(callTree);\n        } else {\n            const callObj = {\n                ...rawArgs\n            };\n            const callTree = createTree(callObj);\n            callTreeArray = Object.values(callTree);\n        }\n        Object.defineProperty(callTreeArray, \"__compiled__\", {\n            enumerable: false,\n            writable: false,\n            value: true\n        });\n        return callTreeArray;\n    }\n    /**\n   * Parse elements of the response array and structuring them into response object\n   * @param method string - method name\n   * @param response string[] - response from the method\n   * @return Result - parsed response corresponding to the abi\n   */ parse(method, response) {\n        const { outputs } = this.abi.find((abi)=>abi.name === method);\n        const responseIterator = response.flat()[Symbol.iterator]();\n        const parsed = outputs.flat().reduce((acc, output, idx)=>{\n            const propName = output.name ?? idx;\n            acc[propName] = responseParser(responseIterator, output, this.structs, this.enums, acc);\n            if (acc[propName] && acc[`${propName}_len`]) {\n                delete acc[`${propName}_len`];\n            }\n            return acc;\n        }, {});\n        return Object.keys(parsed).length === 1 && 0 in parsed ? parsed[0] : parsed;\n    }\n    /**\n   * Format cairo method response data to native js values based on provided format schema\n   * @param method string - cairo method name\n   * @param response string[] - cairo method response\n   * @param format object - formatter object schema\n   * @returns Result - parsed and formatted response object\n   */ format(method, response, format) {\n        const parsed = this.parse(method, response);\n        return formatter(parsed, format);\n    }\n    /**\n   * Helper to extract structs from abi\n   * @param abi Abi\n   * @returns AbiStructs - structs from abi\n   */ static getAbiStruct(abi) {\n        return abi.filter((abiEntry)=>abiEntry.type === \"struct\").reduce((acc, abiEntry)=>({\n                ...acc,\n                [abiEntry.name]: abiEntry\n            }), {});\n    }\n    /**\n   * Helper to extract enums from abi\n   * @param abi Abi\n   * @returns AbiEnums - enums from abi\n   */ static getAbiEnum(abi) {\n        const fullEnumList = abi.filter((abiEntry)=>abiEntry.type === \"enum\").reduce((acc, abiEntry)=>({\n                ...acc,\n                [abiEntry.name]: abiEntry\n            }), {});\n        delete fullEnumList[\"core::bool\"];\n        return fullEnumList;\n    }\n    /**\n   * Helper: Compile HexCalldata | RawCalldata | RawArgs\n   * @param rawCalldata HexCalldata | RawCalldata | RawArgs\n   * @returns Calldata\n   */ static toCalldata(rawCalldata = []) {\n        return CallData.compile(rawCalldata);\n    }\n    /**\n   * Helper: Convert raw to HexCalldata\n   * @param raw HexCalldata | RawCalldata | RawArgs\n   * @returns HexCalldata\n   */ static toHex(raw = []) {\n        const calldata = CallData.compile(raw);\n        return calldata.map((it)=>toHex(it));\n    }\n};\n// src/utils/hash.ts\nvar hash_exports = {};\n__export(hash_exports, {\n    calculateContractAddressFromHash: ()=>calculateContractAddressFromHash,\n    calculateDeclareTransactionHash: ()=>calculateDeclareTransactionHash,\n    calculateDeployAccountTransactionHash: ()=>calculateDeployAccountTransactionHash,\n    calculateDeployTransactionHash: ()=>calculateDeployTransactionHash,\n    calculateTransactionHash: ()=>calculateTransactionHash,\n    calculateTransactionHashCommon: ()=>calculateTransactionHashCommon,\n    computeCompiledClassHash: ()=>computeCompiledClassHash,\n    computeContractClassHash: ()=>computeContractClassHash,\n    computeHashOnElements: ()=>computeHashOnElements,\n    computeLegacyContractClassHash: ()=>computeLegacyContractClassHash,\n    computeSierraContractClassHash: ()=>computeSierraContractClassHash,\n    default: ()=>computeHintedClassHash,\n    feeTransactionVersion: ()=>feeTransactionVersion,\n    feeTransactionVersion_2: ()=>feeTransactionVersion_2,\n    formatSpaces: ()=>formatSpaces,\n    getSelector: ()=>getSelector,\n    getSelectorFromName: ()=>getSelectorFromName,\n    getVersionsByType: ()=>getVersionsByType,\n    keccakBn: ()=>keccakBn,\n    poseidon: ()=>_noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_3__,\n    starknetKeccak: ()=>starknetKeccak,\n    transactionVersion: ()=>transactionVersion,\n    transactionVersion_2: ()=>transactionVersion_2\n});\n\n// src/utils/ec.ts\nvar ec_exports = {};\n__export(ec_exports, {\n    starkCurve: ()=>_scure_starknet__WEBPACK_IMPORTED_MODULE_2__,\n    weierstrass: ()=>_noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_4__\n});\n\n\n// src/utils/json.ts\nvar json_exports = {};\n__export(json_exports, {\n    parse: ()=>parse2,\n    parseAlwaysAsBig: ()=>parseAlwaysAsBig,\n    stringify: ()=>stringify2,\n    stringifyAlwaysAsBig: ()=>stringifyAlwaysAsBig\n});\n\nvar parseIntAsNumberOrBigInt = (x)=>{\n    if (!lossless_json__WEBPACK_IMPORTED_MODULE_5__.isInteger(x)) return parseFloat(x);\n    const v = parseInt(x, 10);\n    return Number.isSafeInteger(v) ? v : BigInt(x);\n};\nvar parse2 = (x)=>lossless_json__WEBPACK_IMPORTED_MODULE_5__.parse(String(x), void 0, parseIntAsNumberOrBigInt);\nvar parseAlwaysAsBig = (x)=>lossless_json__WEBPACK_IMPORTED_MODULE_5__.parse(String(x), void 0, lossless_json__WEBPACK_IMPORTED_MODULE_5__.parseNumberAndBigInt);\nvar stringify2 = (value, replacer, space, numberStringifiers)=>lossless_json__WEBPACK_IMPORTED_MODULE_5__.stringify(value, replacer, space, numberStringifiers);\nvar stringifyAlwaysAsBig = stringify2;\n// src/utils/hash.ts\n\nvar transactionVersion = BN_TRANSACTION_VERSION_1;\nvar transactionVersion_2 = BN_TRANSACTION_VERSION_2;\nvar feeTransactionVersion = BN_FEE_TRANSACTION_VERSION_1;\nvar feeTransactionVersion_2 = BN_FEE_TRANSACTION_VERSION_2;\nfunction getVersionsByType(versionType) {\n    return versionType === \"fee\" ? {\n        v1: feeTransactionVersion,\n        v2: feeTransactionVersion_2\n    } : {\n        v1: transactionVersion,\n        v2: transactionVersion_2\n    };\n}\nfunction computeHashOnElements(data) {\n    return [\n        ...data,\n        data.length\n    ].reduce((x, y)=>_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.pedersen(toBigInt(x), toBigInt(y)), 0).toString();\n}\nfunction calculateTransactionHashCommon(txHashPrefix, version, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData = []) {\n    const calldataHash = computeHashOnElements(calldata);\n    const dataToHash = [\n        txHashPrefix,\n        version,\n        contractAddress,\n        entryPointSelector,\n        calldataHash,\n        maxFee,\n        chainId,\n        ...additionalData\n    ];\n    return computeHashOnElements(dataToHash);\n}\nfunction calculateDeployTransactionHash(contractAddress, constructorCalldata, version, chainId, constructorName = \"constructor\") {\n    return calculateTransactionHashCommon(\"0x6465706c6f79\" /* DEPLOY */ , version, contractAddress, getSelectorFromName(constructorName), constructorCalldata, 0, chainId);\n}\nfunction calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash) {\n    return calculateTransactionHashCommon(\"0x6465636c617265\" /* DECLARE */ , version, senderAddress, 0, [\n        classHash\n    ], maxFee, chainId, [\n        nonce,\n        ...compiledClassHash ? [\n            compiledClassHash\n        ] : []\n    ]);\n}\nfunction calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, salt, version, maxFee, chainId, nonce) {\n    const calldata = [\n        classHash,\n        salt,\n        ...constructorCalldata\n    ];\n    return calculateTransactionHashCommon(\"0x6465706c6f795f6163636f756e74\" /* DEPLOY_ACCOUNT */ , version, contractAddress, 0, calldata, maxFee, chainId, [\n        nonce\n    ]);\n}\nfunction calculateTransactionHash(contractAddress, version, calldata, maxFee, chainId, nonce) {\n    return calculateTransactionHashCommon(\"0x696e766f6b65\" /* INVOKE */ , version, contractAddress, 0, calldata, maxFee, chainId, [\n        nonce\n    ]);\n}\nfunction calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const constructorCalldataHash = computeHashOnElements(compiledCalldata);\n    const CONTRACT_ADDRESS_PREFIX = felt(\"0x535441524b4e45545f434f4e54524143545f41444452455353\");\n    return computeHashOnElements([\n        CONTRACT_ADDRESS_PREFIX,\n        deployerAddress,\n        salt,\n        classHash,\n        constructorCalldataHash\n    ]);\n}\nfunction nullSkipReplacer(key, value) {\n    if (key === \"attributes\" || key === \"accessible_scopes\") {\n        return Array.isArray(value) && value.length === 0 ? void 0 : value;\n    }\n    if (key === \"debug_info\") {\n        return null;\n    }\n    return value === null ? void 0 : value;\n}\nfunction formatSpaces(json2) {\n    let insideQuotes = false;\n    const newString = [];\n    for (const char of json2){\n        if (char === '\"' && (newString.length > 0 && newString.slice(-1)[0] === \"\\\\\") === false) {\n            insideQuotes = !insideQuotes;\n        }\n        if (insideQuotes) {\n            newString.push(char);\n        } else {\n            newString.push(char === \":\" ? \": \" : char === \",\" ? \", \" : char);\n        }\n    }\n    return newString.join(\"\");\n}\nfunction computeHintedClassHash(compiledContract) {\n    const { abi, program } = compiledContract;\n    const contractClass = {\n        abi,\n        program\n    };\n    const serializedJson = formatSpaces(stringify2(contractClass, nullSkipReplacer));\n    return addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak(utf8ToArray(serializedJson)).toString(16));\n}\nfunction computeLegacyContractClassHash(contract) {\n    const compiledContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    const apiVersion = toHex(API_VERSION);\n    const externalEntryPointsHash = computeHashOnElements(compiledContract.entry_points_by_type.EXTERNAL.flatMap((e)=>[\n            e.selector,\n            e.offset\n        ]));\n    const l1HandlerEntryPointsHash = computeHashOnElements(compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e)=>[\n            e.selector,\n            e.offset\n        ]));\n    const constructorEntryPointHash = computeHashOnElements(compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e)=>[\n            e.selector,\n            e.offset\n        ]));\n    const builtinsHash = computeHashOnElements(compiledContract.program.builtins.map((s)=>encodeShortString(s)));\n    const hintedClassHash = computeHintedClassHash(compiledContract);\n    const dataHash = computeHashOnElements(compiledContract.program.data);\n    return computeHashOnElements([\n        apiVersion,\n        externalEntryPointsHash,\n        l1HandlerEntryPointsHash,\n        constructorEntryPointHash,\n        builtinsHash,\n        hintedClassHash,\n        dataHash\n    ]);\n}\nfunction hashBuiltins(builtins) {\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(builtins.flatMap((it)=>{\n        return BigInt(encodeShortString(it));\n    }));\n}\nfunction hashEntryPoint(data) {\n    const base = data.flatMap((it)=>{\n        return [\n            BigInt(it.selector),\n            BigInt(it.offset),\n            hashBuiltins(it.builtins)\n        ];\n    });\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(base);\n}\nfunction computeCompiledClassHash(casm) {\n    const COMPILED_CLASS_VERSION = \"COMPILED_CLASS_V1\";\n    const compiledClassVersion = BigInt(encodeShortString(COMPILED_CLASS_VERSION));\n    const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);\n    const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);\n    const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);\n    const bytecode = (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(casm.bytecode.map((it)=>BigInt(it)));\n    return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)([\n        compiledClassVersion,\n        externalEntryPointsHash,\n        l1Handlers,\n        constructor,\n        bytecode\n    ]));\n}\nfunction hashEntryPointSierra(data) {\n    const base = data.flatMap((it)=>{\n        return [\n            BigInt(it.selector),\n            BigInt(it.function_idx)\n        ];\n    });\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(base);\n}\nfunction hashAbi(sierra) {\n    const indentString = formatSpaces(stringify2(sierra.abi, null));\n    return BigInt(addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak(utf8ToArray(indentString)).toString(16)));\n}\nfunction computeSierraContractClassHash(sierra) {\n    const CONTRACT_CLASS_VERSION = \"CONTRACT_CLASS_V0.1.0\";\n    const compiledClassVersion = BigInt(encodeShortString(CONTRACT_CLASS_VERSION));\n    const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);\n    const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);\n    const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);\n    const abiHash = hashAbi(sierra);\n    const sierraProgram = (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(sierra.sierra_program.map((it)=>BigInt(it)));\n    return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)([\n        compiledClassVersion,\n        externalEntryPointsHash,\n        l1Handlers,\n        constructor,\n        abiHash,\n        sierraProgram\n    ]));\n}\nfunction computeContractClassHash(contract) {\n    const compiledContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    if (\"sierra_program\" in compiledContract) {\n        return computeSierraContractClassHash(compiledContract);\n    }\n    return computeLegacyContractClassHash(compiledContract);\n}\n// src/utils/stark.ts\nvar stark_exports = {};\n__export(stark_exports, {\n    compressProgram: ()=>compressProgram,\n    decompressProgram: ()=>decompressProgram,\n    estimatedFeeToMaxFee: ()=>estimatedFeeToMaxFee,\n    formatSignature: ()=>formatSignature,\n    makeAddress: ()=>makeAddress,\n    randomAddress: ()=>randomAddress,\n    signatureToDecimalArray: ()=>signatureToDecimalArray,\n    signatureToHexArray: ()=>signatureToHexArray\n});\n\n\nfunction compressProgram(jsonProgram) {\n    const stringified = typeof jsonProgram === \"string\" ? jsonProgram : stringify2(jsonProgram);\n    const compressedProgram = (0,pako__WEBPACK_IMPORTED_MODULE_6__.gzip)(stringified);\n    return btoaUniversal(compressedProgram);\n}\nfunction decompressProgram(base642) {\n    if (Array.isArray(base642)) return base642;\n    const decompressed = arrayBufferToString((0,pako__WEBPACK_IMPORTED_MODULE_6__.ungzip)(atobUniversal(base642)));\n    return parse2(decompressed);\n}\nfunction randomAddress() {\n    const randomKeyPair = _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.utils.randomPrivateKey();\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.getStarkKey)(randomKeyPair);\n}\nfunction makeAddress(input) {\n    return addHexPrefix(input).toLowerCase();\n}\nfunction formatSignature(sig) {\n    if (!sig) throw Error(\"formatSignature: provided signature is undefined\");\n    if (Array.isArray(sig)) {\n        return sig.map((it)=>toHex(it));\n    }\n    try {\n        const { r, s } = sig;\n        return [\n            toHex(r),\n            toHex(s)\n        ];\n    } catch (e) {\n        throw new Error(\"Signature need to be weierstrass.SignatureType or an array for custom\");\n    }\n}\nfunction signatureToDecimalArray(sig) {\n    return bigNumberishArrayToDecimalStringArray(formatSignature(sig));\n}\nfunction signatureToHexArray(sig) {\n    return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));\n}\nfunction estimatedFeeToMaxFee(estimatedFee, overhead = 0.5) {\n    const overHeadPercent = Math.round((1 + overhead) * 100);\n    return toBigInt(estimatedFee) * toBigInt(overHeadPercent) / 100n;\n}\n// src/utils/contract.ts\nfunction isSierra(contract) {\n    const compiledContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    return \"sierra_program\" in compiledContract;\n}\nfunction extractContractHashes(payload) {\n    const response = {\n        ...payload\n    };\n    if (isSierra(payload.contract)) {\n        if (!payload.compiledClassHash && payload.casm) {\n            response.compiledClassHash = computeCompiledClassHash(payload.casm);\n        }\n        if (!response.compiledClassHash) throw new Error(\"Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash\");\n    }\n    response.classHash = payload.classHash ?? computeContractClassHash(payload.contract);\n    if (!response.classHash) throw new Error(\"Extract classHash failed, provide (CompiledContract).json file or classHash\");\n    return response;\n}\nfunction contractClassResponseToLegacyCompiledContract(ccr) {\n    if (isSierra(ccr)) {\n        throw Error(\"ContractClassResponse need to be LegacyContractClass (cairo0 response class)\");\n    }\n    const contract = ccr;\n    return {\n        ...contract,\n        program: decompressProgram(contract.program)\n    };\n}\n// src/utils/fetchPonyfill.ts\n\nvar fetchPonyfill_default =  false || // use buildin fetch in browser if available\ntypeof global !== \"undefined\" && global.fetch || // use buildin fetch in node, react-native and service worker if available\nisomorphic_fetch__WEBPACK_IMPORTED_MODULE_7__;\n// src/utils/provider.ts\nvar provider_exports = {};\n__export(provider_exports, {\n    createSierraContractClass: ()=>createSierraContractClass,\n    parseContract: ()=>parseContract,\n    wait: ()=>wait\n});\nfunction wait(delay) {\n    return new Promise((res)=>{\n        setTimeout(res, delay);\n    });\n}\nfunction createSierraContractClass(contract) {\n    const result = {\n        ...contract\n    };\n    delete result.sierra_program_debug_info;\n    result.abi = formatSpaces(stringify2(contract.abi));\n    result.sierra_program = formatSpaces(stringify2(contract.sierra_program));\n    result.sierra_program = compressProgram(result.sierra_program);\n    return result;\n}\nfunction parseContract(contract) {\n    const parsedContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    if (!isSierra(contract)) {\n        return {\n            ...parsedContract,\n            ...\"program\" in parsedContract && {\n                program: compressProgram(parsedContract.program)\n            }\n        };\n    }\n    return createSierraContractClass(parsedContract);\n}\n// src/utils/responseParser/rpc.ts\nvar RPCResponseParser = class {\n    parseGetBlockResponse(res) {\n        return {\n            timestamp: res.timestamp,\n            block_hash: \"block_hash\" in res ? res.block_hash : \"\",\n            block_number: \"block_number\" in res ? res.block_number : -1,\n            new_root: \"new_root\" in res ? res.new_root : \"\",\n            parent_hash: res.parent_hash,\n            status: \"status\" in res ? res.status : \"PENDING\" /* PENDING */ ,\n            transactions: res.transactions\n        };\n    }\n    parseGetTransactionResponse(res) {\n        return {\n            calldata: \"calldata\" in res ? res.calldata : [],\n            contract_address: \"contract_address\" in res ? res.contract_address : \"\",\n            sender_address: \"sender_address\" in res ? res.sender_address : \"\",\n            max_fee: \"max_fee\" in res ? res.max_fee : \"\",\n            nonce: \"nonce\" in res ? res.nonce : \"\",\n            signature: \"signature\" in res ? res.signature : [],\n            transaction_hash: res.transaction_hash,\n            version: res.version\n        };\n    }\n    parseFeeEstimateResponse(res) {\n        return {\n            overall_fee: toBigInt(res[0].overall_fee),\n            gas_consumed: toBigInt(res[0].gas_consumed),\n            gas_price: toBigInt(res[0].gas_price)\n        };\n    }\n    parseFeeEstimateBulkResponse(res) {\n        return res.map((val)=>({\n                overall_fee: toBigInt(val.overall_fee),\n                gas_consumed: toBigInt(val.gas_consumed),\n                gas_price: toBigInt(val.gas_price)\n            }));\n    }\n    parseCallContractResponse(res) {\n        return {\n            result: res\n        };\n    }\n    parseSimulateTransactionResponse(res) {\n        return res.map((it)=>{\n            return {\n                ...it,\n                suggestedMaxFee: estimatedFeeToMaxFee(BigInt(it.fee_estimation.overall_fee))\n            };\n        });\n    }\n    parseContractClassResponse(res) {\n        return {\n            ...res,\n            abi: typeof res.abi === \"string\" ? JSON.parse(res.abi) : res.abi\n        };\n    }\n};\n// src/provider/errors.ts\nfunction fixStack(target, fn = target.constructor) {\n    const { captureStackTrace } = Error;\n    captureStackTrace && captureStackTrace(target, fn);\n}\nfunction fixProto(target, prototype) {\n    const { setPrototypeOf } = Object;\n    setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;\n}\nvar CustomError = class extends Error {\n    constructor(message){\n        super(message);\n        Object.defineProperty(this, \"name\", {\n            value: new.target.name,\n            enumerable: false,\n            configurable: true\n        });\n        fixProto(this, new.target.prototype);\n        fixStack(this);\n    }\n};\nvar LibraryError = class extends CustomError {\n};\nvar GatewayError = class extends LibraryError {\n    constructor(message, errorCode){\n        super(message);\n        this.errorCode = errorCode;\n    }\n};\nvar HttpError = class extends LibraryError {\n    constructor(message, errorCode){\n        super(message);\n        this.errorCode = errorCode;\n    }\n};\n// src/utils/starknetId.ts\nvar starknetId_exports = {};\n__export(starknetId_exports, {\n    StarknetIdContract: ()=>StarknetIdContract,\n    getStarknetIdContract: ()=>getStarknetIdContract,\n    useDecoded: ()=>useDecoded,\n    useEncoded: ()=>useEncoded\n});\nvar basicAlphabet = \"abcdefghijklmnopqrstuvwxyz0123456789-\";\nvar basicSizePlusOne = BigInt(basicAlphabet.length + 1);\nvar bigAlphabet = \"这来\";\nvar basicAlphabetSize = BigInt(basicAlphabet.length);\nvar bigAlphabetSize = BigInt(bigAlphabet.length);\nvar bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);\nfunction extractStars(str) {\n    let k = 0;\n    while(str.endsWith(bigAlphabet[bigAlphabet.length - 1])){\n        str = str.substring(0, str.length - 1);\n        k += 1;\n    }\n    return [\n        str,\n        k\n    ];\n}\nfunction useDecoded(encoded) {\n    let decoded = \"\";\n    encoded.forEach((subdomain)=>{\n        while(subdomain !== ZERO){\n            const code = subdomain % basicSizePlusOne;\n            subdomain /= basicSizePlusOne;\n            if (code === BigInt(basicAlphabet.length)) {\n                const nextSubdomain = subdomain / bigAlphabetSizePlusOne;\n                if (nextSubdomain === ZERO) {\n                    const code2 = subdomain % bigAlphabetSizePlusOne;\n                    subdomain = nextSubdomain;\n                    if (code2 === ZERO) decoded += basicAlphabet[0];\n                    else decoded += bigAlphabet[Number(code2) - 1];\n                } else {\n                    const code2 = subdomain % bigAlphabetSize;\n                    decoded += bigAlphabet[Number(code2)];\n                    subdomain /= bigAlphabetSize;\n                }\n            } else decoded += basicAlphabet[Number(code)];\n        }\n        const [str, k] = extractStars(decoded);\n        if (k) decoded = str + (k % 2 === 0 ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) + bigAlphabet[0] + basicAlphabet[1] : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));\n        decoded += \".\";\n    });\n    if (!decoded) {\n        return decoded;\n    }\n    return decoded.concat(\"stark\");\n}\nfunction useEncoded(decoded) {\n    let encoded = BigInt(0);\n    let multiplier = BigInt(1);\n    if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {\n        const [str, k] = extractStars(decoded.substring(0, decoded.length - 2));\n        decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));\n    } else {\n        const [str, k] = extractStars(decoded);\n        if (k) decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));\n    }\n    for(let i = 0; i < decoded.length; i += 1){\n        const char = decoded[i];\n        const index = basicAlphabet.indexOf(char);\n        const bnIndex = BigInt(basicAlphabet.indexOf(char));\n        if (index !== -1) {\n            if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {\n                encoded += multiplier * basicAlphabetSize;\n                multiplier *= basicSizePlusOne;\n                multiplier *= basicSizePlusOne;\n            } else {\n                encoded += multiplier * bnIndex;\n                multiplier *= basicSizePlusOne;\n            }\n        } else if (bigAlphabet.indexOf(char) !== -1) {\n            encoded += multiplier * basicAlphabetSize;\n            multiplier *= basicSizePlusOne;\n            const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);\n            encoded += multiplier * BigInt(newid);\n            multiplier *= bigAlphabetSize;\n        }\n    }\n    return encoded;\n}\nvar StarknetIdContract = /* @__PURE__ */ ((StarknetIdContract2)=>{\n    StarknetIdContract2[\"MAINNET\"] = \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\";\n    StarknetIdContract2[\"TESTNET\"] = \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\";\n    return StarknetIdContract2;\n})(StarknetIdContract || {});\nfunction getStarknetIdContract(chainId) {\n    switch(chainId){\n        case \"0x534e5f4d41494e\" /* SN_MAIN */ :\n            return \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\" /* MAINNET */ ;\n        case \"0x534e5f474f45524c49\" /* SN_GOERLI */ :\n            return \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\" /* TESTNET */ ;\n        default:\n            throw new Error(\"Starknet.id is not yet deployed on this network\");\n    }\n}\n// src/provider/starknetId.ts\nasync function getStarkName(provider, address, StarknetIdContract2) {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    try {\n        const hexDomain = await provider.callContract({\n            contractAddress: contract,\n            entrypoint: \"address_to_domain\",\n            calldata: CallData.compile({\n                address\n            })\n        });\n        const decimalDomain = hexDomain.result.map((element)=>BigInt(element)).slice(1);\n        const stringDomain = useDecoded(decimalDomain);\n        if (!stringDomain) {\n            throw Error(\"Starkname not found\");\n        }\n        return stringDomain;\n    } catch (e) {\n        if (e instanceof Error && e.message === \"Starkname not found\") {\n            throw e;\n        }\n        throw Error(\"Could not get stark name\");\n    }\n}\nasync function getAddressFromStarkName(provider, name, StarknetIdContract2) {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    try {\n        const addressData = await provider.callContract({\n            contractAddress: contract,\n            entrypoint: \"domain_to_address\",\n            calldata: CallData.compile({\n                domain: [\n                    useEncoded(name.replace(\".stark\", \"\")).toString(10)\n                ]\n            })\n        });\n        return addressData.result[0];\n    } catch  {\n        throw Error(\"Could not get address from stark name\");\n    }\n}\n// src/provider/utils.ts\nvar validBlockTags = Object.values(BlockTag);\nvar Block = class {\n    constructor(_identifier){\n        this.hash = null;\n        this.number = null;\n        this.tag = null;\n        this.valueOf = ()=>this.number;\n        this.toString = ()=>this.hash;\n        this.setIdentifier(_identifier);\n    }\n    setIdentifier(__identifier) {\n        if (typeof __identifier === \"string\" && isHex(__identifier)) {\n            this.hash = __identifier;\n        } else if (typeof __identifier === \"bigint\") {\n            this.hash = toHex(__identifier);\n        } else if (typeof __identifier === \"number\") {\n            this.number = __identifier;\n        } else if (typeof __identifier === \"string\" && validBlockTags.includes(__identifier)) {\n            this.tag = __identifier;\n        } else {\n            this.tag = \"pending\" /* pending */ ;\n        }\n    }\n    // TODO: fix any\n    get queryIdentifier() {\n        if (this.number !== null) {\n            return `blockNumber=${this.number}`;\n        }\n        if (this.hash !== null) {\n            return `blockHash=${this.hash}`;\n        }\n        return `blockNumber=${this.tag}`;\n    }\n    // TODO: fix any\n    get identifier() {\n        if (this.number !== null) {\n            return {\n                block_number: this.number\n            };\n        }\n        if (this.hash !== null) {\n            return {\n                block_hash: this.hash\n            };\n        }\n        return this.tag;\n    }\n    set identifier(_identifier) {\n        this.setIdentifier(_identifier);\n    }\n    get sequencerIdentifier() {\n        return this.hash !== null ? {\n            blockHash: this.hash\n        } : {\n            blockNumber: this.number ?? this.tag\n        };\n    }\n};\n// src/provider/rpc.ts\nvar getDefaultNodeUrl = (networkName, mute = false)=>{\n    if (!mute) console.warn(\"Using default public node url, please provide nodeUrl in provider options!\");\n    const nodes = networkName === \"SN_MAIN\" /* SN_MAIN */  ? RPC_MAINNET_NODES : RPC_GOERLI_NODES;\n    const randIdx = Math.floor(Math.random() * nodes.length);\n    return nodes[randIdx];\n};\nvar defaultOptions = {\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    blockIdentifier: \"pending\" /* pending */ ,\n    retries: 200\n};\nvar RpcProvider = class {\n    constructor(optionsOrProvider){\n        this.responseParser = new RPCResponseParser();\n        /**\n     * @deprecated renamed to getBlockLatestAccepted(); (will be removed in next minor version)\n     */ this.getBlockHashAndNumber = this.getBlockLatestAccepted;\n        /**\n     * @deprecated renamed to getBlockStateUpdate();\n     */ this.getStateUpdate = this.getBlockStateUpdate;\n        /**\n     * Returns the execution traces of all transactions included in the given block\n     * @deprecated renamed to getBlockTransactionsTraces()\n     */ this.traceBlockTransactions = this.getBlockTransactionsTraces;\n        /**\n     * Get the number of transactions in a block given a block id\n     * @deprecated renamed to getBlockTransactionCount()\n     * @returns Number of transactions\n     */ this.getTransactionCount = this.getBlockTransactionCount;\n        /**\n     * @deprecated renamed to getTransactionTrace();\n     * For a given executed transaction, return the trace of its execution, including internal calls\n     */ this.traceTransaction = this.getTransactionTrace;\n        /**\n     * @deprecated renamed to simulateTransaction();\n     */ this.getSimulateTransaction = this.simulateTransaction;\n        const { nodeUrl, retries, headers, blockIdentifier, chainId } = optionsOrProvider || {};\n        if (Object.values(NetworkName).includes(nodeUrl)) {\n            this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider?.default);\n        } else if (nodeUrl) {\n            this.nodeUrl = nodeUrl;\n        } else {\n            this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider?.default);\n        }\n        this.retries = retries || defaultOptions.retries;\n        this.headers = {\n            ...defaultOptions.headers,\n            ...headers\n        };\n        this.blockIdentifier = blockIdentifier || defaultOptions.blockIdentifier;\n        this.chainId = chainId;\n    }\n    fetch(method, params, id = 0) {\n        const rpcRequestBody = {\n            id,\n            jsonrpc: \"2.0\",\n            method,\n            ...params && {\n                params\n            }\n        };\n        return fetchPonyfill_default(this.nodeUrl, {\n            method: \"POST\",\n            body: stringify2(rpcRequestBody),\n            headers: this.headers\n        });\n    }\n    errorHandler(method, params, rpcError, otherError) {\n        if (rpcError) {\n            const { code, message, data } = rpcError;\n            throw new LibraryError(`RPC: ${method} with params ${stringify2(params)}\n ${code}: ${message}: ${stringify2(data)}`);\n        }\n        if (otherError instanceof LibraryError) {\n            throw otherError;\n        }\n        if (otherError) {\n            throw Error(otherError.message);\n        }\n    }\n    async fetchEndpoint(method, params) {\n        try {\n            const rawResult = await this.fetch(method, params);\n            const { error, result } = await rawResult.json();\n            this.errorHandler(method, params, error);\n            return result;\n        } catch (error) {\n            this.errorHandler(method, params, error?.response?.data, error);\n            throw error;\n        }\n    }\n    async getChainId() {\n        this.chainId ?? (this.chainId = await this.fetchEndpoint(\"starknet_chainId\"));\n        return this.chainId;\n    }\n    /**\n   * NEW: Returns the version of the Starknet JSON-RPC specification being used\n   */ async getSpecVersion() {\n        return this.fetchEndpoint(\"starknet_specVersion\");\n    }\n    async getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getNonce\", {\n            contract_address,\n            block_id\n        });\n    }\n    /**\n   * @deprecated use getBlockWithTxHashes or getBlockWithTxs (will be removed on sequencer deprecation)\n   */ async getBlock(blockIdentifier = this.blockIdentifier) {\n        return this.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseGetBlockResponse);\n    }\n    /**\n   * Get the most recent accepted block hash and number\n   */ async getBlockLatestAccepted() {\n        return this.fetchEndpoint(\"starknet_blockHashAndNumber\");\n    }\n    /**\n   * @deprecated redundant use getBlockLatestAccepted();\n   * Get the most recent accepted block number\n   * @returns Number of the latest block\n   */ async getBlockNumber() {\n        return this.fetchEndpoint(\"starknet_blockNumber\");\n    }\n    async getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockWithTxHashes\", {\n            block_id\n        });\n    }\n    async getBlockWithTxs(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockWithTxs\", {\n            block_id\n        });\n    }\n    async getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getStateUpdate\", {\n            block_id\n        });\n    }\n    async getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_traceBlockTransactions\", {\n            block_id\n        });\n    }\n    async getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockTransactionCount\", {\n            block_id\n        });\n    }\n    /**\n   * Return transactions from pending block\n   * @deprecated Instead use getBlock(BlockTag.pending); (will be removed in next minor version)\n   */ async getPendingTransactions() {\n        const { transactions } = await this.getBlock(\"pending\" /* pending */ );\n        return Promise.all(transactions.map((it)=>this.getTransactionByHash(it)));\n    }\n    /**\n   * @deprecated use getTransactionByHash or getTransactionByBlockIdAndIndex (will be removed on sequencer deprecation)\n   */ async getTransaction(txHash) {\n        return this.getTransactionByHash(txHash).then(this.responseParser.parseGetTransactionResponse);\n    }\n    async getTransactionByHash(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_getTransactionByHash\", {\n            transaction_hash\n        });\n    }\n    async getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getTransactionByBlockIdAndIndex\", {\n            block_id,\n            index\n        });\n    }\n    async getTransactionReceipt(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_getTransactionReceipt\", {\n            transaction_hash\n        });\n    }\n    async getTransactionTrace(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_traceTransaction\", {\n            transaction_hash\n        });\n    }\n    /**\n   * NEW: Get the status of a transaction\n   */ async getTransactionStatus(transactionHash) {\n        const transaction_hash = toHex(transactionHash);\n        return this.fetchEndpoint(\"starknet_getTransactionStatus\", {\n            transaction_hash\n        });\n    }\n    /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */ async simulateTransaction(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false, skipFeeCharge = true }) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const simulationFlags = [];\n        if (skipValidate) simulationFlags.push(rpc_exports.ESimulationFlag.SKIP_VALIDATE);\n        if (skipFeeCharge) simulationFlags.push(rpc_exports.ESimulationFlag.SKIP_FEE_CHARGE);\n        return this.fetchEndpoint(\"starknet_simulateTransactions\", {\n            block_id,\n            transactions: invocations.map((it)=>this.buildTransaction(it)),\n            simulation_flags: simulationFlags\n        }).then(this.responseParser.parseSimulateTransactionResponse);\n    }\n    async waitForTransaction(txHash, options) {\n        const transactionHash = toHex(txHash);\n        let { retries } = this;\n        let onchain = false;\n        let isErrorState = false;\n        const retryInterval = options?.retryInterval ?? 5e3;\n        const errorStates = options?.errorStates ?? [\n            rpc_exports.ETransactionStatus.REJECTED,\n            rpc_exports.ETransactionExecutionStatus.REVERTED\n        ];\n        const successStates = options?.successStates ?? [\n            rpc_exports.ETransactionExecutionStatus.SUCCEEDED,\n            rpc_exports.ETransactionStatus.ACCEPTED_ON_L2,\n            rpc_exports.ETransactionStatus.ACCEPTED_ON_L1\n        ];\n        let txStatus;\n        while(!onchain){\n            await wait(retryInterval);\n            try {\n                txStatus = await this.getTransactionStatus(transactionHash);\n                const executionStatus = txStatus.execution_status;\n                const finalityStatus = txStatus.finality_status;\n                if (!finalityStatus) {\n                    const error = new Error(\"waiting for transaction status\");\n                    throw error;\n                }\n                if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {\n                    onchain = true;\n                } else if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n                    const message = `${executionStatus}: ${finalityStatus}`;\n                    const error = new Error(message);\n                    error.response = txStatus;\n                    isErrorState = true;\n                    throw error;\n                }\n            } catch (error) {\n                if (error instanceof Error && isErrorState) {\n                    throw error;\n                }\n                if (retries <= 0) {\n                    throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n                }\n            }\n            retries -= 1;\n        }\n        let txReceipt = null;\n        while(txReceipt === null){\n            try {\n                txReceipt = await this.getTransactionReceipt(transactionHash);\n            } catch (error) {\n                if (retries <= 0) {\n                    throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n                }\n            }\n            retries -= 1;\n            await wait(retryInterval);\n        }\n        return txReceipt;\n    }\n    async getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const parsedKey = toStorageKey(key);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getStorageAt\", {\n            contract_address,\n            key: parsedKey,\n            block_id\n        });\n    }\n    async getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClassHashAt\", {\n            block_id,\n            contract_address\n        });\n    }\n    async getClassByHash(classHash) {\n        return this.getClass(classHash);\n    }\n    async getClass(classHash, blockIdentifier = this.blockIdentifier) {\n        const class_hash = toHex(classHash);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClass\", {\n            class_hash,\n            block_id\n        }).then(this.responseParser.parseContractClassResponse);\n    }\n    async getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClassAt\", {\n            block_id,\n            contract_address\n        }).then(this.responseParser.parseContractClassResponse);\n    }\n    async getCode(_contractAddress, _blockIdentifier) {\n        throw new Error(\"RPC does not implement getCode function\");\n    }\n    async getContractVersion(contractAddress, classHash, { blockIdentifier = this.blockIdentifier, compiler = true } = {}) {\n        let contractClass;\n        if (contractAddress) {\n            contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n        } else if (classHash) {\n            contractClass = await this.getClass(classHash, blockIdentifier);\n        } else {\n            throw Error(\"getContractVersion require contractAddress or classHash\");\n        }\n        if (isSierra(contractClass)) {\n            if (compiler) {\n                const abiTest = getAbiContractVersion(contractClass.abi);\n                return {\n                    cairo: \"1\",\n                    compiler: abiTest.compiler\n                };\n            }\n            return {\n                cairo: \"1\",\n                compiler: void 0\n            };\n        }\n        return {\n            cairo: \"0\",\n            compiler: \"0\"\n        };\n    }\n    /**\n   * @deprecated use get*type*EstimateFee (will be refactored based on type after sequencer deprecation)\n   */ async getEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier) {\n        return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier);\n    }\n    async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const transaction = this.buildTransaction({\n            type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n            ...invocation,\n            ...invocationDetails\n        }, \"fee\");\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: [\n                transaction\n            ],\n            block_id\n        }).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getDeclareEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const transaction = this.buildTransaction({\n            type: \"DECLARE\" /* DECLARE */ ,\n            ...invocation,\n            ...details\n        }, \"fee\");\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: [\n                transaction\n            ],\n            block_id\n        }).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getDeployAccountEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const transaction = this.buildTransaction({\n            type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n            ...invocation,\n            ...details\n        }, \"fee\");\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: [\n                transaction\n            ],\n            block_id\n        }).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getEstimateFeeBulk(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false }) {\n        if (skipValidate) {\n            console.warn(\"getEstimateFeeBulk RPC does not support skipValidate\");\n        }\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: invocations.map((it)=>this.buildTransaction(it, \"fee\")),\n            block_id\n        }).then(this.responseParser.parseFeeEstimateBulkResponse);\n    }\n    async invokeFunction(functionInvocation, details) {\n        return this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n            invoke_transaction: {\n                sender_address: functionInvocation.contractAddress,\n                calldata: CallData.toHex(functionInvocation.calldata),\n                type: rpc_exports.ETransactionType.INVOKE,\n                max_fee: toHex(details.maxFee || 0),\n                version: \"0x1\",\n                signature: signatureToHexArray(functionInvocation.signature),\n                nonce: toHex(details.nonce)\n            }\n        });\n    }\n    async declareContract({ contract, signature, senderAddress, compiledClassHash }, details) {\n        if (!isSierra(contract)) {\n            return this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n                declare_transaction: {\n                    type: rpc_exports.ETransactionType.DECLARE,\n                    contract_class: {\n                        program: contract.program,\n                        entry_points_by_type: contract.entry_points_by_type,\n                        abi: contract.abi\n                    },\n                    version: HEX_STR_TRANSACTION_VERSION_1,\n                    max_fee: toHex(details.maxFee || 0),\n                    signature: signatureToHexArray(signature),\n                    sender_address: senderAddress,\n                    nonce: toHex(details.nonce)\n                }\n            });\n        }\n        return this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n            declare_transaction: {\n                type: rpc_exports.ETransactionType.DECLARE,\n                contract_class: {\n                    sierra_program: decompressProgram(contract.sierra_program),\n                    contract_class_version: contract.contract_class_version,\n                    entry_points_by_type: contract.entry_points_by_type,\n                    abi: contract.abi\n                },\n                compiled_class_hash: compiledClassHash || \"\",\n                version: HEX_STR_TRANSACTION_VERSION_2,\n                max_fee: toHex(details.maxFee || 0),\n                signature: signatureToHexArray(signature),\n                sender_address: senderAddress,\n                nonce: toHex(details.nonce)\n            }\n        });\n    }\n    async deployAccountContract({ classHash, constructorCalldata, addressSalt, signature }, details) {\n        return this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n            deploy_account_transaction: {\n                constructor_calldata: CallData.toHex(constructorCalldata || []),\n                class_hash: toHex(classHash),\n                contract_address_salt: toHex(addressSalt || 0),\n                type: rpc_exports.ETransactionType.DEPLOY_ACCOUNT,\n                max_fee: toHex(details.maxFee || 0),\n                version: toHex(details.version || 0),\n                signature: signatureToHexArray(signature),\n                nonce: toHex(details.nonce)\n            }\n        });\n    }\n    async callContract(call, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const result = await this.fetchEndpoint(\"starknet_call\", {\n            request: {\n                contract_address: call.contractAddress,\n                entry_point_selector: getSelectorFromName(call.entrypoint),\n                calldata: CallData.toHex(call.calldata)\n            },\n            block_id\n        });\n        return this.responseParser.parseCallContractResponse(result);\n    }\n    /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */ async estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {\n        const { from_address, to_address, entry_point_selector, payload } = message;\n        const formattedMessage = {\n            from_address: toHex(from_address),\n            to_address: toHex(to_address),\n            entry_point_selector: getSelector(entry_point_selector),\n            payload: getHexStringArray(payload)\n        };\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_estimateMessageFee\", {\n            message: formattedMessage,\n            block_id\n        });\n    }\n    /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */ async getSyncingStats() {\n        return this.fetchEndpoint(\"starknet_syncing\");\n    }\n    /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */ async getEvents(eventFilter) {\n        return this.fetchEndpoint(\"starknet_getEvents\", {\n            filter: eventFilter\n        });\n    }\n    /**\n   * StarknetId Endpoint (get name from address)\n   */ async getStarkName(address, StarknetIdContract2) {\n        return getStarkName(this, address, StarknetIdContract2);\n    }\n    /**\n   * StarknetId Endpoint (get address from name)\n   */ async getAddressFromStarkName(name, StarknetIdContract2) {\n        return getAddressFromStarkName(this, name, StarknetIdContract2);\n    }\n    buildTransaction(invocation, versionType) {\n        const defaultVersions = getVersionsByType(versionType);\n        const details = {\n            signature: signatureToHexArray(invocation.signature),\n            nonce: toHex(invocation.nonce),\n            max_fee: toHex(invocation.maxFee || 0)\n        };\n        if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */ ) {\n            return {\n                type: rpc_exports.ETransactionType.INVOKE,\n                // Diff between sequencer and rpc invoke type\n                sender_address: invocation.contractAddress,\n                calldata: CallData.toHex(invocation.calldata),\n                version: toHex(invocation.version || defaultVersions.v1),\n                ...details\n            };\n        }\n        if (invocation.type === \"DECLARE\" /* DECLARE */ ) {\n            if (!isSierra(invocation.contract)) {\n                return {\n                    type: invocation.type,\n                    contract_class: invocation.contract,\n                    sender_address: invocation.senderAddress,\n                    version: toHex(invocation.version || defaultVersions.v1),\n                    ...details\n                };\n            }\n            return {\n                // compiled_class_hash\n                type: invocation.type,\n                contract_class: {\n                    ...invocation.contract,\n                    sierra_program: decompressProgram(invocation.contract.sierra_program)\n                },\n                compiled_class_hash: invocation.compiledClassHash || \"\",\n                sender_address: invocation.senderAddress,\n                version: toHex(invocation.version || defaultVersions.v2),\n                ...details\n            };\n        }\n        if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ) {\n            return {\n                type: invocation.type,\n                constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n                class_hash: toHex(invocation.classHash),\n                contract_address_salt: toHex(invocation.addressSalt || 0),\n                version: toHex(invocation.version || defaultVersions.v1),\n                ...details\n            };\n        }\n        throw Error(\"RPC buildTransaction received unknown TransactionType\");\n    }\n};\n// src/provider/sequencer.ts\n\n// src/utils/responseParser/index.ts\nvar ResponseParser = class {\n};\n// src/utils/responseParser/sequencer.ts\nvar SequencerAPIResponseParser = class extends ResponseParser {\n    parseGetBlockResponse(res) {\n        return {\n            ...res,\n            new_root: res.state_root,\n            parent_hash: res.parent_block_hash,\n            transactions: Object.values(res.transactions).map((value)=>\"transaction_hash\" in value && value.transaction_hash).filter(Boolean)\n        };\n    }\n    parseGetTransactionResponse(res) {\n        if (res.status === \"NOT_RECEIVED\" /* NOT_RECEIVED */  && res.finality_status === \"NOT_RECEIVED\" /* NOT_RECEIVED */ ) {\n            throw new LibraryError();\n        }\n        return {\n            ...res,\n            calldata: \"calldata\" in res.transaction ? res.transaction.calldata : [],\n            contract_class: \"contract_class\" in res.transaction ? res.transaction.contract_class : void 0,\n            entry_point_selector: \"entry_point_selector\" in res.transaction ? res.transaction.entry_point_selector : void 0,\n            max_fee: \"max_fee\" in res.transaction ? res.transaction.max_fee : void 0,\n            nonce: res.transaction.nonce,\n            sender_address: \"sender_address\" in res.transaction ? res.transaction.sender_address : void 0,\n            signature: \"signature\" in res.transaction ? res.transaction.signature : void 0,\n            transaction_hash: \"transaction_hash\" in res.transaction ? res.transaction.transaction_hash : void 0,\n            version: \"version\" in res.transaction ? res.transaction.version : void 0\n        };\n    }\n    parseGetTransactionReceiptResponse(res) {\n        return {\n            ...res,\n            messages_sent: res.l2_to_l1_messages,\n            ...\"revert_error\" in res && {\n                revert_reason: res.revert_error\n            }\n        };\n    }\n    parseFeeEstimateResponse(res) {\n        if (\"overall_fee\" in res) {\n            let gasInfo = {};\n            try {\n                gasInfo = {\n                    gas_consumed: toBigInt(res.gas_usage),\n                    gas_price: toBigInt(res.gas_price)\n                };\n            } catch  {}\n            return {\n                overall_fee: toBigInt(res.overall_fee),\n                ...gasInfo\n            };\n        }\n        return {\n            overall_fee: toBigInt(res.amount)\n        };\n    }\n    parseFeeEstimateBulkResponse(res) {\n        return [].concat(res).map((item)=>{\n            if (\"overall_fee\" in item) {\n                let gasInfo = {};\n                try {\n                    gasInfo = {\n                        gas_consumed: toBigInt(item.gas_usage),\n                        gas_price: toBigInt(item.gas_price)\n                    };\n                } catch  {}\n                return {\n                    overall_fee: toBigInt(item.overall_fee),\n                    ...gasInfo\n                };\n            }\n            return {\n                overall_fee: toBigInt(item.amount)\n            };\n        });\n    }\n    parseSimulateTransactionResponse(res) {\n        const suggestedMaxFee = \"overall_fee\" in res.fee_estimation ? res.fee_estimation.overall_fee : res.fee_estimation.amount;\n        return [\n            {\n                transaction_trace: res.trace,\n                fee_estimation: res.fee_estimation,\n                suggestedMaxFee: estimatedFeeToMaxFee(BigInt(suggestedMaxFee))\n            }\n        ];\n    }\n    parseCallContractResponse(res) {\n        return {\n            result: res.result\n        };\n    }\n    parseInvokeFunctionResponse(res) {\n        return {\n            transaction_hash: res.transaction_hash\n        };\n    }\n    parseDeployContractResponse(res) {\n        return {\n            transaction_hash: res.transaction_hash,\n            contract_address: res.address\n        };\n    }\n    parseDeclareContractResponse(res) {\n        return {\n            transaction_hash: res.transaction_hash,\n            class_hash: res.class_hash\n        };\n    }\n    parseGetStateUpdateResponse(res) {\n        const nonces = Object.entries(res.state_diff.nonces).map(([contract_address, nonce])=>({\n                contract_address,\n                nonce\n            }));\n        const storage_diffs = Object.entries(res.state_diff.storage_diffs).map(([address, storage_entries])=>({\n                address,\n                storage_entries\n            }));\n        return {\n            ...res,\n            state_diff: {\n                ...res.state_diff,\n                storage_diffs,\n                nonces\n            }\n        };\n    }\n    parseContractClassResponse(res) {\n        const response = isSierra(res) ? res : parseContract(res);\n        return {\n            ...response,\n            abi: typeof response.abi === \"string\" ? JSON.parse(response.abi) : response.abi\n        };\n    }\n};\n// src/utils/url.ts\n\nvar protocolAndDomainRE = /^(?:\\w+:)?\\/\\/(\\S+)$/;\nvar localhostDomainRE = /^localhost[:?\\d]*(?:[^:?\\d]\\S*)?$/;\nvar nonLocalhostDomainRE = /^[^\\s.]+\\.\\S{2,}$/;\nfunction isUrl(s) {\n    if (!s) {\n        return false;\n    }\n    if (typeof s !== \"string\") {\n        return false;\n    }\n    const match = s.match(protocolAndDomainRE);\n    if (!match) {\n        return false;\n    }\n    const everythingAfterProtocol = match[1];\n    if (!everythingAfterProtocol) {\n        return false;\n    }\n    if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {\n        return true;\n    }\n    return false;\n}\nfunction buildUrl(baseUrl, defaultPath, urlOrPath) {\n    return isUrl(urlOrPath) ? urlOrPath : url_join__WEBPACK_IMPORTED_MODULE_8__(baseUrl, urlOrPath ?? defaultPath);\n}\n// src/provider/sequencer.ts\nfunction isEmptyQueryObject(obj) {\n    return obj === void 0 || Object.keys(obj).length === 0 || Object.keys(obj).length === 1 && Object.entries(obj).every(([k, v])=>k === \"blockIdentifier\" && v === null);\n}\nvar defaultOptions2 = {\n    network: \"SN_GOERLI\" /* SN_GOERLI */ ,\n    blockIdentifier: \"pending\" /* pending */ \n};\nvar SequencerProvider = class {\n    constructor(optionsOrProvider = defaultOptions2){\n        this.responseParser = new SequencerAPIResponseParser();\n        if (\"network\" in optionsOrProvider) {\n            this.baseUrl = SequencerProvider.getNetworkFromName(optionsOrProvider.network);\n            this.feederGatewayUrl = buildUrl(this.baseUrl, \"feeder_gateway\");\n            this.gatewayUrl = buildUrl(this.baseUrl, \"gateway\");\n        } else {\n            this.baseUrl = optionsOrProvider.baseUrl;\n            this.feederGatewayUrl = buildUrl(this.baseUrl, \"feeder_gateway\", optionsOrProvider.feederGatewayUrl);\n            this.gatewayUrl = buildUrl(this.baseUrl, \"gateway\", optionsOrProvider.gatewayUrl);\n        }\n        this.chainId = optionsOrProvider?.chainId ?? SequencerProvider.getChainIdFromBaseUrl(this.baseUrl);\n        this.headers = optionsOrProvider.headers;\n        this.blockIdentifier = optionsOrProvider?.blockIdentifier || defaultOptions2.blockIdentifier;\n    }\n    static getNetworkFromName(name) {\n        switch(name){\n            case \"SN_MAIN\" /* SN_MAIN */ :\n            case \"0x534e5f4d41494e\" /* SN_MAIN */ :\n                return \"https://alpha-mainnet.starknet.io\" /* SN_MAIN */ ;\n            case \"SN_GOERLI\" /* SN_GOERLI */ :\n            case \"0x534e5f474f45524c49\" /* SN_GOERLI */ :\n                return \"https://alpha4.starknet.io\" /* SN_GOERLI */ ;\n            default:\n                throw new Error(\"Could not detect base url from NetworkName\");\n        }\n    }\n    static getChainIdFromBaseUrl(baseUrl) {\n        try {\n            const url = new URL(baseUrl);\n            if (url.host.includes(\"mainnet.starknet.io\")) {\n                return \"0x534e5f4d41494e\" /* SN_MAIN */ ;\n            }\n            return \"0x534e5f474f45524c49\" /* SN_GOERLI */ ;\n        } catch  {\n            console.error(`Could not parse baseUrl: ${baseUrl}`);\n            return \"0x534e5f474f45524c49\" /* SN_GOERLI */ ;\n        }\n    }\n    getFetchUrl(endpoint) {\n        const gatewayUrlEndpoints = [\n            \"add_transaction\"\n        ];\n        return gatewayUrlEndpoints.includes(endpoint) ? this.gatewayUrl : this.feederGatewayUrl;\n    }\n    getFetchMethod(endpoint) {\n        const postMethodEndpoints = [\n            \"add_transaction\",\n            \"call_contract\",\n            \"estimate_fee\",\n            \"estimate_message_fee\",\n            \"estimate_fee_bulk\",\n            \"simulate_transaction\"\n        ];\n        return postMethodEndpoints.includes(endpoint) ? \"POST\" : \"GET\";\n    }\n    getQueryString(query) {\n        if (isEmptyQueryObject(query)) {\n            return \"\";\n        }\n        const queryString = Object.entries(query).map(([key, value])=>{\n            if (key === \"blockIdentifier\") {\n                const block = new Block(value);\n                return `${block.queryIdentifier}`;\n            }\n            return `${key}=${value}`;\n        }).join(\"&\");\n        return `?${queryString}`;\n    }\n    getHeaders(method) {\n        if (method === \"POST\") {\n            return {\n                \"Content-Type\": \"application/json\",\n                ...this.headers\n            };\n        }\n        return this.headers;\n    }\n    // typesafe fetch\n    async fetchEndpoint(endpoint, ...[query, request]) {\n        const baseUrl = this.getFetchUrl(endpoint);\n        const method = this.getFetchMethod(endpoint);\n        const queryString = this.getQueryString(query);\n        const url = url_join__WEBPACK_IMPORTED_MODULE_8__(baseUrl, endpoint, queryString);\n        return this.fetch(url, {\n            method,\n            body: request\n        });\n    }\n    async fetch(endpoint, options) {\n        const url = buildUrl(this.baseUrl, \"\", endpoint);\n        const method = options?.method ?? \"GET\";\n        const headers = this.getHeaders(method);\n        const body = stringify2(options?.body);\n        try {\n            const response = await fetchPonyfill_default(url, {\n                method,\n                body,\n                headers\n            });\n            const textResponse = await response.text();\n            if (!response.ok) {\n                let responseBody;\n                try {\n                    responseBody = parse2(textResponse);\n                } catch  {\n                    throw new HttpError(response.statusText, response.status);\n                }\n                throw new GatewayError(responseBody.message, responseBody.code);\n            }\n            const parseChoice = options?.parseAlwaysAsBigInt ? parseAlwaysAsBig : parse2;\n            return parseChoice(textResponse);\n        } catch (error) {\n            if (error instanceof Error && !(error instanceof LibraryError)) throw Error(`Could not ${method} from endpoint \\`${url}\\`: ${error.message}`);\n            throw error;\n        }\n    }\n    async getChainId() {\n        return Promise.resolve(this.chainId);\n    }\n    async callContract({ contractAddress, entrypoint: entryPointSelector, calldata = [] }, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"call_contract\", {\n            blockIdentifier\n        }, {\n            // TODO - determine best choice once both are fully supported in devnet\n            // signature: [],\n            // sender_address: contractAddress,\n            contract_address: contractAddress,\n            entry_point_selector: getSelectorFromName(entryPointSelector),\n            calldata: CallData.compile(calldata)\n        }).then(this.responseParser.parseCallContractResponse);\n    }\n    async getBlock(blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_block\", {\n            blockIdentifier\n        }).then(this.responseParser.parseGetBlockResponse);\n    }\n    async getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_nonce\", {\n            contractAddress,\n            blockIdentifier\n        });\n    }\n    async getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n        const parsedKey = toBigInt(key).toString(10);\n        return this.fetchEndpoint(\"get_storage_at\", {\n            blockIdentifier,\n            contractAddress,\n            key: parsedKey\n        });\n    }\n    async getTransaction(txHash) {\n        const txHashHex = toHex(txHash);\n        return this.fetchEndpoint(\"get_transaction\", {\n            transactionHash: txHashHex\n        }).then((result)=>{\n            if (Object.values(result).length === 1) throw new LibraryError(result.status);\n            return this.responseParser.parseGetTransactionResponse(result);\n        });\n    }\n    async getTransactionReceipt(txHash) {\n        const txHashHex = toHex(txHash);\n        return this.fetchEndpoint(\"get_transaction_receipt\", {\n            transactionHash: txHashHex\n        }).then(this.responseParser.parseGetTransactionReceiptResponse);\n    }\n    async getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_full_contract\", {\n            blockIdentifier,\n            contractAddress\n        }).then(this.responseParser.parseContractClassResponse);\n    }\n    async getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_class_hash_at\", {\n            blockIdentifier,\n            contractAddress\n        });\n    }\n    async getClassByHash(classHash, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_class_by_hash\", {\n            classHash,\n            blockIdentifier\n        }).then(this.responseParser.parseContractClassResponse);\n    }\n    async getCompiledClassByClassHash(classHash, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_compiled_class_by_class_hash\", {\n            classHash,\n            blockIdentifier\n        });\n    }\n    async getContractVersion(contractAddress, classHash, { blockIdentifier = this.blockIdentifier, compiler = true } = {}) {\n        let contractClass;\n        if (contractAddress) {\n            contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n        } else if (classHash) {\n            contractClass = await this.getClassByHash(classHash, blockIdentifier);\n        } else {\n            throw Error(\"getContractVersion require contractAddress or classHash\");\n        }\n        if (isSierra(contractClass)) {\n            if (compiler) {\n                const abiTest = getAbiContractVersion(contractClass.abi);\n                return {\n                    cairo: \"1\",\n                    compiler: abiTest.compiler\n                };\n            }\n            return {\n                cairo: \"1\",\n                compiler: void 0\n            };\n        }\n        return {\n            cairo: \"0\",\n            compiler: \"0\"\n        };\n    }\n    async invokeFunction(functionInvocation, details) {\n        return this.fetchEndpoint(\"add_transaction\", void 0, {\n            type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n            sender_address: functionInvocation.contractAddress,\n            calldata: CallData.compile(functionInvocation.calldata ?? []),\n            signature: signatureToDecimalArray(functionInvocation.signature),\n            nonce: toHex(details.nonce),\n            max_fee: toHex(details.maxFee || 0),\n            version: \"0x1\"\n        }).then(this.responseParser.parseInvokeFunctionResponse);\n    }\n    async deployAccountContract({ classHash, constructorCalldata, addressSalt, signature }, details) {\n        return this.fetchEndpoint(\"add_transaction\", void 0, {\n            type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n            contract_address_salt: addressSalt ?? randomAddress(),\n            constructor_calldata: CallData.compile(constructorCalldata ?? []),\n            class_hash: toHex(classHash),\n            max_fee: toHex(details.maxFee || 0),\n            version: toHex(details.version || 0),\n            nonce: toHex(details.nonce),\n            signature: signatureToDecimalArray(signature)\n        }).then(this.responseParser.parseDeployContractResponse);\n    }\n    async declareContract({ senderAddress, contract, signature, compiledClassHash }, details) {\n        if (!isSierra(contract)) {\n            return this.fetchEndpoint(\"add_transaction\", void 0, {\n                type: \"DECLARE\" /* DECLARE */ ,\n                contract_class: contract,\n                nonce: toHex(details.nonce),\n                signature: signatureToDecimalArray(signature),\n                sender_address: senderAddress,\n                max_fee: toHex(details.maxFee || 0),\n                version: toHex(transactionVersion)\n            }).then(this.responseParser.parseDeclareContractResponse);\n        }\n        return this.fetchEndpoint(\"add_transaction\", void 0, {\n            type: \"DECLARE\" /* DECLARE */ ,\n            sender_address: senderAddress,\n            compiled_class_hash: compiledClassHash,\n            contract_class: contract,\n            nonce: toHex(details.nonce),\n            signature: signatureToDecimalArray(signature),\n            max_fee: toHex(details.maxFee || 0),\n            version: toHex(transactionVersion_2)\n        }).then(this.responseParser.parseDeclareContractResponse);\n    }\n    async getEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n        return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate);\n    }\n    async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n        const transaction = this.buildTransaction({\n            type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n            ...invocation,\n            ...invocationDetails\n        }, \"fee\");\n        return this.fetchEndpoint(\"estimate_fee\", {\n            blockIdentifier,\n            skipValidate\n        }, transaction).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getDeclareEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n        const transaction = this.buildTransaction({\n            type: \"DECLARE\" /* DECLARE */ ,\n            ...invocation,\n            ...details\n        }, \"fee\");\n        return this.fetchEndpoint(\"estimate_fee\", {\n            blockIdentifier,\n            skipValidate\n        }, transaction).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getDeployAccountEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n        const transaction = this.buildTransaction({\n            type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n            ...invocation,\n            ...details\n        }, \"fee\");\n        return this.fetchEndpoint(\"estimate_fee\", {\n            blockIdentifier,\n            skipValidate\n        }, transaction).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getEstimateFeeBulk(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false }) {\n        const transactions = invocations.map((it)=>this.buildTransaction(it, \"fee\"));\n        return this.fetchEndpoint(\"estimate_fee_bulk\", {\n            blockIdentifier,\n            skipValidate\n        }, transactions).then(this.responseParser.parseFeeEstimateBulkResponse);\n    }\n    async getCode(contractAddress, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_code\", {\n            contractAddress,\n            blockIdentifier\n        });\n    }\n    async waitForTransaction(txHash, options) {\n        let res;\n        let completed = false;\n        let retries = 0;\n        const retryInterval = options?.retryInterval ?? 5e3;\n        const errorStates = options?.errorStates ?? [\n            \"REJECTED\" /* REJECTED */ ,\n            \"NOT_RECEIVED\" /* NOT_RECEIVED */ ,\n            \"REVERTED\" /* REVERTED */ \n        ];\n        const successStates = options?.successStates ?? [\n            \"SUCCEEDED\" /* SUCCEEDED */ ,\n            \"ACCEPTED_ON_L1\" /* ACCEPTED_ON_L1 */ ,\n            \"ACCEPTED_ON_L2\" /* ACCEPTED_ON_L2 */ \n        ];\n        while(!completed){\n            await wait(retryInterval);\n            res = await this.getTransactionStatus(txHash);\n            if (\"NOT_RECEIVED\" /* NOT_RECEIVED */  === res.finality_status && retries < 3) {\n                retries += 1;\n            } else if (successStates.includes(res.finality_status) || successStates.includes(res.execution_status)) {\n                completed = true;\n            } else if (errorStates.includes(res.finality_status) || errorStates.includes(res.execution_status)) {\n                let message;\n                if (res.tx_failure_reason) {\n                    message = `${res.tx_status}: ${res.tx_failure_reason.code}\n${res.tx_failure_reason.error_message}`;\n                } else if (res.tx_revert_reason) {\n                    message = `${res.tx_status}: ${res.tx_revert_reason}`;\n                } else {\n                    message = res.tx_status;\n                }\n                const error = new Error(message);\n                error.response = res;\n                throw error;\n            }\n        }\n        const txReceipt = await this.getTransactionReceipt(txHash);\n        return txReceipt;\n    }\n    /**\n   * Gets the status of a transaction.\n   * @param txHash BigNumberish\n   * @returns GetTransactionStatusResponse - the transaction status object\n   */ async getTransactionStatus(txHash) {\n        const txHashHex = toHex(txHash);\n        return this.fetchEndpoint(\"get_transaction_status\", {\n            transactionHash: txHashHex\n        });\n    }\n    /**\n   * Gets the smart contract address on the goerli testnet.\n   * @returns GetContractAddressesResponse - starknet smart contract addresses\n   */ async getContractAddresses() {\n        return this.fetchEndpoint(\"get_contract_addresses\");\n    }\n    /**\n   * Gets the transaction trace from a tx id.\n   * @param txHash BigNumberish\n   * @returns TransactionTraceResponse - the transaction trace\n   */ async getTransactionTrace(txHash) {\n        const txHashHex = toHex(txHash);\n        return this.fetchEndpoint(\"get_transaction_trace\", {\n            transactionHash: txHashHex\n        });\n    }\n    async estimateMessageFee({ from_address, to_address, entry_point_selector, payload }, blockIdentifier = this.blockIdentifier) {\n        const validCallL1Handler = {\n            from_address: getDecimalString(from_address),\n            to_address: getHexString(to_address),\n            entry_point_selector: getSelector(entry_point_selector),\n            payload: getHexStringArray(payload)\n        };\n        return this.fetchEndpoint(\"estimate_message_fee\", {\n            blockIdentifier\n        }, validCallL1Handler);\n    }\n    /**\n   * Simulate transaction using Sequencer provider\n   * WARNING!: Sequencer will process only first element from invocations array\n   *\n   * @param invocations Array of invocations, but only first invocation will be processed\n   * @param blockIdentifier block identifier, default 'latest'\n   * @param skipValidate Skip Account __validate__ method\n   * @returns\n   */ async getSimulateTransaction(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false, skipExecute = false }) {\n        if (invocations.length > 1) {\n            console.warn(\"Sequencer simulate process only first element from invocations list\");\n        }\n        if (skipExecute) {\n            console.warn(\"Sequencer can't skip account __execute__\");\n        }\n        const transaction = this.buildTransaction(invocations[0]);\n        return this.fetchEndpoint(\"simulate_transaction\", {\n            blockIdentifier,\n            skipValidate: skipValidate ?? false\n        }, transaction).then(this.responseParser.parseSimulateTransactionResponse);\n    }\n    async getStateUpdate(blockIdentifier = this.blockIdentifier) {\n        const args = new Block(blockIdentifier).sequencerIdentifier;\n        return this.fetchEndpoint(\"get_state_update\", {\n            ...args\n        }).then(this.responseParser.parseGetStateUpdateResponse);\n    }\n    // consider adding an optional trace retrieval parameter to the getBlock method\n    async getBlockTraces(blockIdentifier = this.blockIdentifier) {\n        const args = new Block(blockIdentifier).sequencerIdentifier;\n        return this.fetchEndpoint(\"get_block_traces\", {\n            ...args\n        });\n    }\n    async getStarkName(address, StarknetIdContract2) {\n        return getStarkName(this, address, StarknetIdContract2);\n    }\n    async getAddressFromStarkName(name, StarknetIdContract2) {\n        return getAddressFromStarkName(this, name, StarknetIdContract2);\n    }\n    /**\n   * Build Single AccountTransaction from Single AccountInvocation\n   * @param invocation AccountInvocationItem\n   * @param versionType 'fee' | 'transaction' - used to determine default versions\n   * @returns AccountTransactionItem\n   */ buildTransaction(invocation, versionType) {\n        const defaultVersions = getVersionsByType(versionType);\n        const details = {\n            signature: signatureToDecimalArray(invocation.signature),\n            nonce: toHex(invocation.nonce)\n        };\n        if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */ ) {\n            return {\n                type: invocation.type,\n                sender_address: invocation.contractAddress,\n                calldata: CallData.compile(invocation.calldata ?? []),\n                version: toHex(invocation.version || defaultVersions.v1),\n                ...details\n            };\n        }\n        if (invocation.type === \"DECLARE\" /* DECLARE */ ) {\n            if (!isSierra(invocation.contract)) {\n                return {\n                    type: invocation.type,\n                    contract_class: invocation.contract,\n                    sender_address: invocation.senderAddress,\n                    version: toHex(invocation.version || defaultVersions.v1),\n                    // fee from getDeclareEstimateFee use t.v. instead of feet.v.\n                    ...details\n                };\n            }\n            return {\n                type: invocation.type,\n                contract_class: invocation.contract,\n                compiled_class_hash: invocation.compiledClassHash,\n                sender_address: invocation.senderAddress,\n                version: toHex(invocation.version || defaultVersions.v2),\n                // fee on getDeclareEstimateFee use t.v. instead of feet.v.\n                ...details\n            };\n        }\n        if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ) {\n            return {\n                type: invocation.type,\n                constructor_calldata: CallData.compile(invocation.constructorCalldata || []),\n                class_hash: toHex(invocation.classHash),\n                contract_address_salt: toHex(invocation.addressSalt || 0),\n                version: toHex(invocation.version || defaultVersions.v1),\n                ...details\n            };\n        }\n        throw Error(\"Sequencer buildTransaction received unknown TransactionType\");\n    }\n};\n// src/provider/default.ts\nvar Provider = class {\n    constructor(providerOrOptions){\n        if (providerOrOptions instanceof Provider) {\n            this.provider = providerOrOptions.provider;\n        } else if (providerOrOptions instanceof RpcProvider || providerOrOptions instanceof SequencerProvider) {\n            this.provider = providerOrOptions;\n        } else if (providerOrOptions && \"rpc\" in providerOrOptions) {\n            this.provider = new RpcProvider(providerOrOptions.rpc);\n        } else if (providerOrOptions && \"sequencer\" in providerOrOptions) {\n            this.provider = new SequencerProvider(providerOrOptions.sequencer);\n        } else {\n            this.provider = new RpcProvider();\n        }\n    }\n    async getChainId() {\n        return this.provider.getChainId();\n    }\n    async getBlock(blockIdentifier) {\n        return this.provider.getBlock(blockIdentifier);\n    }\n    async getClassAt(contractAddress, blockIdentifier) {\n        return this.provider.getClassAt(contractAddress, blockIdentifier);\n    }\n    async getClassHashAt(contractAddress, blockIdentifier) {\n        return this.provider.getClassHashAt(contractAddress, blockIdentifier);\n    }\n    getClassByHash(classHash) {\n        return this.provider.getClassByHash(classHash);\n    }\n    async getEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier) {\n        return this.provider.getEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier);\n    }\n    async getInvokeEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier, skipValidate) {\n        return this.provider.getInvokeEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier, skipValidate);\n    }\n    async getEstimateFeeBulk(invocations, options) {\n        return this.provider.getEstimateFeeBulk(invocations, options);\n    }\n    async getNonceForAddress(contractAddress, blockIdentifier) {\n        return this.provider.getNonceForAddress(contractAddress, blockIdentifier);\n    }\n    async getStorageAt(contractAddress, key, blockIdentifier) {\n        return this.provider.getStorageAt(contractAddress, key, blockIdentifier);\n    }\n    async getTransaction(txHash) {\n        return this.provider.getTransaction(txHash);\n    }\n    async getTransactionReceipt(txHash) {\n        return this.provider.getTransactionReceipt(txHash);\n    }\n    async callContract(request, blockIdentifier) {\n        return this.provider.callContract(request, blockIdentifier);\n    }\n    async invokeFunction(functionInvocation, details) {\n        return this.provider.invokeFunction(functionInvocation, details);\n    }\n    async deployAccountContract(payload, details) {\n        return this.provider.deployAccountContract(payload, details);\n    }\n    async declareContract(transaction, details) {\n        return this.provider.declareContract(transaction, details);\n    }\n    async getDeclareEstimateFee(transaction, details, blockIdentifier, skipValidate) {\n        return this.provider.getDeclareEstimateFee(transaction, details, blockIdentifier, skipValidate);\n    }\n    getDeployAccountEstimateFee(transaction, details, blockIdentifier, skipValidate) {\n        return this.provider.getDeployAccountEstimateFee(transaction, details, blockIdentifier, skipValidate);\n    }\n    async getCode(contractAddress, blockIdentifier) {\n        return this.provider.getCode(contractAddress, blockIdentifier);\n    }\n    async waitForTransaction(txHash, options) {\n        return this.provider.waitForTransaction(txHash, options);\n    }\n    async getSimulateTransaction(invocations, options) {\n        return this.provider.getSimulateTransaction(invocations, options);\n    }\n    async getStateUpdate(blockIdentifier) {\n        return this.provider.getStateUpdate(blockIdentifier);\n    }\n    async getStarkName(address, StarknetIdContract2) {\n        return getStarkName(this, address, StarknetIdContract2);\n    }\n    async getAddressFromStarkName(name, StarknetIdContract2) {\n        return getAddressFromStarkName(this, name, StarknetIdContract2);\n    }\n    async getContractVersion(contractAddress, classHash, options) {\n        return this.provider.getContractVersion(contractAddress, classHash, options);\n    }\n};\n// src/signer/interface.ts\nvar SignerInterface = class {\n};\n// src/utils/transaction.ts\nvar transaction_exports = {};\n__export(transaction_exports, {\n    fromCallsToExecuteCalldata: ()=>fromCallsToExecuteCalldata,\n    fromCallsToExecuteCalldataWithNonce: ()=>fromCallsToExecuteCalldataWithNonce,\n    fromCallsToExecuteCalldata_cairo1: ()=>fromCallsToExecuteCalldata_cairo1,\n    getExecuteCalldata: ()=>getExecuteCalldata,\n    transformCallsToMulticallArrays: ()=>transformCallsToMulticallArrays,\n    transformCallsToMulticallArrays_cairo1: ()=>transformCallsToMulticallArrays_cairo1\n});\nvar transformCallsToMulticallArrays = (calls)=>{\n    const callArray = [];\n    const calldata = [];\n    calls.forEach((call)=>{\n        const data = CallData.compile(call.calldata || []);\n        callArray.push({\n            to: toBigInt(call.contractAddress).toString(10),\n            selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n            data_offset: calldata.length.toString(),\n            data_len: data.length.toString()\n        });\n        calldata.push(...data);\n    });\n    return {\n        callArray,\n        calldata: CallData.compile({\n            calldata\n        })\n    };\n};\nvar fromCallsToExecuteCalldata = (calls)=>{\n    const { callArray, calldata } = transformCallsToMulticallArrays(calls);\n    const compiledCalls = CallData.compile({\n        callArray\n    });\n    return [\n        ...compiledCalls,\n        ...calldata\n    ];\n};\nvar fromCallsToExecuteCalldataWithNonce = (calls, nonce)=>{\n    return [\n        ...fromCallsToExecuteCalldata(calls),\n        toBigInt(nonce).toString()\n    ];\n};\nvar transformCallsToMulticallArrays_cairo1 = (calls)=>{\n    const callArray = calls.map((call)=>({\n            to: toBigInt(call.contractAddress).toString(10),\n            selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n            calldata: CallData.compile(call.calldata || [])\n        }));\n    return callArray;\n};\nvar fromCallsToExecuteCalldata_cairo1 = (calls)=>{\n    const orderCalls = calls.map((call)=>({\n            contractAddress: call.contractAddress,\n            entrypoint: call.entrypoint,\n            calldata: Array.isArray(call.calldata) && \"__compiled__\" in call.calldata ? call.calldata : CallData.compile(call.calldata)\n        }));\n    return CallData.compile({\n        orderCalls\n    });\n};\nvar getExecuteCalldata = (calls, cairoVersion = \"0\")=>{\n    if (cairoVersion === \"1\") {\n        return fromCallsToExecuteCalldata_cairo1(calls);\n    }\n    return fromCallsToExecuteCalldata(calls);\n};\n// src/utils/typedData.ts\nvar typedData_exports = {};\n__export(typedData_exports, {\n    encodeData: ()=>encodeData,\n    encodeType: ()=>encodeType,\n    encodeValue: ()=>encodeValue,\n    getDependencies: ()=>getDependencies,\n    getMessageHash: ()=>getMessageHash,\n    getStructHash: ()=>getStructHash,\n    getTypeHash: ()=>getTypeHash,\n    isMerkleTreeType: ()=>isMerkleTreeType,\n    prepareSelector: ()=>prepareSelector\n});\n// src/utils/merkle.ts\nvar merkle_exports = {};\n__export(merkle_exports, {\n    MerkleTree: ()=>MerkleTree,\n    proofMerklePath: ()=>proofMerklePath\n});\nvar MerkleTree = class {\n    constructor(leafHashes){\n        this.branches = [];\n        this.leaves = leafHashes;\n        this.root = this.build(leafHashes);\n    }\n    /**\n   * Create Merkle tree\n   * @param leaves hex-string array\n   * @returns format: hex-string; Merkle tree root\n   */ build(leaves) {\n        if (leaves.length === 1) {\n            return leaves[0];\n        }\n        if (leaves.length !== this.leaves.length) {\n            this.branches.push(leaves);\n        }\n        const newLeaves = [];\n        for(let i = 0; i < leaves.length; i += 2){\n            if (i + 1 === leaves.length) {\n                newLeaves.push(MerkleTree.hash(leaves[i], \"0x0\"));\n            } else {\n                newLeaves.push(MerkleTree.hash(leaves[i], leaves[i + 1]));\n            }\n        }\n        return this.build(newLeaves);\n    }\n    /**\n   * Create pedersen hash from a and b\n   * @returns format: hex-string\n   */ static hash(a, b) {\n        const [aSorted, bSorted] = [\n            toBigInt(a),\n            toBigInt(b)\n        ].sort((x, y)=>x >= y ? 1 : -1);\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.pedersen(aSorted, bSorted);\n    }\n    /**\n   * Return path to leaf\n   * @param leaf hex-string\n   * @param branch hex-string array\n   * @param hashPath hex-string array\n   * @returns format: hex-string array\n   */ getProof(leaf, branch = this.leaves, hashPath = []) {\n        const index = branch.indexOf(leaf);\n        if (index === -1) {\n            throw new Error(\"leaf not found\");\n        }\n        if (branch.length === 1) {\n            return hashPath;\n        }\n        const isLeft = index % 2 === 0;\n        const neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? \"0x0\";\n        const newHashPath = [\n            ...hashPath,\n            neededBranch\n        ];\n        const currentBranchLevelIndex = this.leaves.length === branch.length ? -1 : this.branches.findIndex((b)=>b.length === branch.length);\n        const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [\n            this.root\n        ];\n        return this.getProof(MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf), nextBranch, newHashPath);\n    }\n};\nfunction proofMerklePath(root, leaf, path) {\n    if (path.length === 0) {\n        return root === leaf;\n    }\n    const [next, ...rest] = path;\n    return proofMerklePath(root, MerkleTree.hash(leaf, next), rest);\n}\n// src/utils/typedData.ts\nfunction getHex(value) {\n    try {\n        return toHex(value);\n    } catch (e) {\n        if (typeof value === \"string\") {\n            return toHex(encodeShortString(value));\n        }\n        throw new Error(`Invalid BigNumberish: ${value}`);\n    }\n}\nvar validateTypedData = (data)=>{\n    const typedData = data;\n    const valid = Boolean(typedData.types && typedData.primaryType && typedData.message);\n    return valid;\n};\nfunction prepareSelector(selector) {\n    return isHex(selector) ? selector : getSelectorFromName(selector);\n}\nfunction isMerkleTreeType(type) {\n    return type.type === \"merkletree\";\n}\nvar getDependencies = (types, type, dependencies = [])=>{\n    if (type[type.length - 1] === \"*\") {\n        type = type.slice(0, -1);\n    }\n    if (dependencies.includes(type)) {\n        return dependencies;\n    }\n    if (!types[type]) {\n        return dependencies;\n    }\n    return [\n        type,\n        ...types[type].reduce((previous, t)=>[\n                ...previous,\n                ...getDependencies(types, t.type, previous).filter((dependency)=>!previous.includes(dependency))\n            ], [])\n    ];\n};\nfunction getMerkleTreeType(types, ctx) {\n    if (ctx.parent && ctx.key) {\n        const parentType = types[ctx.parent];\n        const merkleType = parentType.find((t)=>t.name === ctx.key);\n        const isMerkleTree = isMerkleTreeType(merkleType);\n        if (!isMerkleTree) {\n            throw new Error(`${ctx.key} is not a merkle tree`);\n        }\n        if (merkleType.contains.endsWith(\"*\")) {\n            throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);\n        }\n        return merkleType.contains;\n    }\n    return \"raw\";\n}\nvar encodeType = (types, type)=>{\n    const [primary, ...dependencies] = getDependencies(types, type);\n    const newTypes = !primary ? [] : [\n        primary,\n        ...dependencies.sort()\n    ];\n    return newTypes.map((dependency)=>{\n        return `${dependency}(${types[dependency].map((t)=>`${t.name}:${t.type}`)})`;\n    }).join(\"\");\n};\nvar getTypeHash = (types, type)=>{\n    return getSelectorFromName(encodeType(types, type));\n};\nvar encodeValue = (types, type, data, ctx = {})=>{\n    if (types[type]) {\n        return [\n            type,\n            getStructHash(types, type, data)\n        ];\n    }\n    if (Object.keys(types).map((x)=>`${x}*`).includes(type)) {\n        const structHashes = data.map((struct)=>{\n            return getStructHash(types, type.slice(0, -1), struct);\n        });\n        return [\n            type,\n            computeHashOnElements(structHashes)\n        ];\n    }\n    if (type === \"merkletree\") {\n        const merkleTreeType = getMerkleTreeType(types, ctx);\n        const structHashes = data.map((struct)=>{\n            return encodeValue(types, merkleTreeType, struct)[1];\n        });\n        const { root } = new MerkleTree(structHashes);\n        return [\n            \"felt\",\n            root\n        ];\n    }\n    if (type === \"felt*\") {\n        return [\n            \"felt*\",\n            computeHashOnElements(data)\n        ];\n    }\n    if (type === \"selector\") {\n        return [\n            \"felt\",\n            prepareSelector(data)\n        ];\n    }\n    return [\n        type,\n        getHex(data)\n    ];\n};\nvar encodeData = (types, type, data)=>{\n    const [returnTypes, values] = types[type].reduce(([ts, vs], field)=>{\n        if (data[field.name] === void 0 || data[field.name] === null) {\n            throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n        }\n        const value = data[field.name];\n        const [t, encodedValue] = encodeValue(types, field.type, value, {\n            parent: type,\n            key: field.name\n        });\n        return [\n            [\n                ...ts,\n                t\n            ],\n            [\n                ...vs,\n                encodedValue\n            ]\n        ];\n    }, [\n        [\n            \"felt\"\n        ],\n        [\n            getTypeHash(types, type)\n        ]\n    ]);\n    return [\n        returnTypes,\n        values\n    ];\n};\nvar getStructHash = (types, type, data)=>{\n    return computeHashOnElements(encodeData(types, type, data)[1]);\n};\nvar getMessageHash = (typedData, account)=>{\n    if (!validateTypedData(typedData)) {\n        throw new Error(\"Typed data does not match JSON schema\");\n    }\n    const message = [\n        encodeShortString(\"StarkNet Message\"),\n        getStructHash(typedData.types, \"StarkNetDomain\", typedData.domain),\n        account,\n        getStructHash(typedData.types, typedData.primaryType, typedData.message)\n    ];\n    return computeHashOnElements(message);\n};\n// src/signer/default.ts\nvar Signer = class {\n    constructor(pk = _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.utils.randomPrivateKey()){\n        this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex(pk);\n    }\n    async getPubKey() {\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.getStarkKey(this.pk);\n    }\n    async signMessage(typedData, accountAddress) {\n        const msgHash = getMessageHash(typedData, accountAddress);\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.sign(msgHash, this.pk);\n    }\n    async signTransaction(transactions, transactionsDetail, abis) {\n        if (abis && abis.length !== transactions.length) {\n            throw new Error(\"ABI must be provided for each transaction or no transaction\");\n        }\n        const calldata = getExecuteCalldata(transactions, transactionsDetail.cairoVersion);\n        const msgHash = calculateTransactionHash(transactionsDetail.walletAddress, transactionsDetail.version, calldata, transactionsDetail.maxFee, transactionsDetail.chainId, transactionsDetail.nonce);\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.sign(msgHash, this.pk);\n    }\n    async signDeployAccountTransaction({ classHash, contractAddress, constructorCalldata, addressSalt, maxFee, version, chainId, nonce }) {\n        const msgHash = calculateDeployAccountTransactionHash(contractAddress, classHash, CallData.compile(constructorCalldata), addressSalt, version, maxFee, chainId, nonce);\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.sign(msgHash, this.pk);\n    }\n    async signDeclareTransaction({ classHash, senderAddress, chainId, maxFee, version, nonce, compiledClassHash }) {\n        const msgHash = calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash);\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.sign(msgHash, this.pk);\n    }\n};\n// src/utils/events.ts\nfunction parseUDCEvent(txReceipt) {\n    if (!txReceipt.events) {\n        throw new Error(\"UDC emitted event is empty\");\n    }\n    const event = txReceipt.events.find((it)=>cleanHex(it.from_address) === cleanHex(UDC.ADDRESS)) || {\n        data: []\n    };\n    return {\n        transaction_hash: txReceipt.transaction_hash,\n        contract_address: event.data[0],\n        address: event.data[0],\n        deployer: event.data[1],\n        unique: event.data[2],\n        classHash: event.data[3],\n        calldata_len: event.data[4],\n        calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),\n        salt: event.data[event.data.length - 1]\n    };\n}\n// src/account/default.ts\nvar Account = class extends Provider {\n    constructor(providerOrOptions, address, pkOrSigner, cairoVersion){\n        super(providerOrOptions);\n        this.deploySelf = this.deployAccount;\n        this.address = address.toLowerCase();\n        this.signer = typeof pkOrSigner === \"string\" || pkOrSigner instanceof Uint8Array ? new Signer(pkOrSigner) : pkOrSigner;\n        if (cairoVersion) {\n            this.cairoVersion = cairoVersion.toString();\n        }\n    }\n    async getNonce(blockIdentifier) {\n        return super.getNonceForAddress(this.address, blockIdentifier);\n    }\n    async getNonceSafe(nonce) {\n        try {\n            return toBigInt(nonce ?? await this.getNonce());\n        } catch (error) {\n            return 0n;\n        }\n    }\n    /**\n   * Retrieves the Cairo version from the network and sets `cairoVersion` if not already set in the constructor\n   * @param classHash if provided detects Cairo version from classHash, otherwise from the account address\n   */ async getCairoVersion(classHash) {\n        if (!this.cairoVersion) {\n            const { cairo } = classHash ? await super.getContractVersion(void 0, classHash) : await super.getContractVersion(this.address);\n            this.cairoVersion = cairo;\n        }\n        return this.cairoVersion;\n    }\n    async estimateFee(calls, estimateFeeDetails) {\n        return this.estimateInvokeFee(calls, estimateFeeDetails);\n    }\n    async estimateInvokeFee(calls, { nonce: providedNonce, blockIdentifier, skipValidate } = {}) {\n        const transactions = Array.isArray(calls) ? calls : [\n            calls\n        ];\n        const nonce = toBigInt(providedNonce ?? await this.getNonce());\n        const version = toBigInt(feeTransactionVersion);\n        const chainId = await this.getChainId();\n        const signerDetails = {\n            walletAddress: this.address,\n            nonce,\n            maxFee: ZERO,\n            version,\n            chainId,\n            cairoVersion: await this.getCairoVersion()\n        };\n        const invocation = await this.buildInvocation(transactions, signerDetails);\n        const response = await super.getInvokeEstimateFee({\n            ...invocation\n        }, {\n            version,\n            nonce\n        }, blockIdentifier, skipValidate);\n        const suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);\n        return {\n            ...response,\n            suggestedMaxFee\n        };\n    }\n    async estimateDeclareFee({ contract, classHash: providedClassHash, casm, compiledClassHash }, { blockIdentifier, nonce: providedNonce, skipValidate } = {}) {\n        const nonce = toBigInt(providedNonce ?? await this.getNonce());\n        const version = !isSierra(contract) ? feeTransactionVersion : feeTransactionVersion_2;\n        const chainId = await this.getChainId();\n        const declareContractTransaction = await this.buildDeclarePayload({\n            classHash: providedClassHash,\n            contract,\n            casm,\n            compiledClassHash\n        }, {\n            nonce,\n            chainId,\n            version,\n            walletAddress: this.address,\n            maxFee: ZERO,\n            cairoVersion: void 0\n        });\n        const response = await super.getDeclareEstimateFee(declareContractTransaction, {\n            version,\n            nonce\n        }, blockIdentifier, skipValidate);\n        const suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);\n        return {\n            ...response,\n            suggestedMaxFee\n        };\n    }\n    async estimateAccountDeployFee({ classHash, addressSalt = 0, constructorCalldata = [], contractAddress: providedContractAddress }, { blockIdentifier, skipValidate } = {}) {\n        const version = toBigInt(feeTransactionVersion);\n        const nonce = ZERO;\n        const chainId = await this.getChainId();\n        const payload = await this.buildAccountDeployPayload({\n            classHash,\n            addressSalt,\n            constructorCalldata,\n            contractAddress: providedContractAddress\n        }, {\n            nonce,\n            chainId,\n            version,\n            walletAddress: this.address,\n            // unused parameter\n            maxFee: ZERO,\n            cairoVersion: void 0\n        });\n        const response = await super.getDeployAccountEstimateFee({\n            ...payload\n        }, {\n            version,\n            nonce\n        }, blockIdentifier, skipValidate);\n        const suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);\n        return {\n            ...response,\n            suggestedMaxFee\n        };\n    }\n    async estimateDeployFee(payload, transactionsDetail) {\n        const calls = this.buildUDCContractPayload(payload);\n        return this.estimateInvokeFee(calls, transactionsDetail);\n    }\n    async estimateFeeBulk(invocations, { nonce, blockIdentifier, skipValidate } = {}) {\n        const accountInvocations = await this.accountInvocationsFactory(invocations, {\n            versions: [\n                feeTransactionVersion,\n                feeTransactionVersion_2\n            ],\n            nonce,\n            blockIdentifier\n        });\n        const response = await super.getEstimateFeeBulk(accountInvocations, {\n            blockIdentifier,\n            skipValidate\n        });\n        return [].concat(response).map((elem)=>{\n            const suggestedMaxFee = estimatedFeeToMaxFee(elem.overall_fee);\n            return {\n                ...elem,\n                suggestedMaxFee\n            };\n        });\n    }\n    async buildInvocation(call, signerDetails) {\n        const calldata = getExecuteCalldata(call, await this.getCairoVersion());\n        const signature = await this.signer.signTransaction(call, signerDetails);\n        return {\n            contractAddress: this.address,\n            calldata,\n            signature\n        };\n    }\n    async execute(calls, abis = void 0, transactionsDetail = {}) {\n        const transactions = Array.isArray(calls) ? calls : [\n            calls\n        ];\n        const nonce = toBigInt(transactionsDetail.nonce ?? await this.getNonce());\n        const maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee({\n            type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n            payload: calls\n        }, transactionsDetail);\n        const version = toBigInt(transactionVersion);\n        const chainId = await this.getChainId();\n        const signerDetails = {\n            walletAddress: this.address,\n            nonce,\n            maxFee,\n            version,\n            chainId,\n            cairoVersion: await this.getCairoVersion()\n        };\n        const signature = await this.signer.signTransaction(transactions, signerDetails, abis);\n        const calldata = getExecuteCalldata(transactions, await this.getCairoVersion());\n        return this.invokeFunction({\n            contractAddress: this.address,\n            calldata,\n            signature\n        }, {\n            nonce,\n            maxFee,\n            version\n        });\n    }\n    /**\n   * First check if contract is already declared, if not declare it\n   * If contract already declared returned transaction_hash is ''.\n   * Method will pass even if contract is already declared\n   * @param transactionsDetail (optional)\n   */ async declareIfNot(payload, transactionsDetail = {}) {\n        const declareContractPayload = extractContractHashes(payload);\n        try {\n            await this.getClassByHash(declareContractPayload.classHash);\n        } catch (error) {\n            return this.declare(payload, transactionsDetail);\n        }\n        return {\n            transaction_hash: \"\",\n            class_hash: declareContractPayload.classHash\n        };\n    }\n    async declare(payload, transactionsDetail = {}) {\n        const declareContractPayload = extractContractHashes(payload);\n        const details = {};\n        details.nonce = toBigInt(transactionsDetail.nonce ?? await this.getNonce());\n        details.maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee({\n            type: \"DECLARE\" /* DECLARE */ ,\n            payload: declareContractPayload\n        }, transactionsDetail);\n        details.version = !isSierra(payload.contract) ? transactionVersion : transactionVersion_2;\n        details.chainId = await this.getChainId();\n        const declareContractTransaction = await this.buildDeclarePayload(declareContractPayload, {\n            ...details,\n            walletAddress: this.address,\n            cairoVersion: void 0\n        });\n        return this.declareContract(declareContractTransaction, details);\n    }\n    async deploy(payload, details) {\n        const params = [].concat(payload).map((it)=>{\n            const { classHash, salt, unique = true, constructorCalldata = [] } = it;\n            const compiledConstructorCallData = CallData.compile(constructorCalldata);\n            const deploySalt = salt ?? randomAddress();\n            return {\n                call: {\n                    contractAddress: UDC.ADDRESS,\n                    entrypoint: UDC.ENTRYPOINT,\n                    calldata: [\n                        classHash,\n                        deploySalt,\n                        toCairoBool(unique),\n                        compiledConstructorCallData.length,\n                        ...compiledConstructorCallData\n                    ]\n                },\n                address: calculateContractAddressFromHash(unique ? _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.pedersen(this.address, deploySalt) : deploySalt, classHash, compiledConstructorCallData, unique ? UDC.ADDRESS : 0)\n            };\n        });\n        const calls = params.map((it)=>it.call);\n        const addresses = params.map((it)=>it.address);\n        const invokeResponse = await this.execute(calls, void 0, details);\n        return {\n            ...invokeResponse,\n            contract_address: addresses\n        };\n    }\n    async deployContract(payload, details) {\n        const deployTx = await this.deploy(payload, details);\n        const txReceipt = await this.waitForTransaction(deployTx.transaction_hash);\n        return parseUDCEvent(txReceipt);\n    }\n    async declareAndDeploy(payload, details) {\n        const { constructorCalldata, salt, unique } = payload;\n        let declare = await this.declareIfNot(payload, details);\n        if (declare.transaction_hash !== \"\") {\n            const tx = await this.waitForTransaction(declare.transaction_hash);\n            declare = {\n                ...declare,\n                ...tx\n            };\n        }\n        const deploy = await this.deployContract({\n            classHash: declare.class_hash,\n            salt,\n            unique,\n            constructorCalldata\n        }, details);\n        return {\n            declare: {\n                ...declare\n            },\n            deploy\n        };\n    }\n    async deployAccount({ classHash, constructorCalldata = [], addressSalt = 0, contractAddress: providedContractAddress }, transactionsDetail = {}) {\n        const version = toBigInt(transactionVersion);\n        const nonce = ZERO;\n        const chainId = await this.getChainId();\n        const compiledCalldata = CallData.compile(constructorCalldata);\n        const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n        const maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee({\n            type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n            payload: {\n                classHash,\n                constructorCalldata: compiledCalldata,\n                addressSalt,\n                contractAddress\n            }\n        }, transactionsDetail);\n        const signature = await this.signer.signDeployAccountTransaction({\n            classHash,\n            constructorCalldata: compiledCalldata,\n            contractAddress,\n            addressSalt,\n            chainId,\n            maxFee,\n            version,\n            nonce\n        });\n        return this.deployAccountContract({\n            classHash,\n            addressSalt,\n            constructorCalldata,\n            signature\n        }, {\n            nonce,\n            maxFee,\n            version\n        });\n    }\n    async signMessage(typedData) {\n        return this.signer.signMessage(typedData, this.address);\n    }\n    async hashMessage(typedData) {\n        return getMessageHash(typedData, this.address);\n    }\n    async verifyMessageHash(hash, signature) {\n        try {\n            await this.callContract({\n                contractAddress: this.address,\n                entrypoint: \"isValidSignature\",\n                calldata: CallData.compile({\n                    hash: toBigInt(hash).toString(),\n                    signature: formatSignature(signature)\n                })\n            });\n            return true;\n        } catch  {\n            return false;\n        }\n    }\n    async verifyMessage(typedData, signature) {\n        const hash = await this.hashMessage(typedData);\n        return this.verifyMessageHash(hash, signature);\n    }\n    async getSuggestedMaxFee({ type, payload }, details) {\n        let feeEstimate;\n        switch(type){\n            case \"INVOKE_FUNCTION\" /* INVOKE */ :\n                feeEstimate = await this.estimateInvokeFee(payload, details);\n                break;\n            case \"DECLARE\" /* DECLARE */ :\n                feeEstimate = await this.estimateDeclareFee(payload, details);\n                break;\n            case \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ :\n                feeEstimate = await this.estimateAccountDeployFee(payload, details);\n                break;\n            case \"DEPLOY\" /* DEPLOY */ :\n                feeEstimate = await this.estimateDeployFee(payload, details);\n                break;\n            default:\n                feeEstimate = {\n                    suggestedMaxFee: ZERO,\n                    overall_fee: ZERO\n                };\n                break;\n        }\n        return feeEstimate.suggestedMaxFee;\n    }\n    /**\n   * will be renamed to buildDeclareContractTransaction\n   */ async buildDeclarePayload(payload, { nonce, chainId, version, walletAddress, maxFee }) {\n        const { classHash, contract, compiledClassHash } = extractContractHashes(payload);\n        const compressedCompiledContract = parseContract(contract);\n        const signature = await this.signer.signDeclareTransaction({\n            classHash,\n            compiledClassHash,\n            senderAddress: walletAddress,\n            chainId,\n            maxFee,\n            version,\n            nonce\n        });\n        return {\n            senderAddress: walletAddress,\n            signature,\n            contract: compressedCompiledContract,\n            compiledClassHash\n        };\n    }\n    async buildAccountDeployPayload({ classHash, addressSalt = 0, constructorCalldata = [], contractAddress: providedContractAddress }, { nonce, chainId, version, maxFee }) {\n        const compiledCalldata = CallData.compile(constructorCalldata);\n        const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n        const signature = await this.signer.signDeployAccountTransaction({\n            classHash,\n            contractAddress,\n            chainId,\n            maxFee,\n            version,\n            nonce,\n            addressSalt,\n            constructorCalldata: compiledCalldata\n        });\n        return {\n            classHash,\n            addressSalt,\n            constructorCalldata: compiledCalldata,\n            signature\n        };\n    }\n    buildUDCContractPayload(payload) {\n        const calls = [].concat(payload).map((it)=>{\n            const { classHash, salt = \"0\", unique = true, constructorCalldata = [] } = it;\n            const compiledConstructorCallData = CallData.compile(constructorCalldata);\n            return {\n                contractAddress: UDC.ADDRESS,\n                entrypoint: UDC.ENTRYPOINT,\n                calldata: [\n                    classHash,\n                    salt,\n                    toCairoBool(unique),\n                    compiledConstructorCallData.length,\n                    ...compiledConstructorCallData\n                ]\n            };\n        });\n        return calls;\n    }\n    async simulateTransaction(invocations, { nonce, blockIdentifier, skipValidate, skipExecute } = {}) {\n        const accountInvocations = await this.accountInvocationsFactory(invocations, {\n            versions: [\n                transactionVersion,\n                transactionVersion_2\n            ],\n            nonce,\n            blockIdentifier\n        });\n        return super.getSimulateTransaction(accountInvocations, {\n            blockIdentifier,\n            skipValidate,\n            skipExecute\n        });\n    }\n    async accountInvocationsFactory(invocations, { versions, nonce, blockIdentifier }) {\n        const version = versions[0];\n        const safeNonce = await this.getNonceSafe(nonce);\n        const chainId = await this.getChainId();\n        const tx0Payload = \"payload\" in invocations[0] ? invocations[0].payload : invocations[0];\n        const cairoVersion = invocations[0].type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */  ? await this.getCairoVersion(tx0Payload.classHash) : await this.getCairoVersion();\n        return Promise.all([].concat(invocations).map(async (transaction, index)=>{\n            const txPayload = \"payload\" in transaction ? transaction.payload : transaction;\n            const signerDetails = {\n                walletAddress: this.address,\n                nonce: toBigInt(Number(safeNonce) + index),\n                maxFee: ZERO,\n                version,\n                chainId,\n                cairoVersion\n            };\n            const common = {\n                type: transaction.type,\n                version,\n                nonce: toBigInt(Number(safeNonce) + index),\n                blockIdentifier\n            };\n            if (transaction.type === \"INVOKE_FUNCTION\" /* INVOKE */ ) {\n                const payload = await this.buildInvocation([].concat(txPayload), signerDetails);\n                return {\n                    ...common,\n                    ...payload\n                };\n            }\n            if (transaction.type === \"DECLARE\" /* DECLARE */ ) {\n                signerDetails.version = !isSierra(txPayload.contract) ? toBigInt(versions[0]) : toBigInt(versions[1]);\n                const payload = await this.buildDeclarePayload(txPayload, signerDetails);\n                return {\n                    ...common,\n                    ...payload,\n                    version: signerDetails.version\n                };\n            }\n            if (transaction.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ) {\n                const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);\n                return {\n                    ...common,\n                    ...payload\n                };\n            }\n            if (transaction.type === \"DEPLOY\" /* DEPLOY */ ) {\n                const calls = this.buildUDCContractPayload(txPayload);\n                const payload = await this.buildInvocation(calls, signerDetails);\n                return {\n                    ...common,\n                    ...payload,\n                    type: \"INVOKE_FUNCTION\" /* INVOKE */ \n                };\n            }\n            throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction}`);\n        }));\n    }\n    async getStarkName(address = this.address, StarknetIdContract2) {\n        return super.getStarkName(address, StarknetIdContract2);\n    }\n};\n// src/provider/interface.ts\nvar ProviderInterface = class {\n};\n// src/provider/index.ts\nvar defaultProvider = new Provider({\n    rpc: {\n        default: true\n    }\n});\n// src/account/interface.ts\nvar AccountInterface = class extends ProviderInterface {\n};\n// src/utils/events/index.ts\nvar events_exports = {};\n__export(events_exports, {\n    getAbiEvents: ()=>getAbiEvents,\n    parseEvents: ()=>parseEvents\n});\nfunction getAbiEvents(abi) {\n    return abi.filter((abiEntry)=>abiEntry.type === \"event\" && (abiEntry.size || abiEntry.kind !== \"enum\")).reduce((acc, abiEntry)=>{\n        const entryName = abiEntry.name.slice(abiEntry.name.lastIndexOf(\":\") + 1);\n        const abiEntryMod = {\n            ...abiEntry\n        };\n        abiEntryMod.name = entryName;\n        return {\n            ...acc,\n            [addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod\n        };\n    }, {});\n}\nfunction parseEvents(providerReceivedEvents, abiEvents, abiStructs, abiEnums) {\n    const ret = providerReceivedEvents.flat().reduce((acc, recEvent)=>{\n        const abiEvent = abiEvents[recEvent.keys[0]];\n        if (!abiEvent) {\n            return acc;\n        }\n        const parsedEvent = {};\n        parsedEvent[abiEvent.name] = {};\n        recEvent.keys.shift();\n        const keysIter = recEvent.keys[Symbol.iterator]();\n        const dataIter = recEvent.data[Symbol.iterator]();\n        const abiEventKeys = abiEvent.members?.filter((it)=>it.kind === \"key\") || abiEvent.keys;\n        const abiEventData = abiEvent.members?.filter((it)=>it.kind === \"data\") || abiEvent.data;\n        abiEventKeys.forEach((key)=>{\n            parsedEvent[abiEvent.name][key.name] = responseParser(keysIter, key, abiStructs, abiEnums, parsedEvent[abiEvent.name]);\n        });\n        abiEventData.forEach((data)=>{\n            parsedEvent[abiEvent.name][data.name] = responseParser(dataIter, data, abiStructs, abiEnums, parsedEvent[abiEvent.name]);\n        });\n        acc.push(parsedEvent);\n        return acc;\n    }, []);\n    return ret;\n}\n// src/contract/default.ts\nvar splitArgsAndOptions = (args)=>{\n    const options = [\n        \"blockIdentifier\",\n        \"parseRequest\",\n        \"parseResponse\",\n        \"formatResponse\",\n        \"maxFee\",\n        \"nonce\",\n        \"signature\",\n        \"addressSalt\"\n    ];\n    const lastArg = args[args.length - 1];\n    if (typeof lastArg === \"object\" && options.some((x)=>x in lastArg)) {\n        return {\n            args,\n            options: args.pop()\n        };\n    }\n    return {\n        args\n    };\n};\nfunction buildCall(contract, functionAbi) {\n    return async function(...args) {\n        const params = splitArgsAndOptions(args);\n        return contract.call(functionAbi.name, params.args, {\n            parseRequest: true,\n            parseResponse: true,\n            ...params.options\n        });\n    };\n}\nfunction buildInvoke(contract, functionAbi) {\n    return async function(...args) {\n        const params = splitArgsAndOptions(args);\n        return contract.invoke(functionAbi.name, params.args, {\n            parseRequest: true,\n            ...params.options\n        });\n    };\n}\nfunction buildDefault(contract, functionAbi) {\n    if (functionAbi.stateMutability === \"view\" || functionAbi.state_mutability === \"view\") {\n        return buildCall(contract, functionAbi);\n    }\n    return buildInvoke(contract, functionAbi);\n}\nfunction buildPopulate(contract, functionAbi) {\n    return function(...args) {\n        return contract.populate(functionAbi.name, args);\n    };\n}\nfunction buildEstimate(contract, functionAbi) {\n    return function(...args) {\n        return contract.estimate(functionAbi.name, args);\n    };\n}\nfunction getCalldata(args, callback) {\n    if (Array.isArray(args) && \"__compiled__\" in args) return args;\n    if (Array.isArray(args) && Array.isArray(args[0]) && \"__compiled__\" in args[0]) return args[0];\n    return callback();\n}\nvar Contract = class {\n    /**\n   * Contract class to handle contract methods\n   *\n   * @param abi - Abi of the contract object\n   * @param address (optional) - address to connect to\n   * @param providerOrAccount (optional) - Provider or Account to attach to\n   */ constructor(abi, address, providerOrAccount = defaultProvider){\n        this.address = address && address.toLowerCase();\n        this.providerOrAccount = providerOrAccount;\n        this.callData = new CallData(abi);\n        this.structs = CallData.getAbiStruct(abi);\n        this.events = getAbiEvents(abi);\n        const parser = createAbiParser(abi);\n        this.abi = parser.getLegacyFormat();\n        const options = {\n            enumerable: true,\n            value: {},\n            writable: false\n        };\n        Object.defineProperties(this, {\n            functions: {\n                enumerable: true,\n                value: {},\n                writable: false\n            },\n            callStatic: {\n                enumerable: true,\n                value: {},\n                writable: false\n            },\n            populateTransaction: {\n                enumerable: true,\n                value: {},\n                writable: false\n            },\n            estimateFee: {\n                enumerable: true,\n                value: {},\n                writable: false\n            }\n        });\n        this.abi.forEach((abiElement)=>{\n            if (abiElement.type !== \"function\") return;\n            const signature = abiElement.name;\n            if (!this[signature]) {\n                Object.defineProperty(this, signature, {\n                    ...options,\n                    value: buildDefault(this, abiElement)\n                });\n            }\n            if (!this.functions[signature]) {\n                Object.defineProperty(this.functions, signature, {\n                    ...options,\n                    value: buildDefault(this, abiElement)\n                });\n            }\n            if (!this.callStatic[signature]) {\n                Object.defineProperty(this.callStatic, signature, {\n                    ...options,\n                    value: buildCall(this, abiElement)\n                });\n            }\n            if (!this.populateTransaction[signature]) {\n                Object.defineProperty(this.populateTransaction, signature, {\n                    ...options,\n                    value: buildPopulate(this, abiElement)\n                });\n            }\n            if (!this.estimateFee[signature]) {\n                Object.defineProperty(this.estimateFee, signature, {\n                    ...options,\n                    value: buildEstimate(this, abiElement)\n                });\n            }\n        });\n    }\n    attach(address) {\n        this.address = address;\n    }\n    connect(providerOrAccount) {\n        this.providerOrAccount = providerOrAccount;\n    }\n    async deployed() {\n        if (this.deployTransactionHash) {\n            await this.providerOrAccount.waitForTransaction(this.deployTransactionHash);\n            this.deployTransactionHash = void 0;\n        }\n        return this;\n    }\n    async call(method, args = [], { parseRequest = true, parseResponse = true, formatResponse = void 0, blockIdentifier = void 0 } = {}) {\n        assert(this.address !== null, \"contract is not connected to an address\");\n        const calldata = getCalldata(args, ()=>{\n            if (parseRequest) {\n                this.callData.validate(\"CALL\" /* CALL */ , method, args);\n                return this.callData.compile(method, args);\n            }\n            console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n            return args;\n        });\n        return this.providerOrAccount.callContract({\n            contractAddress: this.address,\n            calldata,\n            entrypoint: method\n        }, blockIdentifier).then((x)=>{\n            if (!parseResponse) {\n                return x.result;\n            }\n            if (formatResponse) {\n                return this.callData.format(method, x.result, formatResponse);\n            }\n            return this.callData.parse(method, x.result);\n        });\n    }\n    invoke(method, args = [], { parseRequest = true, maxFee, nonce, signature } = {}) {\n        assert(this.address !== null, \"contract is not connected to an address\");\n        const calldata = getCalldata(args, ()=>{\n            if (parseRequest) {\n                this.callData.validate(\"INVOKE\" /* INVOKE */ , method, args);\n                return this.callData.compile(method, args);\n            }\n            console.warn(\"Invoke skipped parsing but provided rawArgs, possible malfunction request\");\n            return args;\n        });\n        const invocation = {\n            contractAddress: this.address,\n            calldata,\n            entrypoint: method\n        };\n        if (\"execute\" in this.providerOrAccount) {\n            return this.providerOrAccount.execute(invocation, void 0, {\n                maxFee,\n                nonce\n            });\n        }\n        if (!nonce) throw new Error(`Nonce is required when invoking a function without an account`);\n        console.warn(`Invoking ${method} without an account. This will not work on a public node.`);\n        return this.providerOrAccount.invokeFunction({\n            ...invocation,\n            signature\n        }, {\n            nonce\n        });\n    }\n    async estimate(method, args = []) {\n        assert(this.address !== null, \"contract is not connected to an address\");\n        if (!getCalldata(args, ()=>false)) {\n            this.callData.validate(\"INVOKE\" /* INVOKE */ , method, args);\n        }\n        const invocation = this.populate(method, args);\n        if (\"estimateInvokeFee\" in this.providerOrAccount) {\n            return this.providerOrAccount.estimateInvokeFee(invocation);\n        }\n        throw Error(\"Contract must be connected to the account contract to estimate\");\n    }\n    populate(method, args = []) {\n        const calldata = getCalldata(args, ()=>this.callData.compile(method, args));\n        return {\n            contractAddress: this.address,\n            entrypoint: method,\n            calldata\n        };\n    }\n    parseEvents(receipt) {\n        return parseEvents(receipt.events?.filter((event)=>cleanHex(event.from_address) === cleanHex(this.address), []) || [], this.events, this.structs, CallData.getAbiEnum(this.abi));\n    }\n    isCairo1() {\n        return cairo_exports.isCairo1Abi(this.abi);\n    }\n    async getVersion() {\n        return this.providerOrAccount.getContractVersion(this.address);\n    }\n    typed(tAbi) {\n        return this;\n    }\n};\n// src/contract/interface.ts\nvar ContractInterface = class {\n};\n// src/contract/contractFactory.ts\nvar ContractFactory = class {\n    /**\n   * @param params CFParams\n   *  - compiledContract: CompiledContract;\n   *  - account: AccountInterface;\n   *  - casm?: CairoAssembly;\n   *  - classHash?: string;\n   *  - compiledClassHash?: string;\n   *  - abi?: Abi;\n   */ constructor(params){\n        this.compiledContract = params.compiledContract;\n        this.account = params.account;\n        this.casm = params.casm;\n        this.abi = params.abi ?? params.compiledContract.abi;\n        this.classHash = params.classHash;\n        this.compiledClassHash = params.compiledClassHash;\n        this.CallData = new CallData(this.abi);\n    }\n    /**\n   * Deploys contract and returns new instance of the Contract\n   *\n   * If contract is not declared it will first declare it, and then deploy\n   */ async deploy(...args) {\n        const { args: param, options = {\n            parseRequest: true\n        } } = splitArgsAndOptions(args);\n        const constructorCalldata = getCalldata(param, ()=>{\n            if (options.parseRequest) {\n                this.CallData.validate(\"DEPLOY\" /* DEPLOY */ , \"constructor\", param);\n                return this.CallData.compile(\"constructor\", param);\n            }\n            console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n            return param;\n        });\n        const { deploy: { contract_address, transaction_hash } } = await this.account.declareAndDeploy({\n            contract: this.compiledContract,\n            casm: this.casm,\n            classHash: this.classHash,\n            compiledClassHash: this.compiledClassHash,\n            constructorCalldata,\n            salt: options.addressSalt\n        });\n        assert(Boolean(contract_address), \"Deployment of the contract failed\");\n        const contractInstance = new Contract(this.compiledContract.abi, contract_address, this.account);\n        contractInstance.deployTransactionHash = transaction_hash;\n        return contractInstance;\n    }\n    /**\n   * Attaches to new Account\n   *\n   * @param account - new Account to attach to\n   */ connect(account) {\n        this.account = account;\n        return this;\n    }\n    /**\n   * Attaches current abi and account to the new address\n   */ attach(address) {\n        return new Contract(this.abi, address, this.account);\n    }\n};\n// src/utils/address.ts\n\nfunction addAddressPadding(address) {\n    return addHexPrefix(removeHexPrefix(toHex(address)).padStart(64, \"0\"));\n}\nfunction validateAndParseAddress(address) {\n    assertInRange(address, ZERO, MASK_251, \"Starknet Address\");\n    const result = addAddressPadding(address);\n    if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n        throw new Error(\"Invalid Address Format\");\n    }\n    return result;\n}\nfunction getChecksumAddress(address) {\n    const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split(\"\");\n    const hex = removeHexPrefix(keccakBn(address));\n    const hashed = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(hex.padStart(64, \"0\"));\n    for(let i = 0; i < chars.length; i += 2){\n        if (hashed[i >> 1] >> 4 >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 15) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return addHexPrefix(chars.join(\"\"));\n}\nfunction validateChecksumAddress(address) {\n    return getChecksumAddress(address) === address;\n}\n// src/index.ts\nvar number = num_exports;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsWUFBWUMsT0FBT0MsY0FBYztBQUNyQyxJQUFJQyxXQUFXLENBQUNDLFFBQVFDO0lBQ3RCLElBQUssSUFBSUMsUUFBUUQsSUFDZkwsVUFBVUksUUFBUUUsTUFBTTtRQUFFQyxLQUFLRixHQUFHLENBQUNDLEtBQUs7UUFBRUUsWUFBWTtJQUFLO0FBQy9EO0FBRUEsbUJBQW1CO0FBQ25CLElBQUlDLG9CQUFvQixDQUFDO0FBQ3pCTixTQUFTTSxtQkFBbUI7SUFDMUJDLGFBQWEsSUFBTUE7SUFDbkJDLDhCQUE4QixJQUFNQTtJQUNwQ0MsOEJBQThCLElBQU1BO0lBQ3BDQywwQkFBMEIsSUFBTUE7SUFDaENDLDBCQUEwQixJQUFNQTtJQUNoQ0MsU0FBUyxJQUFNQTtJQUNmQywrQkFBK0IsSUFBTUE7SUFDckNDLCtCQUErQixJQUFNQTtJQUNyQ0MsWUFBWSxJQUFNQTtJQUNsQkMsVUFBVSxJQUFNQTtJQUNoQkMsVUFBVSxJQUFNQTtJQUNoQkMsYUFBYSxJQUFNQTtJQUNuQkMsa0JBQWtCLElBQU1BO0lBQ3hCQyxtQkFBbUIsSUFBTUE7SUFDekJDLGlCQUFpQixJQUFNQTtJQUN2QkMsc0JBQXNCLElBQU1BO0lBQzVCQyx1QkFBdUIsSUFBTUE7SUFDN0JDLEtBQUssSUFBTUE7SUFDWEMsTUFBTSxJQUFNQTtBQUNkO0FBRUEsc0JBQXNCO0FBQ3RCLElBQUlDLGlCQUFpQixDQUFDO0FBQ3RCMUIsU0FBUzBCLGdCQUFnQjtJQUN2QlgsWUFBWSxJQUFNQTtJQUNsQlksY0FBYyxJQUFNQTtJQUNwQkMscUJBQXFCLElBQU1BO0lBQzNCQyxlQUFlLElBQU1BO0lBQ3JCQyxlQUFlLElBQU1BO0lBQ3JCQyxTQUFTLElB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SSxDQUFDNW1CLE9BQU9nSSxLQUFLLENBQUMsMkJBQTJCO1FBQzNDLE1BQU0sSUFBSTlELE1BQU07SUFDbEI7SUFDQSxPQUFPbEU7QUFDVDtBQUNBLFNBQVNtaUMsbUJBQW1CdmIsT0FBTztJQUNqQyxNQUFNd2IsUUFBUXBrQyxnQkFBZ0Jra0Msd0JBQXdCdGIsVUFBVWxoQixXQUFXLEdBQUduRixLQUFLLENBQUM7SUFDcEYsTUFBTWQsTUFBTXpCLGdCQUFnQjBJLFNBQVNrZ0I7SUFDckMsTUFBTXliLFNBQVNMLHdFQUFXQSxDQUFDdmlDLElBQUlELFFBQVEsQ0FBQyxJQUFJO0lBQzVDLElBQUssSUFBSW9RLElBQUksR0FBR0EsSUFBSXd5QixNQUFNeGlDLE1BQU0sRUFBRWdRLEtBQUssRUFBRztRQUN4QyxJQUFJeXlCLE1BQU0sQ0FBQ3p5QixLQUFLLEVBQUUsSUFBSSxLQUFLLEdBQUc7WUFDNUJ3eUIsS0FBSyxDQUFDeHlCLEVBQUUsR0FBR3d5QixLQUFLLENBQUN4eUIsRUFBRSxDQUFDblAsV0FBVztRQUNqQztRQUNBLElBQUksQ0FBQzRoQyxNQUFNLENBQUN6eUIsS0FBSyxFQUFFLEdBQUcsRUFBQyxLQUFNLEdBQUc7WUFDOUJ3eUIsS0FBSyxDQUFDeHlCLElBQUksRUFBRSxHQUFHd3lCLEtBQUssQ0FBQ3h5QixJQUFJLEVBQUUsQ0FBQ25QLFdBQVc7UUFDekM7SUFDRjtJQUNBLE9BQU9qRCxhQUFhNGtDLE1BQU01aEMsSUFBSSxDQUFDO0FBQ2pDO0FBQ0EsU0FBUzhoQyx3QkFBd0IxYixPQUFPO0lBQ3RDLE9BQU91YixtQkFBbUJ2YixhQUFhQTtBQUN6QztBQUVBLGVBQWU7QUFDZixJQUFJYSxTQUFTdGpCO0FBdUVYLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmV0dGVyaGFjay8uL25vZGVfbW9kdWxlcy9zdGFya25ldC9kaXN0L2luZGV4Lm1qcz9jZTk3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBjb25zdGFudHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoY29uc3RhbnRzX2V4cG9ydHMsIHtcbiAgQVBJX1ZFUlNJT046ICgpID0+IEFQSV9WRVJTSU9OLFxuICBCTl9GRUVfVFJBTlNBQ1RJT05fVkVSU0lPTl8xOiAoKSA9PiBCTl9GRUVfVFJBTlNBQ1RJT05fVkVSU0lPTl8xLFxuICBCTl9GRUVfVFJBTlNBQ1RJT05fVkVSU0lPTl8yOiAoKSA9PiBCTl9GRUVfVFJBTlNBQ1RJT05fVkVSU0lPTl8yLFxuICBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzE6ICgpID0+IEJOX1RSQU5TQUNUSU9OX1ZFUlNJT05fMSxcbiAgQk5fVFJBTlNBQ1RJT05fVkVSU0lPTl8yOiAoKSA9PiBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzIsXG4gIEJhc2VVcmw6ICgpID0+IEJhc2VVcmwsXG4gIEhFWF9TVFJfVFJBTlNBQ1RJT05fVkVSU0lPTl8xOiAoKSA9PiBIRVhfU1RSX1RSQU5TQUNUSU9OX1ZFUlNJT05fMSxcbiAgSEVYX1NUUl9UUkFOU0FDVElPTl9WRVJTSU9OXzI6ICgpID0+IEhFWF9TVFJfVFJBTlNBQ1RJT05fVkVSU0lPTl8yLFxuICBJU19CUk9XU0VSOiAoKSA9PiBJU19CUk9XU0VSLFxuICBNQVNLXzI1MDogKCkgPT4gTUFTS18yNTAsXG4gIE1BU0tfMjUxOiAoKSA9PiBNQVNLXzI1MSxcbiAgTmV0d29ya05hbWU6ICgpID0+IE5ldHdvcmtOYW1lLFxuICBSUENfR09FUkxJX05PREVTOiAoKSA9PiBSUENfR09FUkxJX05PREVTLFxuICBSUENfTUFJTk5FVF9OT0RFUzogKCkgPT4gUlBDX01BSU5ORVRfTk9ERVMsXG4gIFN0YXJrbmV0Q2hhaW5JZDogKCkgPT4gU3RhcmtuZXRDaGFpbklkLFxuICBURVhUX1RPX0ZFTFRfTUFYX0xFTjogKCkgPT4gVEVYVF9UT19GRUxUX01BWF9MRU4sXG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDogKCkgPT4gVHJhbnNhY3Rpb25IYXNoUHJlZml4LFxuICBVREM6ICgpID0+IFVEQyxcbiAgWkVSTzogKCkgPT4gWkVST1xufSk7XG5cbi8vIHNyYy91dGlscy9lbmNvZGUudHNcbnZhciBlbmNvZGVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZW5jb2RlX2V4cG9ydHMsIHtcbiAgSVNfQlJPV1NFUjogKCkgPT4gSVNfQlJPV1NFUixcbiAgYWRkSGV4UHJlZml4OiAoKSA9PiBhZGRIZXhQcmVmaXgsXG4gIGFycmF5QnVmZmVyVG9TdHJpbmc6ICgpID0+IGFycmF5QnVmZmVyVG9TdHJpbmcsXG4gIGF0b2JVbml2ZXJzYWw6ICgpID0+IGF0b2JVbml2ZXJzYWwsXG4gIGJ0b2FVbml2ZXJzYWw6ICgpID0+IGJ0b2FVbml2ZXJzYWwsXG4gIGJ1ZjJoZXg6ICgpID0+IGJ1ZjJoZXgsXG4gIGNhbGNCeXRlTGVuZ3RoOiAoKSA9PiBjYWxjQnl0ZUxlbmd0aCxcbiAgcGFkTGVmdDogKCkgPT4gcGFkTGVmdCxcbiAgcGFzY2FsVG9TbmFrZTogKCkgPT4gcGFzY2FsVG9TbmFrZSxcbiAgcmVtb3ZlSGV4UHJlZml4OiAoKSA9PiByZW1vdmVIZXhQcmVmaXgsXG4gIHNhbml0aXplQnl0ZXM6ICgpID0+IHNhbml0aXplQnl0ZXMsXG4gIHNhbml0aXplSGV4OiAoKSA9PiBzYW5pdGl6ZUhleCxcbiAgc3RyaW5nVG9BcnJheUJ1ZmZlcjogKCkgPT4gc3RyaW5nVG9BcnJheUJ1ZmZlcixcbiAgdXRmOFRvQXJyYXk6ICgpID0+IHV0ZjhUb0FycmF5XG59KTtcbmltcG9ydCB7IGJhc2U2NCB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIElTX0JST1dTRVIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xudmFyIFNUUklOR19aRVJPID0gXCIwXCI7XG5mdW5jdGlvbiBhcnJheUJ1ZmZlclRvU3RyaW5nKGFycmF5KSB7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShhcnJheSkucmVkdWNlKChkYXRhLCBieXRlKSA9PiBkYXRhICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSwgXCJcIik7XG59XG5mdW5jdGlvbiB1dGY4VG9BcnJheShzdHIpIHtcbiAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9BcnJheUJ1ZmZlcihzdHIpIHtcbiAgcmV0dXJuIHV0ZjhUb0FycmF5KHN0cik7XG59XG5mdW5jdGlvbiBhdG9iVW5pdmVyc2FsKGEpIHtcbiAgcmV0dXJuIGJhc2U2NC5kZWNvZGUoYSk7XG59XG5mdW5jdGlvbiBidG9hVW5pdmVyc2FsKGIpIHtcbiAgcmV0dXJuIGJhc2U2NC5lbmNvZGUobmV3IFVpbnQ4QXJyYXkoYikpO1xufVxuZnVuY3Rpb24gYnVmMmhleChidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci5yZWR1Y2UoKHIsIHgpID0+IHIgKyB4LnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIiksIFwiXCIpO1xufVxuZnVuY3Rpb24gcmVtb3ZlSGV4UHJlZml4KGhleCkge1xuICByZXR1cm4gaGV4LnJlcGxhY2UoL14weC9pLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGFkZEhleFByZWZpeChoZXgpIHtcbiAgcmV0dXJuIGAweCR7cmVtb3ZlSGV4UHJlZml4KGhleCl9YDtcbn1cbmZ1bmN0aW9uIHBhZFN0cmluZyhzdHIsIGxlbmd0aCwgbGVmdCwgcGFkZGluZyA9IFNUUklOR19aRVJPKSB7XG4gIGNvbnN0IGRpZmYgPSBsZW5ndGggLSBzdHIubGVuZ3RoO1xuICBsZXQgcmVzdWx0ID0gc3RyO1xuICBpZiAoZGlmZiA+IDApIHtcbiAgICBjb25zdCBwYWQgPSBwYWRkaW5nLnJlcGVhdChkaWZmKTtcbiAgICByZXN1bHQgPSBsZWZ0ID8gcGFkICsgc3RyIDogc3RyICsgcGFkO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYWRMZWZ0KHN0ciwgbGVuZ3RoLCBwYWRkaW5nID0gU1RSSU5HX1pFUk8pIHtcbiAgcmV0dXJuIHBhZFN0cmluZyhzdHIsIGxlbmd0aCwgdHJ1ZSwgcGFkZGluZyk7XG59XG5mdW5jdGlvbiBjYWxjQnl0ZUxlbmd0aChzdHIsIGJ5dGVTaXplID0gOCkge1xuICBjb25zdCB7IGxlbmd0aCB9ID0gc3RyO1xuICBjb25zdCByZW1haW5kZXIgPSBsZW5ndGggJSBieXRlU2l6ZTtcbiAgcmV0dXJuIHJlbWFpbmRlciA/IChsZW5ndGggLSByZW1haW5kZXIpIC8gYnl0ZVNpemUgKiBieXRlU2l6ZSArIGJ5dGVTaXplIDogbGVuZ3RoO1xufVxuZnVuY3Rpb24gc2FuaXRpemVCeXRlcyhzdHIsIGJ5dGVTaXplID0gOCwgcGFkZGluZyA9IFNUUklOR19aRVJPKSB7XG4gIHJldHVybiBwYWRMZWZ0KHN0ciwgY2FsY0J5dGVMZW5ndGgoc3RyLCBieXRlU2l6ZSksIHBhZGRpbmcpO1xufVxuZnVuY3Rpb24gc2FuaXRpemVIZXgoaGV4KSB7XG4gIGhleCA9IHJlbW92ZUhleFByZWZpeChoZXgpO1xuICBoZXggPSBzYW5pdGl6ZUJ5dGVzKGhleCwgMik7XG4gIGlmIChoZXgpIHtcbiAgICBoZXggPSBhZGRIZXhQcmVmaXgoaGV4KTtcbiAgfVxuICByZXR1cm4gaGV4O1xufVxudmFyIHBhc2NhbFRvU25ha2UgPSAodGV4dCkgPT4gL1thLXpdLy50ZXN0KHRleHQpID8gdGV4dC5zcGxpdCgvKD89W0EtWl0pLykuam9pbihcIl9cIikudG9VcHBlckNhc2UoKSA6IHRleHQ7XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBURVhUX1RPX0ZFTFRfTUFYX0xFTiA9IDMxO1xudmFyIEhFWF9TVFJfVFJBTlNBQ1RJT05fVkVSU0lPTl8xID0gXCIweDFcIjtcbnZhciBIRVhfU1RSX1RSQU5TQUNUSU9OX1ZFUlNJT05fMiA9IFwiMHgyXCI7XG52YXIgQk5fVFJBTlNBQ1RJT05fVkVSU0lPTl8xID0gMW47XG52YXIgQk5fVFJBTlNBQ1RJT05fVkVSU0lPTl8yID0gMm47XG52YXIgQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMSA9IDJuICoqIDEyOG4gKyBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzE7XG52YXIgQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMiA9IDJuICoqIDEyOG4gKyBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzI7XG52YXIgWkVSTyA9IDBuO1xudmFyIE1BU0tfMjUwID0gMm4gKiogMjUwbiAtIDFuO1xudmFyIE1BU0tfMjUxID0gMm4gKiogMjUxbjtcbnZhciBBUElfVkVSU0lPTiA9IFpFUk87XG52YXIgQmFzZVVybCA9IC8qIEBfX1BVUkVfXyAqLyAoKEJhc2VVcmwyKSA9PiB7XG4gIEJhc2VVcmwyW1wiU05fTUFJTlwiXSA9IFwiaHR0cHM6Ly9hbHBoYS1tYWlubmV0LnN0YXJrbmV0LmlvXCI7XG4gIEJhc2VVcmwyW1wiU05fR09FUkxJXCJdID0gXCJodHRwczovL2FscGhhNC5zdGFya25ldC5pb1wiO1xuICByZXR1cm4gQmFzZVVybDI7XG59KShCYXNlVXJsIHx8IHt9KTtcbnZhciBOZXR3b3JrTmFtZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ldHdvcmtOYW1lMikgPT4ge1xuICBOZXR3b3JrTmFtZTJbXCJTTl9NQUlOXCJdID0gXCJTTl9NQUlOXCI7XG4gIE5ldHdvcmtOYW1lMltcIlNOX0dPRVJMSVwiXSA9IFwiU05fR09FUkxJXCI7XG4gIHJldHVybiBOZXR3b3JrTmFtZTI7XG59KShOZXR3b3JrTmFtZSB8fCB7fSk7XG52YXIgU3RhcmtuZXRDaGFpbklkID0gLyogQF9fUFVSRV9fICovICgoU3RhcmtuZXRDaGFpbklkNCkgPT4ge1xuICBTdGFya25ldENoYWluSWQ0W1wiU05fTUFJTlwiXSA9IFwiMHg1MzRlNWY0ZDQxNDk0ZVwiO1xuICBTdGFya25ldENoYWluSWQ0W1wiU05fR09FUkxJXCJdID0gXCIweDUzNGU1ZjQ3NGY0NTUyNGM0OVwiO1xuICByZXR1cm4gU3RhcmtuZXRDaGFpbklkNDtcbn0pKFN0YXJrbmV0Q2hhaW5JZCB8fCB7fSk7XG52YXIgVHJhbnNhY3Rpb25IYXNoUHJlZml4ID0gLyogQF9fUFVSRV9fICovICgoVHJhbnNhY3Rpb25IYXNoUHJlZml4MikgPT4ge1xuICBUcmFuc2FjdGlvbkhhc2hQcmVmaXgyW1wiREVDTEFSRVwiXSA9IFwiMHg2NDY1NjM2YzYxNzI2NVwiO1xuICBUcmFuc2FjdGlvbkhhc2hQcmVmaXgyW1wiREVQTE9ZXCJdID0gXCIweDY0NjU3MDZjNmY3OVwiO1xuICBUcmFuc2FjdGlvbkhhc2hQcmVmaXgyW1wiREVQTE9ZX0FDQ09VTlRcIl0gPSBcIjB4NjQ2NTcwNmM2Zjc5NWY2MTYzNjM2Zjc1NmU3NFwiO1xuICBUcmFuc2FjdGlvbkhhc2hQcmVmaXgyW1wiSU5WT0tFXCJdID0gXCIweDY5NmU3NjZmNmI2NVwiO1xuICBUcmFuc2FjdGlvbkhhc2hQcmVmaXgyW1wiTDFfSEFORExFUlwiXSA9IFwiMHg2YzMxNWY2ODYxNmU2NDZjNjU3MlwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25IYXNoUHJlZml4Mjtcbn0pKFRyYW5zYWN0aW9uSGFzaFByZWZpeCB8fCB7fSk7XG52YXIgVURDID0ge1xuICBBRERSRVNTOiBcIjB4MDQxYTc4ZTc0MWU1YWYyZmVjMzRiNjk1Njc5YmM2ODkxNzQyNDM5ZjdhZmI4NDg0ZWNkNzc2NjY2MWFkMDJiZlwiLFxuICBFTlRSWVBPSU5UOiBcImRlcGxveUNvbnRyYWN0XCJcbn07XG52YXIgUlBDX0dPRVJMSV9OT0RFUyA9IFtcbiAgXCJodHRwczovL3N0YXJrbmV0LXRlc3RuZXQucHVibGljLmJsYXN0YXBpLmlvL3JwYy92MC41XCIsXG4gIFwiaHR0cHM6Ly9saW1pdGVkLXJwYy5uZXRoZXJtaW5kLmlvL2dvZXJsaS1qdW5vL3YwXzVcIlxuXTtcbnZhciBSUENfTUFJTk5FVF9OT0RFUyA9IFtcbiAgXCJodHRwczovL3N0YXJrbmV0LW1haW5uZXQucHVibGljLmJsYXN0YXBpLmlvL3JwYy92MC41XCIsXG4gIFwiaHR0cHM6Ly9saW1pdGVkLXJwYy5uZXRoZXJtaW5kLmlvL21haW5uZXQtanVuby92MF81XCJcbl07XG5cbi8vIHNyYy90eXBlcy9pbmRleC50c1xudmFyIHR5cGVzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHR5cGVzX2V4cG9ydHMsIHtcbiAgQmxvY2tTdGF0dXM6ICgpID0+IEJsb2NrU3RhdHVzLFxuICBCbG9ja1RhZzogKCkgPT4gQmxvY2tUYWcsXG4gIEVudHJ5UG9pbnRUeXBlOiAoKSA9PiBFbnRyeVBvaW50VHlwZSxcbiAgTGl0dGVyYWw6ICgpID0+IExpdHRlcmFsLFxuICBSUEM6ICgpID0+IHJwY19leHBvcnRzLFxuICBTSU1VTEFUSU9OX0ZMQUc6ICgpID0+IFNJTVVMQVRJT05fRkxBRyxcbiAgU2VxdWVuY2VyOiAoKSA9PiBzZXF1ZW5jZXJfZXhwb3J0cyxcbiAgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXM6ICgpID0+IFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzLFxuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzOiAoKSA9PiBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzLFxuICBUcmFuc2FjdGlvblN0YXR1czogKCkgPT4gVHJhbnNhY3Rpb25TdGF0dXMsXG4gIFRyYW5zYWN0aW9uVHlwZTogKCkgPT4gVHJhbnNhY3Rpb25UeXBlLFxuICBVaW50OiAoKSA9PiBVaW50LFxuICBWYWxpZGF0ZVR5cGU6ICgpID0+IFZhbGlkYXRlVHlwZVxufSk7XG5cbi8vIHNyYy90eXBlcy9hY2NvdW50LnRzXG52YXIgU0lNVUxBVElPTl9GTEFHID0gLyogQF9fUFVSRV9fICovICgoU0lNVUxBVElPTl9GTEFHMikgPT4ge1xuICBTSU1VTEFUSU9OX0ZMQUcyW1wiU0tJUF9WQUxJREFURVwiXSA9IFwiU0tJUF9WQUxJREFURVwiO1xuICBTSU1VTEFUSU9OX0ZMQUcyW1wiU0tJUF9FWEVDVVRFXCJdID0gXCJTS0lQX0VYRUNVVEVcIjtcbiAgcmV0dXJuIFNJTVVMQVRJT05fRkxBRzI7XG59KShTSU1VTEFUSU9OX0ZMQUcgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvY2FsbGRhdGEudHNcbnZhciBWYWxpZGF0ZVR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChWYWxpZGF0ZVR5cGUyKSA9PiB7XG4gIFZhbGlkYXRlVHlwZTJbXCJERVBMT1lcIl0gPSBcIkRFUExPWVwiO1xuICBWYWxpZGF0ZVR5cGUyW1wiQ0FMTFwiXSA9IFwiQ0FMTFwiO1xuICBWYWxpZGF0ZVR5cGUyW1wiSU5WT0tFXCJdID0gXCJJTlZPS0VcIjtcbiAgcmV0dXJuIFZhbGlkYXRlVHlwZTI7XG59KShWYWxpZGF0ZVR5cGUgfHwge30pO1xudmFyIFVpbnQgPSAvKiBAX19QVVJFX18gKi8gKChVaW50MikgPT4ge1xuICBVaW50MltcInU4XCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1OFwiO1xuICBVaW50MltcInUxNlwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dTE2XCI7XG4gIFVpbnQyW1widTMyXCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1MzJcIjtcbiAgVWludDJbXCJ1NjRcIl0gPSBcImNvcmU6OmludGVnZXI6OnU2NFwiO1xuICBVaW50MltcInUxMjhcIl0gPSBcImNvcmU6OmludGVnZXI6OnUxMjhcIjtcbiAgVWludDJbXCJ1MjU2XCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1MjU2XCI7XG4gIHJldHVybiBVaW50Mjtcbn0pKFVpbnQgfHwge30pO1xudmFyIExpdHRlcmFsID0gLyogQF9fUFVSRV9fICovICgoTGl0dGVyYWwyKSA9PiB7XG4gIExpdHRlcmFsMltcIkNsYXNzSGFzaFwiXSA9IFwiY29yZTo6c3RhcmtuZXQ6OmNsYXNzX2hhc2g6OkNsYXNzSGFzaFwiO1xuICBMaXR0ZXJhbDJbXCJDb250cmFjdEFkZHJlc3NcIl0gPSBcImNvcmU6OnN0YXJrbmV0Ojpjb250cmFjdF9hZGRyZXNzOjpDb250cmFjdEFkZHJlc3NcIjtcbiAgcmV0dXJuIExpdHRlcmFsMjtcbn0pKExpdHRlcmFsIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL2xpYi9jb250cmFjdC9pbmRleC50c1xudmFyIEVudHJ5UG9pbnRUeXBlID0gLyogQF9fUFVSRV9fICovICgoRW50cnlQb2ludFR5cGUyKSA9PiB7XG4gIEVudHJ5UG9pbnRUeXBlMltcIkVYVEVSTkFMXCJdID0gXCJFWFRFUk5BTFwiO1xuICBFbnRyeVBvaW50VHlwZTJbXCJMMV9IQU5ETEVSXCJdID0gXCJMMV9IQU5ETEVSXCI7XG4gIEVudHJ5UG9pbnRUeXBlMltcIkNPTlNUUlVDVE9SXCJdID0gXCJDT05TVFJVQ1RPUlwiO1xuICByZXR1cm4gRW50cnlQb2ludFR5cGUyO1xufSkoRW50cnlQb2ludFR5cGUgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvbGliL2luZGV4LnRzXG52YXIgVHJhbnNhY3Rpb25UeXBlID0gLyogQF9fUFVSRV9fICovICgoVHJhbnNhY3Rpb25UeXBlMikgPT4ge1xuICBUcmFuc2FjdGlvblR5cGUyW1wiREVDTEFSRVwiXSA9IFwiREVDTEFSRVwiO1xuICBUcmFuc2FjdGlvblR5cGUyW1wiREVQTE9ZXCJdID0gXCJERVBMT1lcIjtcbiAgVHJhbnNhY3Rpb25UeXBlMltcIkRFUExPWV9BQ0NPVU5UXCJdID0gXCJERVBMT1lfQUNDT1VOVFwiO1xuICBUcmFuc2FjdGlvblR5cGUyW1wiSU5WT0tFXCJdID0gXCJJTlZPS0VfRlVOQ1RJT05cIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uVHlwZTI7XG59KShUcmFuc2FjdGlvblR5cGUgfHwge30pO1xudmFyIFRyYW5zYWN0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoVHJhbnNhY3Rpb25TdGF0dXMyKSA9PiB7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIk5PVF9SRUNFSVZFRFwiXSA9IFwiTk9UX1JFQ0VJVkVEXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIlJFQ0VJVkVEXCJdID0gXCJSRUNFSVZFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMlwiXSA9IFwiQUNDRVBURURfT05fTDJcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIlJFSkVDVEVEXCJdID0gXCJSRUpFQ1RFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJSRVZFUlRFRFwiXSA9IFwiUkVWRVJURURcIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uU3RhdHVzMjtcbn0pKFRyYW5zYWN0aW9uU3RhdHVzIHx8IHt9KTtcbnZhciBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czIpID0+IHtcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJOT1RfUkVDRUlWRURcIl0gPSBcIk5PVF9SRUNFSVZFRFwiO1xuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIlJFQ0VJVkVEXCJdID0gXCJSRUNFSVZFRFwiO1xuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIkFDQ0VQVEVEX09OX0wyXCJdID0gXCJBQ0NFUFRFRF9PTl9MMlwiO1xuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIkFDQ0VQVEVEX09OX0wxXCJdID0gXCJBQ0NFUFRFRF9PTl9MMVwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czI7XG59KShUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzIHx8IHt9KTtcbnZhciBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMikgPT4ge1xuICBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czJbXCJSRUpFQ1RFRFwiXSA9IFwiUkVKRUNURURcIjtcbiAgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyW1wiUkVWRVJURURcIl0gPSBcIlJFVkVSVEVEXCI7XG4gIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMltcIlNVQ0NFRURFRFwiXSA9IFwiU1VDQ0VFREVEXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czI7XG59KShUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyB8fCB7fSk7XG52YXIgQmxvY2tTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChCbG9ja1N0YXR1czIpID0+IHtcbiAgQmxvY2tTdGF0dXMyW1wiUEVORElOR1wiXSA9IFwiUEVORElOR1wiO1xuICBCbG9ja1N0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMVwiXSA9IFwiQUNDRVBURURfT05fTDFcIjtcbiAgQmxvY2tTdGF0dXMyW1wiQUNDRVBURURfT05fTDJcIl0gPSBcIkFDQ0VQVEVEX09OX0wyXCI7XG4gIEJsb2NrU3RhdHVzMltcIlJFSkVDVEVEXCJdID0gXCJSRUpFQ1RFRFwiO1xuICByZXR1cm4gQmxvY2tTdGF0dXMyO1xufSkoQmxvY2tTdGF0dXMgfHwge30pO1xudmFyIEJsb2NrVGFnID0gLyogQF9fUFVSRV9fICovICgoQmxvY2tUYWcyKSA9PiB7XG4gIEJsb2NrVGFnMltcInBlbmRpbmdcIl0gPSBcInBlbmRpbmdcIjtcbiAgQmxvY2tUYWcyW1wibGF0ZXN0XCJdID0gXCJsYXRlc3RcIjtcbiAgcmV0dXJuIEJsb2NrVGFnMjtcbn0pKEJsb2NrVGFnIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL2FwaS9ycGMudHNcbnZhciBycGNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocnBjX2V4cG9ydHMsIHtcbiAgRUJsb2NrVGFnOiAoKSA9PiBFQmxvY2tUYWcsXG4gIEVEYXRhQXZhaWxhYmlsaXR5TW9kZTogKCkgPT4gRURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICBFU2ltdWxhdGlvbkZsYWc6ICgpID0+IEVTaW11bGF0aW9uRmxhZyxcbiAgRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzOiAoKSA9PiBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMsXG4gIEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzOiAoKSA9PiBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyxcbiAgRVRyYW5zYWN0aW9uU3RhdHVzOiAoKSA9PiBFVHJhbnNhY3Rpb25TdGF0dXMsXG4gIEVUcmFuc2FjdGlvblR5cGU6ICgpID0+IEVUcmFuc2FjdGlvblR5cGUsXG4gIEVycm9yczogKCkgPT4gZXJyb3JzX2V4cG9ydHMsXG4gIEpSUEM6ICgpID0+IGpzb25ycGNfZXhwb3J0cyxcbiAgU1BFQzogKCkgPT4gY29tcG9uZW50c19leHBvcnRzXG59KTtcblxuLy8gc3JjL3R5cGVzL2FwaS9qc29ucnBjL2luZGV4LnRzXG52YXIganNvbnJwY19leHBvcnRzID0ge307XG5cbi8vIHNyYy90eXBlcy9hcGkvcnBjc3BlYy9lcnJvcnMudHNcbnZhciBlcnJvcnNfZXhwb3J0cyA9IHt9O1xuXG4vLyBzcmMvdHlwZXMvYXBpL3JwY3NwZWMvY29tcG9uZW50cy50c1xudmFyIGNvbXBvbmVudHNfZXhwb3J0cyA9IHt9O1xuXG4vLyBzcmMvdHlwZXMvYXBpL3JwY3NwZWMvbm9uc3BlYy50c1xudmFyIEVUcmFuc2FjdGlvblR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25UeXBlMikgPT4ge1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIkRFQ0xBUkVcIl0gPSBcIkRFQ0xBUkVcIjtcbiAgRVRyYW5zYWN0aW9uVHlwZTJbXCJERVBMT1lcIl0gPSBcIkRFUExPWVwiO1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIkRFUExPWV9BQ0NPVU5UXCJdID0gXCJERVBMT1lfQUNDT1VOVFwiO1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIklOVk9LRVwiXSA9IFwiSU5WT0tFXCI7XG4gIEVUcmFuc2FjdGlvblR5cGUyW1wiTDFfSEFORExFUlwiXSA9IFwiTDFfSEFORExFUlwiO1xuICByZXR1cm4gRVRyYW5zYWN0aW9uVHlwZTI7XG59KShFVHJhbnNhY3Rpb25UeXBlIHx8IHt9KTtcbnZhciBFU2ltdWxhdGlvbkZsYWcgPSAvKiBAX19QVVJFX18gKi8gKChFU2ltdWxhdGlvbkZsYWcyKSA9PiB7XG4gIEVTaW11bGF0aW9uRmxhZzJbXCJTS0lQX1ZBTElEQVRFXCJdID0gXCJTS0lQX1ZBTElEQVRFXCI7XG4gIEVTaW11bGF0aW9uRmxhZzJbXCJTS0lQX0ZFRV9DSEFSR0VcIl0gPSBcIlNLSVBfRkVFX0NIQVJHRVwiO1xuICByZXR1cm4gRVNpbXVsYXRpb25GbGFnMjtcbn0pKEVTaW11bGF0aW9uRmxhZyB8fCB7fSk7XG52YXIgRVRyYW5zYWN0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uU3RhdHVzMikgPT4ge1xuICBFVHJhbnNhY3Rpb25TdGF0dXMyW1wiUkVDRUlWRURcIl0gPSBcIlJFQ0VJVkVEXCI7XG4gIEVUcmFuc2FjdGlvblN0YXR1czJbXCJSRUpFQ1RFRFwiXSA9IFwiUkVKRUNURURcIjtcbiAgRVRyYW5zYWN0aW9uU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wyXCJdID0gXCJBQ0NFUFRFRF9PTl9MMlwiO1xuICBFVHJhbnNhY3Rpb25TdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25TdGF0dXMyO1xufSkoRVRyYW5zYWN0aW9uU3RhdHVzIHx8IHt9KTtcbnZhciBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMikgPT4ge1xuICBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMlwiXSA9IFwiQUNDRVBURURfT05fTDJcIjtcbiAgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czI7XG59KShFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyB8fCB7fSk7XG52YXIgRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMikgPT4ge1xuICBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyW1wiU1VDQ0VFREVEXCJdID0gXCJTVUNDRUVERURcIjtcbiAgRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMltcIlJFVkVSVEVEXCJdID0gXCJSRVZFUlRFRFwiO1xuICByZXR1cm4gRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMjtcbn0pKEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyB8fCB7fSk7XG52YXIgRUJsb2NrVGFnID0gLyogQF9fUFVSRV9fICovICgoRUJsb2NrVGFnMikgPT4ge1xuICBFQmxvY2tUYWcyW1wiTEFURVNUXCJdID0gXCJsYXRlc3RcIjtcbiAgRUJsb2NrVGFnMltcIlBFTkRJTkdcIl0gPSBcInBlbmRpbmdcIjtcbiAgcmV0dXJuIEVCbG9ja1RhZzI7XG59KShFQmxvY2tUYWcgfHwge30pO1xudmFyIEVEYXRhQXZhaWxhYmlsaXR5TW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEVEYXRhQXZhaWxhYmlsaXR5TW9kZTIpID0+IHtcbiAgRURhdGFBdmFpbGFiaWxpdHlNb2RlMltcIkwxXCJdID0gXCJMMVwiO1xuICBFRGF0YUF2YWlsYWJpbGl0eU1vZGUyW1wiTDJcIl0gPSBcIkwyXCI7XG4gIHJldHVybiBFRGF0YUF2YWlsYWJpbGl0eU1vZGUyO1xufSkoRURhdGFBdmFpbGFiaWxpdHlNb2RlIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL2FwaS9zZXF1ZW5jZXIudHNcbnZhciBzZXF1ZW5jZXJfZXhwb3J0cyA9IHt9O1xuXG4vLyBzcmMvdXRpbHMvYXNzZXJ0LnRzXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgXCJBc3NlcnRpb24gZmFpbHVyZVwiKTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvbnVtLnRzXG52YXIgbnVtX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG51bV9leHBvcnRzLCB7XG4gIGFzc2VydEluUmFuZ2U6ICgpID0+IGFzc2VydEluUmFuZ2UsXG4gIGJpZ051bWJlcmlzaEFycmF5VG9EZWNpbWFsU3RyaW5nQXJyYXk6ICgpID0+IGJpZ051bWJlcmlzaEFycmF5VG9EZWNpbWFsU3RyaW5nQXJyYXksXG4gIGJpZ051bWJlcmlzaEFycmF5VG9IZXhhZGVjaW1hbFN0cmluZ0FycmF5OiAoKSA9PiBiaWdOdW1iZXJpc2hBcnJheVRvSGV4YWRlY2ltYWxTdHJpbmdBcnJheSxcbiAgY2xlYW5IZXg6ICgpID0+IGNsZWFuSGV4LFxuICBnZXREZWNpbWFsU3RyaW5nOiAoKSA9PiBnZXREZWNpbWFsU3RyaW5nLFxuICBnZXRIZXhTdHJpbmc6ICgpID0+IGdldEhleFN0cmluZyxcbiAgZ2V0SGV4U3RyaW5nQXJyYXk6ICgpID0+IGdldEhleFN0cmluZ0FycmF5LFxuICBoZXhUb0J5dGVzOiAoKSA9PiBoZXhUb0J5dGVzLFxuICBoZXhUb0RlY2ltYWxTdHJpbmc6ICgpID0+IGhleFRvRGVjaW1hbFN0cmluZyxcbiAgaXNCaWdJbnQ6ICgpID0+IGlzQmlnSW50LFxuICBpc0hleDogKCkgPT4gaXNIZXgsXG4gIGlzU3RyaW5nV2hvbGVOdW1iZXI6ICgpID0+IGlzU3RyaW5nV2hvbGVOdW1iZXIsXG4gIHRvQmlnSW50OiAoKSA9PiB0b0JpZ0ludCxcbiAgdG9DYWlyb0Jvb2w6ICgpID0+IHRvQ2Fpcm9Cb29sLFxuICB0b0hleDogKCkgPT4gdG9IZXgsXG4gIHRvSGV4U3RyaW5nOiAoKSA9PiB0b0hleFN0cmluZyxcbiAgdG9TdG9yYWdlS2V5OiAoKSA9PiB0b1N0b3JhZ2VLZXlcbn0pO1xuaW1wb3J0IHsgaGV4VG9CeXRlcyBhcyBoZXhUb0J5dGVzTm9ibGUgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiO1xuZnVuY3Rpb24gaXNIZXgoaGV4KSB7XG4gIHJldHVybiAvXjB4WzAtOWEtZl0qJC9pLnRlc3QoaGV4KTtcbn1cbmZ1bmN0aW9uIHRvQmlnSW50KHZhbHVlKSB7XG4gIHJldHVybiBCaWdJbnQodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNCaWdJbnQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIjtcbn1cbmZ1bmN0aW9uIHRvSGV4KG51bWJlcjIpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeCh0b0JpZ0ludChudW1iZXIyKS50b1N0cmluZygxNikpO1xufVxudmFyIHRvSGV4U3RyaW5nID0gdG9IZXg7XG5mdW5jdGlvbiB0b1N0b3JhZ2VLZXkobnVtYmVyMikge1xuICBjb25zdCByZXMgPSBhZGRIZXhQcmVmaXgodG9CaWdJbnQobnVtYmVyMikudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDY0LCBcIjBcIikpO1xuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gaGV4VG9EZWNpbWFsU3RyaW5nKGhleCkge1xuICByZXR1cm4gQmlnSW50KGFkZEhleFByZWZpeChoZXgpKS50b1N0cmluZygxMCk7XG59XG52YXIgY2xlYW5IZXggPSAoaGV4KSA9PiBoZXgudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eKDB4KTArLywgXCIkMVwiKTtcbmZ1bmN0aW9uIGFzc2VydEluUmFuZ2UoaW5wdXQsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQsIGlucHV0TmFtZSA9IFwiXCIpIHtcbiAgY29uc3QgbWVzc2FnZVN1ZmZpeCA9IGlucHV0TmFtZSA9PT0gXCJcIiA/IFwiaW52YWxpZCBsZW5ndGhcIiA6IGBpbnZhbGlkICR7aW5wdXROYW1lfSBsZW5ndGhgO1xuICBjb25zdCBpbnB1dEJpZ0ludCA9IEJpZ0ludChpbnB1dCk7XG4gIGNvbnN0IGxvd2VyQm91bmRCaWdJbnQgPSBCaWdJbnQobG93ZXJCb3VuZCk7XG4gIGNvbnN0IHVwcGVyQm91bmRCaWdJbnQgPSBCaWdJbnQodXBwZXJCb3VuZCk7XG4gIGFzc2VydChcbiAgICBpbnB1dEJpZ0ludCA+PSBsb3dlckJvdW5kQmlnSW50ICYmIGlucHV0QmlnSW50IDw9IHVwcGVyQm91bmRCaWdJbnQsXG4gICAgYE1lc3NhZ2Ugbm90IHNpZ25hYmxlLCAke21lc3NhZ2VTdWZmaXh9LmBcbiAgKTtcbn1cbmZ1bmN0aW9uIGJpZ051bWJlcmlzaEFycmF5VG9EZWNpbWFsU3RyaW5nQXJyYXkocmF3Q2FsbGRhdGEpIHtcbiAgcmV0dXJuIHJhd0NhbGxkYXRhLm1hcCgoeCkgPT4gdG9CaWdJbnQoeCkudG9TdHJpbmcoMTApKTtcbn1cbmZ1bmN0aW9uIGJpZ051bWJlcmlzaEFycmF5VG9IZXhhZGVjaW1hbFN0cmluZ0FycmF5KHJhd0NhbGxkYXRhKSB7XG4gIHJldHVybiByYXdDYWxsZGF0YS5tYXAoKHgpID0+IHRvSGV4KHgpKTtcbn1cbnZhciBpc1N0cmluZ1dob2xlTnVtYmVyID0gKHZhbHVlKSA9PiAvXlxcZCskLy50ZXN0KHZhbHVlKTtcbmZ1bmN0aW9uIGdldERlY2ltYWxTdHJpbmcodmFsdWUpIHtcbiAgaWYgKGlzSGV4KHZhbHVlKSkge1xuICAgIHJldHVybiBoZXhUb0RlY2ltYWxTdHJpbmcodmFsdWUpO1xuICB9XG4gIGlmIChpc1N0cmluZ1dob2xlTnVtYmVyKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7dmFsdWV9IG5lZWQgdG8gYmUgaGV4LXN0cmluZyBvciB3aG9sZS1udW1iZXItc3RyaW5nYCk7XG59XG5mdW5jdGlvbiBnZXRIZXhTdHJpbmcodmFsdWUpIHtcbiAgaWYgKGlzSGV4KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTdHJpbmdXaG9sZU51bWJlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdG9IZXhTdHJpbmcodmFsdWUpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgJHt2YWx1ZX0gbmVlZCB0byBiZSBoZXgtc3RyaW5nIG9yIHdob2xlLW51bWJlci1zdHJpbmdgKTtcbn1cbmZ1bmN0aW9uIGdldEhleFN0cmluZ0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5tYXAoKGVsKSA9PiBnZXRIZXhTdHJpbmcoZWwpKTtcbn1cbnZhciB0b0NhaXJvQm9vbCA9ICh2YWx1ZSkgPT4gKCt2YWx1ZSkudG9TdHJpbmcoKTtcbmZ1bmN0aW9uIGhleFRvQnl0ZXModmFsdWUpIHtcbiAgaWYgKCFpc0hleCh2YWx1ZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3ZhbHVlfSBuZWVkIHRvIGJlIGEgaGV4LXN0cmluZ2ApO1xuICBsZXQgYWRhcHRlZFZhbHVlID0gcmVtb3ZlSGV4UHJlZml4KHZhbHVlKTtcbiAgaWYgKGFkYXB0ZWRWYWx1ZS5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgYWRhcHRlZFZhbHVlID0gYDAke2FkYXB0ZWRWYWx1ZX1gO1xuICB9XG4gIHJldHVybiBoZXhUb0J5dGVzTm9ibGUoYWRhcHRlZFZhbHVlKTtcbn1cblxuLy8gc3JjL3V0aWxzL3NlbGVjdG9yLnRzXG52YXIgc2VsZWN0b3JfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc2VsZWN0b3JfZXhwb3J0cywge1xuICBnZXRTZWxlY3RvcjogKCkgPT4gZ2V0U2VsZWN0b3IsXG4gIGdldFNlbGVjdG9yRnJvbU5hbWU6ICgpID0+IGdldFNlbGVjdG9yRnJvbU5hbWUsXG4gIGtlY2Nha0JuOiAoKSA9PiBrZWNjYWtCbixcbiAgc3RhcmtuZXRLZWNjYWs6ICgpID0+IHN0YXJrbmV0S2VjY2FrXG59KTtcbmltcG9ydCB7IGtlY2NhayB9IGZyb20gXCJAc2N1cmUvc3RhcmtuZXRcIjtcbmZ1bmN0aW9uIGtlY2Nha0JuKHZhbHVlKSB7XG4gIGNvbnN0IGhleFdpdGhvdXRQcmVmaXggPSByZW1vdmVIZXhQcmVmaXgodG9IZXgoQmlnSW50KHZhbHVlKSkpO1xuICBjb25zdCBldmVuSGV4ID0gaGV4V2l0aG91dFByZWZpeC5sZW5ndGggJSAyID09PSAwID8gaGV4V2l0aG91dFByZWZpeCA6IGAwJHtoZXhXaXRob3V0UHJlZml4fWA7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoa2VjY2FrKGhleFRvQnl0ZXMoYWRkSGV4UHJlZml4KGV2ZW5IZXgpKSkudG9TdHJpbmcoMTYpKTtcbn1cbmZ1bmN0aW9uIGtlY2Nha0hleChzdHIpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChrZWNjYWsodXRmOFRvQXJyYXkoc3RyKSkudG9TdHJpbmcoMTYpKTtcbn1cbmZ1bmN0aW9uIHN0YXJrbmV0S2VjY2FrKHN0cikge1xuICBjb25zdCBoYXNoID0gQmlnSW50KGtlY2Nha0hleChzdHIpKTtcbiAgcmV0dXJuIGhhc2ggJiBNQVNLXzI1MDtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdG9yRnJvbU5hbWUoZnVuY05hbWUpIHtcbiAgcmV0dXJuIHRvSGV4KHN0YXJrbmV0S2VjY2FrKGZ1bmNOYW1lKSk7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rvcih2YWx1ZSkge1xuICBpZiAoaXNIZXgodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N0cmluZ1dob2xlTnVtYmVyKHZhbHVlKSkge1xuICAgIHJldHVybiB0b0hleFN0cmluZyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGdldFNlbGVjdG9yRnJvbU5hbWUodmFsdWUpO1xufVxuXG4vLyBzcmMvdXRpbHMvc2hvcnRTdHJpbmcudHNcbnZhciBzaG9ydFN0cmluZ19leHBvcnRzID0ge307XG5fX2V4cG9ydChzaG9ydFN0cmluZ19leHBvcnRzLCB7XG4gIGRlY29kZVNob3J0U3RyaW5nOiAoKSA9PiBkZWNvZGVTaG9ydFN0cmluZyxcbiAgZW5jb2RlU2hvcnRTdHJpbmc6ICgpID0+IGVuY29kZVNob3J0U3RyaW5nLFxuICBpc0FTQ0lJOiAoKSA9PiBpc0FTQ0lJLFxuICBpc0RlY2ltYWxTdHJpbmc6ICgpID0+IGlzRGVjaW1hbFN0cmluZyxcbiAgaXNMb25nVGV4dDogKCkgPT4gaXNMb25nVGV4dCxcbiAgaXNTaG9ydFN0cmluZzogKCkgPT4gaXNTaG9ydFN0cmluZyxcbiAgaXNTaG9ydFRleHQ6ICgpID0+IGlzU2hvcnRUZXh0LFxuICBpc1RleHQ6ICgpID0+IGlzVGV4dCxcbiAgc3BsaXRMb25nU3RyaW5nOiAoKSA9PiBzcGxpdExvbmdTdHJpbmdcbn0pO1xuZnVuY3Rpb24gaXNBU0NJSShzdHIpIHtcbiAgcmV0dXJuIC9eW1xceDAwLVxceDdGXSokLy50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBpc1Nob3J0U3RyaW5nKHN0cikge1xuICByZXR1cm4gc3RyLmxlbmd0aCA8PSBURVhUX1RPX0ZFTFRfTUFYX0xFTjtcbn1cbmZ1bmN0aW9uIGlzRGVjaW1hbFN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIC9eWzAtOV0qJC9pLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIGlzVGV4dCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgJiYgIWlzSGV4KHZhbCkgJiYgIWlzU3RyaW5nV2hvbGVOdW1iZXIodmFsKTtcbn1cbnZhciBpc1Nob3J0VGV4dCA9ICh2YWwpID0+IGlzVGV4dCh2YWwpICYmIGlzU2hvcnRTdHJpbmcodmFsKTtcbnZhciBpc0xvbmdUZXh0ID0gKHZhbCkgPT4gaXNUZXh0KHZhbCkgJiYgIWlzU2hvcnRTdHJpbmcodmFsKTtcbmZ1bmN0aW9uIHNwbGl0TG9uZ1N0cmluZyhsb25nU3RyKSB7XG4gIGNvbnN0IHJlZ2V4ID0gUmVnRXhwKGBbXl17MSwke1RFWFRfVE9fRkVMVF9NQVhfTEVOfX1gLCBcImdcIik7XG4gIHJldHVybiBsb25nU3RyLm1hdGNoKHJlZ2V4KSB8fCBbXTtcbn1cbmZ1bmN0aW9uIGVuY29kZVNob3J0U3RyaW5nKHN0cikge1xuICBpZiAoIWlzQVNDSUkoc3RyKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBpcyBub3QgYW4gQVNDSUkgc3RyaW5nYCk7XG4gIGlmICghaXNTaG9ydFN0cmluZyhzdHIpKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IGlzIHRvbyBsb25nYCk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoc3RyLnJlcGxhY2UoLy4vZywgKGNoYXIpID0+IGNoYXIuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVNob3J0U3RyaW5nKHN0cikge1xuICBpZiAoIWlzQVNDSUkoc3RyKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBpcyBub3QgYW4gQVNDSUkgc3RyaW5nYCk7XG4gIGlmIChpc0hleChzdHIpKSB7XG4gICAgcmV0dXJuIHJlbW92ZUhleFByZWZpeChzdHIpLnJlcGxhY2UoLy57Mn0vZywgKGhleCkgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXgsIDE2KSkpO1xuICB9XG4gIGlmIChpc0RlY2ltYWxTdHJpbmcoc3RyKSkge1xuICAgIHJldHVybiBkZWNvZGVTaG9ydFN0cmluZyhcIjBYXCIuY29uY2F0KEJpZ0ludChzdHIpLnRvU3RyaW5nKDE2KSkpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IGlzIG5vdCBIZXggb3IgZGVjaW1hbGApO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvY2Fpcm8udHNcbnZhciBjYWlyb19leHBvcnRzID0ge307XG5fX2V4cG9ydChjYWlyb19leHBvcnRzLCB7XG4gIGZlbHQ6ICgpID0+IGZlbHQsXG4gIGdldEFiaUNvbnRyYWN0VmVyc2lvbjogKCkgPT4gZ2V0QWJpQ29udHJhY3RWZXJzaW9uLFxuICBnZXRBcnJheVR5cGU6ICgpID0+IGdldEFycmF5VHlwZSxcbiAgaXNDYWlybzFBYmk6ICgpID0+IGlzQ2Fpcm8xQWJpLFxuICBpc0NhaXJvMVR5cGU6ICgpID0+IGlzQ2Fpcm8xVHlwZSxcbiAgaXNMZW46ICgpID0+IGlzTGVuLFxuICBpc1R5cGVBcnJheTogKCkgPT4gaXNUeXBlQXJyYXksXG4gIGlzVHlwZUJvb2w6ICgpID0+IGlzVHlwZUJvb2wsXG4gIGlzVHlwZUNvbnRyYWN0QWRkcmVzczogKCkgPT4gaXNUeXBlQ29udHJhY3RBZGRyZXNzLFxuICBpc1R5cGVFbnVtOiAoKSA9PiBpc1R5cGVFbnVtLFxuICBpc1R5cGVFdGhBZGRyZXNzOiAoKSA9PiBpc1R5cGVFdGhBZGRyZXNzLFxuICBpc1R5cGVGZWx0OiAoKSA9PiBpc1R5cGVGZWx0LFxuICBpc1R5cGVMaXR0ZXJhbDogKCkgPT4gaXNUeXBlTGl0dGVyYWwsXG4gIGlzVHlwZU5hbWVkVHVwbGU6ICgpID0+IGlzVHlwZU5hbWVkVHVwbGUsXG4gIGlzVHlwZU9wdGlvbjogKCkgPT4gaXNUeXBlT3B0aW9uLFxuICBpc1R5cGVSZXN1bHQ6ICgpID0+IGlzVHlwZVJlc3VsdCxcbiAgaXNUeXBlU3RydWN0OiAoKSA9PiBpc1R5cGVTdHJ1Y3QsXG4gIGlzVHlwZVR1cGxlOiAoKSA9PiBpc1R5cGVUdXBsZSxcbiAgaXNUeXBlVWludDogKCkgPT4gaXNUeXBlVWludCxcbiAgaXNUeXBlVWludDI1NjogKCkgPT4gaXNUeXBlVWludDI1NixcbiAgdHVwbGU6ICgpID0+IHR1cGxlLFxuICB1aW50MjU2OiAoKSA9PiB1aW50MjU2XG59KTtcblxuLy8gc3JjL3V0aWxzL3VpbnQyNTYudHNcbnZhciB1aW50MjU2X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHVpbnQyNTZfZXhwb3J0cywge1xuICBVSU5UXzEyOF9NQVg6ICgpID0+IFVJTlRfMTI4X01BWCxcbiAgVUlOVF8yNTZfTUFYOiAoKSA9PiBVSU5UXzI1Nl9NQVgsXG4gIGJuVG9VaW50MjU2OiAoKSA9PiBiblRvVWludDI1NixcbiAgaXNVaW50MjU2OiAoKSA9PiBpc1VpbnQyNTYsXG4gIHVpbnQyNTZUb0JOOiAoKSA9PiB1aW50MjU2VG9CTlxufSk7XG52YXIgVUlOVF8xMjhfTUFYID0gKDFuIDw8IDEyOG4pIC0gMW47XG52YXIgVUlOVF8yNTZfTUFYID0gKDFuIDw8IDI1Nm4pIC0gMW47XG5mdW5jdGlvbiB1aW50MjU2VG9CTih1aW50MjU2Mikge1xuICByZXR1cm4gKHRvQmlnSW50KHVpbnQyNTYyLmhpZ2gpIDw8IDEyOG4pICsgdG9CaWdJbnQodWludDI1NjIubG93KTtcbn1cbmZ1bmN0aW9uIGlzVWludDI1Nihibikge1xuICByZXR1cm4gdG9CaWdJbnQoYm4pIDw9IFVJTlRfMjU2X01BWDtcbn1cbmZ1bmN0aW9uIGJuVG9VaW50MjU2KGJuKSB7XG4gIGNvbnN0IGJpID0gdG9CaWdJbnQoYm4pO1xuICBpZiAoIWlzVWludDI1NihiaSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIGlzIHRvbyBsYXJnZVwiKTtcbiAgcmV0dXJuIHtcbiAgICBsb3c6IGFkZEhleFByZWZpeCgoYmkgJiBVSU5UXzEyOF9NQVgpLnRvU3RyaW5nKDE2KSksXG4gICAgaGlnaDogYWRkSGV4UHJlZml4KChiaSA+PiAxMjhuKS50b1N0cmluZygxNikpXG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9jYWlyby50c1xudmFyIGlzTGVuID0gKG5hbWUpID0+IC9fbGVuJC8udGVzdChuYW1lKTtcbnZhciBpc1R5cGVGZWx0ID0gKHR5cGUpID0+IHR5cGUgPT09IFwiZmVsdFwiIHx8IHR5cGUgPT09IFwiY29yZTo6ZmVsdDI1MlwiO1xudmFyIGlzVHlwZUFycmF5ID0gKHR5cGUpID0+IC9cXCovLnRlc3QodHlwZSkgfHwgdHlwZS5zdGFydHNXaXRoKFwiY29yZTo6YXJyYXk6OkFycmF5OjpcIikgfHwgdHlwZS5zdGFydHNXaXRoKFwiY29yZTo6YXJyYXk6OlNwYW46OlwiKTtcbnZhciBpc1R5cGVUdXBsZSA9ICh0eXBlKSA9PiAvXlxcKC4qXFwpJC9pLnRlc3QodHlwZSk7XG52YXIgaXNUeXBlTmFtZWRUdXBsZSA9ICh0eXBlKSA9PiAvXFwoLipcXCkvaS50ZXN0KHR5cGUpICYmIHR5cGUuaW5jbHVkZXMoXCI6XCIpO1xudmFyIGlzVHlwZVN0cnVjdCA9ICh0eXBlLCBzdHJ1Y3RzKSA9PiB0eXBlIGluIHN0cnVjdHM7XG52YXIgaXNUeXBlRW51bSA9ICh0eXBlLCBlbnVtcykgPT4gdHlwZSBpbiBlbnVtcztcbnZhciBpc1R5cGVPcHRpb24gPSAodHlwZSkgPT4gdHlwZS5zdGFydHNXaXRoKFwiY29yZTo6b3B0aW9uOjpPcHRpb246OlwiKTtcbnZhciBpc1R5cGVSZXN1bHQgPSAodHlwZSkgPT4gdHlwZS5zdGFydHNXaXRoKFwiY29yZTo6cmVzdWx0OjpSZXN1bHQ6OlwiKTtcbnZhciBpc1R5cGVVaW50ID0gKHR5cGUpID0+IE9iamVjdC52YWx1ZXMoVWludCkuaW5jbHVkZXModHlwZSk7XG52YXIgaXNUeXBlTGl0dGVyYWwgPSAodHlwZSkgPT4gT2JqZWN0LnZhbHVlcyhMaXR0ZXJhbCkuaW5jbHVkZXModHlwZSk7XG52YXIgaXNUeXBlVWludDI1NiA9ICh0eXBlKSA9PiB0eXBlID09PSBcImNvcmU6OmludGVnZXI6OnUyNTZcIjtcbnZhciBpc1R5cGVCb29sID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6Ym9vbFwiO1xudmFyIGlzVHlwZUNvbnRyYWN0QWRkcmVzcyA9ICh0eXBlKSA9PiB0eXBlID09PSBcImNvcmU6OnN0YXJrbmV0Ojpjb250cmFjdF9hZGRyZXNzOjpDb250cmFjdEFkZHJlc3NcIjtcbnZhciBpc1R5cGVFdGhBZGRyZXNzID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCI7XG52YXIgaXNDYWlybzFUeXBlID0gKHR5cGUpID0+IHR5cGUuaW5jbHVkZXMoXCI6OlwiKTtcbnZhciBnZXRBcnJheVR5cGUgPSAodHlwZSkgPT4ge1xuICBpZiAoaXNDYWlybzFUeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIHR5cGUuc3Vic3RyaW5nKHR5cGUuaW5kZXhPZihcIjxcIikgKyAxLCB0eXBlLmxhc3RJbmRleE9mKFwiPlwiKSk7XG4gIH1cbiAgcmV0dXJuIHR5cGUucmVwbGFjZShcIipcIiwgXCJcIik7XG59O1xuZnVuY3Rpb24gaXNDYWlybzFBYmkoYWJpKSB7XG4gIGNvbnN0IHsgY2Fpcm8gfSA9IGdldEFiaUNvbnRyYWN0VmVyc2lvbihhYmkpO1xuICBpZiAoY2Fpcm8gPT09IHZvaWQgMCkge1xuICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGRldGVybWluZSBDYWlybyB2ZXJzaW9uXCIpO1xuICB9XG4gIHJldHVybiBjYWlybyA9PT0gXCIxXCI7XG59XG5mdW5jdGlvbiBnZXRBYmlDb250cmFjdFZlcnNpb24oYWJpKSB7XG4gIGlmIChhYmkuZmluZCgoaXQpID0+IGl0LnR5cGUgPT09IFwiaW50ZXJmYWNlXCIpKSB7XG4gICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogXCIyXCIgfTtcbiAgfVxuICBjb25zdCB0ZXN0RnVuY3Rpb24gPSBhYmkuZmluZChcbiAgICAoaXQpID0+IGl0LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJiAoaXQuaW5wdXRzLmxlbmd0aCB8fCBpdC5vdXRwdXRzLmxlbmd0aClcbiAgKTtcbiAgaWYgKCF0ZXN0RnVuY3Rpb24pIHtcbiAgICByZXR1cm4geyBjYWlybzogdm9pZCAwLCBjb21waWxlcjogdm9pZCAwIH07XG4gIH1cbiAgY29uc3QgaW8gPSB0ZXN0RnVuY3Rpb24uaW5wdXRzLmxlbmd0aCA/IHRlc3RGdW5jdGlvbi5pbnB1dHMgOiB0ZXN0RnVuY3Rpb24ub3V0cHV0cztcbiAgaWYgKGlzQ2Fpcm8xVHlwZShpb1swXS50eXBlKSkge1xuICAgIHJldHVybiB7IGNhaXJvOiBcIjFcIiwgY29tcGlsZXI6IFwiMVwiIH07XG4gIH1cbiAgcmV0dXJuIHsgY2Fpcm86IFwiMFwiLCBjb21waWxlcjogXCIwXCIgfTtcbn1cbnZhciB1aW50MjU2ID0gKGl0KSA9PiB7XG4gIGNvbnN0IGJuID0gQmlnSW50KGl0KTtcbiAgaWYgKCFpc1VpbnQyNTYoYm4pKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciBpcyB0b28gbGFyZ2VcIik7XG4gIHJldHVybiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBsb3c6IChibiAmIFVJTlRfMTI4X01BWCkudG9TdHJpbmcoMTApLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgaGlnaDogKGJuID4+IDEyOG4pLnRvU3RyaW5nKDEwKVxuICB9O1xufTtcbnZhciB0dXBsZSA9ICguLi5hcmdzKSA9PiAoeyAuLi5hcmdzIH0pO1xuZnVuY3Rpb24gZmVsdChpdCkge1xuICBpZiAoaXNCaWdJbnQoaXQpIHx8IHR5cGVvZiBpdCA9PT0gXCJudW1iZXJcIiAmJiBOdW1iZXIuaXNJbnRlZ2VyKGl0KSkge1xuICAgIHJldHVybiBpdC50b1N0cmluZygpO1xuICB9XG4gIGlmIChpc1RleHQoaXQpKSB7XG4gICAgaWYgKCFpc1Nob3J0U3RyaW5nKGl0KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7aXR9IGlzIGEgbG9uZyBzdHJpbmcgPiAzMSBjaGFycywgZmVsdCBjYW4gc3RvcmUgc2hvcnQgc3RyaW5ncywgc3BsaXQgaXQgdG8gYXJyYXkgb2Ygc2hvcnQgc3RyaW5nc2BcbiAgICAgICk7XG4gICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZVNob3J0U3RyaW5nKGl0KTtcbiAgICByZXR1cm4gQmlnSW50KGVuY29kZWQpLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBpdCA9PT0gXCJzdHJpbmdcIiAmJiBpc0hleChpdCkpIHtcbiAgICByZXR1cm4gQmlnSW50KGl0KS50b1N0cmluZygpO1xuICB9XG4gIGlmICh0eXBlb2YgaXQgPT09IFwic3RyaW5nXCIgJiYgaXNTdHJpbmdXaG9sZU51bWJlcihpdCkpIHtcbiAgICByZXR1cm4gaXQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBpdCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gYCR7K2l0fWA7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGAke2l0fSBjYW4ndCBiZSBjb21wdXRlZCBieSBmZWx0KClgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2VudW0vQ2Fpcm9DdXN0b21FbnVtLnRzXG52YXIgQ2Fpcm9DdXN0b21FbnVtID0gY2xhc3Mge1xuICAvKipcbiAgICogQHBhcmFtIGVudW1Db250ZW50IGFuIG9iamVjdCB3aXRoIHRoZSB2YXJpYW50cyBhcyBrZXlzIGFuZCB0aGUgY29udGVudCBhcyB2YWx1ZS4gT25seSBvbmUgY29udGVudCBzaGFsbCBiZSBkZWZpbmVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZW51bUNvbnRlbnQpIHtcbiAgICBjb25zdCB2YXJpYW50c0xpc3QgPSBPYmplY3QudmFsdWVzKGVudW1Db250ZW50KTtcbiAgICBpZiAodmFyaWFudHNMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBFbnVtIG11c3QgaGF2ZSBhIGxlYXN0IDEgdmFyaWFudFwiKTtcbiAgICB9XG4gICAgY29uc3QgbmJBY3RpdmVWYXJpYW50cyA9IHZhcmlhbnRzTGlzdC5maWx0ZXIoXG4gICAgICAoY29udGVudCkgPT4gdHlwZW9mIGNvbnRlbnQgIT09IFwidW5kZWZpbmVkXCJcbiAgICApLmxlbmd0aDtcbiAgICBpZiAobmJBY3RpdmVWYXJpYW50cyAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBFbnVtIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBhY3RpdmUgdmFyaWFudFwiKTtcbiAgICB9XG4gICAgdGhpcy52YXJpYW50ID0gZW51bUNvbnRlbnQ7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSB2YWxpZCB2YXJpYW50IG9mIGEgQ2Fpcm8gY3VzdG9tIEVudW0uXG4gICAqL1xuICB1bndyYXAoKSB7XG4gICAgY29uc3QgdmFyaWFudHMgPSBPYmplY3QuZW50cmllcyh0aGlzLnZhcmlhbnQpO1xuICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnQgPSB2YXJpYW50cy5maW5kKChpdGVtKSA9PiB0eXBlb2YgaXRlbVsxXSAhPT0gXCJ1bmRlZmluZWRcIik7XG4gICAgaWYgKHR5cGVvZiBhY3RpdmVWYXJpYW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlVmFyaWFudFsxXTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHZhbGlkIHZhcmlhbnQgb2YgYSBDYWlybyBjdXN0b20gRW51bS5cbiAgICovXG4gIGFjdGl2ZVZhcmlhbnQoKSB7XG4gICAgY29uc3QgdmFyaWFudHMgPSBPYmplY3QuZW50cmllcyh0aGlzLnZhcmlhbnQpO1xuICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnQgPSB2YXJpYW50cy5maW5kKChpdGVtKSA9PiB0eXBlb2YgaXRlbVsxXSAhPT0gXCJ1bmRlZmluZWRcIik7XG4gICAgaWYgKHR5cGVvZiBhY3RpdmVWYXJpYW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZVZhcmlhbnRbMF07XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9lbnVtL0NhaXJvT3B0aW9uLnRzXG52YXIgQ2Fpcm9PcHRpb25WYXJpYW50ID0gLyogQF9fUFVSRV9fICovICgoQ2Fpcm9PcHRpb25WYXJpYW50MikgPT4ge1xuICBDYWlyb09wdGlvblZhcmlhbnQyW0NhaXJvT3B0aW9uVmFyaWFudDJbXCJTb21lXCJdID0gMF0gPSBcIlNvbWVcIjtcbiAgQ2Fpcm9PcHRpb25WYXJpYW50MltDYWlyb09wdGlvblZhcmlhbnQyW1wiTm9uZVwiXSA9IDFdID0gXCJOb25lXCI7XG4gIHJldHVybiBDYWlyb09wdGlvblZhcmlhbnQyO1xufSkoQ2Fpcm9PcHRpb25WYXJpYW50IHx8IHt9KTtcbnZhciBDYWlyb09wdGlvbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodmFyaWFudCwgc29tZUNvbnRlbnQpIHtcbiAgICBpZiAoISh2YXJpYW50IGluIENhaXJvT3B0aW9uVmFyaWFudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIHZhcmlhbnQgOiBzaG91bGQgYmUgQ2Fpcm9PcHRpb25WYXJpYW50LlNvbWUgb3IgLk5vbmUuXCIpO1xuICAgIH1cbiAgICBpZiAodmFyaWFudCA9PT0gMCAvKiBTb21lICovKSB7XG4gICAgICBpZiAodHlwZW9mIHNvbWVDb250ZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIGNyZWF0aW9uIG9mIGEgQ2Fpcm8gT3B0aW9uIHdpdGggXCJTb21lXCIgdmFyaWFudCBuZWVkcyBhIGNvbnRlbnQgYXMgaW5wdXQuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5Tb21lID0gc29tZUNvbnRlbnQ7XG4gICAgICB0aGlzLk5vbmUgPSB2b2lkIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuU29tZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuTm9uZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgdmFsaWQgdmFyaWFudCBvZiBhIENhaXJvIGN1c3RvbSBFbnVtLlxuICAgKiAgSWYgTm9uZSwgcmV0dXJucyAndW5kZWZpbmVkJy5cbiAgICovXG4gIHVud3JhcCgpIHtcbiAgICBpZiAodGhpcy5Ob25lKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5Tb21lO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWxpZCB2YXJpYW50IGlzICdpc1NvbWUnLlxuICAgKi9cbiAgaXNTb21lKCkge1xuICAgIHJldHVybiAhKHR5cGVvZiB0aGlzLlNvbWUgPT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWxpZCB2YXJpYW50IGlzICdpc05vbmUnLlxuICAgKi9cbiAgaXNOb25lKCkge1xuICAgIHJldHVybiB0aGlzLk5vbmUgPT09IHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9lbnVtL0NhaXJvUmVzdWx0LnRzXG52YXIgQ2Fpcm9SZXN1bHRWYXJpYW50ID0gLyogQF9fUFVSRV9fICovICgoQ2Fpcm9SZXN1bHRWYXJpYW50MikgPT4ge1xuICBDYWlyb1Jlc3VsdFZhcmlhbnQyW0NhaXJvUmVzdWx0VmFyaWFudDJbXCJPa1wiXSA9IDBdID0gXCJPa1wiO1xuICBDYWlyb1Jlc3VsdFZhcmlhbnQyW0NhaXJvUmVzdWx0VmFyaWFudDJbXCJFcnJcIl0gPSAxXSA9IFwiRXJyXCI7XG4gIHJldHVybiBDYWlyb1Jlc3VsdFZhcmlhbnQyO1xufSkoQ2Fpcm9SZXN1bHRWYXJpYW50IHx8IHt9KTtcbnZhciBDYWlyb1Jlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodmFyaWFudCwgcmVzdWx0Q29udGVudCkge1xuICAgIGlmICghKHZhcmlhbnQgaW4gQ2Fpcm9SZXN1bHRWYXJpYW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgdmFyaWFudCA6IHNob3VsZCBiZSBDYWlyb1Jlc3VsdFZhcmlhbnQuT2sgb3IgLkVyci5cIik7XG4gICAgfVxuICAgIGlmICh2YXJpYW50ID09PSAwIC8qIE9rICovKSB7XG4gICAgICB0aGlzLk9rID0gcmVzdWx0Q29udGVudDtcbiAgICAgIHRoaXMuRXJyID0gdm9pZCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLk9rID0gdm9pZCAwO1xuICAgICAgdGhpcy5FcnIgPSByZXN1bHRDb250ZW50O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHZhbGlkIHZhcmlhbnQgb2YgYSBDYWlybyBSZXN1bHQuXG4gICAqL1xuICB1bndyYXAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLk9rICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5PaztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLkVyciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRoaXMuRXJyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3RoIFJlc3VsdC5PayBhbmQgLkVyciBhcmUgdW5kZWZpbmVkLiBOb3QgYXV0aG9yaXplZC5cIik7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ09rJy5cbiAgICovXG4gIGlzT2soKSB7XG4gICAgcmV0dXJuICEodHlwZW9mIHRoaXMuT2sgPT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWxpZCB2YXJpYW50IGlzICdpc0VycicuXG4gICAqL1xuICBpc0VycigpIHtcbiAgICByZXR1cm4gISh0eXBlb2YgdGhpcy5FcnIgPT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvZm9ybWF0dGVyLnRzXG52YXIgZ3VhcmQgPSB7XG4gIGlzQk46IChkYXRhLCB0eXBlLCBrZXkpID0+IHtcbiAgICBpZiAoIWlzQmlnSW50KGRhdGFba2V5XSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBEYXRhIGFuZCBmb3JtYXR0ZXIgbWlzbWF0Y2ggb24gJHtrZXl9OiR7dHlwZVtrZXldfSwgZXhwZWN0ZWQgcmVzcG9uc2UgZGF0YSAke2tleX06JHtkYXRhW2tleV19IHRvIGJlIEJOIGluc3RlYWQgaXQgaXMgJHt0eXBlb2YgZGF0YVtrZXldfWBcbiAgICAgICk7XG4gIH0sXG4gIHVua25vd246IChkYXRhLCB0eXBlLCBrZXkpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBmb3JtYXR0ZXIgdHlwZSBvbiAke2tleX06JHt0eXBlW2tleV19IGZvciBkYXRhICR7a2V5fToke2RhdGFba2V5XX1gKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZvcm1hdHRlcihkYXRhLCB0eXBlLCBzYW1lVHlwZSkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IGVsVHlwZSA9IHNhbWVUeXBlID8/IHR5cGVba2V5XTtcbiAgICBpZiAoIShrZXkgaW4gdHlwZSkgJiYgIXNhbWVUeXBlKSB7XG4gICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKGVsVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKSkge1xuICAgICAgICBjb25zdCBhcnJheVN0ciA9IGZvcm1hdHRlcihcbiAgICAgICAgICBkYXRhW2tleV0sXG4gICAgICAgICAgZGF0YVtrZXldLm1hcCgoXykgPT4gZWxUeXBlKVxuICAgICAgICApO1xuICAgICAgICBhY2Nba2V5XSA9IE9iamVjdC52YWx1ZXMoYXJyYXlTdHIpLmpvaW4oXCJcIik7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICBndWFyZC5pc0JOKGRhdGEsIHR5cGUsIGtleSk7XG4gICAgICBhY2Nba2V5XSA9IGRlY29kZVNob3J0U3RyaW5nKHZhbHVlKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGlmIChlbFR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGd1YXJkLmlzQk4oZGF0YSwgdHlwZSwga2V5KTtcbiAgICAgIGFjY1trZXldID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZWxUeXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGFjY1trZXldID0gZWxUeXBlKHZhbHVlKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGVsVHlwZSkpIHtcbiAgICAgIGNvbnN0IGFycmF5T2JqID0gZm9ybWF0dGVyKGRhdGFba2V5XSwgZWxUeXBlLCBlbFR5cGVbMF0pO1xuICAgICAgYWNjW2tleV0gPSBPYmplY3QudmFsdWVzKGFycmF5T2JqKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZWxUeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBhY2Nba2V5XSA9IGZvcm1hdHRlcihkYXRhW2tleV0sIGVsVHlwZSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBndWFyZC51bmtub3duKGRhdGEsIHR5cGUsIGtleSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcGFyc2VyL3BhcnNlci0wLTEuMS4wLnRzXG52YXIgQWJpUGFyc2VyMSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYWJpKSB7XG4gICAgdGhpcy5hYmkgPSBhYmk7XG4gIH1cbiAgLyoqXG4gICAqIGFiaSBtZXRob2QgaW5wdXRzIGxlbmd0aCB3aXRob3V0ICdfbGVuJyBpbnB1dHNcbiAgICogY2Fpcm8gMCByZWR1Y2VyXG4gICAqIEBwYXJhbSBhYmlNZXRob2QgRnVuY3Rpb25BYmlcbiAgICogQHJldHVybnMgbnVtYmVyXG4gICAqL1xuICBtZXRob2RJbnB1dHNMZW5ndGgoYWJpTWV0aG9kKSB7XG4gICAgcmV0dXJuIGFiaU1ldGhvZC5pbnB1dHMucmVkdWNlKChhY2MsIGlucHV0KSA9PiAhaXNMZW4oaW5wdXQubmFtZSkgPyBhY2MgKyAxIDogYWNjLCAwKTtcbiAgfVxuICAvKipcbiAgICogZ2V0IG1ldGhvZCBkZWZpbml0aW9uIGZyb20gYWJpXG4gICAqIEBwYXJhbSBuYW1lIHN0cmluZ1xuICAgKiBAcmV0dXJucyBGdW5jdGlvbkFiaSB8IHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0TWV0aG9kKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5hYmkuZmluZCgoaXQpID0+IGl0Lm5hbWUgPT09IG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgQWJpIGluIGxlZ2FjeSBmb3JtYXRcbiAgICogQHJldHVybnMgQWJpXG4gICAqL1xuICBnZXRMZWdhY3lGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWJpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcGFyc2VyL3BhcnNlci0yLjAuMC50c1xudmFyIEFiaVBhcnNlcjIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFiaSkge1xuICAgIHRoaXMuYWJpID0gYWJpO1xuICB9XG4gIC8qKlxuICAgKiBhYmkgbWV0aG9kIGlucHV0cyBsZW5ndGhcbiAgICogQHBhcmFtIGFiaU1ldGhvZCBGdW5jdGlvbkFiaVxuICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICovXG4gIG1ldGhvZElucHV0c0xlbmd0aChhYmlNZXRob2QpIHtcbiAgICByZXR1cm4gYWJpTWV0aG9kLmlucHV0cy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIGdldCBtZXRob2QgZGVmaW5pdGlvbiBmcm9tIGFiaVxuICAgKiBAcGFyYW0gbmFtZSBzdHJpbmdcbiAgICogQHJldHVybnMgRnVuY3Rpb25BYmkgfCB1bmRlZmluZWRcbiAgICovXG4gIGdldE1ldGhvZChuYW1lKSB7XG4gICAgY29uc3QgaW50ZiA9IHRoaXMuYWJpLmZpbmQoKGl0KSA9PiBpdC50eXBlID09PSBcImludGVyZmFjZVwiKTtcbiAgICByZXR1cm4gaW50Zi5pdGVtcy5maW5kKChpdCkgPT4gaXQubmFtZSA9PT0gbmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBBYmkgaW4gbGVnYWN5IGZvcm1hdFxuICAgKiBAcmV0dXJucyBBYmlcbiAgICovXG4gIGdldExlZ2FjeUZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5hYmkuZmxhdE1hcCgoZSkgPT4ge1xuICAgICAgaWYgKGUudHlwZSA9PT0gXCJpbnRlcmZhY2VcIikge1xuICAgICAgICByZXR1cm4gZS5pdGVtcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcGFyc2VyL2luZGV4LnRzXG5mdW5jdGlvbiBjcmVhdGVBYmlQYXJzZXIoYWJpKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBnZXRBYmlWZXJzaW9uKGFiaSk7XG4gIGlmICh2ZXJzaW9uID09PSAwIHx8IHZlcnNpb24gPT09IDEpIHtcbiAgICByZXR1cm4gbmV3IEFiaVBhcnNlcjEoYWJpKTtcbiAgfVxuICBpZiAodmVyc2lvbiA9PT0gMikge1xuICAgIHJldHVybiBuZXcgQWJpUGFyc2VyMihhYmkpO1xuICB9XG4gIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBBQkkgdmVyc2lvbiAke3ZlcnNpb259YCk7XG59XG5mdW5jdGlvbiBnZXRBYmlWZXJzaW9uKGFiaSkge1xuICBpZiAoYWJpLmZpbmQoKGl0KSA9PiBpdC50eXBlID09PSBcImludGVyZmFjZVwiKSlcbiAgICByZXR1cm4gMjtcbiAgaWYgKGlzQ2Fpcm8xQWJpKGFiaSkpXG4gICAgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaXNOb0NvbnN0cnVjdG9yVmFsaWQobWV0aG9kLCBhcmdzQ2FsbGRhdGEsIGFiaU1ldGhvZCkge1xuICByZXR1cm4gbWV0aG9kID09PSBcImNvbnN0cnVjdG9yXCIgJiYgIWFiaU1ldGhvZCAmJiAhYXJnc0NhbGxkYXRhLmxlbmd0aDtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3R1cGxlLnRzXG5mdW5jdGlvbiBwYXJzZU5hbWVkVHVwbGUobmFtZWRUdXBsZSkge1xuICBjb25zdCBuYW1lID0gbmFtZWRUdXBsZS5zdWJzdHJpbmcoMCwgbmFtZWRUdXBsZS5pbmRleE9mKFwiOlwiKSk7XG4gIGNvbnN0IHR5cGUgPSBuYW1lZFR1cGxlLnN1YnN0cmluZyhuYW1lLmxlbmd0aCArIFwiOlwiLmxlbmd0aCk7XG4gIHJldHVybiB7IG5hbWUsIHR5cGUgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3ViVHVwbGUocykge1xuICBpZiAoIXMuaW5jbHVkZXMoXCIoXCIpKVxuICAgIHJldHVybiB7IHN1YlR1cGxlOiBbXSwgcmVzdWx0OiBzIH07XG4gIGNvbnN0IHN1YlR1cGxlID0gW107XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgcy5sZW5ndGgpIHtcbiAgICBpZiAoc1tpXSA9PT0gXCIoXCIpIHtcbiAgICAgIGxldCBjb3VudGVyID0gMTtcbiAgICAgIGNvbnN0IGxCcmFja2V0ID0gaTtcbiAgICAgIGkrKztcbiAgICAgIHdoaWxlIChjb3VudGVyKSB7XG4gICAgICAgIGlmIChzW2ldID09PSBcIilcIilcbiAgICAgICAgICBjb3VudGVyLS07XG4gICAgICAgIGlmIChzW2ldID09PSBcIihcIilcbiAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIHN1YlR1cGxlLnB1c2gocy5zdWJzdHJpbmcobEJyYWNrZXQsIGkpKTtcbiAgICAgIHJlc3VsdCArPSBcIiBcIjtcbiAgICAgIGktLTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IHNbaV07XG4gICAgfVxuICAgIGkrKztcbiAgfVxuICByZXR1cm4ge1xuICAgIHN1YlR1cGxlLFxuICAgIHJlc3VsdFxuICB9O1xufVxuZnVuY3Rpb24gZXh0cmFjdENhaXJvMFR1cGxlKHR5cGUpIHtcbiAgY29uc3QgY2xlYW5UeXBlID0gdHlwZS5yZXBsYWNlKC9cXHMvZywgXCJcIikuc2xpY2UoMSwgLTEpO1xuICBjb25zdCB7IHN1YlR1cGxlLCByZXN1bHQgfSA9IHBhcnNlU3ViVHVwbGUoY2xlYW5UeXBlKTtcbiAgbGV0IHJlY29tcG9zZWQgPSByZXN1bHQuc3BsaXQoXCIsXCIpLm1hcCgoaXQpID0+IHtcbiAgICByZXR1cm4gc3ViVHVwbGUubGVuZ3RoID8gaXQucmVwbGFjZShcIiBcIiwgc3ViVHVwbGUuc2hpZnQoKSkgOiBpdDtcbiAgfSk7XG4gIGlmIChpc1R5cGVOYW1lZFR1cGxlKHR5cGUpKSB7XG4gICAgcmVjb21wb3NlZCA9IHJlY29tcG9zZWQucmVkdWNlKChhY2MsIGl0KSA9PiB7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZU5hbWVkVHVwbGUoaXQpKTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgcmV0dXJuIHJlY29tcG9zZWQ7XG59XG5mdW5jdGlvbiBleHRyYWN0Q2Fpcm8xVHVwbGUodHlwZSkge1xuICBjb25zdCBjbGVhblR5cGUgPSB0eXBlLnJlcGxhY2UoL1xccy9nLCBcIlwiKS5zbGljZSgxLCAtMSk7XG4gIGNvbnN0IHsgc3ViVHVwbGUsIHJlc3VsdCB9ID0gcGFyc2VTdWJUdXBsZShjbGVhblR5cGUpO1xuICBjb25zdCByZWNvbXBvc2VkID0gcmVzdWx0LnNwbGl0KFwiLFwiKS5tYXAoKGl0KSA9PiB7XG4gICAgcmV0dXJuIHN1YlR1cGxlLmxlbmd0aCA/IGl0LnJlcGxhY2UoXCIgXCIsIHN1YlR1cGxlLnNoaWZ0KCkpIDogaXQ7XG4gIH0pO1xuICByZXR1cm4gcmVjb21wb3NlZDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RUdXBsZU1lbWJlclR5cGVzKHR5cGUpIHtcbiAgaWYgKGlzQ2Fpcm8xVHlwZSh0eXBlKSkge1xuICAgIHJldHVybiBleHRyYWN0Q2Fpcm8xVHVwbGUodHlwZSk7XG4gIH1cbiAgcmV0dXJuIGV4dHJhY3RDYWlybzBUdXBsZSh0eXBlKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3Byb3BlcnR5T3JkZXIudHNcbmZ1bmN0aW9uIGVycm9yVTI1NihrZXkpIHtcbiAgcmV0dXJuIEVycm9yKFxuICAgIGBZb3VyIG9iamVjdCBpbmNsdWRlcyB0aGUgcHJvcGVydHkgOiAke2tleX0sIGNvbnRhaW5pbmcgYW4gVWludDI1NiBvYmplY3Qgd2l0aG91dCB0aGUgJ2xvdycgYW5kICdoaWdoJyBrZXlzLmBcbiAgKTtcbn1cbmZ1bmN0aW9uIG9yZGVyUHJvcHNCeUFiaSh1bm9yZGVyZWRPYmplY3QsIGFiaU9mT2JqZWN0LCBzdHJ1Y3RzLCBlbnVtcykge1xuICBjb25zdCBvcmRlcklucHV0ID0gKHVub3JkZXJlZEl0ZW0sIGFiaVR5cGUpID0+IHtcbiAgICBpZiAoaXNUeXBlQXJyYXkoYWJpVHlwZSkpIHtcbiAgICAgIHJldHVybiBvcmRlckFycmF5KHVub3JkZXJlZEl0ZW0sIGFiaVR5cGUpO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlRW51bShhYmlUeXBlLCBlbnVtcykpIHtcbiAgICAgIGNvbnN0IGFiaU9iaiA9IGVudW1zW2FiaVR5cGVdO1xuICAgICAgcmV0dXJuIG9yZGVyRW51bSh1bm9yZGVyZWRJdGVtLCBhYmlPYmopO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlVHVwbGUoYWJpVHlwZSkpIHtcbiAgICAgIHJldHVybiBvcmRlclR1cGxlKHVub3JkZXJlZEl0ZW0sIGFiaVR5cGUpO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlRXRoQWRkcmVzcyhhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIHVub3JkZXJlZEl0ZW07XG4gICAgfVxuICAgIGlmIChpc1R5cGVVaW50MjU2KGFiaVR5cGUpKSB7XG4gICAgICBjb25zdCB1MjU2ID0gdW5vcmRlcmVkSXRlbTtcbiAgICAgIGlmICh0eXBlb2YgdTI1NiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gdTI1NjtcbiAgICAgIH1cbiAgICAgIGlmICghKFwibG93XCIgaW4gdTI1NiAmJiBcImhpZ2hcIiBpbiB1MjU2KSkge1xuICAgICAgICB0aHJvdyBlcnJvclUyNTYoYWJpVHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBsb3c6IHUyNTYubG93LCBoaWdoOiB1MjU2LmhpZ2ggfTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZVN0cnVjdChhYmlUeXBlLCBzdHJ1Y3RzKSkge1xuICAgICAgY29uc3QgYWJpT2ZTdHJ1Y3QgPSBzdHJ1Y3RzW2FiaVR5cGVdLm1lbWJlcnM7XG4gICAgICByZXR1cm4gb3JkZXJTdHJ1Y3QodW5vcmRlcmVkSXRlbSwgYWJpT2ZTdHJ1Y3QpO1xuICAgIH1cbiAgICByZXR1cm4gdW5vcmRlcmVkSXRlbTtcbiAgfTtcbiAgY29uc3Qgb3JkZXJTdHJ1Y3QgPSAodW5vcmRlcmVkT2JqZWN0MiwgYWJpT2JqZWN0KSA9PiB7XG4gICAgY29uc3Qgb3JkZXJlZE9iamVjdDIgPSBhYmlPYmplY3QucmVkdWNlKChvcmRlcmVkT2JqZWN0LCBhYmlQYXJhbSkgPT4ge1xuICAgICAgY29uc3Qgc2V0UHJvcGVydHkgPSAodmFsdWUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcmRlcmVkT2JqZWN0LCBhYmlQYXJhbS5uYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSA/PyB1bm9yZGVyZWRPYmplY3QyW2FiaVBhcmFtLm5hbWVdXG4gICAgICB9KTtcbiAgICAgIGlmICh1bm9yZGVyZWRPYmplY3QyW2FiaVBhcmFtLm5hbWVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmIChpc0NhaXJvMVR5cGUoYWJpUGFyYW0udHlwZSkgfHwgIWlzTGVuKGFiaVBhcmFtLm5hbWUpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYFlvdXIgb2JqZWN0IG5lZWRzIGEgcHJvcGVydHkgd2l0aCBrZXkgOiAke2FiaVBhcmFtLm5hbWV9IC5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0UHJvcGVydHkob3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3QyW2FiaVBhcmFtLm5hbWVdLCBhYmlQYXJhbS50eXBlKSk7XG4gICAgICByZXR1cm4gb3JkZXJlZE9iamVjdDtcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIG9yZGVyZWRPYmplY3QyO1xuICB9O1xuICBmdW5jdGlvbiBvcmRlckFycmF5KG15QXJyYXksIGFiaVBhcmFtKSB7XG4gICAgY29uc3QgdHlwZUluQXJyYXkgPSBnZXRBcnJheVR5cGUoYWJpUGFyYW0pO1xuICAgIGlmICh0eXBlb2YgbXlBcnJheSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIG15QXJyYXk7XG4gICAgfVxuICAgIHJldHVybiBteUFycmF5Lm1hcCgobXlFbGVtKSA9PiBvcmRlcklucHV0KG15RWxlbSwgdHlwZUluQXJyYXkpKTtcbiAgfVxuICBmdW5jdGlvbiBvcmRlclR1cGxlKHVub3JkZXJlZE9iamVjdDIsIGFiaVBhcmFtKSB7XG4gICAgY29uc3QgdHlwZUxpc3QgPSBleHRyYWN0VHVwbGVNZW1iZXJUeXBlcyhhYmlQYXJhbSk7XG4gICAgY29uc3Qgb3JkZXJlZE9iamVjdDIgPSB0eXBlTGlzdC5yZWR1Y2UoKG9yZGVyZWRPYmplY3QsIGFiaVR5cGVDYWlyb1gsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBteU9iaktleXMgPSBPYmplY3Qua2V5cyh1bm9yZGVyZWRPYmplY3QyKTtcbiAgICAgIGNvbnN0IHNldFByb3BlcnR5ID0gKHZhbHVlKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkob3JkZXJlZE9iamVjdCwgaW5kZXgudG9TdHJpbmcoKSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdmFsdWUgPz8gdW5vcmRlcmVkT2JqZWN0MltteU9iaktleXNbaW5kZXhdXVxuICAgICAgfSk7XG4gICAgICBjb25zdCBhYmlUeXBlID0gYWJpVHlwZUNhaXJvWD8udHlwZSA/IGFiaVR5cGVDYWlyb1gudHlwZSA6IGFiaVR5cGVDYWlyb1g7XG4gICAgICBzZXRQcm9wZXJ0eShvcmRlcklucHV0KHVub3JkZXJlZE9iamVjdDJbbXlPYmpLZXlzW2luZGV4XV0sIGFiaVR5cGUpKTtcbiAgICAgIHJldHVybiBvcmRlcmVkT2JqZWN0O1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gb3JkZXJlZE9iamVjdDI7XG4gIH1cbiAgY29uc3Qgb3JkZXJFbnVtID0gKHVub3JkZXJlZE9iamVjdDIsIGFiaU9iamVjdCkgPT4ge1xuICAgIGlmIChpc1R5cGVSZXN1bHQoYWJpT2JqZWN0Lm5hbWUpKSB7XG4gICAgICBjb25zdCB1bm9yZGVyZWRSZXN1bHQgPSB1bm9yZGVyZWRPYmplY3QyO1xuICAgICAgY29uc3QgcmVzdWx0T2tUeXBlID0gYWJpT2JqZWN0Lm5hbWUuc3Vic3RyaW5nKFxuICAgICAgICBhYmlPYmplY3QubmFtZS5pbmRleE9mKFwiPFwiKSArIDEsXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmxhc3RJbmRleE9mKFwiLFwiKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3VsdEVyclR5cGUgPSBhYmlPYmplY3QubmFtZS5zdWJzdHJpbmcoXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmluZGV4T2YoXCIsXCIpICsgMSxcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUubGFzdEluZGV4T2YoXCI+XCIpXG4gICAgICApO1xuICAgICAgaWYgKHVub3JkZXJlZFJlc3VsdC5pc09rKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWlyb1Jlc3VsdChcbiAgICAgICAgICAwIC8qIE9rICovLFxuICAgICAgICAgIG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0Mi51bndyYXAoKSwgcmVzdWx0T2tUeXBlKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDYWlyb1Jlc3VsdChcbiAgICAgICAgMSAvKiBFcnIgKi8sXG4gICAgICAgIG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0Mi51bndyYXAoKSwgcmVzdWx0RXJyVHlwZSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVPcHRpb24oYWJpT2JqZWN0Lm5hbWUpKSB7XG4gICAgICBjb25zdCB1bm9yZGVyZWRPcHRpb24gPSB1bm9yZGVyZWRPYmplY3QyO1xuICAgICAgY29uc3QgcmVzdWx0U29tZVR5cGUgPSBhYmlPYmplY3QubmFtZS5zdWJzdHJpbmcoXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmluZGV4T2YoXCI8XCIpICsgMSxcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUubGFzdEluZGV4T2YoXCI+XCIpXG4gICAgICApO1xuICAgICAgaWYgKHVub3JkZXJlZE9wdGlvbi5pc1NvbWUoKSkge1xuICAgICAgICByZXR1cm4gbmV3IENhaXJvT3B0aW9uKFxuICAgICAgICAgIDAgLyogU29tZSAqLyxcbiAgICAgICAgICBvcmRlcklucHV0KHVub3JkZXJlZE9wdGlvbi51bndyYXAoKSwgcmVzdWx0U29tZVR5cGUpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENhaXJvT3B0aW9uKDEgLyogTm9uZSAqLywge30pO1xuICAgIH1cbiAgICBjb25zdCB1bm9yZGVyZWRDdXN0b21FbnVtID0gdW5vcmRlcmVkT2JqZWN0MjtcbiAgICBjb25zdCB2YXJpYW50cyA9IE9iamVjdC5lbnRyaWVzKHVub3JkZXJlZEN1c3RvbUVudW0udmFyaWFudCk7XG4gICAgY29uc3QgbmV3RW50cmllcyA9IHZhcmlhbnRzLm1hcCgodmFyaWFudCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2YXJpYW50WzFdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiB2YXJpYW50O1xuICAgICAgfVxuICAgICAgY29uc3QgdmFyaWFudFR5cGUgPSBhYmlPYmplY3QudHlwZS5zdWJzdHJpbmcoXG4gICAgICAgIGFiaU9iamVjdC50eXBlLmxhc3RJbmRleE9mKFwiPFwiKSArIDEsXG4gICAgICAgIGFiaU9iamVjdC50eXBlLmxhc3RJbmRleE9mKFwiPlwiKVxuICAgICAgKTtcbiAgICAgIGlmICh2YXJpYW50VHlwZSA9PT0gXCIoKVwiKSB7XG4gICAgICAgIHJldHVybiB2YXJpYW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt2YXJpYW50WzBdLCBvcmRlcklucHV0KHVub3JkZXJlZEN1c3RvbUVudW0udW53cmFwKCksIHZhcmlhbnRUeXBlKV07XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBDYWlyb0N1c3RvbUVudW0oT2JqZWN0LmZyb21FbnRyaWVzKG5ld0VudHJpZXMpKTtcbiAgfTtcbiAgY29uc3QgZmluYWxPcmRlcmVkT2JqZWN0ID0gYWJpT2ZPYmplY3QucmVkdWNlKChvcmRlcmVkT2JqZWN0LCBhYmlQYXJhbSkgPT4ge1xuICAgIGNvbnN0IHNldFByb3BlcnR5ID0gKHZhbHVlKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkob3JkZXJlZE9iamVjdCwgYWJpUGFyYW0ubmFtZSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgaWYgKGlzTGVuKGFiaVBhcmFtLm5hbWUpICYmICFpc0NhaXJvMVR5cGUoYWJpUGFyYW0udHlwZSkpIHtcbiAgICAgIHJldHVybiBvcmRlcmVkT2JqZWN0O1xuICAgIH1cbiAgICBzZXRQcm9wZXJ0eShvcmRlcklucHV0KHVub3JkZXJlZE9iamVjdFthYmlQYXJhbS5uYW1lXSwgYWJpUGFyYW0udHlwZSkpO1xuICAgIHJldHVybiBvcmRlcmVkT2JqZWN0O1xuICB9LCB7fSk7XG4gIHJldHVybiBmaW5hbE9yZGVyZWRPYmplY3Q7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9yZXF1ZXN0UGFyc2VyLnRzXG5mdW5jdGlvbiBwYXJzZUJhc2VUeXBlcyh0eXBlLCB2YWwpIHtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc1R5cGVVaW50MjU2KHR5cGUpOlxuICAgICAgY29uc3QgZWxfdWludDI1NiA9IHVpbnQyNTYodmFsKTtcbiAgICAgIHJldHVybiBbZmVsdChlbF91aW50MjU2LmxvdyksIGZlbHQoZWxfdWludDI1Ni5oaWdoKV07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmZWx0KHZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlVHVwbGUoZWxlbWVudCwgdHlwZVN0cikge1xuICBjb25zdCBtZW1iZXJUeXBlcyA9IGV4dHJhY3RUdXBsZU1lbWJlclR5cGVzKHR5cGVTdHIpO1xuICBjb25zdCBlbGVtZW50cyA9IE9iamVjdC52YWx1ZXMoZWxlbWVudCk7XG4gIGlmIChlbGVtZW50cy5sZW5ndGggIT09IG1lbWJlclR5cGVzLmxlbmd0aCkge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgYFBhcnNlVHVwbGU6IHByb3ZpZGVkIGFuZCBleHBlY3RlZCBhYmkgdHVwbGUgc2l6ZSBkbyBub3QgbWF0Y2guXG4gICAgICBwcm92aWRlZDogJHtlbGVtZW50c30gXG4gICAgICBleHBlY3RlZDogJHttZW1iZXJUeXBlc31gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbWVtYmVyVHlwZXMubWFwKChpdCwgZHgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudDogZWxlbWVudHNbZHhdLFxuICAgICAgdHlwZTogaXQudHlwZSA/PyBpdFxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VVaW50MjU2KGVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc3QgeyBsb3csIGhpZ2ggfSA9IGVsZW1lbnQ7XG4gICAgcmV0dXJuIFtmZWx0KGxvdyksIGZlbHQoaGlnaCldO1xuICB9XG4gIGNvbnN0IGVsX3VpbnQyNTYgPSB1aW50MjU2KGVsZW1lbnQpO1xuICByZXR1cm4gW2ZlbHQoZWxfdWludDI1Ni5sb3cpLCBmZWx0KGVsX3VpbnQyNTYuaGlnaCldO1xufVxuZnVuY3Rpb24gcGFyc2VDYWxsZGF0YVZhbHVlKGVsZW1lbnQsIHR5cGUsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGlmIChlbGVtZW50ID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBFcnJvcihgTWlzc2luZyBwYXJhbWV0ZXIgZm9yIHR5cGUgJHt0eXBlfWApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0LnB1c2goZmVsdChlbGVtZW50Lmxlbmd0aCkpO1xuICAgIGNvbnN0IGFycmF5VHlwZSA9IGdldEFycmF5VHlwZSh0eXBlKTtcbiAgICByZXR1cm4gZWxlbWVudC5yZWR1Y2UoKGFjYywgaXQpID0+IHtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KHBhcnNlQ2FsbGRhdGFWYWx1ZShpdCwgYXJyYXlUeXBlLCBzdHJ1Y3RzLCBlbnVtcykpO1xuICAgIH0sIHJlc3VsdCk7XG4gIH1cbiAgaWYgKHN0cnVjdHNbdHlwZV0gJiYgc3RydWN0c1t0eXBlXS5tZW1iZXJzLmxlbmd0aCkge1xuICAgIGlmIChpc1R5cGVVaW50MjU2KHR5cGUpKSB7XG4gICAgICByZXR1cm4gcGFyc2VVaW50MjU2KGVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIilcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlcyh0eXBlLCBlbGVtZW50KTtcbiAgICBjb25zdCB7IG1lbWJlcnMgfSA9IHN0cnVjdHNbdHlwZV07XG4gICAgY29uc3Qgc3ViRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgcmV0dXJuIG1lbWJlcnMucmVkdWNlKChhY2MsIGl0KSA9PiB7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZUNhbGxkYXRhVmFsdWUoc3ViRWxlbWVudFtpdC5uYW1lXSwgaXQudHlwZSwgc3RydWN0cywgZW51bXMpKTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgaWYgKGlzVHlwZVR1cGxlKHR5cGUpKSB7XG4gICAgY29uc3QgdHVwbGVkID0gcGFyc2VUdXBsZShlbGVtZW50LCB0eXBlKTtcbiAgICByZXR1cm4gdHVwbGVkLnJlZHVjZSgoYWNjLCBpdCkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShpdC5lbGVtZW50LCBpdC50eXBlLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZWREYXRhKTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgaWYgKGlzVHlwZVVpbnQyNTYodHlwZSkpIHtcbiAgICByZXR1cm4gcGFyc2VVaW50MjU2KGVsZW1lbnQpO1xuICB9XG4gIGlmIChpc1R5cGVFbnVtKHR5cGUsIGVudW1zKSkge1xuICAgIGNvbnN0IHsgdmFyaWFudHMgfSA9IGVudW1zW3R5cGVdO1xuICAgIGlmIChpc1R5cGVPcHRpb24odHlwZSkpIHtcbiAgICAgIGNvbnN0IG15T3B0aW9uID0gZWxlbWVudDtcbiAgICAgIGlmIChteU9wdGlvbi5pc1NvbWUoKSkge1xuICAgICAgICBjb25zdCBsaXN0VHlwZVZhcmlhbnQyID0gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBcIlNvbWVcIik7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdFR5cGVWYXJpYW50MiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFcnJvciBpbiBhYmkgOiBPcHRpb24gaGFzIG5vICdTb21lJyB2YXJpYW50LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGVWYXJpYW50U29tZSA9IGxpc3RUeXBlVmFyaWFudDIudHlwZTtcbiAgICAgICAgaWYgKHR5cGVWYXJpYW50U29tZSA9PT0gXCIoKVwiKSB7XG4gICAgICAgICAgcmV0dXJuIDAgLyogU29tZSAqLy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFBhcmFtZXRlcjIgPSBwYXJzZUNhbGxkYXRhVmFsdWUoXG4gICAgICAgICAgbXlPcHRpb24udW53cmFwKCksXG4gICAgICAgICAgdHlwZVZhcmlhbnRTb21lLFxuICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgZW51bXNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGFyYW1ldGVyMikpIHtcbiAgICAgICAgICByZXR1cm4gWzAgLyogU29tZSAqLy50b1N0cmluZygpLCAuLi5wYXJzZWRQYXJhbWV0ZXIyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWzAgLyogU29tZSAqLy50b1N0cmluZygpLCBwYXJzZWRQYXJhbWV0ZXIyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxIC8qIE5vbmUgKi8udG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZVJlc3VsdCh0eXBlKSkge1xuICAgICAgY29uc3QgbXlSZXN1bHQgPSBlbGVtZW50O1xuICAgICAgaWYgKG15UmVzdWx0LmlzT2soKSkge1xuICAgICAgICBjb25zdCBsaXN0VHlwZVZhcmlhbnQzID0gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBcIk9rXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RUeXBlVmFyaWFudDMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXJyb3IgaW4gYWJpIDogUmVzdWx0IGhhcyBubyAnT2snIHZhcmlhbnQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZVZhcmlhbnRPayA9IGxpc3RUeXBlVmFyaWFudDMudHlwZTtcbiAgICAgICAgaWYgKHR5cGVWYXJpYW50T2sgPT09IFwiKClcIikge1xuICAgICAgICAgIHJldHVybiAwIC8qIE9rICovLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkUGFyYW1ldGVyMyA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShcbiAgICAgICAgICBteVJlc3VsdC51bndyYXAoKSxcbiAgICAgICAgICB0eXBlVmFyaWFudE9rLFxuICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgZW51bXNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGFyYW1ldGVyMykpIHtcbiAgICAgICAgICByZXR1cm4gWzAgLyogT2sgKi8udG9TdHJpbmcoKSwgLi4ucGFyc2VkUGFyYW1ldGVyM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFswIC8qIE9rICovLnRvU3RyaW5nKCksIHBhcnNlZFBhcmFtZXRlcjNdO1xuICAgICAgfVxuICAgICAgY29uc3QgbGlzdFR5cGVWYXJpYW50MiA9IHZhcmlhbnRzLmZpbmQoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gXCJFcnJcIik7XG4gICAgICBpZiAodHlwZW9mIGxpc3RUeXBlVmFyaWFudDIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEVycm9yIGluIGFiaSA6IFJlc3VsdCBoYXMgbm8gJ0VycicgdmFyaWFudC5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGVWYXJpYW50RXJyID0gbGlzdFR5cGVWYXJpYW50Mi50eXBlO1xuICAgICAgaWYgKHR5cGVWYXJpYW50RXJyID09PSBcIigpXCIpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogRXJyICovLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZWRQYXJhbWV0ZXIyID0gcGFyc2VDYWxsZGF0YVZhbHVlKG15UmVzdWx0LnVud3JhcCgpLCB0eXBlVmFyaWFudEVyciwgc3RydWN0cywgZW51bXMpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGFyYW1ldGVyMikpIHtcbiAgICAgICAgcmV0dXJuIFsxIC8qIEVyciAqLy50b1N0cmluZygpLCAuLi5wYXJzZWRQYXJhbWV0ZXIyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbMSAvKiBFcnIgKi8udG9TdHJpbmcoKSwgcGFyc2VkUGFyYW1ldGVyMl07XG4gICAgfVxuICAgIGNvbnN0IG15RW51bSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgYWN0aXZlVmFyaWFudCA9IG15RW51bS5hY3RpdmVWYXJpYW50KCk7XG4gICAgY29uc3QgbGlzdFR5cGVWYXJpYW50ID0gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBhY3RpdmVWYXJpYW50KTtcbiAgICBpZiAodHlwZW9mIGxpc3RUeXBlVmFyaWFudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgRXJyb3IoYE5vdCBmaW5kIGluIGFiaSA6IEVudW0gaGFzIG5vICcke2FjdGl2ZVZhcmlhbnR9JyB2YXJpYW50LmApO1xuICAgIH1cbiAgICBjb25zdCB0eXBlQWN0aXZlVmFyaWFudCA9IGxpc3RUeXBlVmFyaWFudC50eXBlO1xuICAgIGNvbnN0IG51bUFjdGl2ZVZhcmlhbnQgPSB2YXJpYW50cy5maW5kSW5kZXgoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gYWN0aXZlVmFyaWFudCk7XG4gICAgaWYgKHR5cGVBY3RpdmVWYXJpYW50ID09PSBcIigpXCIpIHtcbiAgICAgIHJldHVybiBudW1BY3RpdmVWYXJpYW50LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFBhcmFtZXRlciA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShteUVudW0udW53cmFwKCksIHR5cGVBY3RpdmVWYXJpYW50LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGFyYW1ldGVyKSkge1xuICAgICAgcmV0dXJuIFtudW1BY3RpdmVWYXJpYW50LnRvU3RyaW5nKCksIC4uLnBhcnNlZFBhcmFtZXRlcl07XG4gICAgfVxuICAgIHJldHVybiBbbnVtQWN0aXZlVmFyaWFudC50b1N0cmluZygpLCBwYXJzZWRQYXJhbWV0ZXJdO1xuICB9XG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IEVycm9yKGBQYXJhbWV0ZXIgJHtlbGVtZW50fSBkbyBub3QgYWxpZ24gd2l0aCBhYmkgcGFyYW1ldGVyICR7dHlwZX1gKTtcbiAgfVxuICByZXR1cm4gcGFyc2VCYXNlVHlwZXModHlwZSwgZWxlbWVudCk7XG59XG5mdW5jdGlvbiBwYXJzZUNhbGxkYXRhRmllbGQoYXJnc0l0ZXJhdG9yLCBpbnB1dCwgc3RydWN0cywgZW51bXMpIHtcbiAgY29uc3QgeyBuYW1lLCB0eXBlIH0gPSBpbnB1dDtcbiAgbGV0IHsgdmFsdWUgfSA9IGFyZ3NJdGVyYXRvci5uZXh0KCk7XG4gIHN3aXRjaCAodHJ1ZSkge1xuICAgIGNhc2UgaXNUeXBlQXJyYXkodHlwZSk6XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpICYmICFpc1RleHQodmFsdWUpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBBQkkgZXhwZWN0ZWQgcGFyYW1ldGVyICR7bmFtZX0gdG8gYmUgYXJyYXkgb3IgbG9uZyBzdHJpbmcsIGdvdCAke3ZhbHVlfWApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IHNwbGl0TG9uZ1N0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VDYWxsZGF0YVZhbHVlKHZhbHVlLCBpbnB1dC50eXBlLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgY2FzZSB0eXBlID09PSBcImNvcmU6OnN0YXJrbmV0OjpldGhfYWRkcmVzczo6RXRoQWRkcmVzc1wiOlxuICAgICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzKHR5cGUsIHZhbHVlKTtcbiAgICBjYXNlIChpc1R5cGVTdHJ1Y3QodHlwZSwgc3RydWN0cykgfHwgaXNUeXBlVHVwbGUodHlwZSkgfHwgaXNUeXBlVWludDI1Nih0eXBlKSk6XG4gICAgICByZXR1cm4gcGFyc2VDYWxsZGF0YVZhbHVlKHZhbHVlLCB0eXBlLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgY2FzZSBpc1R5cGVFbnVtKHR5cGUsIGVudW1zKTpcbiAgICAgIHJldHVybiBwYXJzZUNhbGxkYXRhVmFsdWUoXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlLFxuICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICBlbnVtc1xuICAgICAgKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzKHR5cGUsIHZhbHVlKTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcmVzcG9uc2VQYXJzZXIudHNcbmZ1bmN0aW9uIHBhcnNlQmFzZVR5cGVzMih0eXBlLCBpdCkge1xuICBsZXQgdGVtcDtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc1R5cGVCb29sKHR5cGUpOlxuICAgICAgdGVtcCA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBCb29sZWFuKEJpZ0ludCh0ZW1wKSk7XG4gICAgY2FzZSBpc1R5cGVVaW50MjU2KHR5cGUpOlxuICAgICAgY29uc3QgbG93ID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgY29uc3QgaGlnaCA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiB1aW50MjU2VG9CTih7IGxvdywgaGlnaCB9KTtcbiAgICBjYXNlIHR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCI6XG4gICAgICB0ZW1wID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIEJpZ0ludCh0ZW1wKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGVtcCA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBCaWdJbnQodGVtcCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbGVtZW50LCBzdHJ1Y3RzLCBlbnVtcykge1xuICBpZiAoZWxlbWVudC50eXBlID09PSBcIigpXCIpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgaWYgKGlzVHlwZVVpbnQyNTYoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IGxvdyA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIGNvbnN0IGhpZ2ggPSByZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICByZXR1cm4gdWludDI1NlRvQk4oeyBsb3csIGhpZ2ggfSk7XG4gIH1cbiAgaWYgKGlzVHlwZUFycmF5KGVsZW1lbnQudHlwZSkpIHtcbiAgICBjb25zdCBwYXJzZWREYXRhQXJyID0gW107XG4gICAgY29uc3QgZWwgPSB7IG5hbWU6IFwiXCIsIHR5cGU6IGdldEFycmF5VHlwZShlbGVtZW50LnR5cGUpIH07XG4gICAgY29uc3QgbGVuID0gQmlnSW50KHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICB3aGlsZSAocGFyc2VkRGF0YUFyci5sZW5ndGggPCBsZW4pIHtcbiAgICAgIHBhcnNlZERhdGFBcnIucHVzaChwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgZWwsIHN0cnVjdHMsIGVudW1zKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWREYXRhQXJyO1xuICB9XG4gIGlmIChzdHJ1Y3RzICYmIGVsZW1lbnQudHlwZSBpbiBzdHJ1Y3RzICYmIHN0cnVjdHNbZWxlbWVudC50eXBlXSkge1xuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCIpIHtcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlczIoZWxlbWVudC50eXBlLCByZXNwb25zZUl0ZXJhdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cnVjdHNbZWxlbWVudC50eXBlXS5tZW1iZXJzLnJlZHVjZSgoYWNjLCBlbCkgPT4ge1xuICAgICAgYWNjW2VsLm5hbWVdID0gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuICBpZiAoZW51bXMgJiYgZWxlbWVudC50eXBlIGluIGVudW1zICYmIGVudW1zW2VsZW1lbnQudHlwZV0pIHtcbiAgICBjb25zdCB2YXJpYW50TnVtID0gTnVtYmVyKHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICBjb25zdCByYXdFbnVtID0gZW51bXNbZWxlbWVudC50eXBlXS52YXJpYW50cy5yZWR1Y2UoKGFjYywgdmFyaWFudCwgbnVtKSA9PiB7XG4gICAgICBpZiAobnVtID09PSB2YXJpYW50TnVtKSB7XG4gICAgICAgIGFjY1t2YXJpYW50Lm5hbWVdID0gcGFyc2VSZXNwb25zZVZhbHVlKFxuICAgICAgICAgIHJlc3BvbnNlSXRlcmF0b3IsXG4gICAgICAgICAgeyBuYW1lOiBcIlwiLCB0eXBlOiB2YXJpYW50LnR5cGUgfSxcbiAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgIGVudW1zXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICBhY2NbdmFyaWFudC5uYW1lXSA9IHZvaWQgMDtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIGlmIChlbGVtZW50LnR5cGUuc3RhcnRzV2l0aChcImNvcmU6Om9wdGlvbjo6T3B0aW9uXCIpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdmFyaWFudE51bSA9PT0gMCAvKiBTb21lICovID8gcmF3RW51bS5Tb21lIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIG5ldyBDYWlyb09wdGlvbih2YXJpYW50TnVtLCBjb250ZW50KTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQudHlwZS5zdGFydHNXaXRoKFwiY29yZTo6cmVzdWx0OjpSZXN1bHRcIikpIHtcbiAgICAgIGxldCBjb250ZW50O1xuICAgICAgaWYgKHZhcmlhbnROdW0gPT09IDAgLyogT2sgKi8pIHtcbiAgICAgICAgY29udGVudCA9IHJhd0VudW0uT2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50ID0gcmF3RW51bS5FcnI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENhaXJvUmVzdWx0KHZhcmlhbnROdW0sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBjb25zdCBjdXN0b21FbnVtID0gbmV3IENhaXJvQ3VzdG9tRW51bShyYXdFbnVtKTtcbiAgICByZXR1cm4gY3VzdG9tRW51bTtcbiAgfVxuICBpZiAoaXNUeXBlVHVwbGUoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IG1lbWJlclR5cGVzID0gZXh0cmFjdFR1cGxlTWVtYmVyVHlwZXMoZWxlbWVudC50eXBlKTtcbiAgICByZXR1cm4gbWVtYmVyVHlwZXMucmVkdWNlKChhY2MsIGl0LCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBpdD8ubmFtZSA/IGl0Lm5hbWUgOiBpZHg7XG4gICAgICBjb25zdCB0eXBlID0gaXQ/LnR5cGUgPyBpdC50eXBlIDogaXQ7XG4gICAgICBjb25zdCBlbCA9IHsgbmFtZSwgdHlwZSB9O1xuICAgICAgYWNjW25hbWVdID0gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuICBpZiAoaXNUeXBlQXJyYXkoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IHBhcnNlZERhdGFBcnIgPSBbXTtcbiAgICBjb25zdCBlbCA9IHsgbmFtZTogXCJcIiwgdHlwZTogZ2V0QXJyYXlUeXBlKGVsZW1lbnQudHlwZSkgfTtcbiAgICBjb25zdCBsZW4gPSBCaWdJbnQocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIHdoaWxlIChwYXJzZWREYXRhQXJyLmxlbmd0aCA8IGxlbikge1xuICAgICAgcGFyc2VkRGF0YUFyci5wdXNoKHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbCwgc3RydWN0cywgZW51bXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZERhdGFBcnI7XG4gIH1cbiAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzMihlbGVtZW50LnR5cGUsIHJlc3BvbnNlSXRlcmF0b3IpO1xufVxuZnVuY3Rpb24gcmVzcG9uc2VQYXJzZXIocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcywgcGFyc2VkUmVzdWx0KSB7XG4gIGNvbnN0IHsgbmFtZSwgdHlwZSB9ID0gb3V0cHV0O1xuICBsZXQgdGVtcDtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc0xlbihuYW1lKTpcbiAgICAgIHRlbXAgPSByZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBCaWdJbnQodGVtcCk7XG4gICAgY2FzZSAoc3RydWN0cyAmJiB0eXBlIGluIHN0cnVjdHMgfHwgaXNUeXBlVHVwbGUodHlwZSkpOlxuICAgICAgcmV0dXJuIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIChlbnVtcyAmJiBpc1R5cGVFbnVtKHR5cGUsIGVudW1zKSk6XG4gICAgICByZXR1cm4gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIG91dHB1dCwgc3RydWN0cywgZW51bXMpO1xuICAgIGNhc2UgaXNUeXBlQXJyYXkodHlwZSk6XG4gICAgICBpZiAoaXNDYWlybzFUeXBlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZWREYXRhQXJyID0gW107XG4gICAgICBpZiAocGFyc2VkUmVzdWx0ICYmIHBhcnNlZFJlc3VsdFtgJHtuYW1lfV9sZW5gXSkge1xuICAgICAgICBjb25zdCBhcnJMZW4gPSBwYXJzZWRSZXN1bHRbYCR7bmFtZX1fbGVuYF07XG4gICAgICAgIHdoaWxlIChwYXJzZWREYXRhQXJyLmxlbmd0aCA8IGFyckxlbikge1xuICAgICAgICAgIHBhcnNlZERhdGFBcnIucHVzaChcbiAgICAgICAgICAgIHBhcnNlUmVzcG9uc2VWYWx1ZShcbiAgICAgICAgICAgICAgcmVzcG9uc2VJdGVyYXRvcixcbiAgICAgICAgICAgICAgeyBuYW1lLCB0eXBlOiBvdXRwdXQudHlwZS5yZXBsYWNlKFwiKlwiLCBcIlwiKSB9LFxuICAgICAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgICAgICBlbnVtc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWREYXRhQXJyO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXMyKHR5cGUsIHJlc3BvbnNlSXRlcmF0b3IpO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS92YWxpZGF0ZS50c1xudmFyIHZhbGlkYXRlRmVsdCA9IChwYXJhbWV0ZXIsIGlucHV0KSA9PiB7XG4gIGFzc2VydChcbiAgICB0eXBlb2YgcGFyYW1ldGVyID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJiaWdpbnRcIixcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IHNob3VsZCBiZSBhIGZlbHQgdHlwZWQgYXMgKFN0cmluZywgTnVtYmVyIG9yIEJpZ0ludClgXG4gICk7XG4gIGlmICh0eXBlb2YgcGFyYW1ldGVyID09PSBcInN0cmluZ1wiICYmICFpc0hleChwYXJhbWV0ZXIpKVxuICAgIHJldHVybjtcbiAgY29uc3QgcGFyYW0gPSBCaWdJbnQocGFyYW1ldGVyLnRvU3RyaW5nKDEwKSk7XG4gIGFzc2VydChcbiAgICAvLyBmcm9tIDogaHR0cHM6Ly9naXRodWIuY29tL3N0YXJrd2FyZS1saWJzL3N0YXJrbmV0LXNwZWNzL2Jsb2IvMjliYWI2NTBiZTZiMTg0N2M5MmQ0NDYxZDRjMzMwMDhiNWU1MGIxYS9hcGkvc3RhcmtuZXRfYXBpX29wZW5ycGMuanNvbiNMMTI2NlxuICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDI1Mm4gLSAxbixcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjI1Mi0xXWBcbiAgKTtcbn07XG52YXIgdmFsaWRhdGVVaW50ID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgaWYgKHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwibnVtYmVyXCIpIHtcbiAgICBhc3NlcnQoXG4gICAgICBwYXJhbWV0ZXIgPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICBgVmFsaWRhdGlvbjogUGFyYW1ldGVyIGlzIHRvIGxhcmdlIHRvIGJlIHR5cGVkIGFzIE51bWJlciB1c2UgKEJpZ0ludCBvciBTdHJpbmcpYFxuICAgICk7XG4gIH1cbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgcGFyYW1ldGVyID09PSBcImJpZ2ludFwiIHx8IHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgJiYgXCJsb3dcIiBpbiBwYXJhbWV0ZXIgJiYgXCJoaWdoXCIgaW4gcGFyYW1ldGVyLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gb2YgY2Fpcm8gdHlwZSAke2lucHV0LnR5cGV9IHNob3VsZCBiZSB0eXBlIChTdHJpbmcsIE51bWJlciBvciBCaWdJbnQpLCBidXQgaXMgJHt0eXBlb2YgcGFyYW1ldGVyfSAke3BhcmFtZXRlcn0uYFxuICApO1xuICBjb25zdCBwYXJhbSA9IHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgPyB1aW50MjU2VG9CTihwYXJhbWV0ZXIpIDogdG9CaWdJbnQocGFyYW1ldGVyKTtcbiAgc3dpdGNoIChpbnB1dC50eXBlKSB7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnU4XCIgLyogdTggKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDI1NW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAgLSAyNTVdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1MTZcIiAvKiB1MTYgKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDY1NTM1bixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgNjU1MzVdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1MzJcIiAvKiB1MzIgKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDQyOTQ5NjcyOTVuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCA0Mjk0OTY3Mjk1XWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTY0XCIgLyogdTY0ICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiA2NG4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl42NC0xXWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTEyOFwiIC8qIHUxMjggKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDEyOG4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4xMjgtMV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnUyNTZcIiAvKiB1MjU2ICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAyNTZuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gaXMgJHtpbnB1dC50eXBlfSAwIC0gMl4yNTYtMWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6c3RhcmtuZXQ6OmNsYXNzX2hhc2g6OkNsYXNzSGFzaFwiIC8qIENsYXNzSGFzaCAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgLy8gZnJvbSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zdGFya3dhcmUtbGlicy9zdGFya25ldC1zcGVjcy9ibG9iLzI5YmFiNjUwYmU2YjE4NDdjOTJkNDQ2MWQ0YzMzMDA4YjVlNTBiMWEvYXBpL3N0YXJrbmV0X2FwaV9vcGVucnBjLmpzb24jTDE2NzBcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMjUybiAtIDFuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjI1Mi0xXWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6c3RhcmtuZXQ6OmNvbnRyYWN0X2FkZHJlc3M6OkNvbnRyYWN0QWRkcmVzc1wiIC8qIENvbnRyYWN0QWRkcmVzcyAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgLy8gZnJvbSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zdGFya3dhcmUtbGlicy9zdGFya25ldC1zcGVjcy9ibG9iLzI5YmFiNjUwYmU2YjE4NDdjOTJkNDQ2MWQ0YzMzMDA4YjVlNTBiMWEvYXBpL3N0YXJrbmV0X2FwaV9vcGVucnBjLmpzb24jTDEyNDVcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMjUybiAtIDFuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjI1Mi0xXWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVCb29sID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwiYm9vbGVhblwiLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gb2YgY2Fpcm8gdHlwZSAke2lucHV0LnR5cGV9IHNob3VsZCBiZSB0eXBlIChCb29sZWFuKWBcbiAgKTtcbn07XG52YXIgdmFsaWRhdGVTdHJ1Y3QgPSAocGFyYW1ldGVyLCBpbnB1dCwgc3RydWN0cykgPT4ge1xuICBpZiAoaW5wdXQudHlwZSA9PT0gXCJjb3JlOjppbnRlZ2VyOjp1MjU2XCIgLyogdTI1NiAqLykge1xuICAgIHZhbGlkYXRlVWludChwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlucHV0LnR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCIpIHtcbiAgICBhc3NlcnQoXG4gICAgICB0eXBlb2YgcGFyYW1ldGVyICE9PSBcIm9iamVjdFwiLFxuICAgICAgYEV0aEFkcmVzcyB0eXBlIGlzIHdhaXRpbmcgYSBCaWdOdW1iZXJpc2guIEdvdCAke3BhcmFtZXRlcn1gXG4gICAgKTtcbiAgICBjb25zdCBwYXJhbSA9IEJpZ0ludChwYXJhbWV0ZXIudG9TdHJpbmcoMTApKTtcbiAgICBhc3NlcnQoXG4gICAgICAvLyBmcm9tIDogaHR0cHM6Ly9naXRodWIuY29tL3N0YXJrd2FyZS1saWJzL3N0YXJrbmV0LXNwZWNzL2Jsb2IvMjliYWI2NTBiZTZiMTg0N2M5MmQ0NDYxZDRjMzMwMDhiNWU1MGIxYS9hcGkvc3RhcmtuZXRfYXBpX29wZW5ycGMuanNvbiNMMTI1OVxuICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMTYwbiAtIDFuLFxuICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4xNjAtMV1gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGlzIGNhaXJvIHR5cGUgc3RydWN0ICgke2lucHV0LnR5cGV9KSwgYW5kIHNob3VsZCBiZSBkZWZpbmVkIGFzIGpzIG9iamVjdCAobm90IGFycmF5KWBcbiAgKTtcbiAgc3RydWN0c1tpbnB1dC50eXBlXS5tZW1iZXJzLmZvckVhY2goKHsgbmFtZSB9KSA9PiB7XG4gICAgYXNzZXJ0KFxuICAgICAgT2JqZWN0LmtleXMocGFyYW1ldGVyKS5pbmNsdWRlcyhuYW1lKSxcbiAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGhhdmUgYSBwcm9wZXJ0eSAke25hbWV9YFxuICAgICk7XG4gIH0pO1xufTtcbnZhciB2YWxpZGF0ZUVudW0gPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gaXMgY2Fpcm8gdHlwZSBFbnVtICgke2lucHV0LnR5cGV9KSwgYW5kIHNob3VsZCBiZSBkZWZpbmVkIGFzIGpzIG9iamVjdCAobm90IGFycmF5KWBcbiAgKTtcbiAgY29uc3QgbWV0aG9kc0tleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyYW1ldGVyKSk7XG4gIGNvbnN0IGtleXMgPSBbLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocGFyYW1ldGVyKSwgLi4ubWV0aG9kc0tleXNdO1xuICBpZiAoaXNUeXBlT3B0aW9uKGlucHV0LnR5cGUpICYmIGtleXMuaW5jbHVkZXMoXCJpc1NvbWVcIikgJiYga2V5cy5pbmNsdWRlcyhcImlzTm9uZVwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNUeXBlUmVzdWx0KGlucHV0LnR5cGUpICYmIGtleXMuaW5jbHVkZXMoXCJpc09rXCIpICYmIGtleXMuaW5jbHVkZXMoXCJpc0VyclwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoa2V5cy5pbmNsdWRlcyhcInZhcmlhbnRcIikgJiYga2V5cy5pbmNsdWRlcyhcImFjdGl2ZVZhcmlhbnRcIikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBWYWxpZGF0ZSBFbnVtOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlIHJlY2VpdmVkICR7cGFyYW1ldGVyfSwgaXMgbm90IGFuIEVudW0uYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZVR1cGxlID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IHNob3VsZCBiZSBhIHR1cGxlIChkZWZpbmVkIGFzIG9iamVjdClgXG4gICk7XG59O1xudmFyIHZhbGlkYXRlQXJyYXkgPSAocGFyYW1ldGVyLCBpbnB1dCwgc3RydWN0cywgZW51bXMpID0+IHtcbiAgY29uc3QgYmFzZVR5cGUgPSBnZXRBcnJheVR5cGUoaW5wdXQudHlwZSk7XG4gIGlmIChpc1R5cGVGZWx0KGJhc2VUeXBlKSAmJiBpc0xvbmdUZXh0KHBhcmFtZXRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSwgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBzaG91bGQgYmUgYW4gQXJyYXlgKTtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc1R5cGVGZWx0KGJhc2VUeXBlKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKChwYXJhbSkgPT4gdmFsaWRhdGVGZWx0KHBhcmFtLCBpbnB1dCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVUdXBsZShiYXNlVHlwZSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgoaXQpID0+IHZhbGlkYXRlVHVwbGUoaXQsIHsgbmFtZTogaW5wdXQubmFtZSwgdHlwZTogYmFzZVR5cGUgfSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVBcnJheShiYXNlVHlwZSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaChcbiAgICAgICAgKHBhcmFtKSA9PiB2YWxpZGF0ZUFycmF5KHBhcmFtLCB7IG5hbWU6IFwiXCIsIHR5cGU6IGJhc2VUeXBlIH0sIHN0cnVjdHMsIGVudW1zKVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaXNUeXBlU3RydWN0KGJhc2VUeXBlLCBzdHJ1Y3RzKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKFxuICAgICAgICAoaXQpID0+IHZhbGlkYXRlU3RydWN0KGl0LCB7IG5hbWU6IGlucHV0Lm5hbWUsIHR5cGU6IGJhc2VUeXBlIH0sIHN0cnVjdHMpXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVFbnVtKGJhc2VUeXBlLCBlbnVtcyk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgoaXQpID0+IHZhbGlkYXRlRW51bShpdCwgeyBuYW1lOiBpbnB1dC5uYW1lLCB0eXBlOiBiYXNlVHlwZSB9KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIChpc1R5cGVVaW50KGJhc2VUeXBlKSB8fCBpc1R5cGVMaXR0ZXJhbChiYXNlVHlwZSkpOlxuICAgICAgcGFyYW1ldGVyLmZvckVhY2goKHBhcmFtKSA9PiB2YWxpZGF0ZVVpbnQocGFyYW0sIGlucHV0KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlzVHlwZUJvb2woYmFzZVR5cGUpOlxuICAgICAgcGFyYW1ldGVyLmZvckVhY2goKHBhcmFtKSA9PiB2YWxpZGF0ZUJvb2wocGFyYW0sIGlucHV0KSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVmFsaWRhdGUgVW5oYW5kbGVkOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlICR7cGFyYW1ldGVyfWBcbiAgICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUZpZWxkcyhhYmlNZXRob2QsIGFyZ3MsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGFiaU1ldGhvZC5pbnB1dHMucmVkdWNlKChhY2MsIGlucHV0KSA9PiB7XG4gICAgY29uc3QgcGFyYW1ldGVyID0gYXJnc1thY2NdO1xuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSBpc0xlbihpbnB1dC5uYW1lKTpcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIGNhc2UgaXNUeXBlRmVsdChpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVGZWx0KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgKGlzVHlwZVVpbnQoaW5wdXQudHlwZSkgfHwgaXNUeXBlTGl0dGVyYWwoaW5wdXQudHlwZSkpOlxuICAgICAgICB2YWxpZGF0ZVVpbnQocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVCb29sKGlucHV0LnR5cGUpOlxuICAgICAgICB2YWxpZGF0ZUJvb2wocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVBcnJheShpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVBcnJheShwYXJhbWV0ZXIsIGlucHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVTdHJ1Y3QoaW5wdXQudHlwZSwgc3RydWN0cyk6XG4gICAgICAgIHZhbGlkYXRlU3RydWN0KHBhcmFtZXRlciwgaW5wdXQsIHN0cnVjdHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlRW51bShpbnB1dC50eXBlLCBlbnVtcyk6XG4gICAgICAgIHZhbGlkYXRlRW51bShwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZVR1cGxlKGlucHV0LnR5cGUpOlxuICAgICAgICB2YWxpZGF0ZVR1cGxlKHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVmFsaWRhdGUgVW5oYW5kbGVkOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlICR7cGFyYW1ldGVyfWBcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYyArIDE7XG4gIH0sIDApO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvaW5kZXgudHNcbnZhciBDYWxsRGF0YSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYWJpKSB7XG4gICAgdGhpcy5zdHJ1Y3RzID0gQ2FsbERhdGEuZ2V0QWJpU3RydWN0KGFiaSk7XG4gICAgdGhpcy5lbnVtcyA9IENhbGxEYXRhLmdldEFiaUVudW0oYWJpKTtcbiAgICB0aGlzLnBhcnNlciA9IGNyZWF0ZUFiaVBhcnNlcihhYmkpO1xuICAgIHRoaXMuYWJpID0gdGhpcy5wYXJzZXIuZ2V0TGVnYWN5Rm9ybWF0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIG1ldGhvZCBhcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBvbmVzIGluIHRoZSBhYmlcbiAgICogQHBhcmFtIHR5cGUgVmFsaWRhdGVUeXBlIC0gdHlwZSBvZiB0aGUgbWV0aG9kXG4gICAqIEBwYXJhbSBtZXRob2Qgc3RyaW5nIC0gbmFtZSBvZiB0aGUgbWV0aG9kXG4gICAqIEBwYXJhbSBhcmdzIEFyZ3NPckNhbGxkYXRhIC0gYXJndW1lbnRzIHRoYXQgYXJlIHBhc3NlZCB0byB0aGUgbWV0aG9kXG4gICAqL1xuICB2YWxpZGF0ZSh0eXBlLCBtZXRob2QsIGFyZ3MgPSBbXSkge1xuICAgIGlmICh0eXBlICE9PSBcIkRFUExPWVwiIC8qIERFUExPWSAqLykge1xuICAgICAgY29uc3QgaW52b2NhYmxlRnVuY3Rpb25OYW1lcyA9IHRoaXMuYWJpLmZpbHRlcigoYWJpKSA9PiB7XG4gICAgICAgIGlmIChhYmkudHlwZSAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgaXNWaWV3ID0gYWJpLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgYWJpLnN0YXRlX211dGFiaWxpdHkgPT09IFwidmlld1wiO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJJTlZPS0VcIiAvKiBJTlZPS0UgKi8gPyAhaXNWaWV3IDogaXNWaWV3O1xuICAgICAgfSkubWFwKChhYmkpID0+IGFiaS5uYW1lKTtcbiAgICAgIGFzc2VydChcbiAgICAgICAgaW52b2NhYmxlRnVuY3Rpb25OYW1lcy5pbmNsdWRlcyhtZXRob2QpLFxuICAgICAgICBgJHt0eXBlID09PSBcIklOVk9LRVwiIC8qIElOVk9LRSAqLyA/IFwiaW52b2NhYmxlXCIgOiBcInZpZXdhYmxlXCJ9IG1ldGhvZCBub3QgZm91bmQgaW4gYWJpYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgYWJpTWV0aG9kID0gdGhpcy5hYmkuZmluZChcbiAgICAgIChhYmkpID0+IHR5cGUgPT09IFwiREVQTE9ZXCIgLyogREVQTE9ZICovID8gYWJpLm5hbWUgPT09IG1ldGhvZCAmJiBhYmkudHlwZSA9PT0gXCJjb25zdHJ1Y3RvclwiIDogYWJpLm5hbWUgPT09IG1ldGhvZCAmJiBhYmkudHlwZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgKTtcbiAgICBpZiAoaXNOb0NvbnN0cnVjdG9yVmFsaWQobWV0aG9kLCBhcmdzLCBhYmlNZXRob2QpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlucHV0c0xlbmd0aCA9IHRoaXMucGFyc2VyLm1ldGhvZElucHV0c0xlbmd0aChhYmlNZXRob2QpO1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gaW5wdXRzTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cywgZXhwZWN0ZWQgJHtpbnB1dHNMZW5ndGh9IGFyZ3VtZW50cywgYnV0IGdvdCAke2FyZ3MubGVuZ3RofWBcbiAgICAgICk7XG4gICAgfVxuICAgIHZhbGlkYXRlRmllbGRzKGFiaU1ldGhvZCwgYXJncywgdGhpcy5zdHJ1Y3RzLCB0aGlzLmVudW1zKTtcbiAgfVxuICAvKipcbiAgICogQ29tcGlsZSBjb250cmFjdCBjYWxsRGF0YSB3aXRoIGFiaVxuICAgKiBQYXJzZSB0aGUgY2FsbGRhdGEgYnkgdXNpbmcgaW5wdXQgZmllbGRzIGZyb20gdGhlIGFiaSBmb3IgdGhhdCBtZXRob2RcbiAgICogQHBhcmFtIG1ldGhvZCBzdHJpbmcgLSBtZXRob2QgbmFtZVxuICAgKiBAcGFyYW0gYXJncyBSYXdBcmdzIC0gYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kLiBDYW4gYmUgYW4gYXJyYXkgb2YgYXJndW1lbnRzIChpbiB0aGUgb3JkZXIgb2YgYWJpIGRlZmluaXRpb24pLCBvciBhbiBvYmplY3QgY29uc3RydWN0ZWQgaW4gY29uZm9ybWl0eSB3aXRoIGFiaSAoaW4gdGhpcyBjYXNlLCB0aGUgcGFyYW1ldGVyIGNhbiBiZSBpbiBhIHdyb25nIG9yZGVyKS5cbiAgICogQHJldHVybiBDYWxsZGF0YSAtIHBhcnNlZCBhcmd1bWVudHMgaW4gZm9ybWF0IHRoYXQgY29udHJhY3QgaXMgZXhwZWN0aW5nXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgY2FsbGRhdGEgPSBteUNhbGxEYXRhLmNvbXBpbGUoXCJjb25zdHJ1Y3RvclwiLCBbXCIweDM0YVwiLCBbMSwgM25dXSk7XG4gICAqIGBgYFxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGNhbGxkYXRhMiA9IG15Q2FsbERhdGEuY29tcGlsZShcImNvbnN0cnVjdG9yXCIsIHtsaXN0OlsxLCAzbl0sIGJhbGFuY2U6XCIweDM0XCJ9KTsgLy8gd3Jvbmcgb3JkZXIgaXMgdmFsaWRcbiAgICogYGBgXG4gICAqL1xuICBjb21waWxlKG1ldGhvZCwgYXJnc0NhbGxkYXRhKSB7XG4gICAgY29uc3QgYWJpTWV0aG9kID0gdGhpcy5hYmkuZmluZCgoYWJpRnVuY3Rpb24pID0+IGFiaUZ1bmN0aW9uLm5hbWUgPT09IG1ldGhvZCk7XG4gICAgaWYgKGlzTm9Db25zdHJ1Y3RvclZhbGlkKG1ldGhvZCwgYXJnc0NhbGxkYXRhLCBhYmlNZXRob2QpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCBhcmdzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3NDYWxsZGF0YSkpIHtcbiAgICAgIGFyZ3MgPSBhcmdzQ2FsbGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9yZGVyZWRPYmplY3QgPSBvcmRlclByb3BzQnlBYmkoXG4gICAgICAgIGFyZ3NDYWxsZGF0YSxcbiAgICAgICAgYWJpTWV0aG9kLmlucHV0cyxcbiAgICAgICAgdGhpcy5zdHJ1Y3RzLFxuICAgICAgICB0aGlzLmVudW1zXG4gICAgICApO1xuICAgICAgYXJncyA9IE9iamVjdC52YWx1ZXMob3JkZXJlZE9iamVjdCk7XG4gICAgICB2YWxpZGF0ZUZpZWxkcyhhYmlNZXRob2QsIGFyZ3MsIHRoaXMuc3RydWN0cywgdGhpcy5lbnVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3NJdGVyYXRvciA9IGFyZ3NbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IGNhbGxBcnJheSA9IGFiaU1ldGhvZC5pbnB1dHMucmVkdWNlKFxuICAgICAgKGFjYywgaW5wdXQpID0+IGlzTGVuKGlucHV0Lm5hbWUpICYmICFpc0NhaXJvMVR5cGUoaW5wdXQudHlwZSkgPyBhY2MgOiBhY2MuY29uY2F0KHBhcnNlQ2FsbGRhdGFGaWVsZChhcmdzSXRlcmF0b3IsIGlucHV0LCB0aGlzLnN0cnVjdHMsIHRoaXMuZW51bXMpKSxcbiAgICAgIFtdXG4gICAgKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2FsbEFycmF5LCBcIl9fY29tcGlsZWRfX1wiLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbGxBcnJheTtcbiAgfVxuICAvKipcbiAgICogQ29tcGlsZSBjb250cmFjdCBjYWxsRGF0YSB3aXRob3V0IGFiaVxuICAgKiBAcGFyYW0gcmF3QXJncyBSYXdBcmdzIHJlcHJlc2VudGluZyBjYWlybyBtZXRob2QgYXJndW1lbnRzIG9yIHN0cmluZyBhcnJheSBvZiBjb21waWxlZCBkYXRhXG4gICAqIEByZXR1cm5zIENhbGxkYXRhXG4gICAqL1xuICBzdGF0aWMgY29tcGlsZShyYXdBcmdzKSB7XG4gICAgY29uc3QgY3JlYXRlVHJlZSA9IChvYmopID0+IHtcbiAgICAgIGNvbnN0IGdldEVudHJpZXMgPSAobywgcHJlZml4ID0gXCIuXCIpID0+IHtcbiAgICAgICAgY29uc3Qgb2UgPSBBcnJheS5pc0FycmF5KG8pID8gW28ubGVuZ3RoLnRvU3RyaW5nKCksIC4uLm9dIDogbztcbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9lKS5mbGF0TWFwKChbaywgdl0pID0+IHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSB2O1xuICAgICAgICAgIGlmIChpc0xvbmdUZXh0KHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gc3BsaXRMb25nU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICBpZiAoayA9PT0gXCJlbnRyeXBvaW50XCIpXG4gICAgICAgICAgICB2YWx1ZSA9IGdldFNlbGVjdG9yRnJvbU5hbWUodmFsdWUpO1xuICAgICAgICAgIGNvbnN0IGtrID0gQXJyYXkuaXNBcnJheShvZSkgJiYgayA9PT0gXCIwXCIgPyBcIiQkbGVuXCIgOiBrO1xuICAgICAgICAgIGlmIChpc0JpZ0ludCh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gW1tgJHtwcmVmaXh9JHtra31gLCBmZWx0KHZhbHVlKV1dO1xuICAgICAgICAgIGlmIChPYmplY3QodmFsdWUpID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kc0tleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpKTtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLCAuLi5tZXRob2RzS2V5c107XG4gICAgICAgICAgICBpZiAoa2V5cy5pbmNsdWRlcyhcImlzU29tZVwiKSAmJiBrZXlzLmluY2x1ZGVzKFwiaXNOb25lXCIpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG15T3B0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICAgIGNvbnN0IHZhcmlhbnROYiA9IG15T3B0aW9uLmlzU29tZSgpID8gMCAvKiBTb21lICovIDogMSAvKiBOb25lICovO1xuICAgICAgICAgICAgICBpZiAobXlPcHRpb24uaXNTb21lKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEVudHJpZXMoeyAwOiB2YXJpYW50TmIsIDE6IG15T3B0aW9uLnVud3JhcCgpIH0sIGAke3ByZWZpeH0ke2trfS5gKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtbYCR7cHJlZml4fSR7a2t9YCwgZmVsdCh2YXJpYW50TmIpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5cy5pbmNsdWRlcyhcImlzT2tcIikgJiYga2V5cy5pbmNsdWRlcyhcImlzRXJyXCIpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG15UmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICAgIGNvbnN0IHZhcmlhbnROYiA9IG15UmVzdWx0LmlzT2soKSA/IDAgLyogT2sgKi8gOiAxIC8qIEVyciAqLztcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEVudHJpZXMoeyAwOiB2YXJpYW50TmIsIDE6IG15UmVzdWx0LnVud3JhcCgpIH0sIGAke3ByZWZpeH0ke2trfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlzLmluY2x1ZGVzKFwidmFyaWFudFwiKSAmJiBrZXlzLmluY2x1ZGVzKFwiYWN0aXZlVmFyaWFudFwiKSkge1xuICAgICAgICAgICAgICBjb25zdCBteUVudW0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgY29uc3QgYWN0aXZlVmFyaWFudCA9IG15RW51bS5hY3RpdmVWYXJpYW50KCk7XG4gICAgICAgICAgICAgIGNvbnN0IGxpc3RWYXJpYW50cyA9IE9iamVjdC5rZXlzKG15RW51bS52YXJpYW50KTtcbiAgICAgICAgICAgICAgY29uc3QgYWN0aXZlVmFyaWFudE5iID0gbGlzdFZhcmlhbnRzLmZpbmRJbmRleChcbiAgICAgICAgICAgICAgICAodmFyaWFudCkgPT4gdmFyaWFudCA9PT0gYWN0aXZlVmFyaWFudFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG15RW51bS51bndyYXAoKSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhteUVudW0udW53cmFwKCkpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbW2Ake3ByZWZpeH0ke2trfWAsIGZlbHQoYWN0aXZlVmFyaWFudE5iKV1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBnZXRFbnRyaWVzKHsgMDogYWN0aXZlVmFyaWFudE5iLCAxOiBteUVudW0udW53cmFwKCkgfSwgYCR7cHJlZml4fSR7a2t9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldEVudHJpZXModmFsdWUsIGAke3ByZWZpeH0ke2trfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtbYCR7cHJlZml4fSR7a2t9YCwgZmVsdCh2YWx1ZSldXTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmZyb21FbnRyaWVzKGdldEVudHJpZXMob2JqKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgbGV0IGNhbGxUcmVlQXJyYXk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJhd0FyZ3MpKSB7XG4gICAgICBjb25zdCBjYWxsVHJlZSA9IGNyZWF0ZVRyZWUocmF3QXJncyk7XG4gICAgICBjYWxsVHJlZUFycmF5ID0gT2JqZWN0LnZhbHVlcyhjYWxsVHJlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNhbGxPYmogPSB7IC4uLnJhd0FyZ3MgfTtcbiAgICAgIGNvbnN0IGNhbGxUcmVlID0gY3JlYXRlVHJlZShjYWxsT2JqKTtcbiAgICAgIGNhbGxUcmVlQXJyYXkgPSBPYmplY3QudmFsdWVzKGNhbGxUcmVlKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhbGxUcmVlQXJyYXksIFwiX19jb21waWxlZF9fXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gY2FsbFRyZWVBcnJheTtcbiAgfVxuICAvKipcbiAgICogUGFyc2UgZWxlbWVudHMgb2YgdGhlIHJlc3BvbnNlIGFycmF5IGFuZCBzdHJ1Y3R1cmluZyB0aGVtIGludG8gcmVzcG9uc2Ugb2JqZWN0XG4gICAqIEBwYXJhbSBtZXRob2Qgc3RyaW5nIC0gbWV0aG9kIG5hbWVcbiAgICogQHBhcmFtIHJlc3BvbnNlIHN0cmluZ1tdIC0gcmVzcG9uc2UgZnJvbSB0aGUgbWV0aG9kXG4gICAqIEByZXR1cm4gUmVzdWx0IC0gcGFyc2VkIHJlc3BvbnNlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGFiaVxuICAgKi9cbiAgcGFyc2UobWV0aG9kLCByZXNwb25zZSkge1xuICAgIGNvbnN0IHsgb3V0cHV0cyB9ID0gdGhpcy5hYmkuZmluZCgoYWJpKSA9PiBhYmkubmFtZSA9PT0gbWV0aG9kKTtcbiAgICBjb25zdCByZXNwb25zZUl0ZXJhdG9yID0gcmVzcG9uc2UuZmxhdCgpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBjb25zdCBwYXJzZWQgPSBvdXRwdXRzLmZsYXQoKS5yZWR1Y2UoKGFjYywgb3V0cHV0LCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IHByb3BOYW1lID0gb3V0cHV0Lm5hbWUgPz8gaWR4O1xuICAgICAgYWNjW3Byb3BOYW1lXSA9IHJlc3BvbnNlUGFyc2VyKHJlc3BvbnNlSXRlcmF0b3IsIG91dHB1dCwgdGhpcy5zdHJ1Y3RzLCB0aGlzLmVudW1zLCBhY2MpO1xuICAgICAgaWYgKGFjY1twcm9wTmFtZV0gJiYgYWNjW2Ake3Byb3BOYW1lfV9sZW5gXSkge1xuICAgICAgICBkZWxldGUgYWNjW2Ake3Byb3BOYW1lfV9sZW5gXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwYXJzZWQpLmxlbmd0aCA9PT0gMSAmJiAwIGluIHBhcnNlZCA/IHBhcnNlZFswXSA6IHBhcnNlZDtcbiAgfVxuICAvKipcbiAgICogRm9ybWF0IGNhaXJvIG1ldGhvZCByZXNwb25zZSBkYXRhIHRvIG5hdGl2ZSBqcyB2YWx1ZXMgYmFzZWQgb24gcHJvdmlkZWQgZm9ybWF0IHNjaGVtYVxuICAgKiBAcGFyYW0gbWV0aG9kIHN0cmluZyAtIGNhaXJvIG1ldGhvZCBuYW1lXG4gICAqIEBwYXJhbSByZXNwb25zZSBzdHJpbmdbXSAtIGNhaXJvIG1ldGhvZCByZXNwb25zZVxuICAgKiBAcGFyYW0gZm9ybWF0IG9iamVjdCAtIGZvcm1hdHRlciBvYmplY3Qgc2NoZW1hXG4gICAqIEByZXR1cm5zIFJlc3VsdCAtIHBhcnNlZCBhbmQgZm9ybWF0dGVkIHJlc3BvbnNlIG9iamVjdFxuICAgKi9cbiAgZm9ybWF0KG1ldGhvZCwgcmVzcG9uc2UsIGZvcm1hdCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2UobWV0aG9kLCByZXNwb25zZSk7XG4gICAgcmV0dXJuIGZvcm1hdHRlcihwYXJzZWQsIGZvcm1hdCk7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciB0byBleHRyYWN0IHN0cnVjdHMgZnJvbSBhYmlcbiAgICogQHBhcmFtIGFiaSBBYmlcbiAgICogQHJldHVybnMgQWJpU3RydWN0cyAtIHN0cnVjdHMgZnJvbSBhYmlcbiAgICovXG4gIHN0YXRpYyBnZXRBYmlTdHJ1Y3QoYWJpKSB7XG4gICAgcmV0dXJuIGFiaS5maWx0ZXIoKGFiaUVudHJ5KSA9PiBhYmlFbnRyeS50eXBlID09PSBcInN0cnVjdFwiKS5yZWR1Y2UoXG4gICAgICAoYWNjLCBhYmlFbnRyeSkgPT4gKHtcbiAgICAgICAgLi4uYWNjLFxuICAgICAgICBbYWJpRW50cnkubmFtZV06IGFiaUVudHJ5XG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyIHRvIGV4dHJhY3QgZW51bXMgZnJvbSBhYmlcbiAgICogQHBhcmFtIGFiaSBBYmlcbiAgICogQHJldHVybnMgQWJpRW51bXMgLSBlbnVtcyBmcm9tIGFiaVxuICAgKi9cbiAgc3RhdGljIGdldEFiaUVudW0oYWJpKSB7XG4gICAgY29uc3QgZnVsbEVudW1MaXN0ID0gYWJpLmZpbHRlcigoYWJpRW50cnkpID0+IGFiaUVudHJ5LnR5cGUgPT09IFwiZW51bVwiKS5yZWR1Y2UoXG4gICAgICAoYWNjLCBhYmlFbnRyeSkgPT4gKHtcbiAgICAgICAgLi4uYWNjLFxuICAgICAgICBbYWJpRW50cnkubmFtZV06IGFiaUVudHJ5XG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcbiAgICBkZWxldGUgZnVsbEVudW1MaXN0W1wiY29yZTo6Ym9vbFwiXTtcbiAgICByZXR1cm4gZnVsbEVudW1MaXN0O1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXI6IENvbXBpbGUgSGV4Q2FsbGRhdGEgfCBSYXdDYWxsZGF0YSB8IFJhd0FyZ3NcbiAgICogQHBhcmFtIHJhd0NhbGxkYXRhIEhleENhbGxkYXRhIHwgUmF3Q2FsbGRhdGEgfCBSYXdBcmdzXG4gICAqIEByZXR1cm5zIENhbGxkYXRhXG4gICAqL1xuICBzdGF0aWMgdG9DYWxsZGF0YShyYXdDYWxsZGF0YSA9IFtdKSB7XG4gICAgcmV0dXJuIENhbGxEYXRhLmNvbXBpbGUocmF3Q2FsbGRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXI6IENvbnZlcnQgcmF3IHRvIEhleENhbGxkYXRhXG4gICAqIEBwYXJhbSByYXcgSGV4Q2FsbGRhdGEgfCBSYXdDYWxsZGF0YSB8IFJhd0FyZ3NcbiAgICogQHJldHVybnMgSGV4Q2FsbGRhdGFcbiAgICovXG4gIHN0YXRpYyB0b0hleChyYXcgPSBbXSkge1xuICAgIGNvbnN0IGNhbGxkYXRhID0gQ2FsbERhdGEuY29tcGlsZShyYXcpO1xuICAgIHJldHVybiBjYWxsZGF0YS5tYXAoKGl0KSA9PiB0b0hleChpdCkpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvaGFzaC50c1xudmFyIGhhc2hfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaGFzaF9leHBvcnRzLCB7XG4gIGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoOiAoKSA9PiBjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaCxcbiAgY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaCxcbiAgY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaCxcbiAgY2FsY3VsYXRlRGVwbG95VHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVEZXBsb3lUcmFuc2FjdGlvbkhhc2gsXG4gIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoLFxuICBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb246ICgpID0+IGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbixcbiAgY29tcHV0ZUNvbXBpbGVkQ2xhc3NIYXNoOiAoKSA9PiBjb21wdXRlQ29tcGlsZWRDbGFzc0hhc2gsXG4gIGNvbXB1dGVDb250cmFjdENsYXNzSGFzaDogKCkgPT4gY29tcHV0ZUNvbnRyYWN0Q2xhc3NIYXNoLFxuICBjb21wdXRlSGFzaE9uRWxlbWVudHM6ICgpID0+IGNvbXB1dGVIYXNoT25FbGVtZW50cyxcbiAgY29tcHV0ZUxlZ2FjeUNvbnRyYWN0Q2xhc3NIYXNoOiAoKSA9PiBjb21wdXRlTGVnYWN5Q29udHJhY3RDbGFzc0hhc2gsXG4gIGNvbXB1dGVTaWVycmFDb250cmFjdENsYXNzSGFzaDogKCkgPT4gY29tcHV0ZVNpZXJyYUNvbnRyYWN0Q2xhc3NIYXNoLFxuICBkZWZhdWx0OiAoKSA9PiBjb21wdXRlSGludGVkQ2xhc3NIYXNoLFxuICBmZWVUcmFuc2FjdGlvblZlcnNpb246ICgpID0+IGZlZVRyYW5zYWN0aW9uVmVyc2lvbixcbiAgZmVlVHJhbnNhY3Rpb25WZXJzaW9uXzI6ICgpID0+IGZlZVRyYW5zYWN0aW9uVmVyc2lvbl8yLFxuICBmb3JtYXRTcGFjZXM6ICgpID0+IGZvcm1hdFNwYWNlcyxcbiAgZ2V0U2VsZWN0b3I6ICgpID0+IGdldFNlbGVjdG9yLFxuICBnZXRTZWxlY3RvckZyb21OYW1lOiAoKSA9PiBnZXRTZWxlY3RvckZyb21OYW1lLFxuICBnZXRWZXJzaW9uc0J5VHlwZTogKCkgPT4gZ2V0VmVyc2lvbnNCeVR5cGUsXG4gIGtlY2Nha0JuOiAoKSA9PiBrZWNjYWtCbixcbiAgcG9zZWlkb246ICgpID0+IHBvc2VpZG9uLFxuICBzdGFya25ldEtlY2NhazogKCkgPT4gc3RhcmtuZXRLZWNjYWssXG4gIHRyYW5zYWN0aW9uVmVyc2lvbjogKCkgPT4gdHJhbnNhY3Rpb25WZXJzaW9uLFxuICB0cmFuc2FjdGlvblZlcnNpb25fMjogKCkgPT4gdHJhbnNhY3Rpb25WZXJzaW9uXzJcbn0pO1xuaW1wb3J0IHsgcG9zZWlkb25IYXNoTWFueSB9IGZyb20gXCJAc2N1cmUvc3RhcmtuZXRcIjtcblxuLy8gc3JjL3V0aWxzL2VjLnRzXG52YXIgZWNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZWNfZXhwb3J0cywge1xuICBzdGFya0N1cnZlOiAoKSA9PiBzdGFya0N1cnZlLFxuICB3ZWllcnN0cmFzczogKCkgPT4gd2VpZXJzdHJhc3Ncbn0pO1xuaW1wb3J0ICogYXMgc3RhcmtDdXJ2ZSBmcm9tIFwiQHNjdXJlL3N0YXJrbmV0XCI7XG5pbXBvcnQgKiBhcyB3ZWllcnN0cmFzcyBmcm9tIFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC93ZWllcnN0cmFzc1wiO1xuXG4vLyBzcmMvdXRpbHMvanNvbi50c1xudmFyIGpzb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoanNvbl9leHBvcnRzLCB7XG4gIHBhcnNlOiAoKSA9PiBwYXJzZTIsXG4gIHBhcnNlQWx3YXlzQXNCaWc6ICgpID0+IHBhcnNlQWx3YXlzQXNCaWcsXG4gIHN0cmluZ2lmeTogKCkgPT4gc3RyaW5naWZ5MixcbiAgc3RyaW5naWZ5QWx3YXlzQXNCaWc6ICgpID0+IHN0cmluZ2lmeUFsd2F5c0FzQmlnXG59KTtcbmltcG9ydCAqIGFzIGpzb24gZnJvbSBcImxvc3NsZXNzLWpzb25cIjtcbnZhciBwYXJzZUludEFzTnVtYmVyT3JCaWdJbnQgPSAoeCkgPT4ge1xuICBpZiAoIWpzb24uaXNJbnRlZ2VyKHgpKVxuICAgIHJldHVybiBwYXJzZUZsb2F0KHgpO1xuICBjb25zdCB2ID0gcGFyc2VJbnQoeCwgMTApO1xuICByZXR1cm4gTnVtYmVyLmlzU2FmZUludGVnZXIodikgPyB2IDogQmlnSW50KHgpO1xufTtcbnZhciBwYXJzZTIgPSAoeCkgPT4ganNvbi5wYXJzZShTdHJpbmcoeCksIHZvaWQgMCwgcGFyc2VJbnRBc051bWJlck9yQmlnSW50KTtcbnZhciBwYXJzZUFsd2F5c0FzQmlnID0gKHgpID0+IGpzb24ucGFyc2UoU3RyaW5nKHgpLCB2b2lkIDAsIGpzb24ucGFyc2VOdW1iZXJBbmRCaWdJbnQpO1xudmFyIHN0cmluZ2lmeTIgPSAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSwgbnVtYmVyU3RyaW5naWZpZXJzKSA9PiBqc29uLnN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlLCBudW1iZXJTdHJpbmdpZmllcnMpO1xudmFyIHN0cmluZ2lmeUFsd2F5c0FzQmlnID0gc3RyaW5naWZ5MjtcblxuLy8gc3JjL3V0aWxzL2hhc2gudHNcbmltcG9ydCAqIGFzIHBvc2VpZG9uIGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3Bvc2VpZG9uXCI7XG52YXIgdHJhbnNhY3Rpb25WZXJzaW9uID0gQk5fVFJBTlNBQ1RJT05fVkVSU0lPTl8xO1xudmFyIHRyYW5zYWN0aW9uVmVyc2lvbl8yID0gQk5fVFJBTlNBQ1RJT05fVkVSU0lPTl8yO1xudmFyIGZlZVRyYW5zYWN0aW9uVmVyc2lvbiA9IEJOX0ZFRV9UUkFOU0FDVElPTl9WRVJTSU9OXzE7XG52YXIgZmVlVHJhbnNhY3Rpb25WZXJzaW9uXzIgPSBCTl9GRUVfVFJBTlNBQ1RJT05fVkVSU0lPTl8yO1xuZnVuY3Rpb24gZ2V0VmVyc2lvbnNCeVR5cGUodmVyc2lvblR5cGUpIHtcbiAgcmV0dXJuIHZlcnNpb25UeXBlID09PSBcImZlZVwiID8geyB2MTogZmVlVHJhbnNhY3Rpb25WZXJzaW9uLCB2MjogZmVlVHJhbnNhY3Rpb25WZXJzaW9uXzIgfSA6IHsgdjE6IHRyYW5zYWN0aW9uVmVyc2lvbiwgdjI6IHRyYW5zYWN0aW9uVmVyc2lvbl8yIH07XG59XG5mdW5jdGlvbiBjb21wdXRlSGFzaE9uRWxlbWVudHMoZGF0YSkge1xuICByZXR1cm4gWy4uLmRhdGEsIGRhdGEubGVuZ3RoXS5yZWR1Y2UoKHgsIHkpID0+IHN0YXJrQ3VydmUucGVkZXJzZW4odG9CaWdJbnQoeCksIHRvQmlnSW50KHkpKSwgMCkudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbih0eEhhc2hQcmVmaXgsIHZlcnNpb24sIGNvbnRyYWN0QWRkcmVzcywgZW50cnlQb2ludFNlbGVjdG9yLCBjYWxsZGF0YSwgbWF4RmVlLCBjaGFpbklkLCBhZGRpdGlvbmFsRGF0YSA9IFtdKSB7XG4gIGNvbnN0IGNhbGxkYXRhSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50cyhjYWxsZGF0YSk7XG4gIGNvbnN0IGRhdGFUb0hhc2ggPSBbXG4gICAgdHhIYXNoUHJlZml4LFxuICAgIHZlcnNpb24sXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIGVudHJ5UG9pbnRTZWxlY3RvcixcbiAgICBjYWxsZGF0YUhhc2gsXG4gICAgbWF4RmVlLFxuICAgIGNoYWluSWQsXG4gICAgLi4uYWRkaXRpb25hbERhdGFcbiAgXTtcbiAgcmV0dXJuIGNvbXB1dGVIYXNoT25FbGVtZW50cyhkYXRhVG9IYXNoKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlcGxveVRyYW5zYWN0aW9uSGFzaChjb250cmFjdEFkZHJlc3MsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIHZlcnNpb24sIGNoYWluSWQsIGNvbnN0cnVjdG9yTmFtZSA9IFwiY29uc3RydWN0b3JcIikge1xuICByZXR1cm4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uKFxuICAgIFwiMHg2NDY1NzA2YzZmNzlcIiAvKiBERVBMT1kgKi8sXG4gICAgdmVyc2lvbixcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgZ2V0U2VsZWN0b3JGcm9tTmFtZShjb25zdHJ1Y3Rvck5hbWUpLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgMCxcbiAgICBjaGFpbklkXG4gICk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoKGNsYXNzSGFzaCwgc2VuZGVyQWRkcmVzcywgdmVyc2lvbiwgbWF4RmVlLCBjaGFpbklkLCBub25jZSwgY29tcGlsZWRDbGFzc0hhc2gpIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbihcbiAgICBcIjB4NjQ2NTYzNmM2MTcyNjVcIiAvKiBERUNMQVJFICovLFxuICAgIHZlcnNpb24sXG4gICAgc2VuZGVyQWRkcmVzcyxcbiAgICAwLFxuICAgIFtjbGFzc0hhc2hdLFxuICAgIG1heEZlZSxcbiAgICBjaGFpbklkLFxuICAgIFtub25jZSwgLi4uY29tcGlsZWRDbGFzc0hhc2ggPyBbY29tcGlsZWRDbGFzc0hhc2hdIDogW11dXG4gICk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoKGNvbnRyYWN0QWRkcmVzcywgY2xhc3NIYXNoLCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBzYWx0LCB2ZXJzaW9uLCBtYXhGZWUsIGNoYWluSWQsIG5vbmNlKSB7XG4gIGNvbnN0IGNhbGxkYXRhID0gW2NsYXNzSGFzaCwgc2FsdCwgLi4uY29uc3RydWN0b3JDYWxsZGF0YV07XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24oXG4gICAgXCIweDY0NjU3MDZjNmY3OTVmNjE2MzYzNmY3NTZlNzRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAwLFxuICAgIGNhbGxkYXRhLFxuICAgIG1heEZlZSxcbiAgICBjaGFpbklkLFxuICAgIFtub25jZV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaChjb250cmFjdEFkZHJlc3MsIHZlcnNpb24sIGNhbGxkYXRhLCBtYXhGZWUsIGNoYWluSWQsIG5vbmNlKSB7XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24oXG4gICAgXCIweDY5NmU3NjZmNmI2NVwiIC8qIElOVk9LRSAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAwLFxuICAgIGNhbGxkYXRhLFxuICAgIG1heEZlZSxcbiAgICBjaGFpbklkLFxuICAgIFtub25jZV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoKHNhbHQsIGNsYXNzSGFzaCwgY29uc3RydWN0b3JDYWxsZGF0YSwgZGVwbG95ZXJBZGRyZXNzKSB7XG4gIGNvbnN0IGNvbXBpbGVkQ2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICBjb25zdCBjb25zdHJ1Y3RvckNhbGxkYXRhSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50cyhjb21waWxlZENhbGxkYXRhKTtcbiAgY29uc3QgQ09OVFJBQ1RfQUREUkVTU19QUkVGSVggPSBmZWx0KFwiMHg1MzU0NDE1MjRiNGU0NTU0NWY0MzRmNGU1NDUyNDE0MzU0NWY0MTQ0NDQ1MjQ1NTM1M1wiKTtcbiAgcmV0dXJuIGNvbXB1dGVIYXNoT25FbGVtZW50cyhbXG4gICAgQ09OVFJBQ1RfQUREUkVTU19QUkVGSVgsXG4gICAgZGVwbG95ZXJBZGRyZXNzLFxuICAgIHNhbHQsXG4gICAgY2xhc3NIYXNoLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGFIYXNoXG4gIF0pO1xufVxuZnVuY3Rpb24gbnVsbFNraXBSZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT09IFwiYXR0cmlidXRlc1wiIHx8IGtleSA9PT0gXCJhY2Nlc3NpYmxlX3Njb3Blc1wiKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCA/IHZvaWQgMCA6IHZhbHVlO1xuICB9XG4gIGlmIChrZXkgPT09IFwiZGVidWdfaW5mb1wiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gdm9pZCAwIDogdmFsdWU7XG59XG5mdW5jdGlvbiBmb3JtYXRTcGFjZXMoanNvbjIpIHtcbiAgbGV0IGluc2lkZVF1b3RlcyA9IGZhbHNlO1xuICBjb25zdCBuZXdTdHJpbmcgPSBbXTtcbiAgZm9yIChjb25zdCBjaGFyIG9mIGpzb24yKSB7XG4gICAgaWYgKGNoYXIgPT09ICdcIicgJiYgKG5ld1N0cmluZy5sZW5ndGggPiAwICYmIG5ld1N0cmluZy5zbGljZSgtMSlbMF0gPT09IFwiXFxcXFwiKSA9PT0gZmFsc2UpIHtcbiAgICAgIGluc2lkZVF1b3RlcyA9ICFpbnNpZGVRdW90ZXM7XG4gICAgfVxuICAgIGlmIChpbnNpZGVRdW90ZXMpIHtcbiAgICAgIG5ld1N0cmluZy5wdXNoKGNoYXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHJpbmcucHVzaChjaGFyID09PSBcIjpcIiA/IFwiOiBcIiA6IGNoYXIgPT09IFwiLFwiID8gXCIsIFwiIDogY2hhcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdTdHJpbmcuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVIaW50ZWRDbGFzc0hhc2goY29tcGlsZWRDb250cmFjdCkge1xuICBjb25zdCB7IGFiaSwgcHJvZ3JhbSB9ID0gY29tcGlsZWRDb250cmFjdDtcbiAgY29uc3QgY29udHJhY3RDbGFzcyA9IHsgYWJpLCBwcm9ncmFtIH07XG4gIGNvbnN0IHNlcmlhbGl6ZWRKc29uID0gZm9ybWF0U3BhY2VzKHN0cmluZ2lmeTIoY29udHJhY3RDbGFzcywgbnVsbFNraXBSZXBsYWNlcikpO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KHN0YXJrQ3VydmUua2VjY2FrKHV0ZjhUb0FycmF5KHNlcmlhbGl6ZWRKc29uKSkudG9TdHJpbmcoMTYpKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMZWdhY3lDb250cmFjdENsYXNzSGFzaChjb250cmFjdCkge1xuICBjb25zdCBjb21waWxlZENvbnRyYWN0ID0gdHlwZW9mIGNvbnRyYWN0ID09PSBcInN0cmluZ1wiID8gcGFyc2UyKGNvbnRyYWN0KSA6IGNvbnRyYWN0O1xuICBjb25zdCBhcGlWZXJzaW9uID0gdG9IZXgoQVBJX1ZFUlNJT04pO1xuICBjb25zdCBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50cyhcbiAgICBjb21waWxlZENvbnRyYWN0LmVudHJ5X3BvaW50c19ieV90eXBlLkVYVEVSTkFMLmZsYXRNYXAoKGUpID0+IFtlLnNlbGVjdG9yLCBlLm9mZnNldF0pXG4gICk7XG4gIGNvbnN0IGwxSGFuZGxlckVudHJ5UG9pbnRzSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50cyhcbiAgICBjb21waWxlZENvbnRyYWN0LmVudHJ5X3BvaW50c19ieV90eXBlLkwxX0hBTkRMRVIuZmxhdE1hcCgoZSkgPT4gW2Uuc2VsZWN0b3IsIGUub2Zmc2V0XSlcbiAgKTtcbiAgY29uc3QgY29uc3RydWN0b3JFbnRyeVBvaW50SGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50cyhcbiAgICBjb21waWxlZENvbnRyYWN0LmVudHJ5X3BvaW50c19ieV90eXBlLkNPTlNUUlVDVE9SLmZsYXRNYXAoKGUpID0+IFtlLnNlbGVjdG9yLCBlLm9mZnNldF0pXG4gICk7XG4gIGNvbnN0IGJ1aWx0aW5zSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50cyhcbiAgICBjb21waWxlZENvbnRyYWN0LnByb2dyYW0uYnVpbHRpbnMubWFwKChzKSA9PiBlbmNvZGVTaG9ydFN0cmluZyhzKSlcbiAgKTtcbiAgY29uc3QgaGludGVkQ2xhc3NIYXNoID0gY29tcHV0ZUhpbnRlZENsYXNzSGFzaChjb21waWxlZENvbnRyYWN0KTtcbiAgY29uc3QgZGF0YUhhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMoY29tcGlsZWRDb250cmFjdC5wcm9ncmFtLmRhdGEpO1xuICByZXR1cm4gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKFtcbiAgICBhcGlWZXJzaW9uLFxuICAgIGV4dGVybmFsRW50cnlQb2ludHNIYXNoLFxuICAgIGwxSGFuZGxlckVudHJ5UG9pbnRzSGFzaCxcbiAgICBjb25zdHJ1Y3RvckVudHJ5UG9pbnRIYXNoLFxuICAgIGJ1aWx0aW5zSGFzaCxcbiAgICBoaW50ZWRDbGFzc0hhc2gsXG4gICAgZGF0YUhhc2hcbiAgXSk7XG59XG5mdW5jdGlvbiBoYXNoQnVpbHRpbnMoYnVpbHRpbnMpIHtcbiAgcmV0dXJuIHBvc2VpZG9uSGFzaE1hbnkoXG4gICAgYnVpbHRpbnMuZmxhdE1hcCgoaXQpID0+IHtcbiAgICAgIHJldHVybiBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoaXQpKTtcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gaGFzaEVudHJ5UG9pbnQoZGF0YSkge1xuICBjb25zdCBiYXNlID0gZGF0YS5mbGF0TWFwKChpdCkgPT4ge1xuICAgIHJldHVybiBbQmlnSW50KGl0LnNlbGVjdG9yKSwgQmlnSW50KGl0Lm9mZnNldCksIGhhc2hCdWlsdGlucyhpdC5idWlsdGlucyldO1xuICB9KTtcbiAgcmV0dXJuIHBvc2VpZG9uSGFzaE1hbnkoYmFzZSk7XG59XG5mdW5jdGlvbiBjb21wdXRlQ29tcGlsZWRDbGFzc0hhc2goY2FzbSkge1xuICBjb25zdCBDT01QSUxFRF9DTEFTU19WRVJTSU9OID0gXCJDT01QSUxFRF9DTEFTU19WMVwiO1xuICBjb25zdCBjb21waWxlZENsYXNzVmVyc2lvbiA9IEJpZ0ludChlbmNvZGVTaG9ydFN0cmluZyhDT01QSUxFRF9DTEFTU19WRVJTSU9OKSk7XG4gIGNvbnN0IGV4dGVybmFsRW50cnlQb2ludHNIYXNoID0gaGFzaEVudHJ5UG9pbnQoY2FzbS5lbnRyeV9wb2ludHNfYnlfdHlwZS5FWFRFUk5BTCk7XG4gIGNvbnN0IGwxSGFuZGxlcnMgPSBoYXNoRW50cnlQb2ludChjYXNtLmVudHJ5X3BvaW50c19ieV90eXBlLkwxX0hBTkRMRVIpO1xuICBjb25zdCBjb25zdHJ1Y3RvciA9IGhhc2hFbnRyeVBvaW50KGNhc20uZW50cnlfcG9pbnRzX2J5X3R5cGUuQ09OU1RSVUNUT1IpO1xuICBjb25zdCBieXRlY29kZSA9IHBvc2VpZG9uSGFzaE1hbnkoY2FzbS5ieXRlY29kZS5tYXAoKGl0KSA9PiBCaWdJbnQoaXQpKSk7XG4gIHJldHVybiB0b0hleChcbiAgICBwb3NlaWRvbkhhc2hNYW55KFtcbiAgICAgIGNvbXBpbGVkQ2xhc3NWZXJzaW9uLFxuICAgICAgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2gsXG4gICAgICBsMUhhbmRsZXJzLFxuICAgICAgY29uc3RydWN0b3IsXG4gICAgICBieXRlY29kZVxuICAgIF0pXG4gICk7XG59XG5mdW5jdGlvbiBoYXNoRW50cnlQb2ludFNpZXJyYShkYXRhKSB7XG4gIGNvbnN0IGJhc2UgPSBkYXRhLmZsYXRNYXAoKGl0KSA9PiB7XG4gICAgcmV0dXJuIFtCaWdJbnQoaXQuc2VsZWN0b3IpLCBCaWdJbnQoaXQuZnVuY3Rpb25faWR4KV07XG4gIH0pO1xuICByZXR1cm4gcG9zZWlkb25IYXNoTWFueShiYXNlKTtcbn1cbmZ1bmN0aW9uIGhhc2hBYmkoc2llcnJhKSB7XG4gIGNvbnN0IGluZGVudFN0cmluZyA9IGZvcm1hdFNwYWNlcyhzdHJpbmdpZnkyKHNpZXJyYS5hYmksIG51bGwpKTtcbiAgcmV0dXJuIEJpZ0ludChhZGRIZXhQcmVmaXgoc3RhcmtDdXJ2ZS5rZWNjYWsodXRmOFRvQXJyYXkoaW5kZW50U3RyaW5nKSkudG9TdHJpbmcoMTYpKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlU2llcnJhQ29udHJhY3RDbGFzc0hhc2goc2llcnJhKSB7XG4gIGNvbnN0IENPTlRSQUNUX0NMQVNTX1ZFUlNJT04gPSBcIkNPTlRSQUNUX0NMQVNTX1YwLjEuMFwiO1xuICBjb25zdCBjb21waWxlZENsYXNzVmVyc2lvbiA9IEJpZ0ludChlbmNvZGVTaG9ydFN0cmluZyhDT05UUkFDVF9DTEFTU19WRVJTSU9OKSk7XG4gIGNvbnN0IGV4dGVybmFsRW50cnlQb2ludHNIYXNoID0gaGFzaEVudHJ5UG9pbnRTaWVycmEoc2llcnJhLmVudHJ5X3BvaW50c19ieV90eXBlLkVYVEVSTkFMKTtcbiAgY29uc3QgbDFIYW5kbGVycyA9IGhhc2hFbnRyeVBvaW50U2llcnJhKHNpZXJyYS5lbnRyeV9wb2ludHNfYnlfdHlwZS5MMV9IQU5ETEVSKTtcbiAgY29uc3QgY29uc3RydWN0b3IgPSBoYXNoRW50cnlQb2ludFNpZXJyYShzaWVycmEuZW50cnlfcG9pbnRzX2J5X3R5cGUuQ09OU1RSVUNUT1IpO1xuICBjb25zdCBhYmlIYXNoID0gaGFzaEFiaShzaWVycmEpO1xuICBjb25zdCBzaWVycmFQcm9ncmFtID0gcG9zZWlkb25IYXNoTWFueShzaWVycmEuc2llcnJhX3Byb2dyYW0ubWFwKChpdCkgPT4gQmlnSW50KGl0KSkpO1xuICByZXR1cm4gdG9IZXgoXG4gICAgcG9zZWlkb25IYXNoTWFueShbXG4gICAgICBjb21waWxlZENsYXNzVmVyc2lvbixcbiAgICAgIGV4dGVybmFsRW50cnlQb2ludHNIYXNoLFxuICAgICAgbDFIYW5kbGVycyxcbiAgICAgIGNvbnN0cnVjdG9yLFxuICAgICAgYWJpSGFzaCxcbiAgICAgIHNpZXJyYVByb2dyYW1cbiAgICBdKVxuICApO1xufVxuZnVuY3Rpb24gY29tcHV0ZUNvbnRyYWN0Q2xhc3NIYXNoKGNvbnRyYWN0KSB7XG4gIGNvbnN0IGNvbXBpbGVkQ29udHJhY3QgPSB0eXBlb2YgY29udHJhY3QgPT09IFwic3RyaW5nXCIgPyBwYXJzZTIoY29udHJhY3QpIDogY29udHJhY3Q7XG4gIGlmIChcInNpZXJyYV9wcm9ncmFtXCIgaW4gY29tcGlsZWRDb250cmFjdCkge1xuICAgIHJldHVybiBjb21wdXRlU2llcnJhQ29udHJhY3RDbGFzc0hhc2goY29tcGlsZWRDb250cmFjdCk7XG4gIH1cbiAgcmV0dXJuIGNvbXB1dGVMZWdhY3lDb250cmFjdENsYXNzSGFzaChjb21waWxlZENvbnRyYWN0KTtcbn1cblxuLy8gc3JjL3V0aWxzL3N0YXJrLnRzXG52YXIgc3RhcmtfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3RhcmtfZXhwb3J0cywge1xuICBjb21wcmVzc1Byb2dyYW06ICgpID0+IGNvbXByZXNzUHJvZ3JhbSxcbiAgZGVjb21wcmVzc1Byb2dyYW06ICgpID0+IGRlY29tcHJlc3NQcm9ncmFtLFxuICBlc3RpbWF0ZWRGZWVUb01heEZlZTogKCkgPT4gZXN0aW1hdGVkRmVlVG9NYXhGZWUsXG4gIGZvcm1hdFNpZ25hdHVyZTogKCkgPT4gZm9ybWF0U2lnbmF0dXJlLFxuICBtYWtlQWRkcmVzczogKCkgPT4gbWFrZUFkZHJlc3MsXG4gIHJhbmRvbUFkZHJlc3M6ICgpID0+IHJhbmRvbUFkZHJlc3MsXG4gIHNpZ25hdHVyZVRvRGVjaW1hbEFycmF5OiAoKSA9PiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheSxcbiAgc2lnbmF0dXJlVG9IZXhBcnJheTogKCkgPT4gc2lnbmF0dXJlVG9IZXhBcnJheVxufSk7XG5pbXBvcnQgeyBnZXRTdGFya0tleSwgdXRpbHMgfSBmcm9tIFwiQHNjdXJlL3N0YXJrbmV0XCI7XG5pbXBvcnQgeyBnemlwLCB1bmd6aXAgfSBmcm9tIFwicGFrb1wiO1xuZnVuY3Rpb24gY29tcHJlc3NQcm9ncmFtKGpzb25Qcm9ncmFtKSB7XG4gIGNvbnN0IHN0cmluZ2lmaWVkID0gdHlwZW9mIGpzb25Qcm9ncmFtID09PSBcInN0cmluZ1wiID8ganNvblByb2dyYW0gOiBzdHJpbmdpZnkyKGpzb25Qcm9ncmFtKTtcbiAgY29uc3QgY29tcHJlc3NlZFByb2dyYW0gPSBnemlwKHN0cmluZ2lmaWVkKTtcbiAgcmV0dXJuIGJ0b2FVbml2ZXJzYWwoY29tcHJlc3NlZFByb2dyYW0pO1xufVxuZnVuY3Rpb24gZGVjb21wcmVzc1Byb2dyYW0oYmFzZTY0Mikge1xuICBpZiAoQXJyYXkuaXNBcnJheShiYXNlNjQyKSlcbiAgICByZXR1cm4gYmFzZTY0MjtcbiAgY29uc3QgZGVjb21wcmVzc2VkID0gYXJyYXlCdWZmZXJUb1N0cmluZyh1bmd6aXAoYXRvYlVuaXZlcnNhbChiYXNlNjQyKSkpO1xuICByZXR1cm4gcGFyc2UyKGRlY29tcHJlc3NlZCk7XG59XG5mdW5jdGlvbiByYW5kb21BZGRyZXNzKCkge1xuICBjb25zdCByYW5kb21LZXlQYWlyID0gdXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICByZXR1cm4gZ2V0U3RhcmtLZXkocmFuZG9tS2V5UGFpcik7XG59XG5mdW5jdGlvbiBtYWtlQWRkcmVzcyhpbnB1dCkge1xuICByZXR1cm4gYWRkSGV4UHJlZml4KGlucHV0KS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gZm9ybWF0U2lnbmF0dXJlKHNpZykge1xuICBpZiAoIXNpZylcbiAgICB0aHJvdyBFcnJvcihcImZvcm1hdFNpZ25hdHVyZTogcHJvdmlkZWQgc2lnbmF0dXJlIGlzIHVuZGVmaW5lZFwiKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2lnKSkge1xuICAgIHJldHVybiBzaWcubWFwKChpdCkgPT4gdG9IZXgoaXQpKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHsgciwgcyB9ID0gc2lnO1xuICAgIHJldHVybiBbdG9IZXgociksIHRvSGV4KHMpXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ25hdHVyZSBuZWVkIHRvIGJlIHdlaWVyc3RyYXNzLlNpZ25hdHVyZVR5cGUgb3IgYW4gYXJyYXkgZm9yIGN1c3RvbVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXkoc2lnKSB7XG4gIHJldHVybiBiaWdOdW1iZXJpc2hBcnJheVRvRGVjaW1hbFN0cmluZ0FycmF5KGZvcm1hdFNpZ25hdHVyZShzaWcpKTtcbn1cbmZ1bmN0aW9uIHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnKSB7XG4gIHJldHVybiBiaWdOdW1iZXJpc2hBcnJheVRvSGV4YWRlY2ltYWxTdHJpbmdBcnJheShmb3JtYXRTaWduYXR1cmUoc2lnKSk7XG59XG5mdW5jdGlvbiBlc3RpbWF0ZWRGZWVUb01heEZlZShlc3RpbWF0ZWRGZWUsIG92ZXJoZWFkID0gMC41KSB7XG4gIGNvbnN0IG92ZXJIZWFkUGVyY2VudCA9IE1hdGgucm91bmQoKDEgKyBvdmVyaGVhZCkgKiAxMDApO1xuICByZXR1cm4gdG9CaWdJbnQoZXN0aW1hdGVkRmVlKSAqIHRvQmlnSW50KG92ZXJIZWFkUGVyY2VudCkgLyAxMDBuO1xufVxuXG4vLyBzcmMvdXRpbHMvY29udHJhY3QudHNcbmZ1bmN0aW9uIGlzU2llcnJhKGNvbnRyYWN0KSB7XG4gIGNvbnN0IGNvbXBpbGVkQ29udHJhY3QgPSB0eXBlb2YgY29udHJhY3QgPT09IFwic3RyaW5nXCIgPyBwYXJzZTIoY29udHJhY3QpIDogY29udHJhY3Q7XG4gIHJldHVybiBcInNpZXJyYV9wcm9ncmFtXCIgaW4gY29tcGlsZWRDb250cmFjdDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKSB7XG4gIGNvbnN0IHJlc3BvbnNlID0geyAuLi5wYXlsb2FkIH07XG4gIGlmIChpc1NpZXJyYShwYXlsb2FkLmNvbnRyYWN0KSkge1xuICAgIGlmICghcGF5bG9hZC5jb21waWxlZENsYXNzSGFzaCAmJiBwYXlsb2FkLmNhc20pIHtcbiAgICAgIHJlc3BvbnNlLmNvbXBpbGVkQ2xhc3NIYXNoID0gY29tcHV0ZUNvbXBpbGVkQ2xhc3NIYXNoKHBheWxvYWQuY2FzbSk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuY29tcGlsZWRDbGFzc0hhc2gpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRXh0cmFjdCBjb21waWxlZENsYXNzSGFzaCBmYWlsZWQsIHByb3ZpZGUgKENhaXJvQXNzZW1ibHkpLmNhc20gZmlsZSBvciBjb21waWxlZENsYXNzSGFzaFwiXG4gICAgICApO1xuICB9XG4gIHJlc3BvbnNlLmNsYXNzSGFzaCA9IHBheWxvYWQuY2xhc3NIYXNoID8/IGNvbXB1dGVDb250cmFjdENsYXNzSGFzaChwYXlsb2FkLmNvbnRyYWN0KTtcbiAgaWYgKCFyZXNwb25zZS5jbGFzc0hhc2gpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXh0cmFjdCBjbGFzc0hhc2ggZmFpbGVkLCBwcm92aWRlIChDb21waWxlZENvbnRyYWN0KS5qc29uIGZpbGUgb3IgY2xhc3NIYXNoXCIpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59XG5mdW5jdGlvbiBjb250cmFjdENsYXNzUmVzcG9uc2VUb0xlZ2FjeUNvbXBpbGVkQ29udHJhY3QoY2NyKSB7XG4gIGlmIChpc1NpZXJyYShjY3IpKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJDb250cmFjdENsYXNzUmVzcG9uc2UgbmVlZCB0byBiZSBMZWdhY3lDb250cmFjdENsYXNzIChjYWlybzAgcmVzcG9uc2UgY2xhc3MpXCIpO1xuICB9XG4gIGNvbnN0IGNvbnRyYWN0ID0gY2NyO1xuICByZXR1cm4geyAuLi5jb250cmFjdCwgcHJvZ3JhbTogZGVjb21wcmVzc1Byb2dyYW0oY29udHJhY3QucHJvZ3JhbSkgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2ZldGNoUG9ueWZpbGwudHNcbmltcG9ydCBpc29tb3JwaGljRmV0Y2ggZnJvbSBcImlzb21vcnBoaWMtZmV0Y2hcIjtcbnZhciBmZXRjaFBvbnlmaWxsX2RlZmF1bHQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5mZXRjaCB8fCAvLyB1c2UgYnVpbGRpbiBmZXRjaCBpbiBicm93c2VyIGlmIGF2YWlsYWJsZVxudHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuZmV0Y2ggfHwgLy8gdXNlIGJ1aWxkaW4gZmV0Y2ggaW4gbm9kZSwgcmVhY3QtbmF0aXZlIGFuZCBzZXJ2aWNlIHdvcmtlciBpZiBhdmFpbGFibGVcbmlzb21vcnBoaWNGZXRjaDtcblxuLy8gc3JjL3V0aWxzL3Byb3ZpZGVyLnRzXG52YXIgcHJvdmlkZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocHJvdmlkZXJfZXhwb3J0cywge1xuICBjcmVhdGVTaWVycmFDb250cmFjdENsYXNzOiAoKSA9PiBjcmVhdGVTaWVycmFDb250cmFjdENsYXNzLFxuICBwYXJzZUNvbnRyYWN0OiAoKSA9PiBwYXJzZUNvbnRyYWN0LFxuICB3YWl0OiAoKSA9PiB3YWl0XG59KTtcbmZ1bmN0aW9uIHdhaXQoZGVsYXkpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICBzZXRUaW1lb3V0KHJlcywgZGVsYXkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNpZXJyYUNvbnRyYWN0Q2xhc3MoY29udHJhY3QpIHtcbiAgY29uc3QgcmVzdWx0ID0geyAuLi5jb250cmFjdCB9O1xuICBkZWxldGUgcmVzdWx0LnNpZXJyYV9wcm9ncmFtX2RlYnVnX2luZm87XG4gIHJlc3VsdC5hYmkgPSBmb3JtYXRTcGFjZXMoc3RyaW5naWZ5Mihjb250cmFjdC5hYmkpKTtcbiAgcmVzdWx0LnNpZXJyYV9wcm9ncmFtID0gZm9ybWF0U3BhY2VzKHN0cmluZ2lmeTIoY29udHJhY3Quc2llcnJhX3Byb2dyYW0pKTtcbiAgcmVzdWx0LnNpZXJyYV9wcm9ncmFtID0gY29tcHJlc3NQcm9ncmFtKHJlc3VsdC5zaWVycmFfcHJvZ3JhbSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUNvbnRyYWN0KGNvbnRyYWN0KSB7XG4gIGNvbnN0IHBhcnNlZENvbnRyYWN0ID0gdHlwZW9mIGNvbnRyYWN0ID09PSBcInN0cmluZ1wiID8gcGFyc2UyKGNvbnRyYWN0KSA6IGNvbnRyYWN0O1xuICBpZiAoIWlzU2llcnJhKGNvbnRyYWN0KSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5wYXJzZWRDb250cmFjdCxcbiAgICAgIC4uLlwicHJvZ3JhbVwiIGluIHBhcnNlZENvbnRyYWN0ICYmIHsgcHJvZ3JhbTogY29tcHJlc3NQcm9ncmFtKHBhcnNlZENvbnRyYWN0LnByb2dyYW0pIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBjcmVhdGVTaWVycmFDb250cmFjdENsYXNzKHBhcnNlZENvbnRyYWN0KTtcbn1cblxuLy8gc3JjL3V0aWxzL3Jlc3BvbnNlUGFyc2VyL3JwYy50c1xudmFyIFJQQ1Jlc3BvbnNlUGFyc2VyID0gY2xhc3Mge1xuICBwYXJzZUdldEJsb2NrUmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRpbWVzdGFtcDogcmVzLnRpbWVzdGFtcCxcbiAgICAgIGJsb2NrX2hhc2g6IFwiYmxvY2tfaGFzaFwiIGluIHJlcyA/IHJlcy5ibG9ja19oYXNoIDogXCJcIixcbiAgICAgIGJsb2NrX251bWJlcjogXCJibG9ja19udW1iZXJcIiBpbiByZXMgPyByZXMuYmxvY2tfbnVtYmVyIDogLTEsXG4gICAgICBuZXdfcm9vdDogXCJuZXdfcm9vdFwiIGluIHJlcyA/IHJlcy5uZXdfcm9vdCA6IFwiXCIsXG4gICAgICBwYXJlbnRfaGFzaDogcmVzLnBhcmVudF9oYXNoLFxuICAgICAgc3RhdHVzOiBcInN0YXR1c1wiIGluIHJlcyA/IHJlcy5zdGF0dXMgOiBcIlBFTkRJTkdcIiAvKiBQRU5ESU5HICovLFxuICAgICAgdHJhbnNhY3Rpb25zOiByZXMudHJhbnNhY3Rpb25zXG4gICAgfTtcbiAgfVxuICBwYXJzZUdldFRyYW5zYWN0aW9uUmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbGxkYXRhOiBcImNhbGxkYXRhXCIgaW4gcmVzID8gcmVzLmNhbGxkYXRhIDogW10sXG4gICAgICBjb250cmFjdF9hZGRyZXNzOiBcImNvbnRyYWN0X2FkZHJlc3NcIiBpbiByZXMgPyByZXMuY29udHJhY3RfYWRkcmVzcyA6IFwiXCIsXG4gICAgICBzZW5kZXJfYWRkcmVzczogXCJzZW5kZXJfYWRkcmVzc1wiIGluIHJlcyA/IHJlcy5zZW5kZXJfYWRkcmVzcyA6IFwiXCIsXG4gICAgICBtYXhfZmVlOiBcIm1heF9mZWVcIiBpbiByZXMgPyByZXMubWF4X2ZlZSA6IFwiXCIsXG4gICAgICBub25jZTogXCJub25jZVwiIGluIHJlcyA/IHJlcy5ub25jZSA6IFwiXCIsXG4gICAgICBzaWduYXR1cmU6IFwic2lnbmF0dXJlXCIgaW4gcmVzID8gcmVzLnNpZ25hdHVyZSA6IFtdLFxuICAgICAgdHJhbnNhY3Rpb25faGFzaDogcmVzLnRyYW5zYWN0aW9uX2hhc2gsXG4gICAgICB2ZXJzaW9uOiByZXMudmVyc2lvblxuICAgIH07XG4gIH1cbiAgcGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICBvdmVyYWxsX2ZlZTogdG9CaWdJbnQocmVzWzBdLm92ZXJhbGxfZmVlKSxcbiAgICAgIGdhc19jb25zdW1lZDogdG9CaWdJbnQocmVzWzBdLmdhc19jb25zdW1lZCksXG4gICAgICBnYXNfcHJpY2U6IHRvQmlnSW50KHJlc1swXS5nYXNfcHJpY2UpXG4gICAgfTtcbiAgfVxuICBwYXJzZUZlZUVzdGltYXRlQnVsa1Jlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiByZXMubWFwKCh2YWwpID0+ICh7XG4gICAgICBvdmVyYWxsX2ZlZTogdG9CaWdJbnQodmFsLm92ZXJhbGxfZmVlKSxcbiAgICAgIGdhc19jb25zdW1lZDogdG9CaWdJbnQodmFsLmdhc19jb25zdW1lZCksXG4gICAgICBnYXNfcHJpY2U6IHRvQmlnSW50KHZhbC5nYXNfcHJpY2UpXG4gICAgfSkpO1xuICB9XG4gIHBhcnNlQ2FsbENvbnRyYWN0UmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogcmVzXG4gICAgfTtcbiAgfVxuICBwYXJzZVNpbXVsYXRlVHJhbnNhY3Rpb25SZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4gcmVzLm1hcCgoaXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLml0LFxuICAgICAgICBzdWdnZXN0ZWRNYXhGZWU6IGVzdGltYXRlZEZlZVRvTWF4RmVlKEJpZ0ludChpdC5mZWVfZXN0aW1hdGlvbi5vdmVyYWxsX2ZlZSkpXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIHBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXMsXG4gICAgICBhYmk6IHR5cGVvZiByZXMuYWJpID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZShyZXMuYWJpKSA6IHJlcy5hYmlcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvZXJyb3JzLnRzXG5mdW5jdGlvbiBmaXhTdGFjayh0YXJnZXQsIGZuID0gdGFyZ2V0LmNvbnN0cnVjdG9yKSB7XG4gIGNvbnN0IHsgY2FwdHVyZVN0YWNrVHJhY2UgfSA9IEVycm9yO1xuICBjYXB0dXJlU3RhY2tUcmFjZSAmJiBjYXB0dXJlU3RhY2tUcmFjZSh0YXJnZXQsIGZuKTtcbn1cbmZ1bmN0aW9uIGZpeFByb3RvKHRhcmdldCwgcHJvdG90eXBlKSB7XG4gIGNvbnN0IHsgc2V0UHJvdG90eXBlT2YgfSA9IE9iamVjdDtcbiAgc2V0UHJvdG90eXBlT2YgPyBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvdHlwZSkgOiB0YXJnZXQuX19wcm90b19fID0gcHJvdG90eXBlO1xufVxudmFyIEN1c3RvbUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIHZhbHVlOiBuZXcudGFyZ2V0Lm5hbWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGZpeFByb3RvKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICBmaXhTdGFjayh0aGlzKTtcbiAgfVxufTtcbnZhciBMaWJyYXJ5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEN1c3RvbUVycm9yIHtcbn07XG52YXIgR2F0ZXdheUVycm9yID0gY2xhc3MgZXh0ZW5kcyBMaWJyYXJ5RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvckNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmVycm9yQ29kZSA9IGVycm9yQ29kZTtcbiAgfVxufTtcbnZhciBIdHRwRXJyb3IgPSBjbGFzcyBleHRlbmRzIExpYnJhcnlFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGVycm9yQ29kZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuZXJyb3JDb2RlID0gZXJyb3JDb2RlO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvc3RhcmtuZXRJZC50c1xudmFyIHN0YXJrbmV0SWRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3RhcmtuZXRJZF9leHBvcnRzLCB7XG4gIFN0YXJrbmV0SWRDb250cmFjdDogKCkgPT4gU3RhcmtuZXRJZENvbnRyYWN0LFxuICBnZXRTdGFya25ldElkQ29udHJhY3Q6ICgpID0+IGdldFN0YXJrbmV0SWRDb250cmFjdCxcbiAgdXNlRGVjb2RlZDogKCkgPT4gdXNlRGVjb2RlZCxcbiAgdXNlRW5jb2RlZDogKCkgPT4gdXNlRW5jb2RlZFxufSk7XG52YXIgYmFzaWNBbHBoYWJldCA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LVwiO1xudmFyIGJhc2ljU2l6ZVBsdXNPbmUgPSBCaWdJbnQoYmFzaWNBbHBoYWJldC5sZW5ndGggKyAxKTtcbnZhciBiaWdBbHBoYWJldCA9IFwiXFx1OEZEOVxcdTY3NjVcIjtcbnZhciBiYXNpY0FscGhhYmV0U2l6ZSA9IEJpZ0ludChiYXNpY0FscGhhYmV0Lmxlbmd0aCk7XG52YXIgYmlnQWxwaGFiZXRTaXplID0gQmlnSW50KGJpZ0FscGhhYmV0Lmxlbmd0aCk7XG52YXIgYmlnQWxwaGFiZXRTaXplUGx1c09uZSA9IEJpZ0ludChiaWdBbHBoYWJldC5sZW5ndGggKyAxKTtcbmZ1bmN0aW9uIGV4dHJhY3RTdGFycyhzdHIpIHtcbiAgbGV0IGsgPSAwO1xuICB3aGlsZSAoc3RyLmVuZHNXaXRoKGJpZ0FscGhhYmV0W2JpZ0FscGhhYmV0Lmxlbmd0aCAtIDFdKSkge1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICAgIGsgKz0gMTtcbiAgfVxuICByZXR1cm4gW3N0ciwga107XG59XG5mdW5jdGlvbiB1c2VEZWNvZGVkKGVuY29kZWQpIHtcbiAgbGV0IGRlY29kZWQgPSBcIlwiO1xuICBlbmNvZGVkLmZvckVhY2goKHN1YmRvbWFpbikgPT4ge1xuICAgIHdoaWxlIChzdWJkb21haW4gIT09IFpFUk8pIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBzdWJkb21haW4gJSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgc3ViZG9tYWluIC89IGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICBpZiAoY29kZSA9PT0gQmlnSW50KGJhc2ljQWxwaGFiZXQubGVuZ3RoKSkge1xuICAgICAgICBjb25zdCBuZXh0U3ViZG9tYWluID0gc3ViZG9tYWluIC8gYmlnQWxwaGFiZXRTaXplUGx1c09uZTtcbiAgICAgICAgaWYgKG5leHRTdWJkb21haW4gPT09IFpFUk8pIHtcbiAgICAgICAgICBjb25zdCBjb2RlMiA9IHN1YmRvbWFpbiAlIGJpZ0FscGhhYmV0U2l6ZVBsdXNPbmU7XG4gICAgICAgICAgc3ViZG9tYWluID0gbmV4dFN1YmRvbWFpbjtcbiAgICAgICAgICBpZiAoY29kZTIgPT09IFpFUk8pXG4gICAgICAgICAgICBkZWNvZGVkICs9IGJhc2ljQWxwaGFiZXRbMF07XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVjb2RlZCArPSBiaWdBbHBoYWJldFtOdW1iZXIoY29kZTIpIC0gMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgY29kZTIgPSBzdWJkb21haW4gJSBiaWdBbHBoYWJldFNpemU7XG4gICAgICAgICAgZGVjb2RlZCArPSBiaWdBbHBoYWJldFtOdW1iZXIoY29kZTIpXTtcbiAgICAgICAgICBzdWJkb21haW4gLz0gYmlnQWxwaGFiZXRTaXplO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgZGVjb2RlZCArPSBiYXNpY0FscGhhYmV0W051bWJlcihjb2RlKV07XG4gICAgfVxuICAgIGNvbnN0IFtzdHIsIGtdID0gZXh0cmFjdFN0YXJzKGRlY29kZWQpO1xuICAgIGlmIChrKVxuICAgICAgZGVjb2RlZCA9IHN0ciArIChrICUgMiA9PT0gMCA/IGJpZ0FscGhhYmV0W2JpZ0FscGhhYmV0Lmxlbmd0aCAtIDFdLnJlcGVhdChrIC8gMiAtIDEpICsgYmlnQWxwaGFiZXRbMF0gKyBiYXNpY0FscGhhYmV0WzFdIDogYmlnQWxwaGFiZXRbYmlnQWxwaGFiZXQubGVuZ3RoIC0gMV0ucmVwZWF0KChrIC0gMSkgLyAyICsgMSkpO1xuICAgIGRlY29kZWQgKz0gXCIuXCI7XG4gIH0pO1xuICBpZiAoIWRlY29kZWQpIHtcbiAgICByZXR1cm4gZGVjb2RlZDtcbiAgfVxuICByZXR1cm4gZGVjb2RlZC5jb25jYXQoXCJzdGFya1wiKTtcbn1cbmZ1bmN0aW9uIHVzZUVuY29kZWQoZGVjb2RlZCkge1xuICBsZXQgZW5jb2RlZCA9IEJpZ0ludCgwKTtcbiAgbGV0IG11bHRpcGxpZXIgPSBCaWdJbnQoMSk7XG4gIGlmIChkZWNvZGVkLmVuZHNXaXRoKGJpZ0FscGhhYmV0WzBdICsgYmFzaWNBbHBoYWJldFsxXSkpIHtcbiAgICBjb25zdCBbc3RyLCBrXSA9IGV4dHJhY3RTdGFycyhkZWNvZGVkLnN1YnN0cmluZygwLCBkZWNvZGVkLmxlbmd0aCAtIDIpKTtcbiAgICBkZWNvZGVkID0gc3RyICsgYmlnQWxwaGFiZXRbYmlnQWxwaGFiZXQubGVuZ3RoIC0gMV0ucmVwZWF0KDIgKiAoayArIDEpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbc3RyLCBrXSA9IGV4dHJhY3RTdGFycyhkZWNvZGVkKTtcbiAgICBpZiAoaylcbiAgICAgIGRlY29kZWQgPSBzdHIgKyBiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXS5yZXBlYXQoMSArIDIgKiAoayAtIDEpKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBjaGFyID0gZGVjb2RlZFtpXTtcbiAgICBjb25zdCBpbmRleCA9IGJhc2ljQWxwaGFiZXQuaW5kZXhPZihjaGFyKTtcbiAgICBjb25zdCBibkluZGV4ID0gQmlnSW50KGJhc2ljQWxwaGFiZXQuaW5kZXhPZihjaGFyKSk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGkgPT09IGRlY29kZWQubGVuZ3RoIC0gMSAmJiBkZWNvZGVkW2ldID09PSBiYXNpY0FscGhhYmV0WzBdKSB7XG4gICAgICAgIGVuY29kZWQgKz0gbXVsdGlwbGllciAqIGJhc2ljQWxwaGFiZXRTaXplO1xuICAgICAgICBtdWx0aXBsaWVyICo9IGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICAgIG11bHRpcGxpZXIgKj0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuY29kZWQgKz0gbXVsdGlwbGllciAqIGJuSW5kZXg7XG4gICAgICAgIG11bHRpcGxpZXIgKj0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJpZ0FscGhhYmV0LmluZGV4T2YoY2hhcikgIT09IC0xKSB7XG4gICAgICBlbmNvZGVkICs9IG11bHRpcGxpZXIgKiBiYXNpY0FscGhhYmV0U2l6ZTtcbiAgICAgIG11bHRpcGxpZXIgKj0gYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIGNvbnN0IG5ld2lkID0gKGkgPT09IGRlY29kZWQubGVuZ3RoIC0gMSA/IDEgOiAwKSArIGJpZ0FscGhhYmV0LmluZGV4T2YoY2hhcik7XG4gICAgICBlbmNvZGVkICs9IG11bHRpcGxpZXIgKiBCaWdJbnQobmV3aWQpO1xuICAgICAgbXVsdGlwbGllciAqPSBiaWdBbHBoYWJldFNpemU7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmNvZGVkO1xufVxudmFyIFN0YXJrbmV0SWRDb250cmFjdCA9IC8qIEBfX1BVUkVfXyAqLyAoKFN0YXJrbmV0SWRDb250cmFjdDIpID0+IHtcbiAgU3RhcmtuZXRJZENvbnRyYWN0MltcIk1BSU5ORVRcIl0gPSBcIjB4NmFjNTk3ZjgxMTZmODg2ZmExYzk3YTIzZmE0ZTA4Mjk5OTc1ZWNhZjZiNTk4ODczY2E2NzkyYjliYmZiNjc4XCI7XG4gIFN0YXJrbmV0SWRDb250cmFjdDJbXCJURVNUTkVUXCJdID0gXCIweDNiYWIyNjhlOTMyZDJjZWNkMTk0NmYxMDBhZTY3Y2UzZGZmOWZkMjM0MTE5ZWEyZjZkYTU3ZDE2ZDI5ZmNlXCI7XG4gIHJldHVybiBTdGFya25ldElkQ29udHJhY3QyO1xufSkoU3RhcmtuZXRJZENvbnRyYWN0IHx8IHt9KTtcbmZ1bmN0aW9uIGdldFN0YXJrbmV0SWRDb250cmFjdChjaGFpbklkKSB7XG4gIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgIGNhc2UgXCIweDUzNGU1ZjRkNDE0OTRlXCIgLyogU05fTUFJTiAqLzpcbiAgICAgIHJldHVybiBcIjB4NmFjNTk3ZjgxMTZmODg2ZmExYzk3YTIzZmE0ZTA4Mjk5OTc1ZWNhZjZiNTk4ODczY2E2NzkyYjliYmZiNjc4XCIgLyogTUFJTk5FVCAqLztcbiAgICBjYXNlIFwiMHg1MzRlNWY0NzRmNDU1MjRjNDlcIiAvKiBTTl9HT0VSTEkgKi86XG4gICAgICByZXR1cm4gXCIweDNiYWIyNjhlOTMyZDJjZWNkMTk0NmYxMDBhZTY3Y2UzZGZmOWZkMjM0MTE5ZWEyZjZkYTU3ZDE2ZDI5ZmNlXCIgLyogVEVTVE5FVCAqLztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhcmtuZXQuaWQgaXMgbm90IHlldCBkZXBsb3llZCBvbiB0aGlzIG5ldHdvcmtcIik7XG4gIH1cbn1cblxuLy8gc3JjL3Byb3ZpZGVyL3N0YXJrbmV0SWQudHNcbmFzeW5jIGZ1bmN0aW9uIGdldFN0YXJrTmFtZShwcm92aWRlciwgYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICBjb25zdCBjaGFpbklkID0gYXdhaXQgcHJvdmlkZXIuZ2V0Q2hhaW5JZCgpO1xuICBjb25zdCBjb250cmFjdCA9IFN0YXJrbmV0SWRDb250cmFjdDIgPz8gZ2V0U3RhcmtuZXRJZENvbnRyYWN0KGNoYWluSWQpO1xuICB0cnkge1xuICAgIGNvbnN0IGhleERvbWFpbiA9IGF3YWl0IHByb3ZpZGVyLmNhbGxDb250cmFjdCh7XG4gICAgICBjb250cmFjdEFkZHJlc3M6IGNvbnRyYWN0LFxuICAgICAgZW50cnlwb2ludDogXCJhZGRyZXNzX3RvX2RvbWFpblwiLFxuICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoe1xuICAgICAgICBhZGRyZXNzXG4gICAgICB9KVxuICAgIH0pO1xuICAgIGNvbnN0IGRlY2ltYWxEb21haW4gPSBoZXhEb21haW4ucmVzdWx0Lm1hcCgoZWxlbWVudCkgPT4gQmlnSW50KGVsZW1lbnQpKS5zbGljZSgxKTtcbiAgICBjb25zdCBzdHJpbmdEb21haW4gPSB1c2VEZWNvZGVkKGRlY2ltYWxEb21haW4pO1xuICAgIGlmICghc3RyaW5nRG9tYWluKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIlN0YXJrbmFtZSBub3QgZm91bmRcIik7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdEb21haW47XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZSA9PT0gXCJTdGFya25hbWUgbm90IGZvdW5kXCIpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHRocm93IEVycm9yKFwiQ291bGQgbm90IGdldCBzdGFyayBuYW1lXCIpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBZGRyZXNzRnJvbVN0YXJrTmFtZShwcm92aWRlciwgbmFtZSwgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICBjb25zdCBjaGFpbklkID0gYXdhaXQgcHJvdmlkZXIuZ2V0Q2hhaW5JZCgpO1xuICBjb25zdCBjb250cmFjdCA9IFN0YXJrbmV0SWRDb250cmFjdDIgPz8gZ2V0U3RhcmtuZXRJZENvbnRyYWN0KGNoYWluSWQpO1xuICB0cnkge1xuICAgIGNvbnN0IGFkZHJlc3NEYXRhID0gYXdhaXQgcHJvdmlkZXIuY2FsbENvbnRyYWN0KHtcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogY29udHJhY3QsXG4gICAgICBlbnRyeXBvaW50OiBcImRvbWFpbl90b19hZGRyZXNzXCIsXG4gICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZSh7XG4gICAgICAgIGRvbWFpbjogW3VzZUVuY29kZWQobmFtZS5yZXBsYWNlKFwiLnN0YXJrXCIsIFwiXCIpKS50b1N0cmluZygxMCldXG4gICAgICB9KVxuICAgIH0pO1xuICAgIHJldHVybiBhZGRyZXNzRGF0YS5yZXN1bHRbMF07XG4gIH0gY2F0Y2gge1xuICAgIHRocm93IEVycm9yKFwiQ291bGQgbm90IGdldCBhZGRyZXNzIGZyb20gc3RhcmsgbmFtZVwiKTtcbiAgfVxufVxuXG4vLyBzcmMvcHJvdmlkZXIvdXRpbHMudHNcbnZhciB2YWxpZEJsb2NrVGFncyA9IE9iamVjdC52YWx1ZXMoQmxvY2tUYWcpO1xudmFyIEJsb2NrID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfaWRlbnRpZmllcikge1xuICAgIHRoaXMuaGFzaCA9IG51bGw7XG4gICAgdGhpcy5udW1iZXIgPSBudWxsO1xuICAgIHRoaXMudGFnID0gbnVsbDtcbiAgICB0aGlzLnZhbHVlT2YgPSAoKSA9PiB0aGlzLm51bWJlcjtcbiAgICB0aGlzLnRvU3RyaW5nID0gKCkgPT4gdGhpcy5oYXNoO1xuICAgIHRoaXMuc2V0SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG4gIH1cbiAgc2V0SWRlbnRpZmllcihfX2lkZW50aWZpZXIpIHtcbiAgICBpZiAodHlwZW9mIF9faWRlbnRpZmllciA9PT0gXCJzdHJpbmdcIiAmJiBpc0hleChfX2lkZW50aWZpZXIpKSB7XG4gICAgICB0aGlzLmhhc2ggPSBfX2lkZW50aWZpZXI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgX19pZGVudGlmaWVyID09PSBcImJpZ2ludFwiKSB7XG4gICAgICB0aGlzLmhhc2ggPSB0b0hleChfX2lkZW50aWZpZXIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIF9faWRlbnRpZmllciA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdGhpcy5udW1iZXIgPSBfX2lkZW50aWZpZXI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgX19pZGVudGlmaWVyID09PSBcInN0cmluZ1wiICYmIHZhbGlkQmxvY2tUYWdzLmluY2x1ZGVzKF9faWRlbnRpZmllcikpIHtcbiAgICAgIHRoaXMudGFnID0gX19pZGVudGlmaWVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhZyA9IFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi87XG4gICAgfVxuICB9XG4gIC8vIFRPRE86IGZpeCBhbnlcbiAgZ2V0IHF1ZXJ5SWRlbnRpZmllcigpIHtcbiAgICBpZiAodGhpcy5udW1iZXIgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBgYmxvY2tOdW1iZXI9JHt0aGlzLm51bWJlcn1gO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNoICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYGJsb2NrSGFzaD0ke3RoaXMuaGFzaH1gO1xuICAgIH1cbiAgICByZXR1cm4gYGJsb2NrTnVtYmVyPSR7dGhpcy50YWd9YDtcbiAgfVxuICAvLyBUT0RPOiBmaXggYW55XG4gIGdldCBpZGVudGlmaWVyKCkge1xuICAgIGlmICh0aGlzLm51bWJlciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgYmxvY2tfbnVtYmVyOiB0aGlzLm51bWJlciB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNoICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBibG9ja19oYXNoOiB0aGlzLmhhc2ggfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGFnO1xuICB9XG4gIHNldCBpZGVudGlmaWVyKF9pZGVudGlmaWVyKSB7XG4gICAgdGhpcy5zZXRJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcbiAgfVxuICBnZXQgc2VxdWVuY2VySWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNoICE9PSBudWxsID8geyBibG9ja0hhc2g6IHRoaXMuaGFzaCB9IDogeyBibG9ja051bWJlcjogdGhpcy5udW1iZXIgPz8gdGhpcy50YWcgfTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3ZpZGVyL3JwYy50c1xudmFyIGdldERlZmF1bHROb2RlVXJsID0gKG5ldHdvcmtOYW1lLCBtdXRlID0gZmFsc2UpID0+IHtcbiAgaWYgKCFtdXRlKVxuICAgIGNvbnNvbGUud2FybihcIlVzaW5nIGRlZmF1bHQgcHVibGljIG5vZGUgdXJsLCBwbGVhc2UgcHJvdmlkZSBub2RlVXJsIGluIHByb3ZpZGVyIG9wdGlvbnMhXCIpO1xuICBjb25zdCBub2RlcyA9IG5ldHdvcmtOYW1lID09PSBcIlNOX01BSU5cIiAvKiBTTl9NQUlOICovID8gUlBDX01BSU5ORVRfTk9ERVMgOiBSUENfR09FUkxJX05PREVTO1xuICBjb25zdCByYW5kSWR4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZXMubGVuZ3RoKTtcbiAgcmV0dXJuIG5vZGVzW3JhbmRJZHhdO1xufTtcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICBibG9ja0lkZW50aWZpZXI6IFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi8sXG4gIHJldHJpZXM6IDIwMFxufTtcbnZhciBScGNQcm92aWRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9uc09yUHJvdmlkZXIpIHtcbiAgICB0aGlzLnJlc3BvbnNlUGFyc2VyID0gbmV3IFJQQ1Jlc3BvbnNlUGFyc2VyKCk7XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCk7ICh3aWxsIGJlIHJlbW92ZWQgaW4gbmV4dCBtaW5vciB2ZXJzaW9uKVxuICAgICAqL1xuICAgIHRoaXMuZ2V0QmxvY2tIYXNoQW5kTnVtYmVyID0gdGhpcy5nZXRCbG9ja0xhdGVzdEFjY2VwdGVkO1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8gZ2V0QmxvY2tTdGF0ZVVwZGF0ZSgpO1xuICAgICAqL1xuICAgIHRoaXMuZ2V0U3RhdGVVcGRhdGUgPSB0aGlzLmdldEJsb2NrU3RhdGVVcGRhdGU7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZXhlY3V0aW9uIHRyYWNlcyBvZiBhbGwgdHJhbnNhY3Rpb25zIGluY2x1ZGVkIGluIHRoZSBnaXZlbiBibG9ja1xuICAgICAqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8gZ2V0QmxvY2tUcmFuc2FjdGlvbnNUcmFjZXMoKVxuICAgICAqL1xuICAgIHRoaXMudHJhY2VCbG9ja1RyYW5zYWN0aW9ucyA9IHRoaXMuZ2V0QmxvY2tUcmFuc2FjdGlvbnNUcmFjZXM7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgdHJhbnNhY3Rpb25zIGluIGEgYmxvY2sgZ2l2ZW4gYSBibG9jayBpZFxuICAgICAqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8gZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50KClcbiAgICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgdHJhbnNhY3Rpb25zXG4gICAgICovXG4gICAgdGhpcy5nZXRUcmFuc2FjdGlvbkNvdW50ID0gdGhpcy5nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnQ7XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byBnZXRUcmFuc2FjdGlvblRyYWNlKCk7XG4gICAgICogRm9yIGEgZ2l2ZW4gZXhlY3V0ZWQgdHJhbnNhY3Rpb24sIHJldHVybiB0aGUgdHJhY2Ugb2YgaXRzIGV4ZWN1dGlvbiwgaW5jbHVkaW5nIGludGVybmFsIGNhbGxzXG4gICAgICovXG4gICAgdGhpcy50cmFjZVRyYW5zYWN0aW9uID0gdGhpcy5nZXRUcmFuc2FjdGlvblRyYWNlO1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8gc2ltdWxhdGVUcmFuc2FjdGlvbigpO1xuICAgICAqL1xuICAgIHRoaXMuZ2V0U2ltdWxhdGVUcmFuc2FjdGlvbiA9IHRoaXMuc2ltdWxhdGVUcmFuc2FjdGlvbjtcbiAgICBjb25zdCB7IG5vZGVVcmwsIHJldHJpZXMsIGhlYWRlcnMsIGJsb2NrSWRlbnRpZmllciwgY2hhaW5JZCB9ID0gb3B0aW9uc09yUHJvdmlkZXIgfHwge307XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoTmV0d29ya05hbWUpLmluY2x1ZGVzKG5vZGVVcmwpKSB7XG4gICAgICB0aGlzLm5vZGVVcmwgPSBnZXREZWZhdWx0Tm9kZVVybChub2RlVXJsLCBvcHRpb25zT3JQcm92aWRlcj8uZGVmYXVsdCk7XG4gICAgfSBlbHNlIGlmIChub2RlVXJsKSB7XG4gICAgICB0aGlzLm5vZGVVcmwgPSBub2RlVXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vZGVVcmwgPSBnZXREZWZhdWx0Tm9kZVVybCh2b2lkIDAsIG9wdGlvbnNPclByb3ZpZGVyPy5kZWZhdWx0KTtcbiAgICB9XG4gICAgdGhpcy5yZXRyaWVzID0gcmV0cmllcyB8fCBkZWZhdWx0T3B0aW9ucy5yZXRyaWVzO1xuICAgIHRoaXMuaGVhZGVycyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMuaGVhZGVycywgLi4uaGVhZGVycyB9O1xuICAgIHRoaXMuYmxvY2tJZGVudGlmaWVyID0gYmxvY2tJZGVudGlmaWVyIHx8IGRlZmF1bHRPcHRpb25zLmJsb2NrSWRlbnRpZmllcjtcbiAgICB0aGlzLmNoYWluSWQgPSBjaGFpbklkO1xuICB9XG4gIGZldGNoKG1ldGhvZCwgcGFyYW1zLCBpZCA9IDApIHtcbiAgICBjb25zdCBycGNSZXF1ZXN0Qm9keSA9IHtcbiAgICAgIGlkLFxuICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgIG1ldGhvZCxcbiAgICAgIC4uLnBhcmFtcyAmJiB7IHBhcmFtcyB9XG4gICAgfTtcbiAgICByZXR1cm4gZmV0Y2hQb255ZmlsbF9kZWZhdWx0KHRoaXMubm9kZVVybCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IHN0cmluZ2lmeTIocnBjUmVxdWVzdEJvZHkpLFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgfSk7XG4gIH1cbiAgZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGFyYW1zLCBycGNFcnJvciwgb3RoZXJFcnJvcikge1xuICAgIGlmIChycGNFcnJvcikge1xuICAgICAgY29uc3QgeyBjb2RlLCBtZXNzYWdlLCBkYXRhIH0gPSBycGNFcnJvcjtcbiAgICAgIHRocm93IG5ldyBMaWJyYXJ5RXJyb3IoXG4gICAgICAgIGBSUEM6ICR7bWV0aG9kfSB3aXRoIHBhcmFtcyAke3N0cmluZ2lmeTIocGFyYW1zKX1cbiAke2NvZGV9OiAke21lc3NhZ2V9OiAke3N0cmluZ2lmeTIoZGF0YSl9YFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG90aGVyRXJyb3IgaW5zdGFuY2VvZiBMaWJyYXJ5RXJyb3IpIHtcbiAgICAgIHRocm93IG90aGVyRXJyb3I7XG4gICAgfVxuICAgIGlmIChvdGhlckVycm9yKSB7XG4gICAgICB0aHJvdyBFcnJvcihvdGhlckVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmZXRjaEVuZHBvaW50KG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhd1Jlc3VsdCA9IGF3YWl0IHRoaXMuZmV0Y2gobWV0aG9kLCBwYXJhbXMpO1xuICAgICAgY29uc3QgeyBlcnJvciwgcmVzdWx0IH0gPSBhd2FpdCByYXdSZXN1bHQuanNvbigpO1xuICAgICAgdGhpcy5lcnJvckhhbmRsZXIobWV0aG9kLCBwYXJhbXMsIGVycm9yKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGFyYW1zLCBlcnJvcj8ucmVzcG9uc2U/LmRhdGEsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgIHRoaXMuY2hhaW5JZCA/PyAodGhpcy5jaGFpbklkID0gYXdhaXQgdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfY2hhaW5JZFwiKSk7XG4gICAgcmV0dXJuIHRoaXMuY2hhaW5JZDtcbiAgfVxuICAvKipcbiAgICogTkVXOiBSZXR1cm5zIHRoZSB2ZXJzaW9uIG9mIHRoZSBTdGFya25ldCBKU09OLVJQQyBzcGVjaWZpY2F0aW9uIGJlaW5nIHVzZWRcbiAgICovXG4gIGFzeW5jIGdldFNwZWNWZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9zcGVjVmVyc2lvblwiKTtcbiAgfVxuICBhc3luYyBnZXROb25jZUZvckFkZHJlc3MoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Tm9uY2VcIiwge1xuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBnZXRCbG9ja1dpdGhUeEhhc2hlcyBvciBnZXRCbG9ja1dpdGhUeHMgKHdpbGwgYmUgcmVtb3ZlZCBvbiBzZXF1ZW5jZXIgZGVwcmVjYXRpb24pXG4gICAqL1xuICBhc3luYyBnZXRCbG9jayhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmdldEJsb2NrV2l0aFR4SGFzaGVzKGJsb2NrSWRlbnRpZmllcikudGhlbihcbiAgICAgIHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VHZXRCbG9ja1Jlc3BvbnNlXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBibG9jayBoYXNoIGFuZCBudW1iZXJcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2Jsb2NrSGFzaEFuZE51bWJlclwiKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgcmVkdW5kYW50IHVzZSBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCk7XG4gICAqIEdldCB0aGUgbW9zdCByZWNlbnQgYWNjZXB0ZWQgYmxvY2sgbnVtYmVyXG4gICAqIEByZXR1cm5zIE51bWJlciBvZiB0aGUgbGF0ZXN0IGJsb2NrXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYmxvY2tOdW1iZXJcIik7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tXaXRoVHhIYXNoZXMoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldEJsb2NrV2l0aFR4SGFzaGVzXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tXaXRoVHhzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1dpdGhUeHNcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBhc3luYyBnZXRCbG9ja1N0YXRlVXBkYXRlKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRTdGF0ZVVwZGF0ZVwiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGFzeW5jIGdldEJsb2NrVHJhbnNhY3Rpb25zVHJhY2VzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF90cmFjZUJsb2NrVHJhbnNhY3Rpb25zXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50KGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRyYW5zYWN0aW9ucyBmcm9tIHBlbmRpbmcgYmxvY2tcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCB1c2UgZ2V0QmxvY2soQmxvY2tUYWcucGVuZGluZyk7ICh3aWxsIGJlIHJlbW92ZWQgaW4gbmV4dCBtaW5vciB2ZXJzaW9uKVxuICAgKi9cbiAgYXN5bmMgZ2V0UGVuZGluZ1RyYW5zYWN0aW9ucygpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gYXdhaXQgdGhpcy5nZXRCbG9jayhcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodHJhbnNhY3Rpb25zLm1hcCgoaXQpID0+IHRoaXMuZ2V0VHJhbnNhY3Rpb25CeUhhc2goaXQpKSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBnZXRUcmFuc2FjdGlvbkJ5SGFzaCBvciBnZXRUcmFuc2FjdGlvbkJ5QmxvY2tJZEFuZEluZGV4ICh3aWxsIGJlIHJlbW92ZWQgb24gc2VxdWVuY2VyIGRlcHJlY2F0aW9uKVxuICAgKi9cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24odHhIYXNoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb25CeUhhc2godHhIYXNoKS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VHZXRUcmFuc2FjdGlvblJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvbkJ5SGFzaCh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIiwge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXgoYmxvY2tJZGVudGlmaWVyLCBpbmRleCkge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSWRBbmRJbmRleFwiLCB7IGJsb2NrX2lkLCBpbmRleCB9KTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25UcmFjZSh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfdHJhY2VUcmFuc2FjdGlvblwiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgLyoqXG4gICAqIE5FVzogR2V0IHRoZSBzdGF0dXMgb2YgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25TdGF0dXModHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uU3RhdHVzXCIsIHsgdHJhbnNhY3Rpb25faGFzaCB9KTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIGludm9jYXRpb25zIEFjY291bnRJbnZvY2F0aW9uc1xuICAgKiBAcGFyYW0gc2ltdWxhdGVUcmFuc2FjdGlvbk9wdGlvbnMgYmxvY2tJZGVudGlmaWVyIGFuZCBmbGFncyB0byBza2lwIHZhbGlkYXRpb24gYW5kIGZlZSBjaGFyZ2U8YnIvPlxuICAgKiAtIGJsb2NrSWRlbnRpZmllcjxici8+XG4gICAqIC0gc2tpcFZhbGlkYXRlIChkZWZhdWx0IGZhbHNlKTxici8+XG4gICAqIC0gc2tpcEZlZUNoYXJnZSAoZGVmYXVsdCB0cnVlKTxici8+XG4gICAqL1xuICBhc3luYyBzaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCB7XG4gICAgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIsXG4gICAgc2tpcFZhbGlkYXRlID0gZmFsc2UsXG4gICAgc2tpcEZlZUNoYXJnZSA9IHRydWVcbiAgfSkge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICBjb25zdCBzaW11bGF0aW9uRmxhZ3MgPSBbXTtcbiAgICBpZiAoc2tpcFZhbGlkYXRlKVxuICAgICAgc2ltdWxhdGlvbkZsYWdzLnB1c2gocnBjX2V4cG9ydHMuRVNpbXVsYXRpb25GbGFnLlNLSVBfVkFMSURBVEUpO1xuICAgIGlmIChza2lwRmVlQ2hhcmdlKVxuICAgICAgc2ltdWxhdGlvbkZsYWdzLnB1c2gocnBjX2V4cG9ydHMuRVNpbXVsYXRpb25GbGFnLlNLSVBfRkVFX0NIQVJHRSk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3NpbXVsYXRlVHJhbnNhY3Rpb25zXCIsIHtcbiAgICAgIGJsb2NrX2lkLFxuICAgICAgdHJhbnNhY3Rpb25zOiBpbnZvY2F0aW9ucy5tYXAoKGl0KSA9PiB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oaXQpKSxcbiAgICAgIHNpbXVsYXRpb25fZmxhZ3M6IHNpbXVsYXRpb25GbGFnc1xuICAgIH0pLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZVNpbXVsYXRlVHJhbnNhY3Rpb25SZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKHR4SGFzaCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgbGV0IHsgcmV0cmllcyB9ID0gdGhpcztcbiAgICBsZXQgb25jaGFpbiA9IGZhbHNlO1xuICAgIGxldCBpc0Vycm9yU3RhdGUgPSBmYWxzZTtcbiAgICBjb25zdCByZXRyeUludGVydmFsID0gb3B0aW9ucz8ucmV0cnlJbnRlcnZhbCA/PyA1ZTM7XG4gICAgY29uc3QgZXJyb3JTdGF0ZXMgPSBvcHRpb25zPy5lcnJvclN0YXRlcyA/PyBbXG4gICAgICBycGNfZXhwb3J0cy5FVHJhbnNhY3Rpb25TdGF0dXMuUkVKRUNURUQsXG4gICAgICBycGNfZXhwb3J0cy5FVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMuUkVWRVJURURcbiAgICBdO1xuICAgIGNvbnN0IHN1Y2Nlc3NTdGF0ZXMgPSBvcHRpb25zPy5zdWNjZXNzU3RhdGVzID8/IFtcbiAgICAgIHJwY19leHBvcnRzLkVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cy5TVUNDRUVERUQsXG4gICAgICBycGNfZXhwb3J0cy5FVHJhbnNhY3Rpb25TdGF0dXMuQUNDRVBURURfT05fTDIsXG4gICAgICBycGNfZXhwb3J0cy5FVHJhbnNhY3Rpb25TdGF0dXMuQUNDRVBURURfT05fTDFcbiAgICBdO1xuICAgIGxldCB0eFN0YXR1cztcbiAgICB3aGlsZSAoIW9uY2hhaW4pIHtcbiAgICAgIGF3YWl0IHdhaXQocmV0cnlJbnRlcnZhbCk7XG4gICAgICB0cnkge1xuICAgICAgICB0eFN0YXR1cyA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25TdGF0dXModHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uU3RhdHVzID0gdHhTdGF0dXMuZXhlY3V0aW9uX3N0YXR1cztcbiAgICAgICAgY29uc3QgZmluYWxpdHlTdGF0dXMgPSB0eFN0YXR1cy5maW5hbGl0eV9zdGF0dXM7XG4gICAgICAgIGlmICghZmluYWxpdHlTdGF0dXMpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIndhaXRpbmcgZm9yIHRyYW5zYWN0aW9uIHN0YXR1c1wiKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VjY2Vzc1N0YXRlcy5pbmNsdWRlcyhleGVjdXRpb25TdGF0dXMpIHx8IHN1Y2Nlc3NTdGF0ZXMuaW5jbHVkZXMoZmluYWxpdHlTdGF0dXMpKSB7XG4gICAgICAgICAgb25jaGFpbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3JTdGF0ZXMuaW5jbHVkZXMoZXhlY3V0aW9uU3RhdHVzKSB8fCBlcnJvclN0YXRlcy5pbmNsdWRlcyhmaW5hbGl0eVN0YXR1cykpIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYCR7ZXhlY3V0aW9uU3RhdHVzfTogJHtmaW5hbGl0eVN0YXR1c31gO1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIGVycm9yLnJlc3BvbnNlID0gdHhTdGF0dXM7XG4gICAgICAgICAgaXNFcnJvclN0YXRlID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgaXNFcnJvclN0YXRlKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldHJpZXMgPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgd2FpdEZvclRyYW5zYWN0aW9uIHRpbWVkLW91dCB3aXRoIHJldHJpZXMgJHt0aGlzLnJldHJpZXN9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHJpZXMgLT0gMTtcbiAgICB9XG4gICAgbGV0IHR4UmVjZWlwdCA9IG51bGw7XG4gICAgd2hpbGUgKHR4UmVjZWlwdCA9PT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHhSZWNlaXB0ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChyZXRyaWVzIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdhaXRGb3JUcmFuc2FjdGlvbiB0aW1lZC1vdXQgd2l0aCByZXRyaWVzICR7dGhpcy5yZXRyaWVzfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXRyaWVzIC09IDE7XG4gICAgICBhd2FpdCB3YWl0KHJldHJ5SW50ZXJ2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gdHhSZWNlaXB0O1xuICB9XG4gIGFzeW5jIGdldFN0b3JhZ2VBdChjb250cmFjdEFkZHJlc3MsIGtleSwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBwYXJzZWRLZXkgPSB0b1N0b3JhZ2VLZXkoa2V5KTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFN0b3JhZ2VBdFwiLCB7XG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAga2V5OiBwYXJzZWRLZXksXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldENsYXNzSGFzaEF0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldENsYXNzSGFzaEF0XCIsIHtcbiAgICAgIGJsb2NrX2lkLFxuICAgICAgY29udHJhY3RfYWRkcmVzc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQnlIYXNoKGNsYXNzSGFzaCkge1xuICAgIHJldHVybiB0aGlzLmdldENsYXNzKGNsYXNzSGFzaCk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3MoY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNsYXNzX2hhc2ggPSB0b0hleChjbGFzc0hhc2gpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Q2xhc3NcIiwge1xuICAgICAgY2xhc3NfaGFzaCxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldENsYXNzQXRcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICBjb250cmFjdF9hZGRyZXNzXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRDb2RlKF9jb250cmFjdEFkZHJlc3MsIF9ibG9ja0lkZW50aWZpZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSUEMgZG9lcyBub3QgaW1wbGVtZW50IGdldENvZGUgZnVuY3Rpb25cIik7XG4gIH1cbiAgYXN5bmMgZ2V0Q29udHJhY3RWZXJzaW9uKGNvbnRyYWN0QWRkcmVzcywgY2xhc3NIYXNoLCB7IGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBjb21waWxlciA9IHRydWUgfSA9IHt9KSB7XG4gICAgbGV0IGNvbnRyYWN0Q2xhc3M7XG4gICAgaWYgKGNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgY29udHJhY3RDbGFzcyA9IGF3YWl0IHRoaXMuZ2V0Q2xhc3NBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gICAgfSBlbHNlIGlmIChjbGFzc0hhc2gpIHtcbiAgICAgIGNvbnRyYWN0Q2xhc3MgPSBhd2FpdCB0aGlzLmdldENsYXNzKGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJnZXRDb250cmFjdFZlcnNpb24gcmVxdWlyZSBjb250cmFjdEFkZHJlc3Mgb3IgY2xhc3NIYXNoXCIpO1xuICAgIH1cbiAgICBpZiAoaXNTaWVycmEoY29udHJhY3RDbGFzcykpIHtcbiAgICAgIGlmIChjb21waWxlcikge1xuICAgICAgICBjb25zdCBhYmlUZXN0ID0gZ2V0QWJpQ29udHJhY3RWZXJzaW9uKGNvbnRyYWN0Q2xhc3MuYWJpKTtcbiAgICAgICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogYWJpVGVzdC5jb21waWxlciB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogdm9pZCAwIH07XG4gICAgfVxuICAgIHJldHVybiB7IGNhaXJvOiBcIjBcIiwgY29tcGlsZXI6IFwiMFwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBnZXQqdHlwZSpFc3RpbWF0ZUZlZSAod2lsbCBiZSByZWZhY3RvcmVkIGJhc2VkIG9uIHR5cGUgYWZ0ZXIgc2VxdWVuY2VyIGRlcHJlY2F0aW9uKVxuICAgKi9cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW52b2tlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0SW52b2tlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uKFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLyxcbiAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgLi4uaW52b2NhdGlvbkRldGFpbHNcbiAgICAgIH0sXG4gICAgICBcImZlZVwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVGZWVcIiwge1xuICAgICAgcmVxdWVzdDogW3RyYW5zYWN0aW9uXSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RGVjbGFyZUVzdGltYXRlRmVlKGludm9jYXRpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uKFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovLFxuICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9LFxuICAgICAgXCJmZWVcIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2VzdGltYXRlRmVlXCIsIHtcbiAgICAgIHJlcXVlc3Q6IFt0cmFuc2FjdGlvbl0sXG4gICAgICBibG9ja19pZFxuICAgIH0pLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldERlcGxveUFjY291bnRFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBkZXRhaWxzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovLFxuICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9LFxuICAgICAgXCJmZWVcIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2VzdGltYXRlRmVlXCIsIHtcbiAgICAgIHJlcXVlc3Q6IFt0cmFuc2FjdGlvbl0sXG4gICAgICBibG9ja19pZFxuICAgIH0pLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlQnVsayhpbnZvY2F0aW9ucywgeyBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gZmFsc2UgfSkge1xuICAgIGlmIChza2lwVmFsaWRhdGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcImdldEVzdGltYXRlRmVlQnVsayBSUEMgZG9lcyBub3Qgc3VwcG9ydCBza2lwVmFsaWRhdGVcIik7XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVGZWVcIiwge1xuICAgICAgcmVxdWVzdDogaW52b2NhdGlvbnMubWFwKChpdCkgPT4gdGhpcy5idWlsZFRyYW5zYWN0aW9uKGl0LCBcImZlZVwiKSksXG4gICAgICBibG9ja19pZFxuICAgIH0pLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlQnVsa1Jlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBpbnZva2VGdW5jdGlvbihmdW5jdGlvbkludm9jYXRpb24sIGRldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkSW52b2tlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgaW52b2tlX3RyYW5zYWN0aW9uOiB7XG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBmdW5jdGlvbkludm9jYXRpb24uY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoZnVuY3Rpb25JbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgdHlwZTogcnBjX2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICB2ZXJzaW9uOiBcIjB4MVwiLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoZnVuY3Rpb25JbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGRlY2xhcmVDb250cmFjdCh7IGNvbnRyYWN0LCBzaWduYXR1cmUsIHNlbmRlckFkZHJlc3MsIGNvbXBpbGVkQ2xhc3NIYXNoIH0sIGRldGFpbHMpIHtcbiAgICBpZiAoIWlzU2llcnJhKGNvbnRyYWN0KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlY2xhcmVfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBycGNfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAgIHByb2dyYW06IGNvbnRyYWN0LnByb2dyYW0sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVyc2lvbjogSEVYX1NUUl9UUkFOU0FDVElPTl9WRVJTSU9OXzEsXG4gICAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgIGRlY2xhcmVfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgdHlwZTogcnBjX2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERUNMQVJFLFxuICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgIHNpZXJyYV9wcm9ncmFtOiBkZWNvbXByZXNzUHJvZ3JhbShjb250cmFjdC5zaWVycmFfcHJvZ3JhbSksXG4gICAgICAgICAgY29udHJhY3RfY2xhc3NfdmVyc2lvbjogY29udHJhY3QuY29udHJhY3RfY2xhc3NfdmVyc2lvbixcbiAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgYWJpOiBjb250cmFjdC5hYmlcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGlsZWRfY2xhc3NfaGFzaDogY29tcGlsZWRDbGFzc0hhc2ggfHwgXCJcIixcbiAgICAgICAgdmVyc2lvbjogSEVYX1NUUl9UUkFOU0FDVElPTl9WRVJTSU9OXzIsXG4gICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgc2VuZGVyX2FkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGRlcGxveUFjY291bnRDb250cmFjdCh7IGNsYXNzSGFzaCwgY29uc3RydWN0b3JDYWxsZGF0YSwgYWRkcmVzc1NhbHQsIHNpZ25hdHVyZSB9LCBkZXRhaWxzKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlcGxveUFjY291bnRUcmFuc2FjdGlvblwiLCB7XG4gICAgICBkZXBsb3lfYWNjb3VudF90cmFuc2FjdGlvbjoge1xuICAgICAgICBjb25zdHJ1Y3Rvcl9jYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoY29uc3RydWN0b3JDYWxsZGF0YSB8fCBbXSksXG4gICAgICAgIGNsYXNzX2hhc2g6IHRvSGV4KGNsYXNzSGFzaCksXG4gICAgICAgIGNvbnRyYWN0X2FkZHJlc3Nfc2FsdDogdG9IZXgoYWRkcmVzc1NhbHQgfHwgMCksXG4gICAgICAgIHR5cGU6IHJwY19leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuREVQTE9ZX0FDQ09VTlQsXG4gICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChkZXRhaWxzLnZlcnNpb24gfHwgMCksXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBjYWxsQ29udHJhY3QoY2FsbCwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfY2FsbFwiLCB7XG4gICAgICByZXF1ZXN0OiB7XG4gICAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IGNhbGwuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcjogZ2V0U2VsZWN0b3JGcm9tTmFtZShjYWxsLmVudHJ5cG9pbnQpLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoY2FsbC5jYWxsZGF0YSlcbiAgICAgIH0sXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ2FsbENvbnRyYWN0UmVzcG9uc2UocmVzdWx0KTtcbiAgfVxuICAvKipcbiAgICogTkVXOiBFc3RpbWF0ZSB0aGUgZmVlIGZvciBhIG1lc3NhZ2UgZnJvbSBMMVxuICAgKiBAcGFyYW0gbWVzc2FnZSBNZXNzYWdlIEZyb20gTDFcbiAgICovXG4gIGFzeW5jIGVzdGltYXRlTWVzc2FnZUZlZShtZXNzYWdlLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IHsgZnJvbV9hZGRyZXNzLCB0b19hZGRyZXNzLCBlbnRyeV9wb2ludF9zZWxlY3RvciwgcGF5bG9hZCB9ID0gbWVzc2FnZTtcbiAgICBjb25zdCBmb3JtYXR0ZWRNZXNzYWdlID0ge1xuICAgICAgZnJvbV9hZGRyZXNzOiB0b0hleChmcm9tX2FkZHJlc3MpLFxuICAgICAgdG9fYWRkcmVzczogdG9IZXgodG9fYWRkcmVzcyksXG4gICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcjogZ2V0U2VsZWN0b3IoZW50cnlfcG9pbnRfc2VsZWN0b3IpLFxuICAgICAgcGF5bG9hZDogZ2V0SGV4U3RyaW5nQXJyYXkocGF5bG9hZClcbiAgICB9O1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVNZXNzYWdlRmVlXCIsIHtcbiAgICAgIG1lc3NhZ2U6IGZvcm1hdHRlZE1lc3NhZ2UsXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBhYm91dCB0aGUgc3luYyBzdGF0dXMsIG9yIGZhbHNlIGlmIHRoZSBub2RlIGlzIG5vdCBzeW5jaGluZ1xuICAgKiBAcmV0dXJucyBPYmplY3Qgd2l0aCB0aGUgc3RhdHMgZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0U3luY2luZ1N0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9zeW5jaW5nXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBldmVudHMgbWF0Y2hpbmcgdGhlIGdpdmVuIGZpbHRlclxuICAgKiBAcmV0dXJucyBldmVudHMgYW5kIHRoZSBwYWdpbmF0aW9uIG9mIHRoZSBldmVudHNcbiAgICovXG4gIGFzeW5jIGdldEV2ZW50cyhldmVudEZpbHRlcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRFdmVudHNcIiwgeyBmaWx0ZXI6IGV2ZW50RmlsdGVyIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTdGFya25ldElkIEVuZHBvaW50IChnZXQgbmFtZSBmcm9tIGFkZHJlc3MpXG4gICAqL1xuICBhc3luYyBnZXRTdGFya05hbWUoYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBnZXRTdGFya05hbWUodGhpcywgYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mik7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJrbmV0SWQgRW5kcG9pbnQgKGdldCBhZGRyZXNzIGZyb20gbmFtZSlcbiAgICovXG4gIGFzeW5jIGdldEFkZHJlc3NGcm9tU3RhcmtOYW1lKG5hbWUsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgICByZXR1cm4gZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUodGhpcywgbmFtZSwgU3RhcmtuZXRJZENvbnRyYWN0Mik7XG4gIH1cbiAgYnVpbGRUcmFuc2FjdGlvbihpbnZvY2F0aW9uLCB2ZXJzaW9uVHlwZSkge1xuICAgIGNvbnN0IGRlZmF1bHRWZXJzaW9ucyA9IGdldFZlcnNpb25zQnlUeXBlKHZlcnNpb25UeXBlKTtcbiAgICBjb25zdCBkZXRhaWxzID0ge1xuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KGludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgIG5vbmNlOiB0b0hleChpbnZvY2F0aW9uLm5vbmNlKSxcbiAgICAgIG1heF9mZWU6IHRvSGV4KGludm9jYXRpb24ubWF4RmVlIHx8IDApXG4gICAgfTtcbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogcnBjX2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgIC8vIERpZmYgYmV0d2VlbiBzZXF1ZW5jZXIgYW5kIHJwYyBpbnZva2UgdHlwZVxuICAgICAgICBzZW5kZXJfYWRkcmVzczogaW52b2NhdGlvbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChpbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MSksXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8pIHtcbiAgICAgIGlmICghaXNTaWVycmEoaW52b2NhdGlvbi5jb250cmFjdCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IGludm9jYXRpb24uY29udHJhY3QsXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYxKSxcbiAgICAgICAgICAuLi5kZXRhaWxzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBjb21waWxlZF9jbGFzc19oYXNoXG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAuLi5pbnZvY2F0aW9uLmNvbnRyYWN0LFxuICAgICAgICAgIHNpZXJyYV9wcm9ncmFtOiBkZWNvbXByZXNzUHJvZ3JhbShpbnZvY2F0aW9uLmNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKVxuICAgICAgICB9LFxuICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBpbnZvY2F0aW9uLmNvbXBpbGVkQ2xhc3NIYXNoIHx8IFwiXCIsXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLnNlbmRlckFkZHJlc3MsXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjIpLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29uc3RydWN0b3JfY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGludm9jYXRpb24uY29uc3RydWN0b3JDYWxsZGF0YSB8fCBbXSksXG4gICAgICAgIGNsYXNzX2hhc2g6IHRvSGV4KGludm9jYXRpb24uY2xhc3NIYXNoKSxcbiAgICAgICAgY29udHJhY3RfYWRkcmVzc19zYWx0OiB0b0hleChpbnZvY2F0aW9uLmFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYxKSxcbiAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJSUEMgYnVpbGRUcmFuc2FjdGlvbiByZWNlaXZlZCB1bmtub3duIFRyYW5zYWN0aW9uVHlwZVwiKTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3ZpZGVyL3NlcXVlbmNlci50c1xuaW1wb3J0IHVybGpvaW4yIGZyb20gXCJ1cmwtam9pblwiO1xuXG4vLyBzcmMvdXRpbHMvcmVzcG9uc2VQYXJzZXIvaW5kZXgudHNcbnZhciBSZXNwb25zZVBhcnNlciA9IGNsYXNzIHtcbn07XG5cbi8vIHNyYy91dGlscy9yZXNwb25zZVBhcnNlci9zZXF1ZW5jZXIudHNcbnZhciBTZXF1ZW5jZXJBUElSZXNwb25zZVBhcnNlciA9IGNsYXNzIGV4dGVuZHMgUmVzcG9uc2VQYXJzZXIge1xuICBwYXJzZUdldEJsb2NrUmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlcyxcbiAgICAgIG5ld19yb290OiByZXMuc3RhdGVfcm9vdCxcbiAgICAgIHBhcmVudF9oYXNoOiByZXMucGFyZW50X2Jsb2NrX2hhc2gsXG4gICAgICB0cmFuc2FjdGlvbnM6IE9iamVjdC52YWx1ZXMocmVzLnRyYW5zYWN0aW9ucykubWFwKCh2YWx1ZSkgPT4gXCJ0cmFuc2FjdGlvbl9oYXNoXCIgaW4gdmFsdWUgJiYgdmFsdWUudHJhbnNhY3Rpb25faGFzaCkuZmlsdGVyKEJvb2xlYW4pXG4gICAgfTtcbiAgfVxuICBwYXJzZUdldFRyYW5zYWN0aW9uUmVzcG9uc2UocmVzKSB7XG4gICAgaWYgKHJlcy5zdGF0dXMgPT09IFwiTk9UX1JFQ0VJVkVEXCIgLyogTk9UX1JFQ0VJVkVEICovICYmIHJlcy5maW5hbGl0eV9zdGF0dXMgPT09IFwiTk9UX1JFQ0VJVkVEXCIgLyogTk9UX1JFQ0VJVkVEICovKSB7XG4gICAgICB0aHJvdyBuZXcgTGlicmFyeUVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXMsXG4gICAgICBjYWxsZGF0YTogXCJjYWxsZGF0YVwiIGluIHJlcy50cmFuc2FjdGlvbiA/IHJlcy50cmFuc2FjdGlvbi5jYWxsZGF0YSA6IFtdLFxuICAgICAgY29udHJhY3RfY2xhc3M6IFwiY29udHJhY3RfY2xhc3NcIiBpbiByZXMudHJhbnNhY3Rpb24gPyByZXMudHJhbnNhY3Rpb24uY29udHJhY3RfY2xhc3MgOiB2b2lkIDAsXG4gICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcjogXCJlbnRyeV9wb2ludF9zZWxlY3RvclwiIGluIHJlcy50cmFuc2FjdGlvbiA/IHJlcy50cmFuc2FjdGlvbi5lbnRyeV9wb2ludF9zZWxlY3RvciA6IHZvaWQgMCxcbiAgICAgIG1heF9mZWU6IFwibWF4X2ZlZVwiIGluIHJlcy50cmFuc2FjdGlvbiA/IHJlcy50cmFuc2FjdGlvbi5tYXhfZmVlIDogdm9pZCAwLFxuICAgICAgbm9uY2U6IHJlcy50cmFuc2FjdGlvbi5ub25jZSxcbiAgICAgIHNlbmRlcl9hZGRyZXNzOiBcInNlbmRlcl9hZGRyZXNzXCIgaW4gcmVzLnRyYW5zYWN0aW9uID8gcmVzLnRyYW5zYWN0aW9uLnNlbmRlcl9hZGRyZXNzIDogdm9pZCAwLFxuICAgICAgc2lnbmF0dXJlOiBcInNpZ25hdHVyZVwiIGluIHJlcy50cmFuc2FjdGlvbiA/IHJlcy50cmFuc2FjdGlvbi5zaWduYXR1cmUgOiB2b2lkIDAsXG4gICAgICB0cmFuc2FjdGlvbl9oYXNoOiBcInRyYW5zYWN0aW9uX2hhc2hcIiBpbiByZXMudHJhbnNhY3Rpb24gPyByZXMudHJhbnNhY3Rpb24udHJhbnNhY3Rpb25faGFzaCA6IHZvaWQgMCxcbiAgICAgIHZlcnNpb246IFwidmVyc2lvblwiIGluIHJlcy50cmFuc2FjdGlvbiA/IHJlcy50cmFuc2FjdGlvbi52ZXJzaW9uIDogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBwYXJzZUdldFRyYW5zYWN0aW9uUmVjZWlwdFJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXMsXG4gICAgICBtZXNzYWdlc19zZW50OiByZXMubDJfdG9fbDFfbWVzc2FnZXMsXG4gICAgICAuLi5cInJldmVydF9lcnJvclwiIGluIHJlcyAmJiB7IHJldmVydF9yZWFzb246IHJlcy5yZXZlcnRfZXJyb3IgfVxuICAgIH07XG4gIH1cbiAgcGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlKHJlcykge1xuICAgIGlmIChcIm92ZXJhbGxfZmVlXCIgaW4gcmVzKSB7XG4gICAgICBsZXQgZ2FzSW5mbyA9IHt9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZ2FzSW5mbyA9IHtcbiAgICAgICAgICBnYXNfY29uc3VtZWQ6IHRvQmlnSW50KHJlcy5nYXNfdXNhZ2UpLFxuICAgICAgICAgIGdhc19wcmljZTogdG9CaWdJbnQocmVzLmdhc19wcmljZSlcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3ZlcmFsbF9mZWU6IHRvQmlnSW50KHJlcy5vdmVyYWxsX2ZlZSksXG4gICAgICAgIC4uLmdhc0luZm9cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvdmVyYWxsX2ZlZTogdG9CaWdJbnQocmVzLmFtb3VudClcbiAgICB9O1xuICB9XG4gIHBhcnNlRmVlRXN0aW1hdGVCdWxrUmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChyZXMpLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKFwib3ZlcmFsbF9mZWVcIiBpbiBpdGVtKSB7XG4gICAgICAgIGxldCBnYXNJbmZvID0ge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZ2FzSW5mbyA9IHtcbiAgICAgICAgICAgIGdhc19jb25zdW1lZDogdG9CaWdJbnQoaXRlbS5nYXNfdXNhZ2UpLFxuICAgICAgICAgICAgZ2FzX3ByaWNlOiB0b0JpZ0ludChpdGVtLmdhc19wcmljZSlcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG92ZXJhbGxfZmVlOiB0b0JpZ0ludChpdGVtLm92ZXJhbGxfZmVlKSxcbiAgICAgICAgICAuLi5nYXNJbmZvXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvdmVyYWxsX2ZlZTogdG9CaWdJbnQoaXRlbS5hbW91bnQpXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIHBhcnNlU2ltdWxhdGVUcmFuc2FjdGlvblJlc3BvbnNlKHJlcykge1xuICAgIGNvbnN0IHN1Z2dlc3RlZE1heEZlZSA9IFwib3ZlcmFsbF9mZWVcIiBpbiByZXMuZmVlX2VzdGltYXRpb24gPyByZXMuZmVlX2VzdGltYXRpb24ub3ZlcmFsbF9mZWUgOiByZXMuZmVlX2VzdGltYXRpb24uYW1vdW50O1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRyYW5zYWN0aW9uX3RyYWNlOiByZXMudHJhY2UsXG4gICAgICAgIGZlZV9lc3RpbWF0aW9uOiByZXMuZmVlX2VzdGltYXRpb24sXG4gICAgICAgIHN1Z2dlc3RlZE1heEZlZTogZXN0aW1hdGVkRmVlVG9NYXhGZWUoQmlnSW50KHN1Z2dlc3RlZE1heEZlZSkpXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBwYXJzZUNhbGxDb250cmFjdFJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IHJlcy5yZXN1bHRcbiAgICB9O1xuICB9XG4gIHBhcnNlSW52b2tlRnVuY3Rpb25SZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaDogcmVzLnRyYW5zYWN0aW9uX2hhc2hcbiAgICB9O1xuICB9XG4gIHBhcnNlRGVwbG95Q29udHJhY3RSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaDogcmVzLnRyYW5zYWN0aW9uX2hhc2gsXG4gICAgICBjb250cmFjdF9hZGRyZXNzOiByZXMuYWRkcmVzc1xuICAgIH07XG4gIH1cbiAgcGFyc2VEZWNsYXJlQ29udHJhY3RSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaDogcmVzLnRyYW5zYWN0aW9uX2hhc2gsXG4gICAgICBjbGFzc19oYXNoOiByZXMuY2xhc3NfaGFzaFxuICAgIH07XG4gIH1cbiAgcGFyc2VHZXRTdGF0ZVVwZGF0ZVJlc3BvbnNlKHJlcykge1xuICAgIGNvbnN0IG5vbmNlcyA9IE9iamVjdC5lbnRyaWVzKHJlcy5zdGF0ZV9kaWZmLm5vbmNlcykubWFwKChbY29udHJhY3RfYWRkcmVzcywgbm9uY2VdKSA9PiAoe1xuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIG5vbmNlXG4gICAgfSkpO1xuICAgIGNvbnN0IHN0b3JhZ2VfZGlmZnMgPSBPYmplY3QuZW50cmllcyhyZXMuc3RhdGVfZGlmZi5zdG9yYWdlX2RpZmZzKS5tYXAoXG4gICAgICAoW2FkZHJlc3MsIHN0b3JhZ2VfZW50cmllc10pID0+ICh7IGFkZHJlc3MsIHN0b3JhZ2VfZW50cmllcyB9KVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlcyxcbiAgICAgIHN0YXRlX2RpZmY6IHtcbiAgICAgICAgLi4ucmVzLnN0YXRlX2RpZmYsXG4gICAgICAgIHN0b3JhZ2VfZGlmZnMsXG4gICAgICAgIG5vbmNlc1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcGFyc2VDb250cmFjdENsYXNzUmVzcG9uc2UocmVzKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBpc1NpZXJyYShyZXMpID8gcmVzIDogcGFyc2VDb250cmFjdChyZXMpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNwb25zZSxcbiAgICAgIGFiaTogdHlwZW9mIHJlc3BvbnNlLmFiaSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UocmVzcG9uc2UuYWJpKSA6IHJlc3BvbnNlLmFiaVxuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy91cmwudHNcbmltcG9ydCB1cmxqb2luIGZyb20gXCJ1cmwtam9pblwiO1xudmFyIHByb3RvY29sQW5kRG9tYWluUkUgPSAvXig/Olxcdys6KT9cXC9cXC8oXFxTKykkLztcbnZhciBsb2NhbGhvc3REb21haW5SRSA9IC9ebG9jYWxob3N0Wzo/XFxkXSooPzpbXjo/XFxkXVxcUyopPyQvO1xudmFyIG5vbkxvY2FsaG9zdERvbWFpblJFID0gL15bXlxccy5dK1xcLlxcU3syLH0kLztcbmZ1bmN0aW9uIGlzVXJsKHMpIHtcbiAgaWYgKCFzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgcyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBtYXRjaCA9IHMubWF0Y2gocHJvdG9jb2xBbmREb21haW5SRSk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZXZlcnl0aGluZ0FmdGVyUHJvdG9jb2wgPSBtYXRjaFsxXTtcbiAgaWYgKCFldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobG9jYWxob3N0RG9tYWluUkUudGVzdChldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCkgfHwgbm9uTG9jYWxob3N0RG9tYWluUkUudGVzdChldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBidWlsZFVybChiYXNlVXJsLCBkZWZhdWx0UGF0aCwgdXJsT3JQYXRoKSB7XG4gIHJldHVybiBpc1VybCh1cmxPclBhdGgpID8gdXJsT3JQYXRoIDogdXJsam9pbihiYXNlVXJsLCB1cmxPclBhdGggPz8gZGVmYXVsdFBhdGgpO1xufVxuXG4vLyBzcmMvcHJvdmlkZXIvc2VxdWVuY2VyLnRzXG5mdW5jdGlvbiBpc0VtcHR5UXVlcnlPYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogPT09IHZvaWQgMCB8fCBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMCB8fCBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMSAmJiBPYmplY3QuZW50cmllcyhvYmopLmV2ZXJ5KChbaywgdl0pID0+IGsgPT09IFwiYmxvY2tJZGVudGlmaWVyXCIgJiYgdiA9PT0gbnVsbCk7XG59XG52YXIgZGVmYXVsdE9wdGlvbnMyID0ge1xuICBuZXR3b3JrOiBcIlNOX0dPRVJMSVwiIC8qIFNOX0dPRVJMSSAqLyxcbiAgYmxvY2tJZGVudGlmaWVyOiBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovXG59O1xudmFyIFNlcXVlbmNlclByb3ZpZGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zT3JQcm92aWRlciA9IGRlZmF1bHRPcHRpb25zMikge1xuICAgIHRoaXMucmVzcG9uc2VQYXJzZXIgPSBuZXcgU2VxdWVuY2VyQVBJUmVzcG9uc2VQYXJzZXIoKTtcbiAgICBpZiAoXCJuZXR3b3JrXCIgaW4gb3B0aW9uc09yUHJvdmlkZXIpIHtcbiAgICAgIHRoaXMuYmFzZVVybCA9IFNlcXVlbmNlclByb3ZpZGVyLmdldE5ldHdvcmtGcm9tTmFtZShvcHRpb25zT3JQcm92aWRlci5uZXR3b3JrKTtcbiAgICAgIHRoaXMuZmVlZGVyR2F0ZXdheVVybCA9IGJ1aWxkVXJsKHRoaXMuYmFzZVVybCwgXCJmZWVkZXJfZ2F0ZXdheVwiKTtcbiAgICAgIHRoaXMuZ2F0ZXdheVVybCA9IGJ1aWxkVXJsKHRoaXMuYmFzZVVybCwgXCJnYXRld2F5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJhc2VVcmwgPSBvcHRpb25zT3JQcm92aWRlci5iYXNlVXJsO1xuICAgICAgdGhpcy5mZWVkZXJHYXRld2F5VXJsID0gYnVpbGRVcmwoXG4gICAgICAgIHRoaXMuYmFzZVVybCxcbiAgICAgICAgXCJmZWVkZXJfZ2F0ZXdheVwiLFxuICAgICAgICBvcHRpb25zT3JQcm92aWRlci5mZWVkZXJHYXRld2F5VXJsXG4gICAgICApO1xuICAgICAgdGhpcy5nYXRld2F5VXJsID0gYnVpbGRVcmwodGhpcy5iYXNlVXJsLCBcImdhdGV3YXlcIiwgb3B0aW9uc09yUHJvdmlkZXIuZ2F0ZXdheVVybCk7XG4gICAgfVxuICAgIHRoaXMuY2hhaW5JZCA9IG9wdGlvbnNPclByb3ZpZGVyPy5jaGFpbklkID8/IFNlcXVlbmNlclByb3ZpZGVyLmdldENoYWluSWRGcm9tQmFzZVVybCh0aGlzLmJhc2VVcmwpO1xuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnNPclByb3ZpZGVyLmhlYWRlcnM7XG4gICAgdGhpcy5ibG9ja0lkZW50aWZpZXIgPSBvcHRpb25zT3JQcm92aWRlcj8uYmxvY2tJZGVudGlmaWVyIHx8IGRlZmF1bHRPcHRpb25zMi5ibG9ja0lkZW50aWZpZXI7XG4gIH1cbiAgc3RhdGljIGdldE5ldHdvcmtGcm9tTmFtZShuYW1lKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwiU05fTUFJTlwiIC8qIFNOX01BSU4gKi86XG4gICAgICBjYXNlIFwiMHg1MzRlNWY0ZDQxNDk0ZVwiIC8qIFNOX01BSU4gKi86XG4gICAgICAgIHJldHVybiBcImh0dHBzOi8vYWxwaGEtbWFpbm5ldC5zdGFya25ldC5pb1wiIC8qIFNOX01BSU4gKi87XG4gICAgICBjYXNlIFwiU05fR09FUkxJXCIgLyogU05fR09FUkxJICovOlxuICAgICAgY2FzZSBcIjB4NTM0ZTVmNDc0ZjQ1NTI0YzQ5XCIgLyogU05fR09FUkxJICovOlxuICAgICAgICByZXR1cm4gXCJodHRwczovL2FscGhhNC5zdGFya25ldC5pb1wiIC8qIFNOX0dPRVJMSSAqLztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBkZXRlY3QgYmFzZSB1cmwgZnJvbSBOZXR3b3JrTmFtZVwiKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldENoYWluSWRGcm9tQmFzZVVybChiYXNlVXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgICBpZiAodXJsLmhvc3QuaW5jbHVkZXMoXCJtYWlubmV0LnN0YXJrbmV0LmlvXCIpKSB7XG4gICAgICAgIHJldHVybiBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiMHg1MzRlNWY0NzRmNDU1MjRjNDlcIiAvKiBTTl9HT0VSTEkgKi87XG4gICAgfSBjYXRjaCB7XG4gICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3QgcGFyc2UgYmFzZVVybDogJHtiYXNlVXJsfWApO1xuICAgICAgcmV0dXJuIFwiMHg1MzRlNWY0NzRmNDU1MjRjNDlcIiAvKiBTTl9HT0VSTEkgKi87XG4gICAgfVxuICB9XG4gIGdldEZldGNoVXJsKGVuZHBvaW50KSB7XG4gICAgY29uc3QgZ2F0ZXdheVVybEVuZHBvaW50cyA9IFtcImFkZF90cmFuc2FjdGlvblwiXTtcbiAgICByZXR1cm4gZ2F0ZXdheVVybEVuZHBvaW50cy5pbmNsdWRlcyhlbmRwb2ludCkgPyB0aGlzLmdhdGV3YXlVcmwgOiB0aGlzLmZlZWRlckdhdGV3YXlVcmw7XG4gIH1cbiAgZ2V0RmV0Y2hNZXRob2QoZW5kcG9pbnQpIHtcbiAgICBjb25zdCBwb3N0TWV0aG9kRW5kcG9pbnRzID0gW1xuICAgICAgXCJhZGRfdHJhbnNhY3Rpb25cIixcbiAgICAgIFwiY2FsbF9jb250cmFjdFwiLFxuICAgICAgXCJlc3RpbWF0ZV9mZWVcIixcbiAgICAgIFwiZXN0aW1hdGVfbWVzc2FnZV9mZWVcIixcbiAgICAgIFwiZXN0aW1hdGVfZmVlX2J1bGtcIixcbiAgICAgIFwic2ltdWxhdGVfdHJhbnNhY3Rpb25cIlxuICAgIF07XG4gICAgcmV0dXJuIHBvc3RNZXRob2RFbmRwb2ludHMuaW5jbHVkZXMoZW5kcG9pbnQpID8gXCJQT1NUXCIgOiBcIkdFVFwiO1xuICB9XG4gIGdldFF1ZXJ5U3RyaW5nKHF1ZXJ5KSB7XG4gICAgaWYgKGlzRW1wdHlRdWVyeU9iamVjdChxdWVyeSkpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IE9iamVjdC5lbnRyaWVzKHF1ZXJ5KS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gXCJibG9ja0lkZW50aWZpZXJcIikge1xuICAgICAgICBjb25zdCBibG9jayA9IG5ldyBCbG9jayh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBgJHtibG9jay5xdWVyeUlkZW50aWZpZXJ9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgJHtrZXl9PSR7dmFsdWV9YDtcbiAgICB9KS5qb2luKFwiJlwiKTtcbiAgICByZXR1cm4gYD8ke3F1ZXJ5U3RyaW5nfWA7XG4gIH1cbiAgZ2V0SGVhZGVycyhtZXRob2QpIHtcbiAgICBpZiAobWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLnRoaXMuaGVhZGVyc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGVhZGVycztcbiAgfVxuICAvLyB0eXBlc2FmZSBmZXRjaFxuICBhc3luYyBmZXRjaEVuZHBvaW50KGVuZHBvaW50LCAuLi5bcXVlcnksIHJlcXVlc3RdKSB7XG4gICAgY29uc3QgYmFzZVVybCA9IHRoaXMuZ2V0RmV0Y2hVcmwoZW5kcG9pbnQpO1xuICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMuZ2V0RmV0Y2hNZXRob2QoZW5kcG9pbnQpO1xuICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gdGhpcy5nZXRRdWVyeVN0cmluZyhxdWVyeSk7XG4gICAgY29uc3QgdXJsID0gdXJsam9pbjIoYmFzZVVybCwgZW5kcG9pbnQsIHF1ZXJ5U3RyaW5nKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIGJvZHk6IHJlcXVlc3RcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmZXRjaChlbmRwb2ludCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHVybCA9IGJ1aWxkVXJsKHRoaXMuYmFzZVVybCwgXCJcIiwgZW5kcG9pbnQpO1xuICAgIGNvbnN0IG1ldGhvZCA9IG9wdGlvbnM/Lm1ldGhvZCA/PyBcIkdFVFwiO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmdldEhlYWRlcnMobWV0aG9kKTtcbiAgICBjb25zdCBib2R5ID0gc3RyaW5naWZ5MihvcHRpb25zPy5ib2R5KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFBvbnlmaWxsX2RlZmF1bHQodXJsLCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgYm9keSxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfSk7XG4gICAgICBjb25zdCB0ZXh0UmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGxldCByZXNwb25zZUJvZHk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzcG9uc2VCb2R5ID0gcGFyc2UyKHRleHRSZXNwb25zZSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHRocm93IG5ldyBIdHRwRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgR2F0ZXdheUVycm9yKHJlc3BvbnNlQm9keS5tZXNzYWdlLCByZXNwb25zZUJvZHkuY29kZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZUNob2ljZSA9IG9wdGlvbnM/LnBhcnNlQWx3YXlzQXNCaWdJbnQgPyBwYXJzZUFsd2F5c0FzQmlnIDogcGFyc2UyO1xuICAgICAgcmV0dXJuIHBhcnNlQ2hvaWNlKHRleHRSZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBMaWJyYXJ5RXJyb3IpKVxuICAgICAgICB0aHJvdyBFcnJvcihgQ291bGQgbm90ICR7bWV0aG9kfSBmcm9tIGVuZHBvaW50IFxcYCR7dXJsfVxcYDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldENoYWluSWQoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmNoYWluSWQpO1xuICB9XG4gIGFzeW5jIGNhbGxDb250cmFjdCh7IGNvbnRyYWN0QWRkcmVzcywgZW50cnlwb2ludDogZW50cnlQb2ludFNlbGVjdG9yLCBjYWxsZGF0YSA9IFtdIH0sIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcbiAgICAgIFwiY2FsbF9jb250cmFjdFwiLFxuICAgICAgeyBibG9ja0lkZW50aWZpZXIgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETyAtIGRldGVybWluZSBiZXN0IGNob2ljZSBvbmNlIGJvdGggYXJlIGZ1bGx5IHN1cHBvcnRlZCBpbiBkZXZuZXRcbiAgICAgICAgLy8gc2lnbmF0dXJlOiBbXSxcbiAgICAgICAgLy8gc2VuZGVyX2FkZHJlc3M6IGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgY29udHJhY3RfYWRkcmVzczogY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcjogZ2V0U2VsZWN0b3JGcm9tTmFtZShlbnRyeVBvaW50U2VsZWN0b3IpLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZShjYWxsZGF0YSlcbiAgICAgIH1cbiAgICApLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUNhbGxDb250cmFjdFJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRCbG9jayhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfYmxvY2tcIiwgeyBibG9ja0lkZW50aWZpZXIgfSkudGhlbihcbiAgICAgIHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VHZXRCbG9ja1Jlc3BvbnNlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXROb25jZUZvckFkZHJlc3MoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfbm9uY2VcIiwgeyBjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciB9KTtcbiAgfVxuICBhc3luYyBnZXRTdG9yYWdlQXQoY29udHJhY3RBZGRyZXNzLCBrZXksIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgcGFyc2VkS2V5ID0gdG9CaWdJbnQoa2V5KS50b1N0cmluZygxMCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF9zdG9yYWdlX2F0XCIsIHtcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGtleTogcGFyc2VkS2V5XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24odHhIYXNoKSB7XG4gICAgY29uc3QgdHhIYXNoSGV4ID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X3RyYW5zYWN0aW9uXCIsIHsgdHJhbnNhY3Rpb25IYXNoOiB0eEhhc2hIZXggfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhyZXN1bHQpLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgdGhyb3cgbmV3IExpYnJhcnlFcnJvcihyZXN1bHQuc3RhdHVzKTtcbiAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0VHJhbnNhY3Rpb25SZXNwb25zZShyZXN1bHQpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICBjb25zdCB0eEhhc2hIZXggPSB0b0hleCh0eEhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfdHJhbnNhY3Rpb25fcmVjZWlwdFwiLCB7IHRyYW5zYWN0aW9uSGFzaDogdHhIYXNoSGV4IH0pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0VHJhbnNhY3Rpb25SZWNlaXB0UmVzcG9uc2VcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfZnVsbF9jb250cmFjdFwiLCB7IGJsb2NrSWRlbnRpZmllciwgY29udHJhY3RBZGRyZXNzIH0pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzc0hhc2hBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF9jbGFzc19oYXNoX2F0XCIsIHsgYmxvY2tJZGVudGlmaWVyLCBjb250cmFjdEFkZHJlc3MgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3NCeUhhc2goY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfY2xhc3NfYnlfaGFzaFwiLCB7IGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyIH0pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRDb21waWxlZENsYXNzQnlDbGFzc0hhc2goY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfY29tcGlsZWRfY2xhc3NfYnlfY2xhc3NfaGFzaFwiLCB7IGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyIH0pO1xuICB9XG4gIGFzeW5jIGdldENvbnRyYWN0VmVyc2lvbihjb250cmFjdEFkZHJlc3MsIGNsYXNzSGFzaCwgeyBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgY29tcGlsZXIgPSB0cnVlIH0gPSB7fSkge1xuICAgIGxldCBjb250cmFjdENsYXNzO1xuICAgIGlmIChjb250cmFjdEFkZHJlc3MpIHtcbiAgICAgIGNvbnRyYWN0Q2xhc3MgPSBhd2FpdCB0aGlzLmdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpO1xuICAgIH0gZWxzZSBpZiAoY2xhc3NIYXNoKSB7XG4gICAgICBjb250cmFjdENsYXNzID0gYXdhaXQgdGhpcy5nZXRDbGFzc0J5SGFzaChjbGFzc0hhc2gsIGJsb2NrSWRlbnRpZmllcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiZ2V0Q29udHJhY3RWZXJzaW9uIHJlcXVpcmUgY29udHJhY3RBZGRyZXNzIG9yIGNsYXNzSGFzaFwiKTtcbiAgICB9XG4gICAgaWYgKGlzU2llcnJhKGNvbnRyYWN0Q2xhc3MpKSB7XG4gICAgICBpZiAoY29tcGlsZXIpIHtcbiAgICAgICAgY29uc3QgYWJpVGVzdCA9IGdldEFiaUNvbnRyYWN0VmVyc2lvbihjb250cmFjdENsYXNzLmFiaSk7XG4gICAgICAgIHJldHVybiB7IGNhaXJvOiBcIjFcIiwgY29tcGlsZXI6IGFiaVRlc3QuY29tcGlsZXIgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGNhaXJvOiBcIjFcIiwgY29tcGlsZXI6IHZvaWQgMCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBjYWlybzogXCIwXCIsIGNvbXBpbGVyOiBcIjBcIiB9O1xuICB9XG4gIGFzeW5jIGludm9rZUZ1bmN0aW9uKGZ1bmN0aW9uSW52b2NhdGlvbiwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJhZGRfdHJhbnNhY3Rpb25cIiwgdm9pZCAwLCB7XG4gICAgICB0eXBlOiBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLyxcbiAgICAgIHNlbmRlcl9hZGRyZXNzOiBmdW5jdGlvbkludm9jYXRpb24uY29udHJhY3RBZGRyZXNzLFxuICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoZnVuY3Rpb25JbnZvY2F0aW9uLmNhbGxkYXRhID8/IFtdKSxcbiAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXkoZnVuY3Rpb25JbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSksXG4gICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgIHZlcnNpb246IFwiMHgxXCJcbiAgICB9KS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VJbnZva2VGdW5jdGlvblJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBkZXBsb3lBY2NvdW50Q29udHJhY3QoeyBjbGFzc0hhc2gsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIGFkZHJlc3NTYWx0LCBzaWduYXR1cmUgfSwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJhZGRfdHJhbnNhY3Rpb25cIiwgdm9pZCAwLCB7XG4gICAgICB0eXBlOiBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8sXG4gICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IGFkZHJlc3NTYWx0ID8/IHJhbmRvbUFkZHJlc3MoKSxcbiAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEgPz8gW10pLFxuICAgICAgY2xhc3NfaGFzaDogdG9IZXgoY2xhc3NIYXNoKSxcbiAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgdmVyc2lvbjogdG9IZXgoZGV0YWlscy52ZXJzaW9uIHx8IDApLFxuICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpLFxuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheShzaWduYXR1cmUpXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRGVwbG95Q29udHJhY3RSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZGVjbGFyZUNvbnRyYWN0KHsgc2VuZGVyQWRkcmVzcywgY29udHJhY3QsIHNpZ25hdHVyZSwgY29tcGlsZWRDbGFzc0hhc2ggfSwgZGV0YWlscykge1xuICAgIGlmICghaXNTaWVycmEoY29udHJhY3QpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiYWRkX3RyYW5zYWN0aW9uXCIsIHZvaWQgMCwge1xuICAgICAgICB0eXBlOiBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovLFxuICAgICAgICBjb250cmFjdF9jbGFzczogY29udHJhY3QsXG4gICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheShzaWduYXR1cmUpLFxuICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KHRyYW5zYWN0aW9uVmVyc2lvbilcbiAgICAgIH0pLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZURlY2xhcmVDb250cmFjdFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImFkZF90cmFuc2FjdGlvblwiLCB2b2lkIDAsIHtcbiAgICAgIHR5cGU6IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGNvbXBpbGVkQ2xhc3NIYXNoLFxuICAgICAgY29udHJhY3RfY2xhc3M6IGNvbnRyYWN0LFxuICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpLFxuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheShzaWduYXR1cmUpLFxuICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICB2ZXJzaW9uOiB0b0hleCh0cmFuc2FjdGlvblZlcnNpb25fMilcbiAgICB9KS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VEZWNsYXJlQ29udHJhY3RSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzLmdldEludm9rZUVzdGltYXRlRmVlKGludm9jYXRpb24sIGludm9jYXRpb25EZXRhaWxzLCBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSk7XG4gIH1cbiAgYXN5bmMgZ2V0SW52b2tlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uKFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLyxcbiAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgLi4uaW52b2NhdGlvbkRldGFpbHNcbiAgICAgIH0sXG4gICAgICBcImZlZVwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZXN0aW1hdGVfZmVlXCIsIHsgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgfSwgdHJhbnNhY3Rpb24pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0RGVjbGFyZUVzdGltYXRlRmVlKGludm9jYXRpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uKFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovLFxuICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9LFxuICAgICAgXCJmZWVcIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImVzdGltYXRlX2ZlZVwiLCB7IGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH0sIHRyYW5zYWN0aW9uKS50aGVuKFxuICAgICAgdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlUmVzcG9uc2VcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldERlcGxveUFjY291bnRFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBkZXRhaWxzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gZmFsc2UpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovLFxuICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9LFxuICAgICAgXCJmZWVcIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImVzdGltYXRlX2ZlZVwiLCB7IGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH0sIHRyYW5zYWN0aW9uKS50aGVuKFxuICAgICAgdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlUmVzcG9uc2VcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlQnVsayhpbnZvY2F0aW9ucywgeyBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gZmFsc2UgfSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IGludm9jYXRpb25zLm1hcCgoaXQpID0+IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihpdCwgXCJmZWVcIikpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXG4gICAgICBcImVzdGltYXRlX2ZlZV9idWxrXCIsXG4gICAgICB7IGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH0sXG4gICAgICB0cmFuc2FjdGlvbnNcbiAgICApLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlQnVsa1Jlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRDb2RlKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X2NvZGVcIiwgeyBjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciB9KTtcbiAgfVxuICBhc3luYyB3YWl0Rm9yVHJhbnNhY3Rpb24odHhIYXNoLCBvcHRpb25zKSB7XG4gICAgbGV0IHJlcztcbiAgICBsZXQgY29tcGxldGVkID0gZmFsc2U7XG4gICAgbGV0IHJldHJpZXMgPSAwO1xuICAgIGNvbnN0IHJldHJ5SW50ZXJ2YWwgPSBvcHRpb25zPy5yZXRyeUludGVydmFsID8/IDVlMztcbiAgICBjb25zdCBlcnJvclN0YXRlcyA9IG9wdGlvbnM/LmVycm9yU3RhdGVzID8/IFtcbiAgICAgIFwiUkVKRUNURURcIiAvKiBSRUpFQ1RFRCAqLyxcbiAgICAgIFwiTk9UX1JFQ0VJVkVEXCIgLyogTk9UX1JFQ0VJVkVEICovLFxuICAgICAgXCJSRVZFUlRFRFwiIC8qIFJFVkVSVEVEICovXG4gICAgXTtcbiAgICBjb25zdCBzdWNjZXNzU3RhdGVzID0gb3B0aW9ucz8uc3VjY2Vzc1N0YXRlcyA/PyBbXG4gICAgICBcIlNVQ0NFRURFRFwiIC8qIFNVQ0NFRURFRCAqLyxcbiAgICAgIFwiQUNDRVBURURfT05fTDFcIiAvKiBBQ0NFUFRFRF9PTl9MMSAqLyxcbiAgICAgIFwiQUNDRVBURURfT05fTDJcIiAvKiBBQ0NFUFRFRF9PTl9MMiAqL1xuICAgIF07XG4gICAgd2hpbGUgKCFjb21wbGV0ZWQpIHtcbiAgICAgIGF3YWl0IHdhaXQocmV0cnlJbnRlcnZhbCk7XG4gICAgICByZXMgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uU3RhdHVzKHR4SGFzaCk7XG4gICAgICBpZiAoXCJOT1RfUkVDRUlWRURcIiAvKiBOT1RfUkVDRUlWRUQgKi8gPT09IHJlcy5maW5hbGl0eV9zdGF0dXMgJiYgcmV0cmllcyA8IDMpIHtcbiAgICAgICAgcmV0cmllcyArPSAxO1xuICAgICAgfSBlbHNlIGlmIChzdWNjZXNzU3RhdGVzLmluY2x1ZGVzKHJlcy5maW5hbGl0eV9zdGF0dXMpIHx8IHN1Y2Nlc3NTdGF0ZXMuaW5jbHVkZXMocmVzLmV4ZWN1dGlvbl9zdGF0dXMpKSB7XG4gICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yU3RhdGVzLmluY2x1ZGVzKHJlcy5maW5hbGl0eV9zdGF0dXMpIHx8IGVycm9yU3RhdGVzLmluY2x1ZGVzKHJlcy5leGVjdXRpb25fc3RhdHVzKSkge1xuICAgICAgICBsZXQgbWVzc2FnZTtcbiAgICAgICAgaWYgKHJlcy50eF9mYWlsdXJlX3JlYXNvbikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBgJHtyZXMudHhfc3RhdHVzfTogJHtyZXMudHhfZmFpbHVyZV9yZWFzb24uY29kZX1cbiR7cmVzLnR4X2ZhaWx1cmVfcmVhc29uLmVycm9yX21lc3NhZ2V9YDtcbiAgICAgICAgfSBlbHNlIGlmIChyZXMudHhfcmV2ZXJ0X3JlYXNvbikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBgJHtyZXMudHhfc3RhdHVzfTogJHtyZXMudHhfcmV2ZXJ0X3JlYXNvbn1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lc3NhZ2UgPSByZXMudHhfc3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5yZXNwb25zZSA9IHJlcztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHR4UmVjZWlwdCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCk7XG4gICAgcmV0dXJuIHR4UmVjZWlwdDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgc3RhdHVzIG9mIGEgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB0eEhhc2ggQmlnTnVtYmVyaXNoXG4gICAqIEByZXR1cm5zIEdldFRyYW5zYWN0aW9uU3RhdHVzUmVzcG9uc2UgLSB0aGUgdHJhbnNhY3Rpb24gc3RhdHVzIG9iamVjdFxuICAgKi9cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25TdGF0dXModHhIYXNoKSB7XG4gICAgY29uc3QgdHhIYXNoSGV4ID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X3RyYW5zYWN0aW9uX3N0YXR1c1wiLCB7IHRyYW5zYWN0aW9uSGFzaDogdHhIYXNoSGV4IH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzbWFydCBjb250cmFjdCBhZGRyZXNzIG9uIHRoZSBnb2VybGkgdGVzdG5ldC5cbiAgICogQHJldHVybnMgR2V0Q29udHJhY3RBZGRyZXNzZXNSZXNwb25zZSAtIHN0YXJrbmV0IHNtYXJ0IGNvbnRyYWN0IGFkZHJlc3Nlc1xuICAgKi9cbiAgYXN5bmMgZ2V0Q29udHJhY3RBZGRyZXNzZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF9jb250cmFjdF9hZGRyZXNzZXNcIik7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRyYW5zYWN0aW9uIHRyYWNlIGZyb20gYSB0eCBpZC5cbiAgICogQHBhcmFtIHR4SGFzaCBCaWdOdW1iZXJpc2hcbiAgICogQHJldHVybnMgVHJhbnNhY3Rpb25UcmFjZVJlc3BvbnNlIC0gdGhlIHRyYW5zYWN0aW9uIHRyYWNlXG4gICAqL1xuICBhc3luYyBnZXRUcmFuc2FjdGlvblRyYWNlKHR4SGFzaCkge1xuICAgIGNvbnN0IHR4SGFzaEhleCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF90cmFuc2FjdGlvbl90cmFjZVwiLCB7IHRyYW5zYWN0aW9uSGFzaDogdHhIYXNoSGV4IH0pO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlTWVzc2FnZUZlZSh7IGZyb21fYWRkcmVzcywgdG9fYWRkcmVzcywgZW50cnlfcG9pbnRfc2VsZWN0b3IsIHBheWxvYWQgfSwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCB2YWxpZENhbGxMMUhhbmRsZXIgPSB7XG4gICAgICBmcm9tX2FkZHJlc3M6IGdldERlY2ltYWxTdHJpbmcoZnJvbV9hZGRyZXNzKSxcbiAgICAgIHRvX2FkZHJlc3M6IGdldEhleFN0cmluZyh0b19hZGRyZXNzKSxcbiAgICAgIGVudHJ5X3BvaW50X3NlbGVjdG9yOiBnZXRTZWxlY3RvcihlbnRyeV9wb2ludF9zZWxlY3RvciksXG4gICAgICBwYXlsb2FkOiBnZXRIZXhTdHJpbmdBcnJheShwYXlsb2FkKVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImVzdGltYXRlX21lc3NhZ2VfZmVlXCIsIHsgYmxvY2tJZGVudGlmaWVyIH0sIHZhbGlkQ2FsbEwxSGFuZGxlcik7XG4gIH1cbiAgLyoqXG4gICAqIFNpbXVsYXRlIHRyYW5zYWN0aW9uIHVzaW5nIFNlcXVlbmNlciBwcm92aWRlclxuICAgKiBXQVJOSU5HITogU2VxdWVuY2VyIHdpbGwgcHJvY2VzcyBvbmx5IGZpcnN0IGVsZW1lbnQgZnJvbSBpbnZvY2F0aW9ucyBhcnJheVxuICAgKlxuICAgKiBAcGFyYW0gaW52b2NhdGlvbnMgQXJyYXkgb2YgaW52b2NhdGlvbnMsIGJ1dCBvbmx5IGZpcnN0IGludm9jYXRpb24gd2lsbCBiZSBwcm9jZXNzZWRcbiAgICogQHBhcmFtIGJsb2NrSWRlbnRpZmllciBibG9jayBpZGVudGlmaWVyLCBkZWZhdWx0ICdsYXRlc3QnXG4gICAqIEBwYXJhbSBza2lwVmFsaWRhdGUgU2tpcCBBY2NvdW50IF9fdmFsaWRhdGVfXyBtZXRob2RcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGdldFNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIHtcbiAgICBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcixcbiAgICBza2lwVmFsaWRhdGUgPSBmYWxzZSxcbiAgICBza2lwRXhlY3V0ZSA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAoaW52b2NhdGlvbnMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc29sZS53YXJuKFwiU2VxdWVuY2VyIHNpbXVsYXRlIHByb2Nlc3Mgb25seSBmaXJzdCBlbGVtZW50IGZyb20gaW52b2NhdGlvbnMgbGlzdFwiKTtcbiAgICB9XG4gICAgaWYgKHNraXBFeGVjdXRlKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJTZXF1ZW5jZXIgY2FuJ3Qgc2tpcCBhY2NvdW50IF9fZXhlY3V0ZV9fXCIpO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihpbnZvY2F0aW9uc1swXSk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcbiAgICAgIFwic2ltdWxhdGVfdHJhbnNhY3Rpb25cIixcbiAgICAgIHtcbiAgICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgICBza2lwVmFsaWRhdGU6IHNraXBWYWxpZGF0ZSA/PyBmYWxzZVxuICAgICAgfSxcbiAgICAgIHRyYW5zYWN0aW9uXG4gICAgKS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VTaW11bGF0ZVRyYW5zYWN0aW9uUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldFN0YXRlVXBkYXRlKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYXJncyA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLnNlcXVlbmNlcklkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF9zdGF0ZV91cGRhdGVcIiwgeyAuLi5hcmdzIH0pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0U3RhdGVVcGRhdGVSZXNwb25zZVxuICAgICk7XG4gIH1cbiAgLy8gY29uc2lkZXIgYWRkaW5nIGFuIG9wdGlvbmFsIHRyYWNlIHJldHJpZXZhbCBwYXJhbWV0ZXIgdG8gdGhlIGdldEJsb2NrIG1ldGhvZFxuICBhc3luYyBnZXRCbG9ja1RyYWNlcyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGFyZ3MgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5zZXF1ZW5jZXJJZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfYmxvY2tfdHJhY2VzXCIsIHsgLi4uYXJncyB9KTtcbiAgfVxuICBhc3luYyBnZXRTdGFya05hbWUoYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBnZXRTdGFya05hbWUodGhpcywgYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mik7XG4gIH1cbiAgYXN5bmMgZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUobmFtZSwgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBnZXRBZGRyZXNzRnJvbVN0YXJrTmFtZSh0aGlzLCBuYW1lLCBTdGFya25ldElkQ29udHJhY3QyKTtcbiAgfVxuICAvKipcbiAgICogQnVpbGQgU2luZ2xlIEFjY291bnRUcmFuc2FjdGlvbiBmcm9tIFNpbmdsZSBBY2NvdW50SW52b2NhdGlvblxuICAgKiBAcGFyYW0gaW52b2NhdGlvbiBBY2NvdW50SW52b2NhdGlvbkl0ZW1cbiAgICogQHBhcmFtIHZlcnNpb25UeXBlICdmZWUnIHwgJ3RyYW5zYWN0aW9uJyAtIHVzZWQgdG8gZGV0ZXJtaW5lIGRlZmF1bHQgdmVyc2lvbnNcbiAgICogQHJldHVybnMgQWNjb3VudFRyYW5zYWN0aW9uSXRlbVxuICAgKi9cbiAgYnVpbGRUcmFuc2FjdGlvbihpbnZvY2F0aW9uLCB2ZXJzaW9uVHlwZSkge1xuICAgIGNvbnN0IGRlZmF1bHRWZXJzaW9ucyA9IGdldFZlcnNpb25zQnlUeXBlKHZlcnNpb25UeXBlKTtcbiAgICBjb25zdCBkZXRhaWxzID0ge1xuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheShpbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICBub25jZTogdG9IZXgoaW52b2NhdGlvbi5ub25jZSlcbiAgICB9O1xuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoaW52b2NhdGlvbi5jYWxsZGF0YSA/PyBbXSksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjEpLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovKSB7XG4gICAgICBpZiAoIWlzU2llcnJhKGludm9jYXRpb24uY29udHJhY3QpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICAgIGNvbnRyYWN0X2NsYXNzOiBpbnZvY2F0aW9uLmNvbnRyYWN0LFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLnNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MSksXG4gICAgICAgICAgLy8gZmVlIGZyb20gZ2V0RGVjbGFyZUVzdGltYXRlRmVlIHVzZSB0LnYuIGluc3RlYWQgb2YgZmVldC52LlxuICAgICAgICAgIC4uLmRldGFpbHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29udHJhY3RfY2xhc3M6IGludm9jYXRpb24uY29udHJhY3QsXG4gICAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGludm9jYXRpb24uY29tcGlsZWRDbGFzc0hhc2gsXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLnNlbmRlckFkZHJlc3MsXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjIpLFxuICAgICAgICAvLyBmZWUgb24gZ2V0RGVjbGFyZUVzdGltYXRlRmVlIHVzZSB0LnYuIGluc3RlYWQgb2YgZmVldC52LlxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29uc3RydWN0b3JfY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoaW52b2NhdGlvbi5jb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgY2xhc3NfaGFzaDogdG9IZXgoaW52b2NhdGlvbi5jbGFzc0hhc2gpLFxuICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGludm9jYXRpb24uYWRkcmVzc1NhbHQgfHwgMCksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjEpLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIlNlcXVlbmNlciBidWlsZFRyYW5zYWN0aW9uIHJlY2VpdmVkIHVua25vd24gVHJhbnNhY3Rpb25UeXBlXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvZGVmYXVsdC50c1xudmFyIFByb3ZpZGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihwcm92aWRlck9yT3B0aW9ucykge1xuICAgIGlmIChwcm92aWRlck9yT3B0aW9ucyBpbnN0YW5jZW9mIFByb3ZpZGVyKSB7XG4gICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXJPck9wdGlvbnMucHJvdmlkZXI7XG4gICAgfSBlbHNlIGlmIChwcm92aWRlck9yT3B0aW9ucyBpbnN0YW5jZW9mIFJwY1Byb3ZpZGVyIHx8IHByb3ZpZGVyT3JPcHRpb25zIGluc3RhbmNlb2YgU2VxdWVuY2VyUHJvdmlkZXIpIHtcbiAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlck9yT3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKHByb3ZpZGVyT3JPcHRpb25zICYmIFwicnBjXCIgaW4gcHJvdmlkZXJPck9wdGlvbnMpIHtcbiAgICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgUnBjUHJvdmlkZXIocHJvdmlkZXJPck9wdGlvbnMucnBjKTtcbiAgICB9IGVsc2UgaWYgKHByb3ZpZGVyT3JPcHRpb25zICYmIFwic2VxdWVuY2VyXCIgaW4gcHJvdmlkZXJPck9wdGlvbnMpIHtcbiAgICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgU2VxdWVuY2VyUHJvdmlkZXIocHJvdmlkZXJPck9wdGlvbnMuc2VxdWVuY2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm92aWRlciA9IG5ldyBScGNQcm92aWRlcigpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldENoYWluSWQoKTtcbiAgfVxuICBhc3luYyBnZXRCbG9jayhibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRCbG9jayhibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzc0hhc2hBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldENsYXNzSGFzaEF0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBnZXRDbGFzc0J5SGFzaChjbGFzc0hhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRDbGFzc0J5SGFzaChjbGFzc0hhc2gpO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlKGludm9jYXRpb25XaXRoVHhUeXBlLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbldpdGhUeFR5cGUsIGludm9jYXRpb25EZXRhaWxzLCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldEludm9rZUVzdGltYXRlRmVlKGludm9jYXRpb25XaXRoVHhUeXBlLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRJbnZva2VFc3RpbWF0ZUZlZShcbiAgICAgIGludm9jYXRpb25XaXRoVHhUeXBlLFxuICAgICAgaW52b2NhdGlvbkRldGFpbHMsXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGVcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlQnVsayhpbnZvY2F0aW9ucywgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldEVzdGltYXRlRmVlQnVsayhpbnZvY2F0aW9ucywgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2VGb3JBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0Tm9uY2VGb3JBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRTdG9yYWdlQXQoY29udHJhY3RBZGRyZXNzLCBrZXksIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldFN0b3JhZ2VBdChjb250cmFjdEFkZHJlc3MsIGtleSwgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvbih0eEhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0eEhhc2gpO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgfVxuICBhc3luYyBjYWxsQ29udHJhY3QocmVxdWVzdCwgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuY2FsbENvbnRyYWN0KHJlcXVlc3QsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgaW52b2tlRnVuY3Rpb24oZnVuY3Rpb25JbnZvY2F0aW9uLCBkZXRhaWxzKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuaW52b2tlRnVuY3Rpb24oZnVuY3Rpb25JbnZvY2F0aW9uLCBkZXRhaWxzKTtcbiAgfVxuICBhc3luYyBkZXBsb3lBY2NvdW50Q29udHJhY3QocGF5bG9hZCwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmRlcGxveUFjY291bnRDb250cmFjdChwYXlsb2FkLCBkZXRhaWxzKTtcbiAgfVxuICBhc3luYyBkZWNsYXJlQ29udHJhY3QodHJhbnNhY3Rpb24sIGRldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5kZWNsYXJlQ29udHJhY3QodHJhbnNhY3Rpb24sIGRldGFpbHMpO1xuICB9XG4gIGFzeW5jIGdldERlY2xhcmVFc3RpbWF0ZUZlZSh0cmFuc2FjdGlvbiwgZGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXREZWNsYXJlRXN0aW1hdGVGZWUodHJhbnNhY3Rpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKTtcbiAgfVxuICBnZXREZXBsb3lBY2NvdW50RXN0aW1hdGVGZWUodHJhbnNhY3Rpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0RGVwbG95QWNjb3VudEVzdGltYXRlRmVlKFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICBkZXRhaWxzLFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRDb2RlKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0Q29kZShjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKHR4SGFzaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvbih0eEhhc2gsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGdldFNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRTaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBnZXRTdGF0ZVVwZGF0ZShibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRTdGF0ZVVwZGF0ZShibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldFN0YXJrTmFtZShhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgcmV0dXJuIGdldFN0YXJrTmFtZSh0aGlzLCBhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKTtcbiAgfVxuICBhc3luYyBnZXRBZGRyZXNzRnJvbVN0YXJrTmFtZShuYW1lLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgcmV0dXJuIGdldEFkZHJlc3NGcm9tU3RhcmtOYW1lKHRoaXMsIG5hbWUsIFN0YXJrbmV0SWRDb250cmFjdDIpO1xuICB9XG4gIGFzeW5jIGdldENvbnRyYWN0VmVyc2lvbihjb250cmFjdEFkZHJlc3MsIGNsYXNzSGFzaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldENvbnRyYWN0VmVyc2lvbihjb250cmFjdEFkZHJlc3MsIGNsYXNzSGFzaCwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXIvaW50ZXJmYWNlLnRzXG52YXIgU2lnbmVySW50ZXJmYWNlID0gY2xhc3Mge1xufTtcblxuLy8gc3JjL3V0aWxzL3RyYW5zYWN0aW9uLnRzXG52YXIgdHJhbnNhY3Rpb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHJhbnNhY3Rpb25fZXhwb3J0cywge1xuICBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YTogKCkgPT4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEsXG4gIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhV2l0aE5vbmNlOiAoKSA9PiBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZSxcbiAgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xOiAoKSA9PiBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YV9jYWlybzEsXG4gIGdldEV4ZWN1dGVDYWxsZGF0YTogKCkgPT4gZ2V0RXhlY3V0ZUNhbGxkYXRhLFxuICB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzOiAoKSA9PiB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzLFxuICB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzX2NhaXJvMTogKCkgPT4gdHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5c19jYWlybzFcbn0pO1xudmFyIHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXMgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgY2FsbEFycmF5ID0gW107XG4gIGNvbnN0IGNhbGxkYXRhID0gW107XG4gIGNhbGxzLmZvckVhY2goKGNhbGwpID0+IHtcbiAgICBjb25zdCBkYXRhID0gQ2FsbERhdGEuY29tcGlsZShjYWxsLmNhbGxkYXRhIHx8IFtdKTtcbiAgICBjYWxsQXJyYXkucHVzaCh7XG4gICAgICB0bzogdG9CaWdJbnQoY2FsbC5jb250cmFjdEFkZHJlc3MpLnRvU3RyaW5nKDEwKSxcbiAgICAgIHNlbGVjdG9yOiB0b0JpZ0ludChnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCkpLnRvU3RyaW5nKDEwKSxcbiAgICAgIGRhdGFfb2Zmc2V0OiBjYWxsZGF0YS5sZW5ndGgudG9TdHJpbmcoKSxcbiAgICAgIGRhdGFfbGVuOiBkYXRhLmxlbmd0aC50b1N0cmluZygpXG4gICAgfSk7XG4gICAgY2FsbGRhdGEucHVzaCguLi5kYXRhKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2FsbEFycmF5LFxuICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHsgY2FsbGRhdGEgfSlcbiAgfTtcbn07XG52YXIgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgeyBjYWxsQXJyYXksIGNhbGxkYXRhIH0gPSB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzKGNhbGxzKTtcbiAgY29uc3QgY29tcGlsZWRDYWxscyA9IENhbGxEYXRhLmNvbXBpbGUoeyBjYWxsQXJyYXkgfSk7XG4gIHJldHVybiBbLi4uY29tcGlsZWRDYWxscywgLi4uY2FsbGRhdGFdO1xufTtcbnZhciBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZSA9IChjYWxscywgbm9uY2UpID0+IHtcbiAgcmV0dXJuIFsuLi5mcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YShjYWxscyksIHRvQmlnSW50KG5vbmNlKS50b1N0cmluZygpXTtcbn07XG52YXIgdHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5c19jYWlybzEgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgY2FsbEFycmF5ID0gY2FsbHMubWFwKChjYWxsKSA9PiAoe1xuICAgIHRvOiB0b0JpZ0ludChjYWxsLmNvbnRyYWN0QWRkcmVzcykudG9TdHJpbmcoMTApLFxuICAgIHNlbGVjdG9yOiB0b0JpZ0ludChnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCkpLnRvU3RyaW5nKDEwKSxcbiAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZShjYWxsLmNhbGxkYXRhIHx8IFtdKVxuICB9KSk7XG4gIHJldHVybiBjYWxsQXJyYXk7XG59O1xudmFyIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMSA9IChjYWxscykgPT4ge1xuICBjb25zdCBvcmRlckNhbGxzID0gY2FsbHMubWFwKChjYWxsKSA9PiAoe1xuICAgIGNvbnRyYWN0QWRkcmVzczogY2FsbC5jb250cmFjdEFkZHJlc3MsXG4gICAgZW50cnlwb2ludDogY2FsbC5lbnRyeXBvaW50LFxuICAgIGNhbGxkYXRhOiBBcnJheS5pc0FycmF5KGNhbGwuY2FsbGRhdGEpICYmIFwiX19jb21waWxlZF9fXCIgaW4gY2FsbC5jYWxsZGF0YSA/IGNhbGwuY2FsbGRhdGEgOiBDYWxsRGF0YS5jb21waWxlKGNhbGwuY2FsbGRhdGEpXG4gICAgLy8gUmF3QXJnc09iamVjdCB8IFJhd0FyZ3NBcnJheSB0eXBlXG4gIH0pKTtcbiAgcmV0dXJuIENhbGxEYXRhLmNvbXBpbGUoeyBvcmRlckNhbGxzIH0pO1xufTtcbnZhciBnZXRFeGVjdXRlQ2FsbGRhdGEgPSAoY2FsbHMsIGNhaXJvVmVyc2lvbiA9IFwiMFwiKSA9PiB7XG4gIGlmIChjYWlyb1ZlcnNpb24gPT09IFwiMVwiKSB7XG4gICAgcmV0dXJuIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMShjYWxscyk7XG4gIH1cbiAgcmV0dXJuIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhKGNhbGxzKTtcbn07XG5cbi8vIHNyYy91dGlscy90eXBlZERhdGEudHNcbnZhciB0eXBlZERhdGFfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHlwZWREYXRhX2V4cG9ydHMsIHtcbiAgZW5jb2RlRGF0YTogKCkgPT4gZW5jb2RlRGF0YSxcbiAgZW5jb2RlVHlwZTogKCkgPT4gZW5jb2RlVHlwZSxcbiAgZW5jb2RlVmFsdWU6ICgpID0+IGVuY29kZVZhbHVlLFxuICBnZXREZXBlbmRlbmNpZXM6ICgpID0+IGdldERlcGVuZGVuY2llcyxcbiAgZ2V0TWVzc2FnZUhhc2g6ICgpID0+IGdldE1lc3NhZ2VIYXNoLFxuICBnZXRTdHJ1Y3RIYXNoOiAoKSA9PiBnZXRTdHJ1Y3RIYXNoLFxuICBnZXRUeXBlSGFzaDogKCkgPT4gZ2V0VHlwZUhhc2gsXG4gIGlzTWVya2xlVHJlZVR5cGU6ICgpID0+IGlzTWVya2xlVHJlZVR5cGUsXG4gIHByZXBhcmVTZWxlY3RvcjogKCkgPT4gcHJlcGFyZVNlbGVjdG9yXG59KTtcblxuLy8gc3JjL3V0aWxzL21lcmtsZS50c1xudmFyIG1lcmtsZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChtZXJrbGVfZXhwb3J0cywge1xuICBNZXJrbGVUcmVlOiAoKSA9PiBNZXJrbGVUcmVlLFxuICBwcm9vZk1lcmtsZVBhdGg6ICgpID0+IHByb29mTWVya2xlUGF0aFxufSk7XG52YXIgTWVya2xlVHJlZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobGVhZkhhc2hlcykge1xuICAgIHRoaXMuYnJhbmNoZXMgPSBbXTtcbiAgICB0aGlzLmxlYXZlcyA9IGxlYWZIYXNoZXM7XG4gICAgdGhpcy5yb290ID0gdGhpcy5idWlsZChsZWFmSGFzaGVzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIE1lcmtsZSB0cmVlXG4gICAqIEBwYXJhbSBsZWF2ZXMgaGV4LXN0cmluZyBhcnJheVxuICAgKiBAcmV0dXJucyBmb3JtYXQ6IGhleC1zdHJpbmc7IE1lcmtsZSB0cmVlIHJvb3RcbiAgICovXG4gIGJ1aWxkKGxlYXZlcykge1xuICAgIGlmIChsZWF2ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gbGVhdmVzWzBdO1xuICAgIH1cbiAgICBpZiAobGVhdmVzLmxlbmd0aCAhPT0gdGhpcy5sZWF2ZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmJyYW5jaGVzLnB1c2gobGVhdmVzKTtcbiAgICB9XG4gICAgY29uc3QgbmV3TGVhdmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWF2ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGlmIChpICsgMSA9PT0gbGVhdmVzLmxlbmd0aCkge1xuICAgICAgICBuZXdMZWF2ZXMucHVzaChNZXJrbGVUcmVlLmhhc2gobGVhdmVzW2ldLCBcIjB4MFwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdMZWF2ZXMucHVzaChNZXJrbGVUcmVlLmhhc2gobGVhdmVzW2ldLCBsZWF2ZXNbaSArIDFdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJ1aWxkKG5ld0xlYXZlcyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBwZWRlcnNlbiBoYXNoIGZyb20gYSBhbmQgYlxuICAgKiBAcmV0dXJucyBmb3JtYXQ6IGhleC1zdHJpbmdcbiAgICovXG4gIHN0YXRpYyBoYXNoKGEsIGIpIHtcbiAgICBjb25zdCBbYVNvcnRlZCwgYlNvcnRlZF0gPSBbdG9CaWdJbnQoYSksIHRvQmlnSW50KGIpXS5zb3J0KCh4LCB5KSA9PiB4ID49IHkgPyAxIDogLTEpO1xuICAgIHJldHVybiBzdGFya0N1cnZlLnBlZGVyc2VuKGFTb3J0ZWQsIGJTb3J0ZWQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gcGF0aCB0byBsZWFmXG4gICAqIEBwYXJhbSBsZWFmIGhleC1zdHJpbmdcbiAgICogQHBhcmFtIGJyYW5jaCBoZXgtc3RyaW5nIGFycmF5XG4gICAqIEBwYXJhbSBoYXNoUGF0aCBoZXgtc3RyaW5nIGFycmF5XG4gICAqIEByZXR1cm5zIGZvcm1hdDogaGV4LXN0cmluZyBhcnJheVxuICAgKi9cbiAgZ2V0UHJvb2YobGVhZiwgYnJhbmNoID0gdGhpcy5sZWF2ZXMsIGhhc2hQYXRoID0gW10pIHtcbiAgICBjb25zdCBpbmRleCA9IGJyYW5jaC5pbmRleE9mKGxlYWYpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImxlYWYgbm90IGZvdW5kXCIpO1xuICAgIH1cbiAgICBpZiAoYnJhbmNoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGhhc2hQYXRoO1xuICAgIH1cbiAgICBjb25zdCBpc0xlZnQgPSBpbmRleCAlIDIgPT09IDA7XG4gICAgY29uc3QgbmVlZGVkQnJhbmNoID0gKGlzTGVmdCA/IGJyYW5jaFtpbmRleCArIDFdIDogYnJhbmNoW2luZGV4IC0gMV0pID8/IFwiMHgwXCI7XG4gICAgY29uc3QgbmV3SGFzaFBhdGggPSBbLi4uaGFzaFBhdGgsIG5lZWRlZEJyYW5jaF07XG4gICAgY29uc3QgY3VycmVudEJyYW5jaExldmVsSW5kZXggPSB0aGlzLmxlYXZlcy5sZW5ndGggPT09IGJyYW5jaC5sZW5ndGggPyAtMSA6IHRoaXMuYnJhbmNoZXMuZmluZEluZGV4KChiKSA9PiBiLmxlbmd0aCA9PT0gYnJhbmNoLmxlbmd0aCk7XG4gICAgY29uc3QgbmV4dEJyYW5jaCA9IHRoaXMuYnJhbmNoZXNbY3VycmVudEJyYW5jaExldmVsSW5kZXggKyAxXSA/PyBbdGhpcy5yb290XTtcbiAgICByZXR1cm4gdGhpcy5nZXRQcm9vZihcbiAgICAgIE1lcmtsZVRyZWUuaGFzaChpc0xlZnQgPyBsZWFmIDogbmVlZGVkQnJhbmNoLCBpc0xlZnQgPyBuZWVkZWRCcmFuY2ggOiBsZWFmKSxcbiAgICAgIG5leHRCcmFuY2gsXG4gICAgICBuZXdIYXNoUGF0aFxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBwcm9vZk1lcmtsZVBhdGgocm9vdCwgbGVhZiwgcGF0aCkge1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gcm9vdCA9PT0gbGVhZjtcbiAgfVxuICBjb25zdCBbbmV4dCwgLi4ucmVzdF0gPSBwYXRoO1xuICByZXR1cm4gcHJvb2ZNZXJrbGVQYXRoKHJvb3QsIE1lcmtsZVRyZWUuaGFzaChsZWFmLCBuZXh0KSwgcmVzdCk7XG59XG5cbi8vIHNyYy91dGlscy90eXBlZERhdGEudHNcbmZ1bmN0aW9uIGdldEhleCh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0b0hleCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdG9IZXgoZW5jb2RlU2hvcnRTdHJpbmcodmFsdWUpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEJpZ051bWJlcmlzaDogJHt2YWx1ZX1gKTtcbiAgfVxufVxudmFyIHZhbGlkYXRlVHlwZWREYXRhID0gKGRhdGEpID0+IHtcbiAgY29uc3QgdHlwZWREYXRhID0gZGF0YTtcbiAgY29uc3QgdmFsaWQgPSBCb29sZWFuKHR5cGVkRGF0YS50eXBlcyAmJiB0eXBlZERhdGEucHJpbWFyeVR5cGUgJiYgdHlwZWREYXRhLm1lc3NhZ2UpO1xuICByZXR1cm4gdmFsaWQ7XG59O1xuZnVuY3Rpb24gcHJlcGFyZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIHJldHVybiBpc0hleChzZWxlY3RvcikgPyBzZWxlY3RvciA6IGdldFNlbGVjdG9yRnJvbU5hbWUoc2VsZWN0b3IpO1xufVxuZnVuY3Rpb24gaXNNZXJrbGVUcmVlVHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLnR5cGUgPT09IFwibWVya2xldHJlZVwiO1xufVxudmFyIGdldERlcGVuZGVuY2llcyA9ICh0eXBlcywgdHlwZSwgZGVwZW5kZW5jaWVzID0gW10pID0+IHtcbiAgaWYgKHR5cGVbdHlwZS5sZW5ndGggLSAxXSA9PT0gXCIqXCIpIHtcbiAgICB0eXBlID0gdHlwZS5zbGljZSgwLCAtMSk7XG4gIH1cbiAgaWYgKGRlcGVuZGVuY2llcy5pbmNsdWRlcyh0eXBlKSkge1xuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cbiAgaWYgKCF0eXBlc1t0eXBlXSkge1xuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cbiAgcmV0dXJuIFtcbiAgICB0eXBlLFxuICAgIC4uLnR5cGVzW3R5cGVdLnJlZHVjZShcbiAgICAgIChwcmV2aW91cywgdCkgPT4gW1xuICAgICAgICAuLi5wcmV2aW91cyxcbiAgICAgICAgLi4uZ2V0RGVwZW5kZW5jaWVzKHR5cGVzLCB0LnR5cGUsIHByZXZpb3VzKS5maWx0ZXIoXG4gICAgICAgICAgKGRlcGVuZGVuY3kpID0+ICFwcmV2aW91cy5pbmNsdWRlcyhkZXBlbmRlbmN5KVxuICAgICAgICApXG4gICAgICBdLFxuICAgICAgW11cbiAgICApXG4gIF07XG59O1xuZnVuY3Rpb24gZ2V0TWVya2xlVHJlZVR5cGUodHlwZXMsIGN0eCkge1xuICBpZiAoY3R4LnBhcmVudCAmJiBjdHgua2V5KSB7XG4gICAgY29uc3QgcGFyZW50VHlwZSA9IHR5cGVzW2N0eC5wYXJlbnRdO1xuICAgIGNvbnN0IG1lcmtsZVR5cGUgPSBwYXJlbnRUeXBlLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gY3R4LmtleSk7XG4gICAgY29uc3QgaXNNZXJrbGVUcmVlID0gaXNNZXJrbGVUcmVlVHlwZShtZXJrbGVUeXBlKTtcbiAgICBpZiAoIWlzTWVya2xlVHJlZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2N0eC5rZXl9IGlzIG5vdCBhIG1lcmtsZSB0cmVlYCk7XG4gICAgfVxuICAgIGlmIChtZXJrbGVUeXBlLmNvbnRhaW5zLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXJrbGUgdHJlZSBjb250YWluIHByb3BlcnR5IG11c3Qgbm90IGJlIGFuIGFycmF5IGJ1dCB3YXMgZ2l2ZW4gJHtjdHgua2V5fWApO1xuICAgIH1cbiAgICByZXR1cm4gbWVya2xlVHlwZS5jb250YWlucztcbiAgfVxuICByZXR1cm4gXCJyYXdcIjtcbn1cbnZhciBlbmNvZGVUeXBlID0gKHR5cGVzLCB0eXBlKSA9PiB7XG4gIGNvbnN0IFtwcmltYXJ5LCAuLi5kZXBlbmRlbmNpZXNdID0gZ2V0RGVwZW5kZW5jaWVzKHR5cGVzLCB0eXBlKTtcbiAgY29uc3QgbmV3VHlwZXMgPSAhcHJpbWFyeSA/IFtdIDogW3ByaW1hcnksIC4uLmRlcGVuZGVuY2llcy5zb3J0KCldO1xuICByZXR1cm4gbmV3VHlwZXMubWFwKChkZXBlbmRlbmN5KSA9PiB7XG4gICAgcmV0dXJuIGAke2RlcGVuZGVuY3l9KCR7dHlwZXNbZGVwZW5kZW5jeV0ubWFwKCh0KSA9PiBgJHt0Lm5hbWV9OiR7dC50eXBlfWApfSlgO1xuICB9KS5qb2luKFwiXCIpO1xufTtcbnZhciBnZXRUeXBlSGFzaCA9ICh0eXBlcywgdHlwZSkgPT4ge1xuICByZXR1cm4gZ2V0U2VsZWN0b3JGcm9tTmFtZShlbmNvZGVUeXBlKHR5cGVzLCB0eXBlKSk7XG59O1xudmFyIGVuY29kZVZhbHVlID0gKHR5cGVzLCB0eXBlLCBkYXRhLCBjdHggPSB7fSkgPT4ge1xuICBpZiAodHlwZXNbdHlwZV0pIHtcbiAgICByZXR1cm4gW3R5cGUsIGdldFN0cnVjdEhhc2godHlwZXMsIHR5cGUsIGRhdGEpXTtcbiAgfVxuICBpZiAoT2JqZWN0LmtleXModHlwZXMpLm1hcCgoeCkgPT4gYCR7eH0qYCkuaW5jbHVkZXModHlwZSkpIHtcbiAgICBjb25zdCBzdHJ1Y3RIYXNoZXMgPSBkYXRhLm1hcCgoc3RydWN0KSA9PiB7XG4gICAgICByZXR1cm4gZ2V0U3RydWN0SGFzaCh0eXBlcywgdHlwZS5zbGljZSgwLCAtMSksIHN0cnVjdCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFt0eXBlLCBjb21wdXRlSGFzaE9uRWxlbWVudHMoc3RydWN0SGFzaGVzKV07XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwibWVya2xldHJlZVwiKSB7XG4gICAgY29uc3QgbWVya2xlVHJlZVR5cGUgPSBnZXRNZXJrbGVUcmVlVHlwZSh0eXBlcywgY3R4KTtcbiAgICBjb25zdCBzdHJ1Y3RIYXNoZXMgPSBkYXRhLm1hcCgoc3RydWN0KSA9PiB7XG4gICAgICByZXR1cm4gZW5jb2RlVmFsdWUodHlwZXMsIG1lcmtsZVRyZWVUeXBlLCBzdHJ1Y3QpWzFdO1xuICAgIH0pO1xuICAgIGNvbnN0IHsgcm9vdCB9ID0gbmV3IE1lcmtsZVRyZWUoc3RydWN0SGFzaGVzKTtcbiAgICByZXR1cm4gW1wiZmVsdFwiLCByb290XTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJmZWx0KlwiKSB7XG4gICAgcmV0dXJuIFtcImZlbHQqXCIsIGNvbXB1dGVIYXNoT25FbGVtZW50cyhkYXRhKV07XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwic2VsZWN0b3JcIikge1xuICAgIHJldHVybiBbXCJmZWx0XCIsIHByZXBhcmVTZWxlY3RvcihkYXRhKV07XG4gIH1cbiAgcmV0dXJuIFt0eXBlLCBnZXRIZXgoZGF0YSldO1xufTtcbnZhciBlbmNvZGVEYXRhID0gKHR5cGVzLCB0eXBlLCBkYXRhKSA9PiB7XG4gIGNvbnN0IFtyZXR1cm5UeXBlcywgdmFsdWVzXSA9IHR5cGVzW3R5cGVdLnJlZHVjZShcbiAgICAoW3RzLCB2c10sIGZpZWxkKSA9PiB7XG4gICAgICBpZiAoZGF0YVtmaWVsZC5uYW1lXSA9PT0gdm9pZCAwIHx8IGRhdGFbZmllbGQubmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZW5jb2RlIGRhdGE6IG1pc3NpbmcgZGF0YSBmb3IgJyR7ZmllbGQubmFtZX0nYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IGRhdGFbZmllbGQubmFtZV07XG4gICAgICBjb25zdCBbdCwgZW5jb2RlZFZhbHVlXSA9IGVuY29kZVZhbHVlKHR5cGVzLCBmaWVsZC50eXBlLCB2YWx1ZSwge1xuICAgICAgICBwYXJlbnQ6IHR5cGUsXG4gICAgICAgIGtleTogZmllbGQubmFtZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbLi4udHMsIHRdLFxuICAgICAgICBbLi4udnMsIGVuY29kZWRWYWx1ZV1cbiAgICAgIF07XG4gICAgfSxcbiAgICBbW1wiZmVsdFwiXSwgW2dldFR5cGVIYXNoKHR5cGVzLCB0eXBlKV1dXG4gICk7XG4gIHJldHVybiBbcmV0dXJuVHlwZXMsIHZhbHVlc107XG59O1xudmFyIGdldFN0cnVjdEhhc2ggPSAodHlwZXMsIHR5cGUsIGRhdGEpID0+IHtcbiAgcmV0dXJuIGNvbXB1dGVIYXNoT25FbGVtZW50cyhlbmNvZGVEYXRhKHR5cGVzLCB0eXBlLCBkYXRhKVsxXSk7XG59O1xudmFyIGdldE1lc3NhZ2VIYXNoID0gKHR5cGVkRGF0YSwgYWNjb3VudCkgPT4ge1xuICBpZiAoIXZhbGlkYXRlVHlwZWREYXRhKHR5cGVkRGF0YSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlZCBkYXRhIGRvZXMgbm90IG1hdGNoIEpTT04gc2NoZW1hXCIpO1xuICB9XG4gIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgZW5jb2RlU2hvcnRTdHJpbmcoXCJTdGFya05ldCBNZXNzYWdlXCIpLFxuICAgIGdldFN0cnVjdEhhc2godHlwZWREYXRhLnR5cGVzLCBcIlN0YXJrTmV0RG9tYWluXCIsIHR5cGVkRGF0YS5kb21haW4pLFxuICAgIGFjY291bnQsXG4gICAgZ2V0U3RydWN0SGFzaCh0eXBlZERhdGEudHlwZXMsIHR5cGVkRGF0YS5wcmltYXJ5VHlwZSwgdHlwZWREYXRhLm1lc3NhZ2UpXG4gIF07XG4gIHJldHVybiBjb21wdXRlSGFzaE9uRWxlbWVudHMobWVzc2FnZSk7XG59O1xuXG4vLyBzcmMvc2lnbmVyL2RlZmF1bHQudHNcbnZhciBTaWduZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBrID0gc3RhcmtDdXJ2ZS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCkpIHtcbiAgICB0aGlzLnBrID0gcGsgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gYnVmMmhleChwaykgOiB0b0hleChwayk7XG4gIH1cbiAgYXN5bmMgZ2V0UHViS2V5KCkge1xuICAgIHJldHVybiBzdGFya0N1cnZlLmdldFN0YXJrS2V5KHRoaXMucGspO1xuICB9XG4gIGFzeW5jIHNpZ25NZXNzYWdlKHR5cGVkRGF0YSwgYWNjb3VudEFkZHJlc3MpIHtcbiAgICBjb25zdCBtc2dIYXNoID0gZ2V0TWVzc2FnZUhhc2godHlwZWREYXRhLCBhY2NvdW50QWRkcmVzcyk7XG4gICAgcmV0dXJuIHN0YXJrQ3VydmUuc2lnbihtc2dIYXNoLCB0aGlzLnBrKTtcbiAgfVxuICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25zLCB0cmFuc2FjdGlvbnNEZXRhaWwsIGFiaXMpIHtcbiAgICBpZiAoYWJpcyAmJiBhYmlzLmxlbmd0aCAhPT0gdHJhbnNhY3Rpb25zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUJJIG11c3QgYmUgcHJvdmlkZWQgZm9yIGVhY2ggdHJhbnNhY3Rpb24gb3Igbm8gdHJhbnNhY3Rpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKHRyYW5zYWN0aW9ucywgdHJhbnNhY3Rpb25zRGV0YWlsLmNhaXJvVmVyc2lvbik7XG4gICAgY29uc3QgbXNnSGFzaCA9IGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaChcbiAgICAgIHRyYW5zYWN0aW9uc0RldGFpbC53YWxsZXRBZGRyZXNzLFxuICAgICAgdHJhbnNhY3Rpb25zRGV0YWlsLnZlcnNpb24sXG4gICAgICBjYWxsZGF0YSxcbiAgICAgIHRyYW5zYWN0aW9uc0RldGFpbC5tYXhGZWUsXG4gICAgICB0cmFuc2FjdGlvbnNEZXRhaWwuY2hhaW5JZCxcbiAgICAgIHRyYW5zYWN0aW9uc0RldGFpbC5ub25jZVxuICAgICk7XG4gICAgcmV0dXJuIHN0YXJrQ3VydmUuc2lnbihtc2dIYXNoLCB0aGlzLnBrKTtcbiAgfVxuICBhc3luYyBzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKHtcbiAgICBjbGFzc0hhc2gsXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgYWRkcmVzc1NhbHQsXG4gICAgbWF4RmVlLFxuICAgIHZlcnNpb24sXG4gICAgY2hhaW5JZCxcbiAgICBub25jZVxuICB9KSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2goXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBjbGFzc0hhc2gsXG4gICAgICBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpLFxuICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgbWF4RmVlLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIG5vbmNlXG4gICAgKTtcbiAgICByZXR1cm4gc3RhcmtDdXJ2ZS5zaWduKG1zZ0hhc2gsIHRoaXMucGspO1xuICB9XG4gIGFzeW5jIHNpZ25EZWNsYXJlVHJhbnNhY3Rpb24oe1xuICAgIGNsYXNzSGFzaCxcbiAgICBzZW5kZXJBZGRyZXNzLFxuICAgIGNoYWluSWQsXG4gICAgbWF4RmVlLFxuICAgIHZlcnNpb24sXG4gICAgbm9uY2UsXG4gICAgY29tcGlsZWRDbGFzc0hhc2hcbiAgfSkge1xuICAgIGNvbnN0IG1zZ0hhc2ggPSBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoKFxuICAgICAgY2xhc3NIYXNoLFxuICAgICAgc2VuZGVyQWRkcmVzcyxcbiAgICAgIHZlcnNpb24sXG4gICAgICBtYXhGZWUsXG4gICAgICBjaGFpbklkLFxuICAgICAgbm9uY2UsXG4gICAgICBjb21waWxlZENsYXNzSGFzaFxuICAgICk7XG4gICAgcmV0dXJuIHN0YXJrQ3VydmUuc2lnbihtc2dIYXNoLCB0aGlzLnBrKTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2V2ZW50cy50c1xuZnVuY3Rpb24gcGFyc2VVRENFdmVudCh0eFJlY2VpcHQpIHtcbiAgaWYgKCF0eFJlY2VpcHQuZXZlbnRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVURDIGVtaXR0ZWQgZXZlbnQgaXMgZW1wdHlcIik7XG4gIH1cbiAgY29uc3QgZXZlbnQgPSB0eFJlY2VpcHQuZXZlbnRzLmZpbmQoXG4gICAgKGl0KSA9PiBjbGVhbkhleChpdC5mcm9tX2FkZHJlc3MpID09PSBjbGVhbkhleChVREMuQUREUkVTUylcbiAgKSB8fCB7XG4gICAgZGF0YTogW11cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2FjdGlvbl9oYXNoOiB0eFJlY2VpcHQudHJhbnNhY3Rpb25faGFzaCxcbiAgICBjb250cmFjdF9hZGRyZXNzOiBldmVudC5kYXRhWzBdLFxuICAgIGFkZHJlc3M6IGV2ZW50LmRhdGFbMF0sXG4gICAgZGVwbG95ZXI6IGV2ZW50LmRhdGFbMV0sXG4gICAgdW5pcXVlOiBldmVudC5kYXRhWzJdLFxuICAgIGNsYXNzSGFzaDogZXZlbnQuZGF0YVszXSxcbiAgICBjYWxsZGF0YV9sZW46IGV2ZW50LmRhdGFbNF0sXG4gICAgY2FsbGRhdGE6IGV2ZW50LmRhdGEuc2xpY2UoNSwgNSArIHBhcnNlSW50KGV2ZW50LmRhdGFbNF0sIDE2KSksXG4gICAgc2FsdDogZXZlbnQuZGF0YVtldmVudC5kYXRhLmxlbmd0aCAtIDFdXG4gIH07XG59XG5cbi8vIHNyYy9hY2NvdW50L2RlZmF1bHQudHNcbnZhciBBY2NvdW50ID0gY2xhc3MgZXh0ZW5kcyBQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKHByb3ZpZGVyT3JPcHRpb25zLCBhZGRyZXNzLCBwa09yU2lnbmVyLCBjYWlyb1ZlcnNpb24pIHtcbiAgICBzdXBlcihwcm92aWRlck9yT3B0aW9ucyk7XG4gICAgdGhpcy5kZXBsb3lTZWxmID0gdGhpcy5kZXBsb3lBY2NvdW50O1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnNpZ25lciA9IHR5cGVvZiBwa09yU2lnbmVyID09PSBcInN0cmluZ1wiIHx8IHBrT3JTaWduZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gbmV3IFNpZ25lcihwa09yU2lnbmVyKSA6IHBrT3JTaWduZXI7XG4gICAgaWYgKGNhaXJvVmVyc2lvbikge1xuICAgICAgdGhpcy5jYWlyb1ZlcnNpb24gPSBjYWlyb1ZlcnNpb24udG9TdHJpbmcoKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2UoYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldE5vbmNlRm9yQWRkcmVzcyh0aGlzLmFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2VTYWZlKG5vbmNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0b0JpZ0ludChub25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gMG47XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIENhaXJvIHZlcnNpb24gZnJvbSB0aGUgbmV0d29yayBhbmQgc2V0cyBgY2Fpcm9WZXJzaW9uYCBpZiBub3QgYWxyZWFkeSBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSBjbGFzc0hhc2ggaWYgcHJvdmlkZWQgZGV0ZWN0cyBDYWlybyB2ZXJzaW9uIGZyb20gY2xhc3NIYXNoLCBvdGhlcndpc2UgZnJvbSB0aGUgYWNjb3VudCBhZGRyZXNzXG4gICAqL1xuICBhc3luYyBnZXRDYWlyb1ZlcnNpb24oY2xhc3NIYXNoKSB7XG4gICAgaWYgKCF0aGlzLmNhaXJvVmVyc2lvbikge1xuICAgICAgY29uc3QgeyBjYWlybyB9ID0gY2xhc3NIYXNoID8gYXdhaXQgc3VwZXIuZ2V0Q29udHJhY3RWZXJzaW9uKHZvaWQgMCwgY2xhc3NIYXNoKSA6IGF3YWl0IHN1cGVyLmdldENvbnRyYWN0VmVyc2lvbih0aGlzLmFkZHJlc3MpO1xuICAgICAgdGhpcy5jYWlyb1ZlcnNpb24gPSBjYWlybztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2Fpcm9WZXJzaW9uO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlRmVlKGNhbGxzLCBlc3RpbWF0ZUZlZURldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZUludm9rZUZlZShjYWxscywgZXN0aW1hdGVGZWVEZXRhaWxzKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZUludm9rZUZlZShjYWxscywgeyBub25jZTogcHJvdmlkZWROb25jZSwgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgfSA9IHt9KSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25zID0gQXJyYXkuaXNBcnJheShjYWxscykgPyBjYWxscyA6IFtjYWxsc107XG4gICAgY29uc3Qgbm9uY2UgPSB0b0JpZ0ludChwcm92aWRlZE5vbmNlID8/IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKSk7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvQmlnSW50KGZlZVRyYW5zYWN0aW9uVmVyc2lvbik7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHNpZ25lckRldGFpbHMgPSB7XG4gICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBub25jZSxcbiAgICAgIG1heEZlZTogWkVSTyxcbiAgICAgIHZlcnNpb24sXG4gICAgICBjaGFpbklkLFxuICAgICAgY2Fpcm9WZXJzaW9uOiBhd2FpdCB0aGlzLmdldENhaXJvVmVyc2lvbigpXG4gICAgfTtcbiAgICBjb25zdCBpbnZvY2F0aW9uID0gYXdhaXQgdGhpcy5idWlsZEludm9jYXRpb24odHJhbnNhY3Rpb25zLCBzaWduZXJEZXRhaWxzKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHN1cGVyLmdldEludm9rZUVzdGltYXRlRmVlKFxuICAgICAgeyAuLi5pbnZvY2F0aW9uIH0sXG4gICAgICB7IHZlcnNpb24sIG5vbmNlIH0sXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGVcbiAgICApO1xuICAgIGNvbnN0IHN1Z2dlc3RlZE1heEZlZSA9IGVzdGltYXRlZEZlZVRvTWF4RmVlKHJlc3BvbnNlLm92ZXJhbGxfZmVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICBzdWdnZXN0ZWRNYXhGZWVcbiAgICB9O1xuICB9XG4gIGFzeW5jIGVzdGltYXRlRGVjbGFyZUZlZSh7IGNvbnRyYWN0LCBjbGFzc0hhc2g6IHByb3ZpZGVkQ2xhc3NIYXNoLCBjYXNtLCBjb21waWxlZENsYXNzSGFzaCB9LCB7IGJsb2NrSWRlbnRpZmllciwgbm9uY2U6IHByb3ZpZGVkTm9uY2UsIHNraXBWYWxpZGF0ZSB9ID0ge30pIHtcbiAgICBjb25zdCBub25jZSA9IHRvQmlnSW50KHByb3ZpZGVkTm9uY2UgPz8gYXdhaXQgdGhpcy5nZXROb25jZSgpKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gIWlzU2llcnJhKGNvbnRyYWN0KSA/IGZlZVRyYW5zYWN0aW9uVmVyc2lvbiA6IGZlZVRyYW5zYWN0aW9uVmVyc2lvbl8yO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuYnVpbGREZWNsYXJlUGF5bG9hZChcbiAgICAgIHsgY2xhc3NIYXNoOiBwcm92aWRlZENsYXNzSGFzaCwgY29udHJhY3QsIGNhc20sIGNvbXBpbGVkQ2xhc3NIYXNoIH0sXG4gICAgICB7XG4gICAgICAgIG5vbmNlLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgIG1heEZlZTogWkVSTyxcbiAgICAgICAgY2Fpcm9WZXJzaW9uOiB2b2lkIDBcbiAgICAgICAgLy8gdW51c2VkIHBhcmFtZXRlclxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzdXBlci5nZXREZWNsYXJlRXN0aW1hdGVGZWUoXG4gICAgICBkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbixcbiAgICAgIHsgdmVyc2lvbiwgbm9uY2UgfSxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZVxuICAgICk7XG4gICAgY29uc3Qgc3VnZ2VzdGVkTWF4RmVlID0gZXN0aW1hdGVkRmVlVG9NYXhGZWUocmVzcG9uc2Uub3ZlcmFsbF9mZWUpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNwb25zZSxcbiAgICAgIHN1Z2dlc3RlZE1heEZlZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVBY2NvdW50RGVwbG95RmVlKHtcbiAgICBjbGFzc0hhc2gsXG4gICAgYWRkcmVzc1NhbHQgPSAwLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBbXSxcbiAgICBjb250cmFjdEFkZHJlc3M6IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzXG4gIH0sIHsgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgfSA9IHt9KSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvQmlnSW50KGZlZVRyYW5zYWN0aW9uVmVyc2lvbik7XG4gICAgY29uc3Qgbm9uY2UgPSBaRVJPO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZEFjY291bnREZXBsb3lQYXlsb2FkKFxuICAgICAgeyBjbGFzc0hhc2gsIGFkZHJlc3NTYWx0LCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBjb250cmFjdEFkZHJlc3M6IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzIH0sXG4gICAgICB7XG4gICAgICAgIG5vbmNlLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgIC8vIHVudXNlZCBwYXJhbWV0ZXJcbiAgICAgICAgbWF4RmVlOiBaRVJPLFxuICAgICAgICBjYWlyb1ZlcnNpb246IHZvaWQgMFxuICAgICAgICAvLyB1bnVzZWQgcGFyYW1ldGVyXG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHN1cGVyLmdldERlcGxveUFjY291bnRFc3RpbWF0ZUZlZShcbiAgICAgIHsgLi4ucGF5bG9hZCB9LFxuICAgICAgeyB2ZXJzaW9uLCBub25jZSB9LFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgKTtcbiAgICBjb25zdCBzdWdnZXN0ZWRNYXhGZWUgPSBlc3RpbWF0ZWRGZWVUb01heEZlZShyZXNwb25zZS5vdmVyYWxsX2ZlZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgc3VnZ2VzdGVkTWF4RmVlXG4gICAgfTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZURlcGxveUZlZShwYXlsb2FkLCB0cmFuc2FjdGlvbnNEZXRhaWwpIHtcbiAgICBjb25zdCBjYWxscyA9IHRoaXMuYnVpbGRVRENDb250cmFjdFBheWxvYWQocGF5bG9hZCk7XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVJbnZva2VGZWUoY2FsbHMsIHRyYW5zYWN0aW9uc0RldGFpbCk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVGZWVCdWxrKGludm9jYXRpb25zLCB7IG5vbmNlLCBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSB9ID0ge30pIHtcbiAgICBjb25zdCBhY2NvdW50SW52b2NhdGlvbnMgPSBhd2FpdCB0aGlzLmFjY291bnRJbnZvY2F0aW9uc0ZhY3RvcnkoaW52b2NhdGlvbnMsIHtcbiAgICAgIHZlcnNpb25zOiBbZmVlVHJhbnNhY3Rpb25WZXJzaW9uLCBmZWVUcmFuc2FjdGlvblZlcnNpb25fMl0sXG4gICAgICBub25jZSxcbiAgICAgIGJsb2NrSWRlbnRpZmllclxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc3VwZXIuZ2V0RXN0aW1hdGVGZWVCdWxrKGFjY291bnRJbnZvY2F0aW9ucywge1xuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgfSk7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChyZXNwb25zZSkubWFwKChlbGVtKSA9PiB7XG4gICAgICBjb25zdCBzdWdnZXN0ZWRNYXhGZWUgPSBlc3RpbWF0ZWRGZWVUb01heEZlZShlbGVtLm92ZXJhbGxfZmVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmVsZW0sXG4gICAgICAgIHN1Z2dlc3RlZE1heEZlZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBidWlsZEludm9jYXRpb24oY2FsbCwgc2lnbmVyRGV0YWlscykge1xuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKGNhbGwsIGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKCkpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25UcmFuc2FjdGlvbihjYWxsLCBzaWduZXJEZXRhaWxzKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBjYWxsZGF0YSxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZXhlY3V0ZShjYWxscywgYWJpcyA9IHZvaWQgMCwgdHJhbnNhY3Rpb25zRGV0YWlsID0ge30pIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBBcnJheS5pc0FycmF5KGNhbGxzKSA/IGNhbGxzIDogW2NhbGxzXTtcbiAgICBjb25zdCBub25jZSA9IHRvQmlnSW50KHRyYW5zYWN0aW9uc0RldGFpbC5ub25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpO1xuICAgIGNvbnN0IG1heEZlZSA9IHRyYW5zYWN0aW9uc0RldGFpbC5tYXhGZWUgPz8gYXdhaXQgdGhpcy5nZXRTdWdnZXN0ZWRNYXhGZWUoXG4gICAgICB7IHR5cGU6IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovLCBwYXlsb2FkOiBjYWxscyB9LFxuICAgICAgdHJhbnNhY3Rpb25zRGV0YWlsXG4gICAgKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9CaWdJbnQodHJhbnNhY3Rpb25WZXJzaW9uKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3Qgc2lnbmVyRGV0YWlscyA9IHtcbiAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIG5vbmNlLFxuICAgICAgbWF4RmVlLFxuICAgICAgdmVyc2lvbixcbiAgICAgIGNoYWluSWQsXG4gICAgICBjYWlyb1ZlcnNpb246IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKClcbiAgICB9O1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbnMsIHNpZ25lckRldGFpbHMsIGFiaXMpO1xuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKHRyYW5zYWN0aW9ucywgYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKSk7XG4gICAgcmV0dXJuIHRoaXMuaW52b2tlRnVuY3Rpb24oXG4gICAgICB7IGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLCBjYWxsZGF0YSwgc2lnbmF0dXJlIH0sXG4gICAgICB7XG4gICAgICAgIG5vbmNlLFxuICAgICAgICBtYXhGZWUsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBGaXJzdCBjaGVjayBpZiBjb250cmFjdCBpcyBhbHJlYWR5IGRlY2xhcmVkLCBpZiBub3QgZGVjbGFyZSBpdFxuICAgKiBJZiBjb250cmFjdCBhbHJlYWR5IGRlY2xhcmVkIHJldHVybmVkIHRyYW5zYWN0aW9uX2hhc2ggaXMgJycuXG4gICAqIE1ldGhvZCB3aWxsIHBhc3MgZXZlbiBpZiBjb250cmFjdCBpcyBhbHJlYWR5IGRlY2xhcmVkXG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvbnNEZXRhaWwgKG9wdGlvbmFsKVxuICAgKi9cbiAgYXN5bmMgZGVjbGFyZUlmTm90KHBheWxvYWQsIHRyYW5zYWN0aW9uc0RldGFpbCA9IHt9KSB7XG4gICAgY29uc3QgZGVjbGFyZUNvbnRyYWN0UGF5bG9hZCA9IGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5nZXRDbGFzc0J5SGFzaChkZWNsYXJlQ29udHJhY3RQYXlsb2FkLmNsYXNzSGFzaCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY2xhcmUocGF5bG9hZCwgdHJhbnNhY3Rpb25zRGV0YWlsKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zYWN0aW9uX2hhc2g6IFwiXCIsXG4gICAgICBjbGFzc19oYXNoOiBkZWNsYXJlQ29udHJhY3RQYXlsb2FkLmNsYXNzSGFzaFxuICAgIH07XG4gIH1cbiAgYXN5bmMgZGVjbGFyZShwYXlsb2FkLCB0cmFuc2FjdGlvbnNEZXRhaWwgPSB7fSkge1xuICAgIGNvbnN0IGRlY2xhcmVDb250cmFjdFBheWxvYWQgPSBleHRyYWN0Q29udHJhY3RIYXNoZXMocGF5bG9hZCk7XG4gICAgY29uc3QgZGV0YWlscyA9IHt9O1xuICAgIGRldGFpbHMubm9uY2UgPSB0b0JpZ0ludCh0cmFuc2FjdGlvbnNEZXRhaWwubm9uY2UgPz8gYXdhaXQgdGhpcy5nZXROb25jZSgpKTtcbiAgICBkZXRhaWxzLm1heEZlZSA9IHRyYW5zYWN0aW9uc0RldGFpbC5tYXhGZWUgPz8gYXdhaXQgdGhpcy5nZXRTdWdnZXN0ZWRNYXhGZWUoXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgICAgIHBheWxvYWQ6IGRlY2xhcmVDb250cmFjdFBheWxvYWRcbiAgICAgIH0sXG4gICAgICB0cmFuc2FjdGlvbnNEZXRhaWxcbiAgICApO1xuICAgIGRldGFpbHMudmVyc2lvbiA9ICFpc1NpZXJyYShwYXlsb2FkLmNvbnRyYWN0KSA/IHRyYW5zYWN0aW9uVmVyc2lvbiA6IHRyYW5zYWN0aW9uVmVyc2lvbl8yO1xuICAgIGRldGFpbHMuY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IGRlY2xhcmVDb250cmFjdFRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5idWlsZERlY2xhcmVQYXlsb2FkKGRlY2xhcmVDb250cmFjdFBheWxvYWQsIHtcbiAgICAgIC4uLmRldGFpbHMsXG4gICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBjYWlyb1ZlcnNpb246IHZvaWQgMFxuICAgICAgLy8gdW51c2VkIHBhcmFtZXRlclxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmRlY2xhcmVDb250cmFjdChkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbiwgZGV0YWlscyk7XG4gIH1cbiAgYXN5bmMgZGVwbG95KHBheWxvYWQsIGRldGFpbHMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBbXS5jb25jYXQocGF5bG9hZCkubWFwKChpdCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgIHNhbHQsXG4gICAgICAgIHVuaXF1ZSA9IHRydWUsXG4gICAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBbXVxuICAgICAgfSA9IGl0O1xuICAgICAgY29uc3QgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICAgIGNvbnN0IGRlcGxveVNhbHQgPSBzYWx0ID8/IHJhbmRvbUFkZHJlc3MoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbGw6IHtcbiAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IFVEQy5BRERSRVNTLFxuICAgICAgICAgIGVudHJ5cG9pbnQ6IFVEQy5FTlRSWVBPSU5ULFxuICAgICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgICAgICBkZXBsb3lTYWx0LFxuICAgICAgICAgICAgdG9DYWlyb0Jvb2wodW5pcXVlKSxcbiAgICAgICAgICAgIGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAuLi5jb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGFcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIGFkZHJlc3M6IGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoKFxuICAgICAgICAgIHVuaXF1ZSA/IHN0YXJrQ3VydmUucGVkZXJzZW4odGhpcy5hZGRyZXNzLCBkZXBsb3lTYWx0KSA6IGRlcGxveVNhbHQsXG4gICAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICAgIGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YSxcbiAgICAgICAgICB1bmlxdWUgPyBVREMuQUREUkVTUyA6IDBcbiAgICAgICAgKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjYWxscyA9IHBhcmFtcy5tYXAoKGl0KSA9PiBpdC5jYWxsKTtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSBwYXJhbXMubWFwKChpdCkgPT4gaXQuYWRkcmVzcyk7XG4gICAgY29uc3QgaW52b2tlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmV4ZWN1dGUoY2FsbHMsIHZvaWQgMCwgZGV0YWlscyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmludm9rZVJlc3BvbnNlLFxuICAgICAgY29udHJhY3RfYWRkcmVzczogYWRkcmVzc2VzXG4gICAgfTtcbiAgfVxuICBhc3luYyBkZXBsb3lDb250cmFjdChwYXlsb2FkLCBkZXRhaWxzKSB7XG4gICAgY29uc3QgZGVwbG95VHggPSBhd2FpdCB0aGlzLmRlcGxveShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICBjb25zdCB0eFJlY2VpcHQgPSBhd2FpdCB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbihkZXBsb3lUeC50cmFuc2FjdGlvbl9oYXNoKTtcbiAgICByZXR1cm4gcGFyc2VVRENFdmVudCh0eFJlY2VpcHQpO1xuICB9XG4gIGFzeW5jIGRlY2xhcmVBbmREZXBsb3kocGF5bG9hZCwgZGV0YWlscykge1xuICAgIGNvbnN0IHsgY29uc3RydWN0b3JDYWxsZGF0YSwgc2FsdCwgdW5pcXVlIH0gPSBwYXlsb2FkO1xuICAgIGxldCBkZWNsYXJlID0gYXdhaXQgdGhpcy5kZWNsYXJlSWZOb3QocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgaWYgKGRlY2xhcmUudHJhbnNhY3Rpb25faGFzaCAhPT0gXCJcIikge1xuICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbihkZWNsYXJlLnRyYW5zYWN0aW9uX2hhc2gpO1xuICAgICAgZGVjbGFyZSA9IHsgLi4uZGVjbGFyZSwgLi4udHggfTtcbiAgICB9XG4gICAgY29uc3QgZGVwbG95ID0gYXdhaXQgdGhpcy5kZXBsb3lDb250cmFjdChcbiAgICAgIHsgY2xhc3NIYXNoOiBkZWNsYXJlLmNsYXNzX2hhc2gsIHNhbHQsIHVuaXF1ZSwgY29uc3RydWN0b3JDYWxsZGF0YSB9LFxuICAgICAgZGV0YWlsc1xuICAgICk7XG4gICAgcmV0dXJuIHsgZGVjbGFyZTogeyAuLi5kZWNsYXJlIH0sIGRlcGxveSB9O1xuICB9XG4gIGFzeW5jIGRlcGxveUFjY291bnQoe1xuICAgIGNsYXNzSGFzaCxcbiAgICBjb25zdHJ1Y3RvckNhbGxkYXRhID0gW10sXG4gICAgYWRkcmVzc1NhbHQgPSAwLFxuICAgIGNvbnRyYWN0QWRkcmVzczogcHJvdmlkZWRDb250cmFjdEFkZHJlc3NcbiAgfSwgdHJhbnNhY3Rpb25zRGV0YWlsID0ge30pIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9CaWdJbnQodHJhbnNhY3Rpb25WZXJzaW9uKTtcbiAgICBjb25zdCBub25jZSA9IFpFUk87XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IGNvbXBpbGVkQ2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICAgIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzID8/IGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoKGFkZHJlc3NTYWx0LCBjbGFzc0hhc2gsIGNvbXBpbGVkQ2FsbGRhdGEsIDApO1xuICAgIGNvbnN0IG1heEZlZSA9IHRyYW5zYWN0aW9uc0RldGFpbC5tYXhGZWUgPz8gYXdhaXQgdGhpcy5nZXRTdWdnZXN0ZWRNYXhGZWUoXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIGNsYXNzSGFzaCxcbiAgICAgICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhLFxuICAgICAgICAgIGFkZHJlc3NTYWx0LFxuICAgICAgICAgIGNvbnRyYWN0QWRkcmVzc1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHJhbnNhY3Rpb25zRGV0YWlsXG4gICAgKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25lci5zaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKHtcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGE6IGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBhZGRyZXNzU2FsdCxcbiAgICAgIGNoYWluSWQsXG4gICAgICBtYXhGZWUsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgbm9uY2VcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5kZXBsb3lBY2NvdW50Q29udHJhY3QoXG4gICAgICB7IGNsYXNzSGFzaCwgYWRkcmVzc1NhbHQsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIHNpZ25hdHVyZSB9LFxuICAgICAge1xuICAgICAgICBub25jZSxcbiAgICAgICAgbWF4RmVlLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBzaWduTWVzc2FnZSh0eXBlZERhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduZXIuc2lnbk1lc3NhZ2UodHlwZWREYXRhLCB0aGlzLmFkZHJlc3MpO1xuICB9XG4gIGFzeW5jIGhhc2hNZXNzYWdlKHR5cGVkRGF0YSkge1xuICAgIHJldHVybiBnZXRNZXNzYWdlSGFzaCh0eXBlZERhdGEsIHRoaXMuYWRkcmVzcyk7XG4gIH1cbiAgYXN5bmMgdmVyaWZ5TWVzc2FnZUhhc2goaGFzaCwgc2lnbmF0dXJlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuY2FsbENvbnRyYWN0KHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgIGVudHJ5cG9pbnQ6IFwiaXNWYWxpZFNpZ25hdHVyZVwiLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZSh7XG4gICAgICAgICAgaGFzaDogdG9CaWdJbnQoaGFzaCkudG9TdHJpbmcoKSxcbiAgICAgICAgICBzaWduYXR1cmU6IGZvcm1hdFNpZ25hdHVyZShzaWduYXR1cmUpXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyB2ZXJpZnlNZXNzYWdlKHR5cGVkRGF0YSwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuaGFzaE1lc3NhZ2UodHlwZWREYXRhKTtcbiAgICByZXR1cm4gdGhpcy52ZXJpZnlNZXNzYWdlSGFzaChoYXNoLCBzaWduYXR1cmUpO1xuICB9XG4gIGFzeW5jIGdldFN1Z2dlc3RlZE1heEZlZSh7IHR5cGUsIHBheWxvYWQgfSwgZGV0YWlscykge1xuICAgIGxldCBmZWVFc3RpbWF0ZTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi86XG4gICAgICAgIGZlZUVzdGltYXRlID0gYXdhaXQgdGhpcy5lc3RpbWF0ZUludm9rZUZlZShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi86XG4gICAgICAgIGZlZUVzdGltYXRlID0gYXdhaXQgdGhpcy5lc3RpbWF0ZURlY2xhcmVGZWUocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi86XG4gICAgICAgIGZlZUVzdGltYXRlID0gYXdhaXQgdGhpcy5lc3RpbWF0ZUFjY291bnREZXBsb3lGZWUocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkRFUExPWVwiIC8qIERFUExPWSAqLzpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSBhd2FpdCB0aGlzLmVzdGltYXRlRGVwbG95RmVlKHBheWxvYWQsIGRldGFpbHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGZlZUVzdGltYXRlID0geyBzdWdnZXN0ZWRNYXhGZWU6IFpFUk8sIG92ZXJhbGxfZmVlOiBaRVJPIH07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZmVlRXN0aW1hdGUuc3VnZ2VzdGVkTWF4RmVlO1xuICB9XG4gIC8qKlxuICAgKiB3aWxsIGJlIHJlbmFtZWQgdG8gYnVpbGREZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgYnVpbGREZWNsYXJlUGF5bG9hZChwYXlsb2FkLCB7IG5vbmNlLCBjaGFpbklkLCB2ZXJzaW9uLCB3YWxsZXRBZGRyZXNzLCBtYXhGZWUgfSkge1xuICAgIGNvbnN0IHsgY2xhc3NIYXNoLCBjb250cmFjdCwgY29tcGlsZWRDbGFzc0hhc2ggfSA9IGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKTtcbiAgICBjb25zdCBjb21wcmVzc2VkQ29tcGlsZWRDb250cmFjdCA9IHBhcnNlQ29udHJhY3QoY29udHJhY3QpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25EZWNsYXJlVHJhbnNhY3Rpb24oe1xuICAgICAgY2xhc3NIYXNoLFxuICAgICAgY29tcGlsZWRDbGFzc0hhc2gsXG4gICAgICBzZW5kZXJBZGRyZXNzOiB3YWxsZXRBZGRyZXNzLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIG1heEZlZSxcbiAgICAgIHZlcnNpb24sXG4gICAgICBub25jZVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBzZW5kZXJBZGRyZXNzOiB3YWxsZXRBZGRyZXNzLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgY29udHJhY3Q6IGNvbXByZXNzZWRDb21waWxlZENvbnRyYWN0LFxuICAgICAgY29tcGlsZWRDbGFzc0hhc2hcbiAgICB9O1xuICB9XG4gIGFzeW5jIGJ1aWxkQWNjb3VudERlcGxveVBheWxvYWQoe1xuICAgIGNsYXNzSGFzaCxcbiAgICBhZGRyZXNzU2FsdCA9IDAsXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdLFxuICAgIGNvbnRyYWN0QWRkcmVzczogcHJvdmlkZWRDb250cmFjdEFkZHJlc3NcbiAgfSwgeyBub25jZSwgY2hhaW5JZCwgdmVyc2lvbiwgbWF4RmVlIH0pIHtcbiAgICBjb25zdCBjb21waWxlZENhbGxkYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBwcm92aWRlZENvbnRyYWN0QWRkcmVzcyA/PyBjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaChhZGRyZXNzU2FsdCwgY2xhc3NIYXNoLCBjb21waWxlZENhbGxkYXRhLCAwKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25lci5zaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKHtcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGNoYWluSWQsXG4gICAgICBtYXhGZWUsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgbm9uY2UsXG4gICAgICBhZGRyZXNzU2FsdCxcbiAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGE6IGNvbXBpbGVkQ2FsbGRhdGFcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3NIYXNoLFxuICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfTtcbiAgfVxuICBidWlsZFVEQ0NvbnRyYWN0UGF5bG9hZChwYXlsb2FkKSB7XG4gICAgY29uc3QgY2FsbHMgPSBbXS5jb25jYXQocGF5bG9hZCkubWFwKChpdCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgIHNhbHQgPSBcIjBcIixcbiAgICAgICAgdW5pcXVlID0gdHJ1ZSxcbiAgICAgICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdXG4gICAgICB9ID0gaXQ7XG4gICAgICBjb25zdCBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBVREMuQUREUkVTUyxcbiAgICAgICAgZW50cnlwb2ludDogVURDLkVOVFJZUE9JTlQsXG4gICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICAgIHNhbHQsXG4gICAgICAgICAgdG9DYWlyb0Jvb2wodW5pcXVlKSxcbiAgICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEubGVuZ3RoLFxuICAgICAgICAgIC4uLmNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YVxuICAgICAgICBdXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBjYWxscztcbiAgfVxuICBhc3luYyBzaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCB7IG5vbmNlLCBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSwgc2tpcEV4ZWN1dGUgfSA9IHt9KSB7XG4gICAgY29uc3QgYWNjb3VudEludm9jYXRpb25zID0gYXdhaXQgdGhpcy5hY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5KGludm9jYXRpb25zLCB7XG4gICAgICB2ZXJzaW9uczogW3RyYW5zYWN0aW9uVmVyc2lvbiwgdHJhbnNhY3Rpb25WZXJzaW9uXzJdLFxuICAgICAgbm9uY2UsXG4gICAgICBibG9ja0lkZW50aWZpZXJcbiAgICB9KTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0U2ltdWxhdGVUcmFuc2FjdGlvbihhY2NvdW50SW52b2NhdGlvbnMsIHtcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZSxcbiAgICAgIHNraXBFeGVjdXRlXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgYWNjb3VudEludm9jYXRpb25zRmFjdG9yeShpbnZvY2F0aW9ucywgeyB2ZXJzaW9ucywgbm9uY2UsIGJsb2NrSWRlbnRpZmllciB9KSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IHZlcnNpb25zWzBdO1xuICAgIGNvbnN0IHNhZmVOb25jZSA9IGF3YWl0IHRoaXMuZ2V0Tm9uY2VTYWZlKG5vbmNlKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgdHgwUGF5bG9hZCA9IFwicGF5bG9hZFwiIGluIGludm9jYXRpb25zWzBdID8gaW52b2NhdGlvbnNbMF0ucGF5bG9hZCA6IGludm9jYXRpb25zWzBdO1xuICAgIGNvbnN0IGNhaXJvVmVyc2lvbiA9IGludm9jYXRpb25zWzBdLnR5cGUgPT09IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyA/IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKHR4MFBheWxvYWQuY2xhc3NIYXNoKSA6IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKCk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgW10uY29uY2F0KGludm9jYXRpb25zKS5tYXAoYXN5bmMgKHRyYW5zYWN0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB0eFBheWxvYWQgPSBcInBheWxvYWRcIiBpbiB0cmFuc2FjdGlvbiA/IHRyYW5zYWN0aW9uLnBheWxvYWQgOiB0cmFuc2FjdGlvbjtcbiAgICAgICAgY29uc3Qgc2lnbmVyRGV0YWlscyA9IHtcbiAgICAgICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgbm9uY2U6IHRvQmlnSW50KE51bWJlcihzYWZlTm9uY2UpICsgaW5kZXgpLFxuICAgICAgICAgIG1heEZlZTogWkVSTyxcbiAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgY2Fpcm9WZXJzaW9uXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbW1vbiA9IHtcbiAgICAgICAgICB0eXBlOiB0cmFuc2FjdGlvbi50eXBlLFxuICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgbm9uY2U6IHRvQmlnSW50KE51bWJlcihzYWZlTm9uY2UpICsgaW5kZXgpLFxuICAgICAgICAgIGJsb2NrSWRlbnRpZmllclxuICAgICAgICB9O1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi8pIHtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZEludm9jYXRpb24oXG4gICAgICAgICAgICBbXS5jb25jYXQodHhQYXlsb2FkKSxcbiAgICAgICAgICAgIHNpZ25lckRldGFpbHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICAuLi5wYXlsb2FkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLykge1xuICAgICAgICAgIHNpZ25lckRldGFpbHMudmVyc2lvbiA9ICFpc1NpZXJyYSh0eFBheWxvYWQuY29udHJhY3QpID8gdG9CaWdJbnQodmVyc2lvbnNbMF0pIDogdG9CaWdJbnQodmVyc2lvbnNbMV0pO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzLmJ1aWxkRGVjbGFyZVBheWxvYWQodHhQYXlsb2FkLCBzaWduZXJEZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgIHZlcnNpb246IHNpZ25lckRldGFpbHMudmVyc2lvblxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT09IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLykge1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzLmJ1aWxkQWNjb3VudERlcGxveVBheWxvYWQodHhQYXlsb2FkLCBzaWduZXJEZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgLi4ucGF5bG9hZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT09IFwiREVQTE9ZXCIgLyogREVQTE9ZICovKSB7XG4gICAgICAgICAgY29uc3QgY2FsbHMgPSB0aGlzLmJ1aWxkVURDQ29udHJhY3RQYXlsb2FkKHR4UGF5bG9hZCk7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXMuYnVpbGRJbnZvY2F0aW9uKGNhbGxzLCBzaWduZXJEZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgIHR5cGU6IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBFcnJvcihgYWNjb3VudEludm9jYXRpb25zRmFjdG9yeTogdW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZTogJHt0cmFuc2FjdGlvbn1gKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRTdGFya05hbWUoYWRkcmVzcyA9IHRoaXMuYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBzdXBlci5nZXRTdGFya05hbWUoYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mik7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9pbnRlcmZhY2UudHNcbnZhciBQcm92aWRlckludGVyZmFjZSA9IGNsYXNzIHtcbn07XG5cbi8vIHNyYy9wcm92aWRlci9pbmRleC50c1xudmFyIGRlZmF1bHRQcm92aWRlciA9IG5ldyBQcm92aWRlcih7IHJwYzogeyBkZWZhdWx0OiB0cnVlIH0gfSk7XG5cbi8vIHNyYy9hY2NvdW50L2ludGVyZmFjZS50c1xudmFyIEFjY291bnRJbnRlcmZhY2UgPSBjbGFzcyBleHRlbmRzIFByb3ZpZGVySW50ZXJmYWNlIHtcbn07XG5cbi8vIHNyYy91dGlscy9ldmVudHMvaW5kZXgudHNcbnZhciBldmVudHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZXZlbnRzX2V4cG9ydHMsIHtcbiAgZ2V0QWJpRXZlbnRzOiAoKSA9PiBnZXRBYmlFdmVudHMsXG4gIHBhcnNlRXZlbnRzOiAoKSA9PiBwYXJzZUV2ZW50c1xufSk7XG5mdW5jdGlvbiBnZXRBYmlFdmVudHMoYWJpKSB7XG4gIHJldHVybiBhYmkuZmlsdGVyKChhYmlFbnRyeSkgPT4gYWJpRW50cnkudHlwZSA9PT0gXCJldmVudFwiICYmIChhYmlFbnRyeS5zaXplIHx8IGFiaUVudHJ5LmtpbmQgIT09IFwiZW51bVwiKSkucmVkdWNlKChhY2MsIGFiaUVudHJ5KSA9PiB7XG4gICAgY29uc3QgZW50cnlOYW1lID0gYWJpRW50cnkubmFtZS5zbGljZShhYmlFbnRyeS5uYW1lLmxhc3RJbmRleE9mKFwiOlwiKSArIDEpO1xuICAgIGNvbnN0IGFiaUVudHJ5TW9kID0geyAuLi5hYmlFbnRyeSB9O1xuICAgIGFiaUVudHJ5TW9kLm5hbWUgPSBlbnRyeU5hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmFjYyxcbiAgICAgIFthZGRIZXhQcmVmaXgoc3RhcmtDdXJ2ZS5rZWNjYWsodXRmOFRvQXJyYXkoZW50cnlOYW1lKSkudG9TdHJpbmcoMTYpKV06IGFiaUVudHJ5TW9kXG4gICAgfTtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gcGFyc2VFdmVudHMocHJvdmlkZXJSZWNlaXZlZEV2ZW50cywgYWJpRXZlbnRzLCBhYmlTdHJ1Y3RzLCBhYmlFbnVtcykge1xuICBjb25zdCByZXQgPSBwcm92aWRlclJlY2VpdmVkRXZlbnRzLmZsYXQoKS5yZWR1Y2UoKGFjYywgcmVjRXZlbnQpID0+IHtcbiAgICBjb25zdCBhYmlFdmVudCA9IGFiaUV2ZW50c1tyZWNFdmVudC5rZXlzWzBdXTtcbiAgICBpZiAoIWFiaUV2ZW50KSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRFdmVudCA9IHt9O1xuICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdID0ge307XG4gICAgcmVjRXZlbnQua2V5cy5zaGlmdCgpO1xuICAgIGNvbnN0IGtleXNJdGVyID0gcmVjRXZlbnQua2V5c1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgZGF0YUl0ZXIgPSByZWNFdmVudC5kYXRhW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBjb25zdCBhYmlFdmVudEtleXMgPSBhYmlFdmVudC5tZW1iZXJzPy5maWx0ZXIoKGl0KSA9PiBpdC5raW5kID09PSBcImtleVwiKSB8fCBhYmlFdmVudC5rZXlzO1xuICAgIGNvbnN0IGFiaUV2ZW50RGF0YSA9IGFiaUV2ZW50Lm1lbWJlcnM/LmZpbHRlcigoaXQpID0+IGl0LmtpbmQgPT09IFwiZGF0YVwiKSB8fCBhYmlFdmVudC5kYXRhO1xuICAgIGFiaUV2ZW50S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdW2tleS5uYW1lXSA9IHJlc3BvbnNlUGFyc2VyKFxuICAgICAgICBrZXlzSXRlcixcbiAgICAgICAga2V5LFxuICAgICAgICBhYmlTdHJ1Y3RzLFxuICAgICAgICBhYmlFbnVtcyxcbiAgICAgICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV1cbiAgICAgICk7XG4gICAgfSk7XG4gICAgYWJpRXZlbnREYXRhLmZvckVhY2goKGRhdGEpID0+IHtcbiAgICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdW2RhdGEubmFtZV0gPSByZXNwb25zZVBhcnNlcihcbiAgICAgICAgZGF0YUl0ZXIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGFiaVN0cnVjdHMsXG4gICAgICAgIGFiaUVudW1zLFxuICAgICAgICBwYXJzZWRFdmVudFthYmlFdmVudC5uYW1lXVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBhY2MucHVzaChwYXJzZWRFdmVudCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10pO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBzcmMvY29udHJhY3QvZGVmYXVsdC50c1xudmFyIHNwbGl0QXJnc0FuZE9wdGlvbnMgPSAoYXJncykgPT4ge1xuICBjb25zdCBvcHRpb25zID0gW1xuICAgIFwiYmxvY2tJZGVudGlmaWVyXCIsXG4gICAgXCJwYXJzZVJlcXVlc3RcIixcbiAgICBcInBhcnNlUmVzcG9uc2VcIixcbiAgICBcImZvcm1hdFJlc3BvbnNlXCIsXG4gICAgXCJtYXhGZWVcIixcbiAgICBcIm5vbmNlXCIsXG4gICAgXCJzaWduYXR1cmVcIixcbiAgICBcImFkZHJlc3NTYWx0XCJcbiAgXTtcbiAgY29uc3QgbGFzdEFyZyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgaWYgKHR5cGVvZiBsYXN0QXJnID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuc29tZSgoeCkgPT4geCBpbiBsYXN0QXJnKSkge1xuICAgIHJldHVybiB7IGFyZ3MsIG9wdGlvbnM6IGFyZ3MucG9wKCkgfTtcbiAgfVxuICByZXR1cm4geyBhcmdzIH07XG59O1xuZnVuY3Rpb24gYnVpbGRDYWxsKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHNwbGl0QXJnc0FuZE9wdGlvbnMoYXJncyk7XG4gICAgcmV0dXJuIGNvbnRyYWN0LmNhbGwoZnVuY3Rpb25BYmkubmFtZSwgcGFyYW1zLmFyZ3MsIHtcbiAgICAgIHBhcnNlUmVxdWVzdDogdHJ1ZSxcbiAgICAgIHBhcnNlUmVzcG9uc2U6IHRydWUsXG4gICAgICAuLi5wYXJhbXMub3B0aW9uc1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRJbnZva2UoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3BsaXRBcmdzQW5kT3B0aW9ucyhhcmdzKTtcbiAgICByZXR1cm4gY29udHJhY3QuaW52b2tlKGZ1bmN0aW9uQWJpLm5hbWUsIHBhcmFtcy5hcmdzLCB7XG4gICAgICBwYXJzZVJlcXVlc3Q6IHRydWUsXG4gICAgICAuLi5wYXJhbXMub3B0aW9uc1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGREZWZhdWx0KGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICBpZiAoZnVuY3Rpb25BYmkuc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBmdW5jdGlvbkFiaS5zdGF0ZV9tdXRhYmlsaXR5ID09PSBcInZpZXdcIikge1xuICAgIHJldHVybiBidWlsZENhbGwoY29udHJhY3QsIGZ1bmN0aW9uQWJpKTtcbiAgfVxuICByZXR1cm4gYnVpbGRJbnZva2UoY29udHJhY3QsIGZ1bmN0aW9uQWJpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUG9wdWxhdGUoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGNvbnRyYWN0LnBvcHVsYXRlKGZ1bmN0aW9uQWJpLm5hbWUsIGFyZ3MpO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRFc3RpbWF0ZShjb250cmFjdCwgZnVuY3Rpb25BYmkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gY29udHJhY3QuZXN0aW1hdGUoZnVuY3Rpb25BYmkubmFtZSwgYXJncyk7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDYWxsZGF0YShhcmdzLCBjYWxsYmFjaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBcIl9fY29tcGlsZWRfX1wiIGluIGFyZ3MpXG4gICAgcmV0dXJuIGFyZ3M7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIEFycmF5LmlzQXJyYXkoYXJnc1swXSkgJiYgXCJfX2NvbXBpbGVkX19cIiBpbiBhcmdzWzBdKVxuICAgIHJldHVybiBhcmdzWzBdO1xuICByZXR1cm4gY2FsbGJhY2soKTtcbn1cbnZhciBDb250cmFjdCA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENvbnRyYWN0IGNsYXNzIHRvIGhhbmRsZSBjb250cmFjdCBtZXRob2RzXG4gICAqXG4gICAqIEBwYXJhbSBhYmkgLSBBYmkgb2YgdGhlIGNvbnRyYWN0IG9iamVjdFxuICAgKiBAcGFyYW0gYWRkcmVzcyAob3B0aW9uYWwpIC0gYWRkcmVzcyB0byBjb25uZWN0IHRvXG4gICAqIEBwYXJhbSBwcm92aWRlck9yQWNjb3VudCAob3B0aW9uYWwpIC0gUHJvdmlkZXIgb3IgQWNjb3VudCB0byBhdHRhY2ggdG9cbiAgICovXG4gIGNvbnN0cnVjdG9yKGFiaSwgYWRkcmVzcywgcHJvdmlkZXJPckFjY291bnQgPSBkZWZhdWx0UHJvdmlkZXIpIHtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzICYmIGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3ZpZGVyT3JBY2NvdW50ID0gcHJvdmlkZXJPckFjY291bnQ7XG4gICAgdGhpcy5jYWxsRGF0YSA9IG5ldyBDYWxsRGF0YShhYmkpO1xuICAgIHRoaXMuc3RydWN0cyA9IENhbGxEYXRhLmdldEFiaVN0cnVjdChhYmkpO1xuICAgIHRoaXMuZXZlbnRzID0gZ2V0QWJpRXZlbnRzKGFiaSk7XG4gICAgY29uc3QgcGFyc2VyID0gY3JlYXRlQWJpUGFyc2VyKGFiaSk7XG4gICAgdGhpcy5hYmkgPSBwYXJzZXIuZ2V0TGVnYWN5Rm9ybWF0KCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBmdW5jdGlvbnM6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfSxcbiAgICAgIGNhbGxTdGF0aWM6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfSxcbiAgICAgIHBvcHVsYXRlVHJhbnNhY3Rpb246IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfSxcbiAgICAgIGVzdGltYXRlRmVlOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH1cbiAgICB9KTtcbiAgICB0aGlzLmFiaS5mb3JFYWNoKChhYmlFbGVtZW50KSA9PiB7XG4gICAgICBpZiAoYWJpRWxlbWVudC50eXBlICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGFiaUVsZW1lbnQubmFtZTtcbiAgICAgIGlmICghdGhpc1tzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZERlZmF1bHQodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZnVuY3Rpb25zW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZnVuY3Rpb25zLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZERlZmF1bHQodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY2FsbFN0YXRpY1tzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmNhbGxTdGF0aWMsIHNpZ25hdHVyZSwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdmFsdWU6IGJ1aWxkQ2FsbCh0aGlzLCBhYmlFbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbiwgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGRQb3B1bGF0ZSh0aGlzLCBhYmlFbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5lc3RpbWF0ZUZlZVtzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVzdGltYXRlRmVlLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZEVzdGltYXRlKHRoaXMsIGFiaUVsZW1lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGF0dGFjaChhZGRyZXNzKSB7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgfVxuICBjb25uZWN0KHByb3ZpZGVyT3JBY2NvdW50KSB7XG4gICAgdGhpcy5wcm92aWRlck9yQWNjb3VudCA9IHByb3ZpZGVyT3JBY2NvdW50O1xuICB9XG4gIGFzeW5jIGRlcGxveWVkKCkge1xuICAgIGlmICh0aGlzLmRlcGxveVRyYW5zYWN0aW9uSGFzaCkge1xuICAgICAgYXdhaXQgdGhpcy5wcm92aWRlck9yQWNjb3VudC53YWl0Rm9yVHJhbnNhY3Rpb24odGhpcy5kZXBsb3lUcmFuc2FjdGlvbkhhc2gpO1xuICAgICAgdGhpcy5kZXBsb3lUcmFuc2FjdGlvbkhhc2ggPSB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFzeW5jIGNhbGwobWV0aG9kLCBhcmdzID0gW10sIHtcbiAgICBwYXJzZVJlcXVlc3QgPSB0cnVlLFxuICAgIHBhcnNlUmVzcG9uc2UgPSB0cnVlLFxuICAgIGZvcm1hdFJlc3BvbnNlID0gdm9pZCAwLFxuICAgIGJsb2NrSWRlbnRpZmllciA9IHZvaWQgMFxuICB9ID0ge30pIHtcbiAgICBhc3NlcnQodGhpcy5hZGRyZXNzICE9PSBudWxsLCBcImNvbnRyYWN0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYW4gYWRkcmVzc1wiKTtcbiAgICBjb25zdCBjYWxsZGF0YSA9IGdldENhbGxkYXRhKGFyZ3MsICgpID0+IHtcbiAgICAgIGlmIChwYXJzZVJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5jYWxsRGF0YS52YWxpZGF0ZShcIkNBTExcIiAvKiBDQUxMICovLCBtZXRob2QsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsRGF0YS5jb21waWxlKG1ldGhvZCwgYXJncyk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLndhcm4oXCJDYWxsIHNraXBwZWQgcGFyc2luZyBidXQgcHJvdmlkZWQgcmF3QXJncywgcG9zc2libGUgbWFsZnVuY3Rpb24gcmVxdWVzdFwiKTtcbiAgICAgIHJldHVybiBhcmdzO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmNhbGxDb250cmFjdChcbiAgICAgIHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgIGNhbGxkYXRhLFxuICAgICAgICBlbnRyeXBvaW50OiBtZXRob2RcbiAgICAgIH0sXG4gICAgICBibG9ja0lkZW50aWZpZXJcbiAgICApLnRoZW4oKHgpID0+IHtcbiAgICAgIGlmICghcGFyc2VSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4geC5yZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0UmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbERhdGEuZm9ybWF0KG1ldGhvZCwgeC5yZXN1bHQsIGZvcm1hdFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLnBhcnNlKG1ldGhvZCwgeC5yZXN1bHQpO1xuICAgIH0pO1xuICB9XG4gIGludm9rZShtZXRob2QsIGFyZ3MgPSBbXSwgeyBwYXJzZVJlcXVlc3QgPSB0cnVlLCBtYXhGZWUsIG5vbmNlLCBzaWduYXR1cmUgfSA9IHt9KSB7XG4gICAgYXNzZXJ0KHRoaXMuYWRkcmVzcyAhPT0gbnVsbCwgXCJjb250cmFjdCBpcyBub3QgY29ubmVjdGVkIHRvIGFuIGFkZHJlc3NcIik7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB7XG4gICAgICBpZiAocGFyc2VSZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuY2FsbERhdGEudmFsaWRhdGUoXCJJTlZPS0VcIiAvKiBJTlZPS0UgKi8sIG1ldGhvZCwgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIkludm9rZSBza2lwcGVkIHBhcnNpbmcgYnV0IHByb3ZpZGVkIHJhd0FyZ3MsIHBvc3NpYmxlIG1hbGZ1bmN0aW9uIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9KTtcbiAgICBjb25zdCBpbnZvY2F0aW9uID0ge1xuICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBjYWxsZGF0YSxcbiAgICAgIGVudHJ5cG9pbnQ6IG1ldGhvZFxuICAgIH07XG4gICAgaWYgKFwiZXhlY3V0ZVwiIGluIHRoaXMucHJvdmlkZXJPckFjY291bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmV4ZWN1dGUoaW52b2NhdGlvbiwgdm9pZCAwLCB7XG4gICAgICAgIG1heEZlZSxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIW5vbmNlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb25jZSBpcyByZXF1aXJlZCB3aGVuIGludm9raW5nIGEgZnVuY3Rpb24gd2l0aG91dCBhbiBhY2NvdW50YCk7XG4gICAgY29uc29sZS53YXJuKGBJbnZva2luZyAke21ldGhvZH0gd2l0aG91dCBhbiBhY2NvdW50LiBUaGlzIHdpbGwgbm90IHdvcmsgb24gYSBwdWJsaWMgbm9kZS5gKTtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlck9yQWNjb3VudC5pbnZva2VGdW5jdGlvbihcbiAgICAgIHtcbiAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgc2lnbmF0dXJlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBub25jZVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGUobWV0aG9kLCBhcmdzID0gW10pIHtcbiAgICBhc3NlcnQodGhpcy5hZGRyZXNzICE9PSBudWxsLCBcImNvbnRyYWN0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYW4gYWRkcmVzc1wiKTtcbiAgICBpZiAoIWdldENhbGxkYXRhKGFyZ3MsICgpID0+IGZhbHNlKSkge1xuICAgICAgdGhpcy5jYWxsRGF0YS52YWxpZGF0ZShcIklOVk9LRVwiIC8qIElOVk9LRSAqLywgbWV0aG9kLCBhcmdzKTtcbiAgICB9XG4gICAgY29uc3QgaW52b2NhdGlvbiA9IHRoaXMucG9wdWxhdGUobWV0aG9kLCBhcmdzKTtcbiAgICBpZiAoXCJlc3RpbWF0ZUludm9rZUZlZVwiIGluIHRoaXMucHJvdmlkZXJPckFjY291bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmVzdGltYXRlSW52b2tlRmVlKGludm9jYXRpb24pO1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIkNvbnRyYWN0IG11c3QgYmUgY29ubmVjdGVkIHRvIHRoZSBhY2NvdW50IGNvbnRyYWN0IHRvIGVzdGltYXRlXCIpO1xuICB9XG4gIHBvcHVsYXRlKG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgZW50cnlwb2ludDogbWV0aG9kLFxuICAgICAgY2FsbGRhdGFcbiAgICB9O1xuICB9XG4gIHBhcnNlRXZlbnRzKHJlY2VpcHQpIHtcbiAgICByZXR1cm4gcGFyc2VFdmVudHMoXG4gICAgICByZWNlaXB0LmV2ZW50cz8uZmlsdGVyKFxuICAgICAgICAoZXZlbnQpID0+IGNsZWFuSGV4KGV2ZW50LmZyb21fYWRkcmVzcykgPT09IGNsZWFuSGV4KHRoaXMuYWRkcmVzcyksXG4gICAgICAgIFtdXG4gICAgICApIHx8IFtdLFxuICAgICAgdGhpcy5ldmVudHMsXG4gICAgICB0aGlzLnN0cnVjdHMsXG4gICAgICBDYWxsRGF0YS5nZXRBYmlFbnVtKHRoaXMuYWJpKVxuICAgICk7XG4gIH1cbiAgaXNDYWlybzEoKSB7XG4gICAgcmV0dXJuIGNhaXJvX2V4cG9ydHMuaXNDYWlybzFBYmkodGhpcy5hYmkpO1xuICB9XG4gIGFzeW5jIGdldFZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXJPckFjY291bnQuZ2V0Q29udHJhY3RWZXJzaW9uKHRoaXMuYWRkcmVzcyk7XG4gIH1cbiAgdHlwZWQodEFiaSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG4vLyBzcmMvY29udHJhY3QvaW50ZXJmYWNlLnRzXG52YXIgQ29udHJhY3RJbnRlcmZhY2UgPSBjbGFzcyB7XG59O1xuXG4vLyBzcmMvY29udHJhY3QvY29udHJhY3RGYWN0b3J5LnRzXG52YXIgQ29udHJhY3RGYWN0b3J5ID0gY2xhc3Mge1xuICAvKipcbiAgICogQHBhcmFtIHBhcmFtcyBDRlBhcmFtc1xuICAgKiAgLSBjb21waWxlZENvbnRyYWN0OiBDb21waWxlZENvbnRyYWN0O1xuICAgKiAgLSBhY2NvdW50OiBBY2NvdW50SW50ZXJmYWNlO1xuICAgKiAgLSBjYXNtPzogQ2Fpcm9Bc3NlbWJseTtcbiAgICogIC0gY2xhc3NIYXNoPzogc3RyaW5nO1xuICAgKiAgLSBjb21waWxlZENsYXNzSGFzaD86IHN0cmluZztcbiAgICogIC0gYWJpPzogQWJpO1xuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgdGhpcy5jb21waWxlZENvbnRyYWN0ID0gcGFyYW1zLmNvbXBpbGVkQ29udHJhY3Q7XG4gICAgdGhpcy5hY2NvdW50ID0gcGFyYW1zLmFjY291bnQ7XG4gICAgdGhpcy5jYXNtID0gcGFyYW1zLmNhc207XG4gICAgdGhpcy5hYmkgPSBwYXJhbXMuYWJpID8/IHBhcmFtcy5jb21waWxlZENvbnRyYWN0LmFiaTtcbiAgICB0aGlzLmNsYXNzSGFzaCA9IHBhcmFtcy5jbGFzc0hhc2g7XG4gICAgdGhpcy5jb21waWxlZENsYXNzSGFzaCA9IHBhcmFtcy5jb21waWxlZENsYXNzSGFzaDtcbiAgICB0aGlzLkNhbGxEYXRhID0gbmV3IENhbGxEYXRhKHRoaXMuYWJpKTtcbiAgfVxuICAvKipcbiAgICogRGVwbG95cyBjb250cmFjdCBhbmQgcmV0dXJucyBuZXcgaW5zdGFuY2Ugb2YgdGhlIENvbnRyYWN0XG4gICAqXG4gICAqIElmIGNvbnRyYWN0IGlzIG5vdCBkZWNsYXJlZCBpdCB3aWxsIGZpcnN0IGRlY2xhcmUgaXQsIGFuZCB0aGVuIGRlcGxveVxuICAgKi9cbiAgYXN5bmMgZGVwbG95KC4uLmFyZ3MpIHtcbiAgICBjb25zdCB7IGFyZ3M6IHBhcmFtLCBvcHRpb25zID0geyBwYXJzZVJlcXVlc3Q6IHRydWUgfSB9ID0gc3BsaXRBcmdzQW5kT3B0aW9ucyhhcmdzKTtcbiAgICBjb25zdCBjb25zdHJ1Y3RvckNhbGxkYXRhID0gZ2V0Q2FsbGRhdGEocGFyYW0sICgpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnBhcnNlUmVxdWVzdCkge1xuICAgICAgICB0aGlzLkNhbGxEYXRhLnZhbGlkYXRlKFwiREVQTE9ZXCIgLyogREVQTE9ZICovLCBcImNvbnN0cnVjdG9yXCIsIHBhcmFtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbERhdGEuY29tcGlsZShcImNvbnN0cnVjdG9yXCIsIHBhcmFtKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIkNhbGwgc2tpcHBlZCBwYXJzaW5nIGJ1dCBwcm92aWRlZCByYXdBcmdzLCBwb3NzaWJsZSBtYWxmdW5jdGlvbiByZXF1ZXN0XCIpO1xuICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGRlcGxveTogeyBjb250cmFjdF9hZGRyZXNzLCB0cmFuc2FjdGlvbl9oYXNoIH1cbiAgICB9ID0gYXdhaXQgdGhpcy5hY2NvdW50LmRlY2xhcmVBbmREZXBsb3koe1xuICAgICAgY29udHJhY3Q6IHRoaXMuY29tcGlsZWRDb250cmFjdCxcbiAgICAgIGNhc206IHRoaXMuY2FzbSxcbiAgICAgIGNsYXNzSGFzaDogdGhpcy5jbGFzc0hhc2gsXG4gICAgICBjb21waWxlZENsYXNzSGFzaDogdGhpcy5jb21waWxlZENsYXNzSGFzaCxcbiAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICBzYWx0OiBvcHRpb25zLmFkZHJlc3NTYWx0XG4gICAgfSk7XG4gICAgYXNzZXJ0KEJvb2xlYW4oY29udHJhY3RfYWRkcmVzcyksIFwiRGVwbG95bWVudCBvZiB0aGUgY29udHJhY3QgZmFpbGVkXCIpO1xuICAgIGNvbnN0IGNvbnRyYWN0SW5zdGFuY2UgPSBuZXcgQ29udHJhY3QoXG4gICAgICB0aGlzLmNvbXBpbGVkQ29udHJhY3QuYWJpLFxuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIHRoaXMuYWNjb3VudFxuICAgICk7XG4gICAgY29udHJhY3RJbnN0YW5jZS5kZXBsb3lUcmFuc2FjdGlvbkhhc2ggPSB0cmFuc2FjdGlvbl9oYXNoO1xuICAgIHJldHVybiBjb250cmFjdEluc3RhbmNlO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2hlcyB0byBuZXcgQWNjb3VudFxuICAgKlxuICAgKiBAcGFyYW0gYWNjb3VudCAtIG5ldyBBY2NvdW50IHRvIGF0dGFjaCB0b1xuICAgKi9cbiAgY29ubmVjdChhY2NvdW50KSB7XG4gICAgdGhpcy5hY2NvdW50ID0gYWNjb3VudDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXR0YWNoZXMgY3VycmVudCBhYmkgYW5kIGFjY291bnQgdG8gdGhlIG5ldyBhZGRyZXNzXG4gICAqL1xuICBhdHRhY2goYWRkcmVzcykge1xuICAgIHJldHVybiBuZXcgQ29udHJhY3QodGhpcy5hYmksIGFkZHJlc3MsIHRoaXMuYWNjb3VudCk7XG4gIH1cbiAgLy8gZXRoZXJzLmpzJyBnZXREZXBsb3lUcmFuc2FjdGlvbiBjYW50IGJlIHN1cHBvcnRlZCBhcyBpdCByZXF1aXJlcyB0aGUgYWNjb3VudCBvciBzaWduZXIgdG8gcmV0dXJuIGEgc2lnbmVkIHRyYW5zYWN0aW9uIHdoaWNoIGlzIG5vdCBwb3NzaWJsZSB3aXRoIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uXG59O1xuXG4vLyBzcmMvdXRpbHMvYWRkcmVzcy50c1xuaW1wb3J0IHsgaGV4VG9CeXRlcyBhcyBoZXhUb0J5dGVzMiB9IGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzXCI7XG5mdW5jdGlvbiBhZGRBZGRyZXNzUGFkZGluZyhhZGRyZXNzKSB7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgocmVtb3ZlSGV4UHJlZml4KHRvSGV4KGFkZHJlc3MpKS5wYWRTdGFydCg2NCwgXCIwXCIpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzKGFkZHJlc3MpIHtcbiAgYXNzZXJ0SW5SYW5nZShhZGRyZXNzLCBaRVJPLCBNQVNLXzI1MSwgXCJTdGFya25ldCBBZGRyZXNzXCIpO1xuICBjb25zdCByZXN1bHQgPSBhZGRBZGRyZXNzUGFkZGluZyhhZGRyZXNzKTtcbiAgaWYgKCFyZXN1bHQubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdezY0fSQvKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgQWRkcmVzcyBGb3JtYXRcIik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG4gIGNvbnN0IGNoYXJzID0gcmVtb3ZlSGV4UHJlZml4KHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzKGFkZHJlc3MpKS50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiXCIpO1xuICBjb25zdCBoZXggPSByZW1vdmVIZXhQcmVmaXgoa2VjY2FrQm4oYWRkcmVzcykpO1xuICBjb25zdCBoYXNoZWQgPSBoZXhUb0J5dGVzMihoZXgucGFkU3RhcnQoNjQsIFwiMFwiKSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBpZiAoaGFzaGVkW2kgPj4gMV0gPj4gNCA+PSA4KSB7XG4gICAgICBjaGFyc1tpXSA9IGNoYXJzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmICgoaGFzaGVkW2kgPj4gMV0gJiAxNSkgPj0gOCkge1xuICAgICAgY2hhcnNbaSArIDFdID0gY2hhcnNbaSArIDFdLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoY2hhcnMuam9pbihcIlwiKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUNoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG4gIHJldHVybiBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcykgPT09IGFkZHJlc3M7XG59XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIG51bWJlciA9IG51bV9leHBvcnRzO1xuZXhwb3J0IHtcbiAgQWNjb3VudCxcbiAgQWNjb3VudEludGVyZmFjZSxcbiAgQmxvY2tTdGF0dXMsXG4gIEJsb2NrVGFnLFxuICBDYWlyb0N1c3RvbUVudW0sXG4gIENhaXJvT3B0aW9uLFxuICBDYWlyb09wdGlvblZhcmlhbnQsXG4gIENhaXJvUmVzdWx0LFxuICBDYWlyb1Jlc3VsdFZhcmlhbnQsXG4gIENhbGxEYXRhLFxuICBDb250cmFjdCxcbiAgQ29udHJhY3RGYWN0b3J5LFxuICBDb250cmFjdEludGVyZmFjZSxcbiAgQ3VzdG9tRXJyb3IsXG4gIEVudHJ5UG9pbnRUeXBlLFxuICBHYXRld2F5RXJyb3IsXG4gIEh0dHBFcnJvcixcbiAgTGlicmFyeUVycm9yLFxuICBMaXR0ZXJhbCxcbiAgUHJvdmlkZXIsXG4gIFByb3ZpZGVySW50ZXJmYWNlLFxuICBycGNfZXhwb3J0cyBhcyBSUEMsXG4gIFJwY1Byb3ZpZGVyLFxuICBTSU1VTEFUSU9OX0ZMQUcsXG4gIHNlcXVlbmNlcl9leHBvcnRzIGFzIFNlcXVlbmNlcixcbiAgU2VxdWVuY2VyUHJvdmlkZXIsXG4gIFNpZ25lcixcbiAgU2lnbmVySW50ZXJmYWNlLFxuICBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyxcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyxcbiAgVHJhbnNhY3Rpb25TdGF0dXMsXG4gIFRyYW5zYWN0aW9uVHlwZSxcbiAgVWludCxcbiAgVmFsaWRhdGVUeXBlLFxuICBhZGRBZGRyZXNzUGFkZGluZyxcbiAgYnVpbGRVcmwsXG4gIGNhaXJvX2V4cG9ydHMgYXMgY2Fpcm8sXG4gIGNvbnN0YW50c19leHBvcnRzIGFzIGNvbnN0YW50cyxcbiAgY29udHJhY3RDbGFzc1Jlc3BvbnNlVG9MZWdhY3lDb21waWxlZENvbnRyYWN0LFxuICBkZWZhdWx0UHJvdmlkZXIsXG4gIGVjX2V4cG9ydHMgYXMgZWMsXG4gIGVuY29kZV9leHBvcnRzIGFzIGVuY29kZSxcbiAgZXZlbnRzX2V4cG9ydHMgYXMgZXZlbnRzLFxuICBleHRyYWN0Q29udHJhY3RIYXNoZXMsXG4gIGZpeFByb3RvLFxuICBmaXhTdGFjayxcbiAgZ2V0Q2FsbGRhdGEsXG4gIGdldENoZWNrc3VtQWRkcmVzcyxcbiAgZ2V0RGVmYXVsdE5vZGVVcmwsXG4gIGhhc2hfZXhwb3J0cyBhcyBoYXNoLFxuICBpc1NpZXJyYSxcbiAgaXNVcmwsXG4gIGpzb25fZXhwb3J0cyBhcyBqc29uLFxuICBtZXJrbGVfZXhwb3J0cyBhcyBtZXJrbGUsXG4gIG51bV9leHBvcnRzIGFzIG51bSxcbiAgbnVtYmVyLFxuICBwYXJzZVVEQ0V2ZW50LFxuICBwcm92aWRlcl9leHBvcnRzIGFzIHByb3ZpZGVyLFxuICBzZWxlY3Rvcl9leHBvcnRzIGFzIHNlbGVjdG9yLFxuICBzaG9ydFN0cmluZ19leHBvcnRzIGFzIHNob3J0U3RyaW5nLFxuICBzcGxpdEFyZ3NBbmRPcHRpb25zLFxuICBzdGFya19leHBvcnRzIGFzIHN0YXJrLFxuICBzdGFya25ldElkX2V4cG9ydHMgYXMgc3RhcmtuZXRJZCxcbiAgdHJhbnNhY3Rpb25fZXhwb3J0cyBhcyB0cmFuc2FjdGlvbixcbiAgdHlwZWREYXRhX2V4cG9ydHMgYXMgdHlwZWREYXRhLFxuICB0eXBlc19leHBvcnRzIGFzIHR5cGVzLFxuICB1aW50MjU2X2V4cG9ydHMgYXMgdWludDI1NixcbiAgdmFsaWRhdGVBbmRQYXJzZUFkZHJlc3MsXG4gIHZhbGlkYXRlQ2hlY2tzdW1BZGRyZXNzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImdldCIsImVudW1lcmFibGUiLCJjb25zdGFudHNfZXhwb3J0cyIsIkFQSV9WRVJTSU9OIiwiQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMSIsIkJOX0ZFRV9UUkFOU0FDVElPTl9WRVJTSU9OXzIiLCJCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzEiLCJCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzIiLCJCYXNlVXJsIiwiSEVYX1NUUl9UUkFOU0FDVElPTl9WRVJTSU9OXzEiLCJIRVhfU1RSX1RSQU5TQUNUSU9OX1ZFUlNJT05fMiIsIklTX0JST1dTRVIiLCJNQVNLXzI1MCIsIk1BU0tfMjUxIiwiTmV0d29ya05hbWUiLCJSUENfR09FUkxJX05PREVTIiwiUlBDX01BSU5ORVRfTk9ERVMiLCJTdGFya25ldENoYWluSWQiLCJURVhUX1RPX0ZFTFRfTUFYX0xFTiIsIlRyYW5zYWN0aW9uSGFzaFByZWZpeCIsIlVEQyIsIlpFUk8iLCJlbmNvZGVfZXhwb3J0cyIsImFkZEhleFByZWZpeCIsImFycmF5QnVmZmVyVG9TdHJpbmciLCJhdG9iVW5pdmVyc2FsIiwiYnRvYVVuaXZlcnNhbCIsImJ1ZjJoZXgiLCJjYWxjQnl0ZUxlbmd0aCIsInBhZExlZnQiLCJwYXNjYWxUb1NuYWtlIiwicmVtb3ZlSGV4UHJlZml4Iiwic2FuaXRpemVCeXRlcyIsInNhbml0aXplSGV4Iiwic3RyaW5nVG9BcnJheUJ1ZmZlciIsInV0ZjhUb0FycmF5IiwiYmFzZTY0IiwiU1RSSU5HX1pFUk8iLCJhcnJheSIsIlVpbnQ4QXJyYXkiLCJyZWR1Y2UiLCJkYXRhIiwiYnl0ZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInN0ciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiYSIsImRlY29kZSIsImIiLCJidWZmZXIiLCJyIiwieCIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJoZXgiLCJyZXBsYWNlIiwicGFkU3RyaW5nIiwibGVuZ3RoIiwibGVmdCIsInBhZGRpbmciLCJkaWZmIiwicmVzdWx0IiwicGFkIiwicmVwZWF0IiwiYnl0ZVNpemUiLCJyZW1haW5kZXIiLCJ0ZXh0IiwidGVzdCIsInNwbGl0Iiwiam9pbiIsInRvVXBwZXJDYXNlIiwiQmFzZVVybDIiLCJOZXR3b3JrTmFtZTIiLCJTdGFya25ldENoYWluSWQ0IiwiVHJhbnNhY3Rpb25IYXNoUHJlZml4MiIsIkFERFJFU1MiLCJFTlRSWVBPSU5UIiwidHlwZXNfZXhwb3J0cyIsIkJsb2NrU3RhdHVzIiwiQmxvY2tUYWciLCJFbnRyeVBvaW50VHlwZSIsIkxpdHRlcmFsIiwiUlBDIiwicnBjX2V4cG9ydHMiLCJTSU1VTEFUSU9OX0ZMQUciLCJTZXF1ZW5jZXIiLCJzZXF1ZW5jZXJfZXhwb3J0cyIsIlRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzIiwiVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyIsIlRyYW5zYWN0aW9uU3RhdHVzIiwiVHJhbnNhY3Rpb25UeXBlIiwiVWludCIsIlZhbGlkYXRlVHlwZSIsIlNJTVVMQVRJT05fRkxBRzIiLCJWYWxpZGF0ZVR5cGUyIiwiVWludDIiLCJMaXR0ZXJhbDIiLCJFbnRyeVBvaW50VHlwZTIiLCJUcmFuc2FjdGlvblR5cGUyIiwiVHJhbnNhY3Rpb25TdGF0dXMyIiwiVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czIiLCJUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czIiLCJCbG9ja1N0YXR1czIiLCJCbG9ja1RhZzIiLCJFQmxvY2tUYWciLCJFRGF0YUF2YWlsYWJpbGl0eU1vZGUiLCJFU2ltdWxhdGlvbkZsYWciLCJFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMiLCJFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyIsIkVUcmFuc2FjdGlvblN0YXR1cyIsIkVUcmFuc2FjdGlvblR5cGUiLCJFcnJvcnMiLCJlcnJvcnNfZXhwb3J0cyIsIkpSUEMiLCJqc29ucnBjX2V4cG9ydHMiLCJTUEVDIiwiY29tcG9uZW50c19leHBvcnRzIiwiRVRyYW5zYWN0aW9uVHlwZTIiLCJFU2ltdWxhdGlvbkZsYWcyIiwiRVRyYW5zYWN0aW9uU3RhdHVzMiIsIkVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMiIsIkVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czIiLCJFQmxvY2tUYWcyIiwiRURhdGFBdmFpbGFiaWxpdHlNb2RlMiIsImFzc2VydCIsImNvbmRpdGlvbiIsIm1lc3NhZ2UiLCJFcnJvciIsIm51bV9leHBvcnRzIiwiYXNzZXJ0SW5SYW5nZSIsImJpZ051bWJlcmlzaEFycmF5VG9EZWNpbWFsU3RyaW5nQXJyYXkiLCJiaWdOdW1iZXJpc2hBcnJheVRvSGV4YWRlY2ltYWxTdHJpbmdBcnJheSIsImNsZWFuSGV4IiwiZ2V0RGVjaW1hbFN0cmluZyIsImdldEhleFN0cmluZyIsImdldEhleFN0cmluZ0FycmF5IiwiaGV4VG9CeXRlcyIsImhleFRvRGVjaW1hbFN0cmluZyIsImlzQmlnSW50IiwiaXNIZXgiLCJpc1N0cmluZ1dob2xlTnVtYmVyIiwidG9CaWdJbnQiLCJ0b0NhaXJvQm9vbCIsInRvSGV4IiwidG9IZXhTdHJpbmciLCJ0b1N0b3JhZ2VLZXkiLCJoZXhUb0J5dGVzTm9ibGUiLCJ2YWx1ZSIsIkJpZ0ludCIsIm51bWJlcjIiLCJyZXMiLCJ0b0xvd2VyQ2FzZSIsImlucHV0IiwibG93ZXJCb3VuZCIsInVwcGVyQm91bmQiLCJpbnB1dE5hbWUiLCJtZXNzYWdlU3VmZml4IiwiaW5wdXRCaWdJbnQiLCJsb3dlckJvdW5kQmlnSW50IiwidXBwZXJCb3VuZEJpZ0ludCIsInJhd0NhbGxkYXRhIiwibWFwIiwiZWwiLCJhZGFwdGVkVmFsdWUiLCJzZWxlY3Rvcl9leHBvcnRzIiwiZ2V0U2VsZWN0b3IiLCJnZXRTZWxlY3RvckZyb21OYW1lIiwia2VjY2FrQm4iLCJzdGFya25ldEtlY2NhayIsImtlY2NhayIsImhleFdpdGhvdXRQcmVmaXgiLCJldmVuSGV4Iiwia2VjY2FrSGV4IiwiaGFzaCIsImZ1bmNOYW1lIiwic2hvcnRTdHJpbmdfZXhwb3J0cyIsImRlY29kZVNob3J0U3RyaW5nIiwiZW5jb2RlU2hvcnRTdHJpbmciLCJpc0FTQ0lJIiwiaXNEZWNpbWFsU3RyaW5nIiwiaXNMb25nVGV4dCIsImlzU2hvcnRTdHJpbmciLCJpc1Nob3J0VGV4dCIsImlzVGV4dCIsInNwbGl0TG9uZ1N0cmluZyIsInZhbCIsImxvbmdTdHIiLCJyZWdleCIsIlJlZ0V4cCIsIm1hdGNoIiwiY2hhciIsImNoYXJDb2RlQXQiLCJwYXJzZUludCIsImNvbmNhdCIsImNhaXJvX2V4cG9ydHMiLCJmZWx0IiwiZ2V0QWJpQ29udHJhY3RWZXJzaW9uIiwiZ2V0QXJyYXlUeXBlIiwiaXNDYWlybzFBYmkiLCJpc0NhaXJvMVR5cGUiLCJpc0xlbiIsImlzVHlwZUFycmF5IiwiaXNUeXBlQm9vbCIsImlzVHlwZUNvbnRyYWN0QWRkcmVzcyIsImlzVHlwZUVudW0iLCJpc1R5cGVFdGhBZGRyZXNzIiwiaXNUeXBlRmVsdCIsImlzVHlwZUxpdHRlcmFsIiwiaXNUeXBlTmFtZWRUdXBsZSIsImlzVHlwZU9wdGlvbiIsImlzVHlwZVJlc3VsdCIsImlzVHlwZVN0cnVjdCIsImlzVHlwZVR1cGxlIiwiaXNUeXBlVWludCIsImlzVHlwZVVpbnQyNTYiLCJ0dXBsZSIsInVpbnQyNTYiLCJ1aW50MjU2X2V4cG9ydHMiLCJVSU5UXzEyOF9NQVgiLCJVSU5UXzI1Nl9NQVgiLCJiblRvVWludDI1NiIsImlzVWludDI1NiIsInVpbnQyNTZUb0JOIiwidWludDI1NjIiLCJoaWdoIiwibG93IiwiYm4iLCJiaSIsInR5cGUiLCJzdGFydHNXaXRoIiwiaW5jbHVkZXMiLCJzdHJ1Y3RzIiwiZW51bXMiLCJ2YWx1ZXMiLCJzdWJzdHJpbmciLCJpbmRleE9mIiwibGFzdEluZGV4T2YiLCJhYmkiLCJjYWlybyIsImZpbmQiLCJpdCIsImNvbXBpbGVyIiwidGVzdEZ1bmN0aW9uIiwiaW5wdXRzIiwib3V0cHV0cyIsImlvIiwiYXJncyIsIk51bWJlciIsImlzSW50ZWdlciIsImVuY29kZWQiLCJDYWlyb0N1c3RvbUVudW0iLCJjb25zdHJ1Y3RvciIsImVudW1Db250ZW50IiwidmFyaWFudHNMaXN0IiwibmJBY3RpdmVWYXJpYW50cyIsImZpbHRlciIsImNvbnRlbnQiLCJ2YXJpYW50IiwidW53cmFwIiwidmFyaWFudHMiLCJlbnRyaWVzIiwiYWN0aXZlVmFyaWFudCIsIml0ZW0iLCJDYWlyb09wdGlvblZhcmlhbnQiLCJDYWlyb09wdGlvblZhcmlhbnQyIiwiQ2Fpcm9PcHRpb24iLCJzb21lQ29udGVudCIsIlNvbWUiLCJOb25lIiwiaXNTb21lIiwiaXNOb25lIiwiQ2Fpcm9SZXN1bHRWYXJpYW50IiwiQ2Fpcm9SZXN1bHRWYXJpYW50MiIsIkNhaXJvUmVzdWx0IiwicmVzdWx0Q29udGVudCIsIk9rIiwiRXJyIiwiaXNPayIsImlzRXJyIiwiZ3VhcmQiLCJpc0JOIiwia2V5IiwidW5rbm93biIsImZvcm1hdHRlciIsInNhbWVUeXBlIiwiYWNjIiwiZWxUeXBlIiwiQXJyYXkiLCJpc0FycmF5IiwiYXJyYXlTdHIiLCJfIiwiYXJyYXlPYmoiLCJBYmlQYXJzZXIxIiwibWV0aG9kSW5wdXRzTGVuZ3RoIiwiYWJpTWV0aG9kIiwiZ2V0TWV0aG9kIiwiZ2V0TGVnYWN5Rm9ybWF0IiwiQWJpUGFyc2VyMiIsImludGYiLCJpdGVtcyIsImZsYXRNYXAiLCJlIiwiY3JlYXRlQWJpUGFyc2VyIiwidmVyc2lvbiIsImdldEFiaVZlcnNpb24iLCJpc05vQ29uc3RydWN0b3JWYWxpZCIsIm1ldGhvZCIsImFyZ3NDYWxsZGF0YSIsInBhcnNlTmFtZWRUdXBsZSIsIm5hbWVkVHVwbGUiLCJwYXJzZVN1YlR1cGxlIiwicyIsInN1YlR1cGxlIiwiaSIsImNvdW50ZXIiLCJsQnJhY2tldCIsInB1c2giLCJleHRyYWN0Q2Fpcm8wVHVwbGUiLCJjbGVhblR5cGUiLCJzbGljZSIsInJlY29tcG9zZWQiLCJzaGlmdCIsImV4dHJhY3RDYWlybzFUdXBsZSIsImV4dHJhY3RUdXBsZU1lbWJlclR5cGVzIiwiZXJyb3JVMjU2Iiwib3JkZXJQcm9wc0J5QWJpIiwidW5vcmRlcmVkT2JqZWN0IiwiYWJpT2ZPYmplY3QiLCJvcmRlcklucHV0IiwidW5vcmRlcmVkSXRlbSIsImFiaVR5cGUiLCJvcmRlckFycmF5IiwiYWJpT2JqIiwib3JkZXJFbnVtIiwib3JkZXJUdXBsZSIsInUyNTYiLCJhYmlPZlN0cnVjdCIsIm1lbWJlcnMiLCJvcmRlclN0cnVjdCIsInVub3JkZXJlZE9iamVjdDIiLCJhYmlPYmplY3QiLCJvcmRlcmVkT2JqZWN0MiIsIm9yZGVyZWRPYmplY3QiLCJhYmlQYXJhbSIsInNldFByb3BlcnR5IiwibXlBcnJheSIsInR5cGVJbkFycmF5IiwibXlFbGVtIiwidHlwZUxpc3QiLCJhYmlUeXBlQ2Fpcm9YIiwiaW5kZXgiLCJteU9iaktleXMiLCJrZXlzIiwidW5vcmRlcmVkUmVzdWx0IiwicmVzdWx0T2tUeXBlIiwicmVzdWx0RXJyVHlwZSIsInVub3JkZXJlZE9wdGlvbiIsInJlc3VsdFNvbWVUeXBlIiwidW5vcmRlcmVkQ3VzdG9tRW51bSIsIm5ld0VudHJpZXMiLCJ2YXJpYW50VHlwZSIsImZyb21FbnRyaWVzIiwiZmluYWxPcmRlcmVkT2JqZWN0IiwicGFyc2VCYXNlVHlwZXMiLCJlbF91aW50MjU2IiwicGFyc2VUdXBsZSIsImVsZW1lbnQiLCJ0eXBlU3RyIiwibWVtYmVyVHlwZXMiLCJlbGVtZW50cyIsImR4IiwicGFyc2VVaW50MjU2IiwicGFyc2VDYWxsZGF0YVZhbHVlIiwiYXJyYXlUeXBlIiwic3ViRWxlbWVudCIsInR1cGxlZCIsInBhcnNlZERhdGEiLCJteU9wdGlvbiIsImxpc3RUeXBlVmFyaWFudDIiLCJ0eXBlVmFyaWFudFNvbWUiLCJwYXJzZWRQYXJhbWV0ZXIyIiwibXlSZXN1bHQiLCJsaXN0VHlwZVZhcmlhbnQzIiwidHlwZVZhcmlhbnRPayIsInBhcnNlZFBhcmFtZXRlcjMiLCJ0eXBlVmFyaWFudEVyciIsIm15RW51bSIsImxpc3RUeXBlVmFyaWFudCIsInR5cGVBY3RpdmVWYXJpYW50IiwibnVtQWN0aXZlVmFyaWFudCIsImZpbmRJbmRleCIsInBhcnNlZFBhcmFtZXRlciIsInBhcnNlQ2FsbGRhdGFGaWVsZCIsImFyZ3NJdGVyYXRvciIsIm5leHQiLCJwYXJzZUJhc2VUeXBlczIiLCJ0ZW1wIiwiQm9vbGVhbiIsInBhcnNlUmVzcG9uc2VWYWx1ZSIsInJlc3BvbnNlSXRlcmF0b3IiLCJwYXJzZWREYXRhQXJyIiwibGVuIiwidmFyaWFudE51bSIsInJhd0VudW0iLCJudW0iLCJjdXN0b21FbnVtIiwiaWR4IiwicmVzcG9uc2VQYXJzZXIiLCJvdXRwdXQiLCJwYXJzZWRSZXN1bHQiLCJhcnJMZW4iLCJ2YWxpZGF0ZUZlbHQiLCJwYXJhbWV0ZXIiLCJwYXJhbSIsInZhbGlkYXRlVWludCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJ2YWxpZGF0ZUJvb2wiLCJ2YWxpZGF0ZVN0cnVjdCIsImZvckVhY2giLCJ2YWxpZGF0ZUVudW0iLCJtZXRob2RzS2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRQcm90b3R5cGVPZiIsInZhbGlkYXRlVHVwbGUiLCJ2YWxpZGF0ZUFycmF5IiwiYmFzZVR5cGUiLCJ2YWxpZGF0ZUZpZWxkcyIsIkNhbGxEYXRhIiwiZ2V0QWJpU3RydWN0IiwiZ2V0QWJpRW51bSIsInBhcnNlciIsInZhbGlkYXRlIiwiaW52b2NhYmxlRnVuY3Rpb25OYW1lcyIsImlzVmlldyIsInN0YXRlTXV0YWJpbGl0eSIsInN0YXRlX211dGFiaWxpdHkiLCJpbnB1dHNMZW5ndGgiLCJjb21waWxlIiwiYWJpRnVuY3Rpb24iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNhbGxBcnJheSIsIndyaXRhYmxlIiwicmF3QXJncyIsImNyZWF0ZVRyZWUiLCJvYmoiLCJnZXRFbnRyaWVzIiwibyIsInByZWZpeCIsIm9lIiwiayIsInYiLCJrayIsInZhcmlhbnROYiIsImxpc3RWYXJpYW50cyIsImFjdGl2ZVZhcmlhbnROYiIsImNhbGxUcmVlQXJyYXkiLCJjYWxsVHJlZSIsImNhbGxPYmoiLCJwYXJzZSIsInJlc3BvbnNlIiwiZmxhdCIsInBhcnNlZCIsInByb3BOYW1lIiwiZm9ybWF0IiwiYWJpRW50cnkiLCJmdWxsRW51bUxpc3QiLCJ0b0NhbGxkYXRhIiwicmF3IiwiY2FsbGRhdGEiLCJoYXNoX2V4cG9ydHMiLCJjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaCIsImNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2giLCJjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoIiwiY2FsY3VsYXRlRGVwbG95VHJhbnNhY3Rpb25IYXNoIiwiY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoIiwiY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uIiwiY29tcHV0ZUNvbXBpbGVkQ2xhc3NIYXNoIiwiY29tcHV0ZUNvbnRyYWN0Q2xhc3NIYXNoIiwiY29tcHV0ZUhhc2hPbkVsZW1lbnRzIiwiY29tcHV0ZUxlZ2FjeUNvbnRyYWN0Q2xhc3NIYXNoIiwiY29tcHV0ZVNpZXJyYUNvbnRyYWN0Q2xhc3NIYXNoIiwiZGVmYXVsdCIsImNvbXB1dGVIaW50ZWRDbGFzc0hhc2giLCJmZWVUcmFuc2FjdGlvblZlcnNpb24iLCJmZWVUcmFuc2FjdGlvblZlcnNpb25fMiIsImZvcm1hdFNwYWNlcyIsImdldFZlcnNpb25zQnlUeXBlIiwicG9zZWlkb24iLCJ0cmFuc2FjdGlvblZlcnNpb24iLCJ0cmFuc2FjdGlvblZlcnNpb25fMiIsInBvc2VpZG9uSGFzaE1hbnkiLCJlY19leHBvcnRzIiwic3RhcmtDdXJ2ZSIsIndlaWVyc3RyYXNzIiwianNvbl9leHBvcnRzIiwicGFyc2UyIiwicGFyc2VBbHdheXNBc0JpZyIsInN0cmluZ2lmeSIsInN0cmluZ2lmeTIiLCJzdHJpbmdpZnlBbHdheXNBc0JpZyIsImpzb24iLCJwYXJzZUludEFzTnVtYmVyT3JCaWdJbnQiLCJwYXJzZUZsb2F0IiwiaXNTYWZlSW50ZWdlciIsInBhcnNlTnVtYmVyQW5kQmlnSW50IiwicmVwbGFjZXIiLCJzcGFjZSIsIm51bWJlclN0cmluZ2lmaWVycyIsInZlcnNpb25UeXBlIiwidjEiLCJ2MiIsInkiLCJwZWRlcnNlbiIsInR4SGFzaFByZWZpeCIsImNvbnRyYWN0QWRkcmVzcyIsImVudHJ5UG9pbnRTZWxlY3RvciIsIm1heEZlZSIsImNoYWluSWQiLCJhZGRpdGlvbmFsRGF0YSIsImNhbGxkYXRhSGFzaCIsImRhdGFUb0hhc2giLCJjb25zdHJ1Y3RvckNhbGxkYXRhIiwiY29uc3RydWN0b3JOYW1lIiwiY2xhc3NIYXNoIiwic2VuZGVyQWRkcmVzcyIsIm5vbmNlIiwiY29tcGlsZWRDbGFzc0hhc2giLCJzYWx0IiwiZGVwbG95ZXJBZGRyZXNzIiwiY29tcGlsZWRDYWxsZGF0YSIsImNvbnN0cnVjdG9yQ2FsbGRhdGFIYXNoIiwiQ09OVFJBQ1RfQUREUkVTU19QUkVGSVgiLCJudWxsU2tpcFJlcGxhY2VyIiwianNvbjIiLCJpbnNpZGVRdW90ZXMiLCJuZXdTdHJpbmciLCJjb21waWxlZENvbnRyYWN0IiwicHJvZ3JhbSIsImNvbnRyYWN0Q2xhc3MiLCJzZXJpYWxpemVkSnNvbiIsImNvbnRyYWN0IiwiYXBpVmVyc2lvbiIsImV4dGVybmFsRW50cnlQb2ludHNIYXNoIiwiZW50cnlfcG9pbnRzX2J5X3R5cGUiLCJFWFRFUk5BTCIsInNlbGVjdG9yIiwib2Zmc2V0IiwibDFIYW5kbGVyRW50cnlQb2ludHNIYXNoIiwiTDFfSEFORExFUiIsImNvbnN0cnVjdG9yRW50cnlQb2ludEhhc2giLCJDT05TVFJVQ1RPUiIsImJ1aWx0aW5zSGFzaCIsImJ1aWx0aW5zIiwiaGludGVkQ2xhc3NIYXNoIiwiZGF0YUhhc2giLCJoYXNoQnVpbHRpbnMiLCJoYXNoRW50cnlQb2ludCIsImJhc2UiLCJjYXNtIiwiQ09NUElMRURfQ0xBU1NfVkVSU0lPTiIsImNvbXBpbGVkQ2xhc3NWZXJzaW9uIiwibDFIYW5kbGVycyIsImJ5dGVjb2RlIiwiaGFzaEVudHJ5UG9pbnRTaWVycmEiLCJmdW5jdGlvbl9pZHgiLCJoYXNoQWJpIiwic2llcnJhIiwiaW5kZW50U3RyaW5nIiwiQ09OVFJBQ1RfQ0xBU1NfVkVSU0lPTiIsImFiaUhhc2giLCJzaWVycmFQcm9ncmFtIiwic2llcnJhX3Byb2dyYW0iLCJzdGFya19leHBvcnRzIiwiY29tcHJlc3NQcm9ncmFtIiwiZGVjb21wcmVzc1Byb2dyYW0iLCJlc3RpbWF0ZWRGZWVUb01heEZlZSIsImZvcm1hdFNpZ25hdHVyZSIsIm1ha2VBZGRyZXNzIiwicmFuZG9tQWRkcmVzcyIsInNpZ25hdHVyZVRvRGVjaW1hbEFycmF5Iiwic2lnbmF0dXJlVG9IZXhBcnJheSIsImdldFN0YXJrS2V5IiwidXRpbHMiLCJnemlwIiwidW5nemlwIiwianNvblByb2dyYW0iLCJzdHJpbmdpZmllZCIsImNvbXByZXNzZWRQcm9ncmFtIiwiYmFzZTY0MiIsImRlY29tcHJlc3NlZCIsInJhbmRvbUtleVBhaXIiLCJyYW5kb21Qcml2YXRlS2V5Iiwic2lnIiwiZXN0aW1hdGVkRmVlIiwib3ZlcmhlYWQiLCJvdmVySGVhZFBlcmNlbnQiLCJNYXRoIiwicm91bmQiLCJpc1NpZXJyYSIsImV4dHJhY3RDb250cmFjdEhhc2hlcyIsInBheWxvYWQiLCJjb250cmFjdENsYXNzUmVzcG9uc2VUb0xlZ2FjeUNvbXBpbGVkQ29udHJhY3QiLCJjY3IiLCJpc29tb3JwaGljRmV0Y2giLCJmZXRjaFBvbnlmaWxsX2RlZmF1bHQiLCJ3aW5kb3ciLCJmZXRjaCIsImdsb2JhbCIsInByb3ZpZGVyX2V4cG9ydHMiLCJjcmVhdGVTaWVycmFDb250cmFjdENsYXNzIiwicGFyc2VDb250cmFjdCIsIndhaXQiLCJkZWxheSIsIlByb21pc2UiLCJzZXRUaW1lb3V0Iiwic2llcnJhX3Byb2dyYW1fZGVidWdfaW5mbyIsInBhcnNlZENvbnRyYWN0IiwiUlBDUmVzcG9uc2VQYXJzZXIiLCJwYXJzZUdldEJsb2NrUmVzcG9uc2UiLCJ0aW1lc3RhbXAiLCJibG9ja19oYXNoIiwiYmxvY2tfbnVtYmVyIiwibmV3X3Jvb3QiLCJwYXJlbnRfaGFzaCIsInN0YXR1cyIsInRyYW5zYWN0aW9ucyIsInBhcnNlR2V0VHJhbnNhY3Rpb25SZXNwb25zZSIsImNvbnRyYWN0X2FkZHJlc3MiLCJzZW5kZXJfYWRkcmVzcyIsIm1heF9mZWUiLCJzaWduYXR1cmUiLCJ0cmFuc2FjdGlvbl9oYXNoIiwicGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlIiwib3ZlcmFsbF9mZWUiLCJnYXNfY29uc3VtZWQiLCJnYXNfcHJpY2UiLCJwYXJzZUZlZUVzdGltYXRlQnVsa1Jlc3BvbnNlIiwicGFyc2VDYWxsQ29udHJhY3RSZXNwb25zZSIsInBhcnNlU2ltdWxhdGVUcmFuc2FjdGlvblJlc3BvbnNlIiwic3VnZ2VzdGVkTWF4RmVlIiwiZmVlX2VzdGltYXRpb24iLCJwYXJzZUNvbnRyYWN0Q2xhc3NSZXNwb25zZSIsIkpTT04iLCJmaXhTdGFjayIsImZuIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJmaXhQcm90byIsInByb3RvdHlwZSIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQ3VzdG9tRXJyb3IiLCJjb25maWd1cmFibGUiLCJMaWJyYXJ5RXJyb3IiLCJHYXRld2F5RXJyb3IiLCJlcnJvckNvZGUiLCJIdHRwRXJyb3IiLCJzdGFya25ldElkX2V4cG9ydHMiLCJTdGFya25ldElkQ29udHJhY3QiLCJnZXRTdGFya25ldElkQ29udHJhY3QiLCJ1c2VEZWNvZGVkIiwidXNlRW5jb2RlZCIsImJhc2ljQWxwaGFiZXQiLCJiYXNpY1NpemVQbHVzT25lIiwiYmlnQWxwaGFiZXQiLCJiYXNpY0FscGhhYmV0U2l6ZSIsImJpZ0FscGhhYmV0U2l6ZSIsImJpZ0FscGhhYmV0U2l6ZVBsdXNPbmUiLCJleHRyYWN0U3RhcnMiLCJlbmRzV2l0aCIsImRlY29kZWQiLCJzdWJkb21haW4iLCJjb2RlIiwibmV4dFN1YmRvbWFpbiIsImNvZGUyIiwibXVsdGlwbGllciIsImJuSW5kZXgiLCJuZXdpZCIsIlN0YXJrbmV0SWRDb250cmFjdDIiLCJnZXRTdGFya05hbWUiLCJwcm92aWRlciIsImFkZHJlc3MiLCJnZXRDaGFpbklkIiwiaGV4RG9tYWluIiwiY2FsbENvbnRyYWN0IiwiZW50cnlwb2ludCIsImRlY2ltYWxEb21haW4iLCJzdHJpbmdEb21haW4iLCJnZXRBZGRyZXNzRnJvbVN0YXJrTmFtZSIsImFkZHJlc3NEYXRhIiwiZG9tYWluIiwidmFsaWRCbG9ja1RhZ3MiLCJCbG9jayIsIl9pZGVudGlmaWVyIiwibnVtYmVyIiwidGFnIiwidmFsdWVPZiIsInNldElkZW50aWZpZXIiLCJfX2lkZW50aWZpZXIiLCJxdWVyeUlkZW50aWZpZXIiLCJpZGVudGlmaWVyIiwic2VxdWVuY2VySWRlbnRpZmllciIsImJsb2NrSGFzaCIsImJsb2NrTnVtYmVyIiwiZ2V0RGVmYXVsdE5vZGVVcmwiLCJuZXR3b3JrTmFtZSIsIm11dGUiLCJjb25zb2xlIiwid2FybiIsIm5vZGVzIiwicmFuZElkeCIsImZsb29yIiwicmFuZG9tIiwiZGVmYXVsdE9wdGlvbnMiLCJoZWFkZXJzIiwiYmxvY2tJZGVudGlmaWVyIiwicmV0cmllcyIsIlJwY1Byb3ZpZGVyIiwib3B0aW9uc09yUHJvdmlkZXIiLCJnZXRCbG9ja0hhc2hBbmROdW1iZXIiLCJnZXRCbG9ja0xhdGVzdEFjY2VwdGVkIiwiZ2V0U3RhdGVVcGRhdGUiLCJnZXRCbG9ja1N0YXRlVXBkYXRlIiwidHJhY2VCbG9ja1RyYW5zYWN0aW9ucyIsImdldEJsb2NrVHJhbnNhY3Rpb25zVHJhY2VzIiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsImdldEJsb2NrVHJhbnNhY3Rpb25Db3VudCIsInRyYWNlVHJhbnNhY3Rpb24iLCJnZXRUcmFuc2FjdGlvblRyYWNlIiwiZ2V0U2ltdWxhdGVUcmFuc2FjdGlvbiIsInNpbXVsYXRlVHJhbnNhY3Rpb24iLCJub2RlVXJsIiwicGFyYW1zIiwiaWQiLCJycGNSZXF1ZXN0Qm9keSIsImpzb25ycGMiLCJib2R5IiwiZXJyb3JIYW5kbGVyIiwicnBjRXJyb3IiLCJvdGhlckVycm9yIiwiZmV0Y2hFbmRwb2ludCIsInJhd1Jlc3VsdCIsImVycm9yIiwiZ2V0U3BlY1ZlcnNpb24iLCJnZXROb25jZUZvckFkZHJlc3MiLCJibG9ja19pZCIsImdldEJsb2NrIiwiZ2V0QmxvY2tXaXRoVHhIYXNoZXMiLCJ0aGVuIiwiZ2V0QmxvY2tOdW1iZXIiLCJnZXRCbG9ja1dpdGhUeHMiLCJnZXRQZW5kaW5nVHJhbnNhY3Rpb25zIiwiZ2V0VHJhbnNhY3Rpb25CeUhhc2giLCJnZXRUcmFuc2FjdGlvbiIsInR4SGFzaCIsImdldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXgiLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJnZXRUcmFuc2FjdGlvblN0YXR1cyIsInRyYW5zYWN0aW9uSGFzaCIsImludm9jYXRpb25zIiwic2tpcFZhbGlkYXRlIiwic2tpcEZlZUNoYXJnZSIsInNpbXVsYXRpb25GbGFncyIsIlNLSVBfVkFMSURBVEUiLCJTS0lQX0ZFRV9DSEFSR0UiLCJidWlsZFRyYW5zYWN0aW9uIiwic2ltdWxhdGlvbl9mbGFncyIsIndhaXRGb3JUcmFuc2FjdGlvbiIsIm9wdGlvbnMiLCJvbmNoYWluIiwiaXNFcnJvclN0YXRlIiwicmV0cnlJbnRlcnZhbCIsImVycm9yU3RhdGVzIiwiUkVKRUNURUQiLCJSRVZFUlRFRCIsInN1Y2Nlc3NTdGF0ZXMiLCJTVUNDRUVERUQiLCJBQ0NFUFRFRF9PTl9MMiIsIkFDQ0VQVEVEX09OX0wxIiwidHhTdGF0dXMiLCJleGVjdXRpb25TdGF0dXMiLCJleGVjdXRpb25fc3RhdHVzIiwiZmluYWxpdHlTdGF0dXMiLCJmaW5hbGl0eV9zdGF0dXMiLCJ0eFJlY2VpcHQiLCJnZXRTdG9yYWdlQXQiLCJwYXJzZWRLZXkiLCJnZXRDbGFzc0hhc2hBdCIsImdldENsYXNzQnlIYXNoIiwiZ2V0Q2xhc3MiLCJjbGFzc19oYXNoIiwiZ2V0Q2xhc3NBdCIsImdldENvZGUiLCJfY29udHJhY3RBZGRyZXNzIiwiX2Jsb2NrSWRlbnRpZmllciIsImdldENvbnRyYWN0VmVyc2lvbiIsImFiaVRlc3QiLCJnZXRFc3RpbWF0ZUZlZSIsImludm9jYXRpb24iLCJpbnZvY2F0aW9uRGV0YWlscyIsImdldEludm9rZUVzdGltYXRlRmVlIiwidHJhbnNhY3Rpb24iLCJyZXF1ZXN0IiwiZ2V0RGVjbGFyZUVzdGltYXRlRmVlIiwiZGV0YWlscyIsImdldERlcGxveUFjY291bnRFc3RpbWF0ZUZlZSIsImdldEVzdGltYXRlRmVlQnVsayIsImludm9rZUZ1bmN0aW9uIiwiZnVuY3Rpb25JbnZvY2F0aW9uIiwiaW52b2tlX3RyYW5zYWN0aW9uIiwiSU5WT0tFIiwiZGVjbGFyZUNvbnRyYWN0IiwiZGVjbGFyZV90cmFuc2FjdGlvbiIsIkRFQ0xBUkUiLCJjb250cmFjdF9jbGFzcyIsImNvbnRyYWN0X2NsYXNzX3ZlcnNpb24iLCJjb21waWxlZF9jbGFzc19oYXNoIiwiZGVwbG95QWNjb3VudENvbnRyYWN0IiwiYWRkcmVzc1NhbHQiLCJkZXBsb3lfYWNjb3VudF90cmFuc2FjdGlvbiIsImNvbnN0cnVjdG9yX2NhbGxkYXRhIiwiY29udHJhY3RfYWRkcmVzc19zYWx0IiwiREVQTE9ZX0FDQ09VTlQiLCJjYWxsIiwiZW50cnlfcG9pbnRfc2VsZWN0b3IiLCJlc3RpbWF0ZU1lc3NhZ2VGZWUiLCJmcm9tX2FkZHJlc3MiLCJ0b19hZGRyZXNzIiwiZm9ybWF0dGVkTWVzc2FnZSIsImdldFN5bmNpbmdTdGF0cyIsImdldEV2ZW50cyIsImV2ZW50RmlsdGVyIiwiZGVmYXVsdFZlcnNpb25zIiwidXJsam9pbjIiLCJSZXNwb25zZVBhcnNlciIsIlNlcXVlbmNlckFQSVJlc3BvbnNlUGFyc2VyIiwic3RhdGVfcm9vdCIsInBhcmVudF9ibG9ja19oYXNoIiwicGFyc2VHZXRUcmFuc2FjdGlvblJlY2VpcHRSZXNwb25zZSIsIm1lc3NhZ2VzX3NlbnQiLCJsMl90b19sMV9tZXNzYWdlcyIsInJldmVydF9yZWFzb24iLCJyZXZlcnRfZXJyb3IiLCJnYXNJbmZvIiwiZ2FzX3VzYWdlIiwiYW1vdW50IiwidHJhbnNhY3Rpb25fdHJhY2UiLCJ0cmFjZSIsInBhcnNlSW52b2tlRnVuY3Rpb25SZXNwb25zZSIsInBhcnNlRGVwbG95Q29udHJhY3RSZXNwb25zZSIsInBhcnNlRGVjbGFyZUNvbnRyYWN0UmVzcG9uc2UiLCJwYXJzZUdldFN0YXRlVXBkYXRlUmVzcG9uc2UiLCJub25jZXMiLCJzdGF0ZV9kaWZmIiwic3RvcmFnZV9kaWZmcyIsInN0b3JhZ2VfZW50cmllcyIsInVybGpvaW4iLCJwcm90b2NvbEFuZERvbWFpblJFIiwibG9jYWxob3N0RG9tYWluUkUiLCJub25Mb2NhbGhvc3REb21haW5SRSIsImlzVXJsIiwiZXZlcnl0aGluZ0FmdGVyUHJvdG9jb2wiLCJidWlsZFVybCIsImJhc2VVcmwiLCJkZWZhdWx0UGF0aCIsInVybE9yUGF0aCIsImlzRW1wdHlRdWVyeU9iamVjdCIsImV2ZXJ5IiwiZGVmYXVsdE9wdGlvbnMyIiwibmV0d29yayIsIlNlcXVlbmNlclByb3ZpZGVyIiwiZ2V0TmV0d29ya0Zyb21OYW1lIiwiZmVlZGVyR2F0ZXdheVVybCIsImdhdGV3YXlVcmwiLCJnZXRDaGFpbklkRnJvbUJhc2VVcmwiLCJ1cmwiLCJVUkwiLCJob3N0IiwiZ2V0RmV0Y2hVcmwiLCJlbmRwb2ludCIsImdhdGV3YXlVcmxFbmRwb2ludHMiLCJnZXRGZXRjaE1ldGhvZCIsInBvc3RNZXRob2RFbmRwb2ludHMiLCJnZXRRdWVyeVN0cmluZyIsInF1ZXJ5IiwicXVlcnlTdHJpbmciLCJibG9jayIsImdldEhlYWRlcnMiLCJ0ZXh0UmVzcG9uc2UiLCJvayIsInJlc3BvbnNlQm9keSIsInN0YXR1c1RleHQiLCJwYXJzZUNob2ljZSIsInBhcnNlQWx3YXlzQXNCaWdJbnQiLCJyZXNvbHZlIiwidHhIYXNoSGV4IiwiZ2V0Q29tcGlsZWRDbGFzc0J5Q2xhc3NIYXNoIiwiY29tcGxldGVkIiwidHhfZmFpbHVyZV9yZWFzb24iLCJ0eF9zdGF0dXMiLCJlcnJvcl9tZXNzYWdlIiwidHhfcmV2ZXJ0X3JlYXNvbiIsImdldENvbnRyYWN0QWRkcmVzc2VzIiwidmFsaWRDYWxsTDFIYW5kbGVyIiwic2tpcEV4ZWN1dGUiLCJnZXRCbG9ja1RyYWNlcyIsIlByb3ZpZGVyIiwicHJvdmlkZXJPck9wdGlvbnMiLCJycGMiLCJzZXF1ZW5jZXIiLCJpbnZvY2F0aW9uV2l0aFR4VHlwZSIsIlNpZ25lckludGVyZmFjZSIsInRyYW5zYWN0aW9uX2V4cG9ydHMiLCJmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YSIsImZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhV2l0aE5vbmNlIiwiZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xIiwiZ2V0RXhlY3V0ZUNhbGxkYXRhIiwidHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5cyIsInRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXNfY2Fpcm8xIiwiY2FsbHMiLCJ0byIsImRhdGFfb2Zmc2V0IiwiZGF0YV9sZW4iLCJjb21waWxlZENhbGxzIiwib3JkZXJDYWxscyIsImNhaXJvVmVyc2lvbiIsInR5cGVkRGF0YV9leHBvcnRzIiwiZW5jb2RlRGF0YSIsImVuY29kZVR5cGUiLCJlbmNvZGVWYWx1ZSIsImdldERlcGVuZGVuY2llcyIsImdldE1lc3NhZ2VIYXNoIiwiZ2V0U3RydWN0SGFzaCIsImdldFR5cGVIYXNoIiwiaXNNZXJrbGVUcmVlVHlwZSIsInByZXBhcmVTZWxlY3RvciIsIm1lcmtsZV9leHBvcnRzIiwiTWVya2xlVHJlZSIsInByb29mTWVya2xlUGF0aCIsImxlYWZIYXNoZXMiLCJicmFuY2hlcyIsImxlYXZlcyIsInJvb3QiLCJidWlsZCIsIm5ld0xlYXZlcyIsImFTb3J0ZWQiLCJiU29ydGVkIiwic29ydCIsImdldFByb29mIiwibGVhZiIsImJyYW5jaCIsImhhc2hQYXRoIiwiaXNMZWZ0IiwibmVlZGVkQnJhbmNoIiwibmV3SGFzaFBhdGgiLCJjdXJyZW50QnJhbmNoTGV2ZWxJbmRleCIsIm5leHRCcmFuY2giLCJwYXRoIiwicmVzdCIsImdldEhleCIsInZhbGlkYXRlVHlwZWREYXRhIiwidHlwZWREYXRhIiwidmFsaWQiLCJ0eXBlcyIsInByaW1hcnlUeXBlIiwiZGVwZW5kZW5jaWVzIiwicHJldmlvdXMiLCJ0IiwiZGVwZW5kZW5jeSIsImdldE1lcmtsZVRyZWVUeXBlIiwiY3R4IiwicGFyZW50IiwicGFyZW50VHlwZSIsIm1lcmtsZVR5cGUiLCJpc01lcmtsZVRyZWUiLCJjb250YWlucyIsInByaW1hcnkiLCJuZXdUeXBlcyIsInN0cnVjdEhhc2hlcyIsInN0cnVjdCIsIm1lcmtsZVRyZWVUeXBlIiwicmV0dXJuVHlwZXMiLCJ0cyIsInZzIiwiZmllbGQiLCJlbmNvZGVkVmFsdWUiLCJhY2NvdW50IiwiU2lnbmVyIiwicGsiLCJnZXRQdWJLZXkiLCJzaWduTWVzc2FnZSIsImFjY291bnRBZGRyZXNzIiwibXNnSGFzaCIsInNpZ24iLCJzaWduVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbnNEZXRhaWwiLCJhYmlzIiwid2FsbGV0QWRkcmVzcyIsInNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24iLCJzaWduRGVjbGFyZVRyYW5zYWN0aW9uIiwicGFyc2VVRENFdmVudCIsImV2ZW50cyIsImV2ZW50IiwiZGVwbG95ZXIiLCJ1bmlxdWUiLCJjYWxsZGF0YV9sZW4iLCJBY2NvdW50IiwicGtPclNpZ25lciIsImRlcGxveVNlbGYiLCJkZXBsb3lBY2NvdW50Iiwic2lnbmVyIiwiZ2V0Tm9uY2UiLCJnZXROb25jZVNhZmUiLCJnZXRDYWlyb1ZlcnNpb24iLCJlc3RpbWF0ZUZlZSIsImVzdGltYXRlRmVlRGV0YWlscyIsImVzdGltYXRlSW52b2tlRmVlIiwicHJvdmlkZWROb25jZSIsInNpZ25lckRldGFpbHMiLCJidWlsZEludm9jYXRpb24iLCJlc3RpbWF0ZURlY2xhcmVGZWUiLCJwcm92aWRlZENsYXNzSGFzaCIsImRlY2xhcmVDb250cmFjdFRyYW5zYWN0aW9uIiwiYnVpbGREZWNsYXJlUGF5bG9hZCIsImVzdGltYXRlQWNjb3VudERlcGxveUZlZSIsInByb3ZpZGVkQ29udHJhY3RBZGRyZXNzIiwiYnVpbGRBY2NvdW50RGVwbG95UGF5bG9hZCIsImVzdGltYXRlRGVwbG95RmVlIiwiYnVpbGRVRENDb250cmFjdFBheWxvYWQiLCJlc3RpbWF0ZUZlZUJ1bGsiLCJhY2NvdW50SW52b2NhdGlvbnMiLCJhY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5IiwidmVyc2lvbnMiLCJlbGVtIiwiZXhlY3V0ZSIsImdldFN1Z2dlc3RlZE1heEZlZSIsImRlY2xhcmVJZk5vdCIsImRlY2xhcmVDb250cmFjdFBheWxvYWQiLCJkZWNsYXJlIiwiZGVwbG95IiwiY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhIiwiZGVwbG95U2FsdCIsImFkZHJlc3NlcyIsImludm9rZVJlc3BvbnNlIiwiZGVwbG95Q29udHJhY3QiLCJkZXBsb3lUeCIsImRlY2xhcmVBbmREZXBsb3kiLCJ0eCIsImhhc2hNZXNzYWdlIiwidmVyaWZ5TWVzc2FnZUhhc2giLCJ2ZXJpZnlNZXNzYWdlIiwiZmVlRXN0aW1hdGUiLCJjb21wcmVzc2VkQ29tcGlsZWRDb250cmFjdCIsInNhZmVOb25jZSIsInR4MFBheWxvYWQiLCJ0eFBheWxvYWQiLCJjb21tb24iLCJQcm92aWRlckludGVyZmFjZSIsImRlZmF1bHRQcm92aWRlciIsIkFjY291bnRJbnRlcmZhY2UiLCJldmVudHNfZXhwb3J0cyIsImdldEFiaUV2ZW50cyIsInBhcnNlRXZlbnRzIiwic2l6ZSIsImtpbmQiLCJlbnRyeU5hbWUiLCJhYmlFbnRyeU1vZCIsInByb3ZpZGVyUmVjZWl2ZWRFdmVudHMiLCJhYmlFdmVudHMiLCJhYmlTdHJ1Y3RzIiwiYWJpRW51bXMiLCJyZXQiLCJyZWNFdmVudCIsImFiaUV2ZW50IiwicGFyc2VkRXZlbnQiLCJrZXlzSXRlciIsImRhdGFJdGVyIiwiYWJpRXZlbnRLZXlzIiwiYWJpRXZlbnREYXRhIiwic3BsaXRBcmdzQW5kT3B0aW9ucyIsImxhc3RBcmciLCJzb21lIiwicG9wIiwiYnVpbGRDYWxsIiwiZnVuY3Rpb25BYmkiLCJwYXJzZVJlcXVlc3QiLCJwYXJzZVJlc3BvbnNlIiwiYnVpbGRJbnZva2UiLCJpbnZva2UiLCJidWlsZERlZmF1bHQiLCJidWlsZFBvcHVsYXRlIiwicG9wdWxhdGUiLCJidWlsZEVzdGltYXRlIiwiZXN0aW1hdGUiLCJnZXRDYWxsZGF0YSIsImNhbGxiYWNrIiwiQ29udHJhY3QiLCJwcm92aWRlck9yQWNjb3VudCIsImNhbGxEYXRhIiwiZGVmaW5lUHJvcGVydGllcyIsImZ1bmN0aW9ucyIsImNhbGxTdGF0aWMiLCJwb3B1bGF0ZVRyYW5zYWN0aW9uIiwiYWJpRWxlbWVudCIsImF0dGFjaCIsImNvbm5lY3QiLCJkZXBsb3llZCIsImRlcGxveVRyYW5zYWN0aW9uSGFzaCIsImZvcm1hdFJlc3BvbnNlIiwicmVjZWlwdCIsImlzQ2Fpcm8xIiwiZ2V0VmVyc2lvbiIsInR5cGVkIiwidEFiaSIsIkNvbnRyYWN0SW50ZXJmYWNlIiwiQ29udHJhY3RGYWN0b3J5IiwiY29udHJhY3RJbnN0YW5jZSIsImhleFRvQnl0ZXMyIiwiYWRkQWRkcmVzc1BhZGRpbmciLCJ2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyIsImdldENoZWNrc3VtQWRkcmVzcyIsImNoYXJzIiwiaGFzaGVkIiwidmFsaWRhdGVDaGVja3N1bUFkZHJlc3MiLCJjb25zdGFudHMiLCJlYyIsIm1lcmtsZSIsInNob3J0U3RyaW5nIiwic3RhcmsiLCJzdGFya25ldElkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/dist/index.mjs\n");

/***/ })

};
;